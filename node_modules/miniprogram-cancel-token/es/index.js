/**
 * 为异步Promise和async/await 提供取消接口
 * @example `const cts = CancleToken.source(); cts.cancle()`
 */
export class CancelToken {
    /**
     * 生成CancelToken
     * @param executor - callback
     */
    constructor(executor) {
        let resolve;
        // tslint:disable-next-line:promise-must-complete
        this.promise = new Promise((res) => { resolve = res; });
        executor((reason) => {
            if (this.reason === undefined) { // 防止重复执行
                this.reason = reason === undefined ? 'abort' : reason;
                resolve({ errMsg: this.reason, cancel: true });
            }
        });
    }
    /**
     * Create TokenSoure
     * @returns 生成一个CancelTokenSource
     */
    static source() {
        let cancel;
        const token = new CancelToken((c) => {
            cancel = c;
        });
        ///@ts-ignore
        return { token, cancel };
    }
    /**
     * 是否已取消
     */
    isCancelled() {
        return this.reason !== undefined;
    }
    /**
     * 如果已取消，抛出异常
     * 防止二次取消
     * @throws { errMsg: string }
     */
    throwIfRequested() {
        if (this.reason !== undefined) {
            throw typeof this.reason === 'string' ? { errMsg: this.reason, cancel: true, source: CancelToken.name } : this.reason;
        }
    }
}
//# sourceMappingURL=index.js.map