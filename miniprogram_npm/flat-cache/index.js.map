{"version":3,"sources":["cache.js","utils.js","del.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var path = require( 'path' );\nvar fs = require( 'fs' );\nvar utils = require( './utils' );\nvar del = require( './del' );\nvar writeJSON = utils.writeJSON;\n\nvar cache = {\n  /**\n   * Load a cache identified by the given Id. If the element does not exists, then initialize an empty\n   * cache storage. If specified `cacheDir` will be used as the directory to persist the data to. If omitted\n   * then the cache module directory `./cache` will be used instead\n   *\n   * @method load\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   */\n  load: function ( docId, cacheDir ) {\n    var me = this;\n\n    me._visited = { };\n    me._persisted = { };\n    me._pathToFile = cacheDir ? path.resolve( cacheDir, docId ) : path.resolve( __dirname, './.cache/', docId );\n\n    if ( fs.existsSync( me._pathToFile ) ) {\n      me._persisted = utils.tryParse( me._pathToFile, { } );\n    }\n  },\n\n  /**\n   * Load the cache from the provided file\n   * @method loadFile\n   * @param  {String} pathToFile the path to the file containing the info for the cache\n   */\n  loadFile: function ( pathToFile ) {\n    var me = this;\n    var dir = path.dirname( pathToFile );\n    var fName = path.basename( pathToFile );\n\n    me.load( fName, dir );\n  },\n\n  /**\n   * Returns the entire persisted object\n   * @method all\n   * @returns {*}\n   */\n  all: function () {\n    return this._persisted;\n  },\n\n  keys: function () {\n    return Object.keys( this._persisted );\n  },\n  /**\n   * sets a key to a given value\n   * @method setKey\n   * @param key {string} the key to set\n   * @param value {object} the value of the key. Could be any object that can be serialized with JSON.stringify\n   */\n  setKey: function ( key, value ) {\n    this._visited[ key ] = true;\n    this._persisted[ key ] = value;\n  },\n  /**\n   * remove a given key from the cache\n   * @method removeKey\n   * @param key {String} the key to remove from the object\n   */\n  removeKey: function ( key ) {\n    delete this._visited[ key ]; // esfmt-ignore-line\n    delete this._persisted[ key ]; // esfmt-ignore-line\n  },\n  /**\n   * Return the value of the provided key\n   * @method getKey\n   * @param key {String} the name of the key to retrieve\n   * @returns {*} the value from the key\n   */\n  getKey: function ( key ) {\n    this._visited[ key ] = true;\n    return this._persisted[ key ];\n  },\n\n  /**\n   * Remove keys that were not accessed/set since the\n   * last time the `prune` method was called.\n   * @method _prune\n   * @private\n   */\n  _prune: function () {\n    var me = this;\n    var obj = { };\n\n    var keys = Object.keys( me._visited );\n\n    // no keys visited for either get or set value\n    if ( keys.length === 0 ) {\n      return;\n    }\n\n    keys.forEach( function ( key ) {\n      obj[ key ] = me._persisted[ key ];\n    } );\n\n    me._visited = { };\n    me._persisted = obj;\n  },\n\n  /**\n   * Save the state of the cache identified by the docId to disk\n   * as a JSON structure\n   * @param [noPrune=false] {Boolean} whether to remove from cache the non visited files\n   * @method save\n   */\n  save: function ( noPrune ) {\n    var me = this;\n\n    (!noPrune) && me._prune();\n    writeJSON( me._pathToFile, me._persisted );\n  },\n\n  /**\n   * remove the file where the cache is persisted\n   * @method removeCacheFile\n   * @return {Boolean} true or false if the file was successfully deleted\n   */\n  removeCacheFile: function () {\n    return del( this._pathToFile );\n  },\n  /**\n   * Destroy the file cache and cache content.\n   * @method destroy\n   */\n  destroy: function () {\n    var me = this;\n    me._visited = { };\n    me._persisted = { };\n\n    me.removeCacheFile();\n  }\n};\n\nmodule.exports = {\n  /**\n   * Alias for create. Should be considered depreacted. Will be removed in next releases\n   *\n   * @method load\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   * @returns {cache} cache instance\n   */\n  load: function ( docId, cacheDir ) {\n    return this.create( docId, cacheDir );\n  },\n\n  /**\n  * Load a cache identified by the given Id. If the element does not exists, then initialize an empty\n  * cache storage.\n  *\n  * @method create\n  * @param docId {String} the id of the cache, would also be used as the name of the file cache\n  * @param [cacheDir] {String} directory for the cache entry\n  * @returns {cache} cache instance\n  */\n  create: function ( docId, cacheDir ) {\n    var obj = Object.create( cache );\n    obj.load( docId, cacheDir );\n    return obj;\n  },\n\n  createFromFile: function ( filePath ) {\n    var obj = Object.create( cache );\n    obj.loadFile( filePath );\n    return obj;\n  },\n  /**\n   * Clear the cache identified by the given id. Caches stored in a different cache directory can be deleted directly\n   *\n   * @method clearCache\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param cacheDir {String} the directory where the cache file was written\n   * @returns {Boolean} true if the cache folder was deleted. False otherwise\n   */\n  clearCacheById: function ( docId, cacheDir ) {\n    var filePath = cacheDir ? path.resolve( cacheDir, docId ) : path.resolve( __dirname, './.cache/', docId );\n    return del( filePath );\n  },\n  /**\n   * Remove all cache stored in the cache directory\n   * @method clearAll\n   * @returns {Boolean} true if the cache folder was deleted. False otherwise\n   */\n  clearAll: function ( cacheDir ) {\n    var filePath = cacheDir ? path.resolve( cacheDir ) : path.resolve( __dirname, './.cache/' );\n    return del( filePath );\n  }\n};\n","var fs = require( 'fs' );\nvar write = require( 'write' );\nvar flatted = require( 'flatted' );\n\nmodule.exports = {\n  tryParse: function ( filePath, defaultValue ) {\n    var result;\n    try {\n      result = this.readJSON( filePath );\n    } catch (ex) {\n      result = defaultValue;\n    }\n    return result;\n  },\n\n  /**\n   * Read json file synchronously using flatted\n   *\n   * @method readJSON\n   * @param  {String} filePath Json filepath\n   * @returns {*} parse result\n   */\n  readJSON: function ( filePath ) {\n    return flatted.parse( fs.readFileSync( filePath, {\n      encoding: 'utf8'\n    } ) );\n  },\n\n  /**\n   * Write json file synchronously using circular-json\n   *\n   * @method writeJSON\n   * @param  {String} filePath Json filepath\n   * @param  {*} data Object to serialize\n   */\n  writeJSON: function ( filePath, data ) {\n    write.sync( filePath, flatted.stringify( data ) );\n  }\n};\n","var rimraf = require( 'rimraf' ).sync;\nvar fs = require( 'fs' );\n\nmodule.exports = function del( file ) {\n  if ( fs.existsSync( file ) ) {\n    //if rimraf doesn't throw then the file has been deleted or didn't exist\n    rimraf( file, {\n      glob: false\n    } );\n    return true;\n  }\n  return false;\n};\n"]}