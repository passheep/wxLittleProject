{"version":3,"sources":["api.js","linter.js","code-path-analysis\\code-path-analyzer.js","code-path-analysis\\code-path.js","code-path-analysis\\code-path-state.js","code-path-analysis\\code-path-segment.js","code-path-analysis\\debug-helpers.js","code-path-analysis\\fork-context.js","code-path-analysis\\id-generator.js","util\\ast-utils.js","config\\config-ops.js","config\\config-validator.js","util\\ajv.js","..\\conf\\config-schema.js","config\\environments.js","..\\conf\\environments.js","util\\apply-disable-directives.js","util\\safe-emitter.js","util\\node-event-generator.js","util\\source-code.js","token-store\\index.js","token-store\\cursors.js","token-store\\backward-token-comment-cursor.js","token-store\\cursor.js","token-store\\utils.js","token-store\\backward-token-cursor.js","token-store\\filter-cursor.js","token-store\\decorative-cursor.js","token-store\\forward-token-comment-cursor.js","token-store\\forward-token-cursor.js","token-store\\limit-cursor.js","token-store\\skip-cursor.js","token-store\\padded-token-cursor.js","util\\traverser.js","util\\report-translator.js","util\\rule-fixer.js","util\\interpolate.js","rules.js","built-in-rules-index.js","rules\\accessor-pairs.js","rules\\array-bracket-newline.js","rules\\array-bracket-spacing.js","rules\\array-callback-return.js","rules\\array-element-newline.js","rules\\arrow-body-style.js","rules\\arrow-parens.js","rules\\arrow-spacing.js","rules\\block-scoped-var.js","rules\\block-spacing.js","rules\\brace-style.js","rules\\callback-return.js","rules\\camelcase.js","rules\\capitalized-comments.js","util\\patterns\\letters.js","rules\\class-methods-use-this.js","rules\\comma-dangle.js","rules\\comma-spacing.js","rules\\comma-style.js","rules\\complexity.js","rules\\computed-property-spacing.js","rules\\consistent-return.js","rules\\consistent-this.js","rules\\constructor-super.js","rules\\curly.js","rules\\default-case.js","rules\\dot-location.js","rules\\dot-notation.js","util\\keywords.js","rules\\eol-last.js","rules\\eqeqeq.js","rules\\for-direction.js","rules\\func-call-spacing.js","rules\\func-name-matching.js","rules\\func-names.js","rules\\func-style.js","rules\\function-paren-newline.js","rules\\generator-star-spacing.js","rules\\getter-return.js","rules\\global-require.js","rules\\guard-for-in.js","rules\\handle-callback-err.js","rules\\id-blacklist.js","rules\\id-length.js","rules\\id-match.js","rules\\implicit-arrow-linebreak.js","rules\\indent.js","rules\\indent-legacy.js","rules\\init-declarations.js","rules\\jsx-quotes.js","rules\\key-spacing.js","rules\\keyword-spacing.js","rules\\line-comment-position.js","rules\\linebreak-style.js","rules\\lines-around-comment.js","rules\\lines-around-directive.js","rules\\lines-between-class-members.js","rules\\max-classes-per-file.js","rules\\max-depth.js","rules\\max-len.js","rules\\max-lines.js","rules\\max-lines-per-function.js","rules\\max-nested-callbacks.js","rules\\max-params.js","rules\\max-statements.js","rules\\max-statements-per-line.js","rules\\multiline-comment-style.js","rules\\multiline-ternary.js","rules\\new-cap.js","rules\\new-parens.js","rules\\newline-after-var.js","rules\\newline-before-return.js","rules\\newline-per-chained-call.js","rules\\no-alert.js","rules\\no-array-constructor.js","rules\\no-async-promise-executor.js","rules\\no-await-in-loop.js","rules\\no-bitwise.js","rules\\no-buffer-constructor.js","rules\\no-caller.js","rules\\no-case-declarations.js","rules\\no-catch-shadow.js","rules\\no-class-assign.js","rules\\no-compare-neg-zero.js","rules\\no-cond-assign.js","rules\\no-confusing-arrow.js","rules\\no-console.js","rules\\no-const-assign.js","rules\\no-constant-condition.js","rules\\no-continue.js","rules\\no-control-regex.js","rules\\no-debugger.js","rules\\no-delete-var.js","rules\\no-div-regex.js","rules\\no-dupe-args.js","rules\\no-dupe-class-members.js","rules\\no-dupe-keys.js","rules\\no-duplicate-case.js","rules\\no-duplicate-imports.js","rules\\no-else-return.js","util\\fix-tracker.js","rules\\no-empty.js","rules\\no-empty-character-class.js","rules\\no-empty-function.js","rules\\no-empty-pattern.js","rules\\no-eq-null.js","rules\\no-eval.js","rules\\no-ex-assign.js","rules\\no-extend-native.js","rules\\no-extra-bind.js","rules\\no-extra-boolean-cast.js","rules\\no-extra-label.js","rules\\no-extra-parens.js","rules\\no-extra-semi.js","rules\\no-fallthrough.js","rules\\no-floating-decimal.js","rules\\no-func-assign.js","rules\\no-global-assign.js","rules\\no-implicit-coercion.js","rules\\no-implicit-globals.js","rules\\no-implied-eval.js","rules\\no-inline-comments.js","rules\\no-inner-declarations.js","rules\\no-invalid-regexp.js","rules\\no-invalid-this.js","rules\\no-irregular-whitespace.js","rules\\no-iterator.js","rules\\no-label-var.js","rules\\no-labels.js","rules\\no-lone-blocks.js","rules\\no-lonely-if.js","rules\\no-loop-func.js","rules\\no-magic-numbers.js","rules\\no-misleading-character-class.js","util\\unicode\\index.js","util\\unicode\\is-combining-character.js","util\\unicode\\is-emoji-modifier.js","util\\unicode\\is-regional-indicator-symbol.js","util\\unicode\\is-surrogate-pair.js","rules\\no-mixed-operators.js","rules\\no-mixed-requires.js","rules\\no-mixed-spaces-and-tabs.js","rules\\no-multi-assign.js","rules\\no-multi-spaces.js","rules\\no-multi-str.js","rules\\no-multiple-empty-lines.js","rules\\no-native-reassign.js","rules\\no-negated-condition.js","rules\\no-negated-in-lhs.js","rules\\no-nested-ternary.js","rules\\no-new.js","rules\\no-new-func.js","rules\\no-new-object.js","rules\\no-new-require.js","rules\\no-new-symbol.js","rules\\no-new-wrappers.js","rules\\no-obj-calls.js","rules\\no-octal.js","rules\\no-octal-escape.js","rules\\no-param-reassign.js","rules\\no-path-concat.js","rules\\no-plusplus.js","rules\\no-process-env.js","rules\\no-process-exit.js","rules\\no-proto.js","rules\\no-prototype-builtins.js","rules\\no-redeclare.js","rules\\no-regex-spaces.js","rules\\no-restricted-globals.js","rules\\no-restricted-imports.js","rules\\no-restricted-modules.js","rules\\no-restricted-properties.js","rules\\no-restricted-syntax.js","rules\\no-return-assign.js","rules\\no-return-await.js","rules\\no-script-url.js","rules\\no-self-assign.js","rules\\no-self-compare.js","rules\\no-sequences.js","rules\\no-shadow.js","rules\\no-shadow-restricted-names.js","rules\\no-spaced-func.js","rules\\no-sparse-arrays.js","rules\\no-sync.js","rules\\no-tabs.js","rules\\no-template-curly-in-string.js","rules\\no-ternary.js","rules\\no-this-before-super.js","rules\\no-throw-literal.js","rules\\no-trailing-spaces.js","rules\\no-undef.js","rules\\no-undef-init.js","rules\\no-undefined.js","rules\\no-underscore-dangle.js","rules\\no-unexpected-multiline.js","rules\\no-unmodified-loop-condition.js","rules\\no-unneeded-ternary.js","rules\\no-unreachable.js","rules\\no-unsafe-finally.js","rules\\no-unsafe-negation.js","rules\\no-unused-expressions.js","rules\\no-unused-labels.js","rules\\no-unused-vars.js","rules\\no-use-before-define.js","rules\\no-useless-call.js","rules\\no-useless-catch.js","rules\\no-useless-computed-key.js","rules\\no-useless-concat.js","rules\\no-useless-constructor.js","rules\\no-useless-escape.js","rules\\no-useless-rename.js","rules\\no-useless-return.js","rules\\no-var.js","rules\\no-void.js","rules\\no-warning-comments.js","rules\\no-whitespace-before-property.js","rules\\no-with.js","rules\\nonblock-statement-body-position.js","rules\\object-curly-newline.js","rules\\object-curly-spacing.js","rules\\object-property-newline.js","rules\\object-shorthand.js","rules\\one-var.js","rules\\one-var-declaration-per-line.js","rules\\operator-assignment.js","rules\\operator-linebreak.js","rules\\padded-blocks.js","rules\\padding-line-between-statements.js","rules\\prefer-arrow-callback.js","rules\\prefer-const.js","rules\\prefer-destructuring.js","rules\\prefer-named-capture-group.js","rules\\prefer-numeric-literals.js","rules\\prefer-object-spread.js","rules\\prefer-promise-reject-errors.js","rules\\prefer-reflect.js","rules\\prefer-rest-params.js","rules\\prefer-spread.js","rules\\prefer-template.js","rules\\quote-props.js","rules\\quotes.js","rules\\radix.js","rules\\require-atomic-updates.js","rules\\require-await.js","rules\\require-jsdoc.js","rules\\require-unicode-regexp.js","rules\\require-yield.js","rules\\rest-spread-spacing.js","rules\\semi.js","rules\\semi-spacing.js","rules\\semi-style.js","rules\\sort-imports.js","rules\\sort-keys.js","rules\\sort-vars.js","rules\\space-before-blocks.js","rules\\space-before-function-paren.js","rules\\space-in-parens.js","rules\\space-infix-ops.js","rules\\space-unary-ops.js","rules\\spaced-comment.js","rules\\strict.js","rules\\switch-colon-spacing.js","rules\\symbol-description.js","rules\\template-curly-spacing.js","rules\\template-tag-spacing.js","rules\\unicode-bom.js","rules\\use-isnan.js","rules\\valid-jsdoc.js","rules\\valid-typeof.js","rules\\vars-on-top.js","rules\\wrap-iife.js","rules\\wrap-regex.js","rules\\yield-star-spacing.js","rules\\yoda.js","util\\timing.js","util\\config-comment-parser.js","..\\package.json","util\\source-code-fixer.js","cli-engine.js","..\\conf\\default-cli-options.js","util\\ignored-paths.js","util\\path-utils.js","config.js","config\\config-file.js","util\\module-resolver.js","util\\naming.js","config\\config-cache.js","config\\plugins.js","util\\file-finder.js","util\\lint-result-cache.js","util\\hash.js","util\\glob-utils.js","util\\glob.js","load-rules.js","testers\\rule-tester.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,AENA,ADGA,AFMA;ADIA,AENA,AENA,ADGA,AFMA;ADIA,AENA,AENA,ADGA,AFMA;ADIA,AENA,AGTA,ADGA,ADGA,AFMA;ADIA,AENA,AGTA,ADGA,ADGA,AFMA;ADIA,AENA,AGTA,ADGA,ADGA,AFMA;ADIA,AENA,AGTA,ADGA,ADGA,AGTA,ALeA;ADIA,AENA,AGTA,ADGA,ADGA,AGTA,ALeA;ADIA,AENA,AGTA,ADGA,ADGA,AGTA,ALeA;ADIA,AENA,AGTA,ADGA,ADGA,AGTA,ACHA,ANkBA;ADIA,AENA,AGTA,ADGA,ADGA,AGTA,ACHA,ANkBA;ADIA,AENA,AGTA,ADGA,ADGA,AGTA,ACHA,ANkBA;ADIA,AENA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,APqBA;ADIA,AENA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,APqBA;ADIA,AENA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,APqBA;ADIA,AENA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,APqBA,AQxBA;AT4BA,AENA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,APqBA,AQxBA;APsBA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,APqBA,AQxBA;APsBA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,AT2BA,AQxBA;APsBA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,AT2BA,AQxBA;APsBA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,AT2BA,AQxBA;APsBA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AV8BA,AQxBA;APsBA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AV8BA,AQxBA;APsBA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AV8BA,AQxBA;APsBA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AV8BA,AWjCA,AHSA;APsBA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AV8BA,AWjCA,AHSA;APsBA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AV8BA,AWjCA,AHSA;AIXA,AXiCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AV8BA,AWjCA,AHSA;AIXA,AXiCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AV8BA,AWjCA,AHSA;AIXA,AXiCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AV8BA,AWjCA,AHSA;AIXA,AXiCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AWjCA,AHSA;AIXA,AXiCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AWjCA,AHSA;AIXA,AXiCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AWjCA,AHSA;AIXA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AWjCA,AHSA;AIXA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AWjCA,AHSA;AIXA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AWjCA,AHSA;AIXA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AWjCA,AIZA,APqBA;AIXA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AWjCA,AIZA,APqBA;AIXA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AWjCA,AIZA,APqBA;AIXA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AWjCA,AIZA,APqBA,AQxBA;AJaA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AWjCA,AIZA,APqBA,AQxBA;AJaA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AWjCA,AIZA,APqBA,AQxBA;AJaA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AWjCA,AIZA,APqBA,AS3BA,ADGA;AJaA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AWjCA,AIZA,APqBA,AS3BA,ADGA;AJaA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AWjCA,AIZA,APqBA,AS3BA,ADGA;AJaA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AWjCA,AIZA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AWjCA,AIZA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AWjCA,AIZA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AmBzDA,ARwBA,AIZA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AmBzDA,ARwBA,AIZA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AmBzDA,ARwBA,AIZA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AoB5DA,ADGA,ARwBA,AIZA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AoB5DA,ADGA,ARwBA,AIZA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AoB5DA,ADGA,ARwBA,AIZA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AqB/DA,ADGA,ADGA,ARwBA,AIZA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AqB/DA,ADGA,ADGA,ARwBA,AIZA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AqB/DA,ADGA,ADGA,AJYA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AqB/DA,ACHA,AFMA,ADGA,AJYA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,ACHA,AENA,ACHA,AGTA,AbuCA,AqB/DA,ACHA,AFMA,ADGA,AJYA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,ACHA,AFMA,ADGA,AJYA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,ACHA,AFMA,ADGA,AIZA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,ACHA,AFMA,ADGA,AIZA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,ACHA,AFMA,ADGA,AIZA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,ADGA,AIZA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,ADGA,AIZA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,ADGA,AIZA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AKfA,ANkBA,AIZA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AKfA,ANkBA,AIZA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AKfA,ANkBA,AIZA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,ANkBA,AIZA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,ANkBA,AIZA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,ANkBA,AIZA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ARwBA,AIZA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ARwBA,AIZA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ARwBA,AIZA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AIZA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AIZA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AIZA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,ANkBA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,ANkBA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,ANkBA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,ACHA,APqBA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,ACHA,APqBA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,ACHA,APqBA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,AS3BA,ADGA,AENA;ANmBA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,AS3BA,ADGA,AENA,Ac1CA;ApB6DA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,AS3BA,ADGA,AENA,Ac1CA;ApB6DA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,AS3BA,ADGA,AENA,Ac1CA;ApB6DA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,AS3BA,AgBhDA,AjBmDA,AENA,Ac1CA;ApB6DA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,AS3BA,AgBhDA,AjBmDA,AENA,Ac1CA;ApB6DA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,AS3BA,AgBhDA,Af6CA,Ac1CA;ApB6DA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;ApB6DA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;ApB6DA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;ApB6DA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;ApB6DA,AENA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AqB/DA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AoC5GA,Af6CA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AoC5GA,Af6CA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AbuCA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AoC5GA,Af6CA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AoC5GA,Af6CA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AoC5GA,Af6CA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AoC5GA,Af6CA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AoC5GA,AENA,AjBmDA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AoC5GA,AENA,AjBmDA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AoC5GA,AENA,AjBmDA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AoC5GA,AENA,ACHA,AlBsDA,AGTA,AFMA,AFMA,AMlBA,ADGA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AoC5GA,AENA,ACHA,AlBsDA,AGTA,AFMA,AFMA,AKfA,AENA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AoC5GA,AENA,ACHA,AlBsDA,AGTA,AFMA,AFMA,AOrBA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AoC5GA,AENA,ACHA,ACHA,AnByDA,AGTA,AFMA,AFMA,AOrBA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AoC5GA,AENA,ACHA,ACHA,AhBgDA,AFMA,AFMA,AOrBA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AoC5GA,AENA,ACHA,ACHA,AhBgDA,AFMA,AFMA,AOrBA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AGTA,AbuCA,AoC5GA,AENA,ACHA,ACHA,ACHA,AjBmDA,AFMA,AFMA,AOrBA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,AjBmDA,AFMA,AFMA,AOrBA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,AjBmDA,AFMA,AFMA,AOrBA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,AlBsDA,AFMA,AFMA,AOrBA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,AlBsDA,AFMA,AFMA,AOrBA,ACHA,AT2BA,AU9BA,AENA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,AlBsDA,AFMA,AFMA,AOrBA,ACHA,AT2BA,AYpCA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AnByDA,AFMA,AFMA,AOrBA,ACHA,AT2BA,AYpCA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AnByDA,AFMA,AFMA,AOrBA,ACHA,AT2BA,AYpCA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ArB+DA,AFMA,AOrBA,ACHA,AT2BA,AYpCA,ADGA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtBkEA,AFMA,AOrBA,ACHA,AT2BA,AWjCA,APqBA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtBkEA,AFMA,AOrBA,ACHA,AT2BA,AIZA,ARwBA,APqBA,A2BjFA,AlBsDA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtBkEA,AFMA,AOrBA,ACHA,AT2BA,AIZA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvBqEA,AFMA,AOrBA,ACHA,AT2BA,AIZA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvBqEA,AFMA,AOrBA,ACHA,AT2BA,AIZA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvBqEA,AFMA,AOrBA,ACHA,AT2BA,AIZA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxBwEA,AFMA,AOrBA,ACHA,AT2BA,AIZA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxBwEA,AFMA,AQxBA,AT2BA,AIZA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxBwEA,AFMA,AQxBA,AT2BA,AIZA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzB2EA,AFMA,AQxBA,AT2BA,AIZA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzB2EA,AFMA,AQxBA,AT2BA,AIZA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3BiFA,AQxBA,AT2BA,AIZA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5BoFA,AQxBA,AT2BA,AIZA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5BoFA,AQxBA,AT2BA,AIZA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5BoFA,AQxBA,AT2BA,AIZA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7BuFA,AQxBA,AT2BA,AIZA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7BuFA,ADGA,AIZA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7BuFA,ADGA,AIZA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9B0FA,ADGA,AIZA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AlBuDA,AuBrEA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9B0FA,ADGA,AIZA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9B0FA,ADGA,AIZA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhCgGA,AIZA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhCgGA,AIZA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhCgGA,AIZA,ARwBA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhCgGA,AIZA,ARwBA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhCgGA,AIZA,ARwBA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhCgGA,AIZA,ARwBA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AlCsGA,AIZA,ARwBA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AlCsGA,AIZA,ARwBA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AlCsGA,AIZA,ARwBA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AnCyGA,AIZA,ARwBA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AnCyGA,AIZA,ARwBA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AnCyGA,AIZA,ARwBA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ApC4GA,AIZA,ARwBA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ApC4GA,AIZA,ARwBA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ApC4GA,AIZA,ARwBA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ArC+GA,AIZA,ARwBA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ArC+GA,AIZA,ARwBA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ArC+GA,AIZA,ARwBA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AtCkHA,AIZA,ARwBA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AtCkHA,AIZA,ARwBA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AtCkHA,AIZA,ARwBA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AvCqHA,AJYA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AvCqHA,AJYA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AvCqHA,AJYA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxCwHA,AJYA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxCwHA,AJYA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxCwHA,AJYA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzC2HA,AJYA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzC2HA,AJYA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzC2HA,AJYA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1C8HA,AJYA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1C8HA,AJYA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1C8HA,AJYA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3CiIA,AJYA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3CiIA,AJYA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3CiIA,AJYA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5CoIA,AJYA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5CoIA,AJYA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5CoIA,AJYA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7CuIA,AJYA,APqBA,AS3BA,AmCzGA,AnByDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7CuIA,AJYA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7CuIA,AJYA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9C0IA,AJYA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9C0IA,AJYA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9C0IA,AJYA,APqBA,AS3BA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9C0IA,AJYA,APqBA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9C0IA,AJYA,APqBA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9C0IA,AJYA,APqBA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AhDgJA,AJYA,APqBA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AhDgJA,AJYA,APqBA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AhDgJA,AJYA,APqBA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AjDmJA,AJYA,APqBA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AjDmJA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AjDmJA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AlDsJA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AlDsJA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AlDsJA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AnDyJA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AnDyJA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AnDyJA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ApD4JA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ApD4JA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AGTA,ACHA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ApD4JA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ArD+JA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ArD+JA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AoC5GA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ArD+JA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtDkKA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtDkKA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtDkKA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvDqKA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvDqKA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvDqKA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxDwKA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxDwKA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxDwKA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzD2KA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzD2KA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzD2KA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1D8KA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1D8KA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1D8KA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3DiLA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3DiLA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3DiLA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5DoLA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5DoLA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5DoLA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7DuLA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7DuLA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7DuLA,AXiCA,A0D9KA,AjDmJA,AgBhDA,ACHA,AhBgDA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9D0LA,AXiCA,A0D9KA,AjDmJA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9D0LA,AXiCA,A0D9KA,AjDmJA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,ADGA,AIZA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9D0LA,AXiCA,A0D9KA,AjDmJA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/D6LA,AXiCA,A0D9KA,AjDmJA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/D6LA,AXiCA,A0D9KA,AjDmJA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/D6LA,AXiCA,A0D9KA,AjDmJA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhEgMA,AXiCA,A0D9KA,AjDmJA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhEgMA,AXiCA,A0D9KA,AjDmJA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhEgMA,AXiCA,A0D9KA,AjDmJA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjEmMA,AXiCA,A0D9KA,AjDmJA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjEmMA,AXiCA,A0D9KA,AjDmJA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjEmMA,AXiCA,A0D9KA,AjDmJA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AjEmMA,AXiCA,A0D9KA,AjDmJA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AjEmMA,AXiCA,A0D9KA,AjDmJA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AGTA,ADGA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AjEmMA,AXiCA,A0D9KA,AjDmJA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,AnEyMA,AXiCA,A0D9KA,AjDmJA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,AnEyMA,AXiCA,A0D9KA,AjDmJA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,AnEyMA,AXiCA,A0D9KA,AjDmJA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ApE4MA,AXiCA,A0D9KA,AjDmJA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ApE4MA,AXiCA,A0D9KA,AjDmJA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ApE4MA,AXiCA,A0D9KA,AjDmJA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ArE+MA,AXiCA,A0D9KA,AjDmJA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ArE+MA,AXiCA,A0D9KA,AjDmJA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ArE+MA,AXiCA,AS3BA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,AtEkNA,AXiCA,AS3BA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,AtEkNA,AXiCA,AS3BA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,AtEkNA,AXiCA,AS3BA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,AvEqNA,AXiCA,AS3BA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,AvEqNA,AXiCA,AS3BA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,AvEqNA,AXiCA,AS3BA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AxEwNA,AXiCA,AS3BA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AxEwNA,AXiCA,AS3BA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AxEwNA,AXiCA,AS3BA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzE2NA,AXiCA,AS3BA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzE2NA,AXiCA,AS3BA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AGTA,AGTA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzE2NA,AXiCA,AS3BA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1E8NA,AXiCA,AS3BA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1E8NA,AXiCA,AS3BA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AsClHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1E8NA,AXiCA,AS3BA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3EiOA,AXiCA,AS3BA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3EiOA,AXiCA,AS3BA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3EiOA,AXiCA,AS3BA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5EoOA,AXiCA,AS3BA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5EoOA,AXiCA,AS3BA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5EoOA,AXiCA,AS3BA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7EuOA,AXiCA,AS3BA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7EuOA,AXiCA,AS3BA,AgBhDA,Af6CA,Ac1CA;AKdA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7EuOA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9E0OA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9E0OA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9E0OA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/E6OA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/E6OA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/E6OA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,A/E6OA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,A/E6OA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,A/E6OA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,AjFmPA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,AjFmPA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,AjFmPA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AlFsPA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AlFsPA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AlFsPA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AnFyPA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AnFyPA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AnFyPA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,ACHA,AV8BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AnFyPA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AnFyPA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AnFyPA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ArF+PA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ArF+PA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ArF+PA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AtFkQA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AtFkQA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AtFkQA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AvFqQA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AvFqQA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AvFqQA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,AxFwQA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,AxFwQA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,AxFwQA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,AzF2QA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,AzF2QA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,AzF2QA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,A1F8QA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,A1F8QA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,A1F8QA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3FiRA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3FiRA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3FiRA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5FoRA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5FoRA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5FoRA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7FuRA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7FuRA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7FuRA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9F0RA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9F0RA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9F0RA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/F6RA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/F6RA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/F6RA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhGgSA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhGgSA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhGgSA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjGmSA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjGmSA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjGmSA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlGsSA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlGsSA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlGsSA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnGySA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnGySA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnGySA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApG4SA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApG4SA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApG4SA,AXiCA,AS3BA,AgBhDA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArG+SA,AXiCA,AyB3EA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AGTA,AENA,AENA,ACHA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArG+SA,AXiCA,AyB3EA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,AENA,ACHA,ACHA,AOrBA,ACHA,AGTA,AENA,AGTA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArG+SA,AXiCA,AyB3EA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,AENA,ACHA,ACHA,AOrBA,ACHA,AGTA,AENA,AGTA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtGkTA,AXiCA,AyB3EA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,AENA,ACHA,ACHA,AOrBA,ACHA,AGTA,AENA,AGTA,AENA,ACHA,AGTA,AGTA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtGkTA,AXiCA,AyB3EA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,AENA,ACHA,ACHA,AOrBA,ACHA,AGTA,AENA,AGTA,AENA,ACHA,AMlBA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtGkTA,AXiCA,AyB3EA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,AENA,ACHA,ACHA,AOrBA,ACHA,AGTA,AENA,AGTA,AENA,ACHA,AMlBA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,AENA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvGqTA,AXiCA,AyB3EA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,AENA,ACHA,ACHA,AOrBA,ACHA,AGTA,AENA,AGTA,AENA,ACHA,AMlBA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AIZA,AENA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvGqTA,AXiCA,AyB3EA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,AENA,ACHA,ACHA,AOrBA,ACHA,AGTA,AENA,AGTA,AENA,ACHA,AMlBA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvGqTA,AXiCA,AyB3EA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,AENA,ACHA,ACHA,AOrBA,ACHA,AGTA,AENA,AGTA,AENA,ACHA,AMlBA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxGwTA,AXiCA,AyB3EA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,AENA,ACHA,AQxBA,ACHA,AGTA,AENA,AGTA,AENA,ACHA,AMlBA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxGwTA,AXiCA,AyB3EA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,AENA,ACHA,AQxBA,ACHA,AGTA,AENA,AGTA,AENA,ACHA,AMlBA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxGwTA,AXiCA,AyB3EA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,AENA,ACHA,AQxBA,ACHA,AGTA,AENA,AGTA,AENA,ACHA,AMlBA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzG2TA,AXiCA,AyB3EA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,AENA,ACHA,AQxBA,ACHA,AGTA,AENA,AGTA,AENA,ACHA,AMlBA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzG2TA,AXiCA,AyB3EA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,AENA,ACHA,AQxBA,ACHA,AGTA,AENA,AGTA,AENA,ACHA,AMlBA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzG2TA,AXiCA,AyB3EA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,AENA,ACHA,AQxBA,ACHA,AGTA,AENA,AKfA,ACHA,AMlBA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1G8TA,AXiCA,AyB3EA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,AENA,ACHA,AQxBA,ACHA,AGTA,AENA,AKfA,ACHA,AMlBA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1G8TA,AXiCA,AyB3EA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,AENA,ACHA,AQxBA,ACHA,AGTA,AENA,AKfA,ACHA,AMlBA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1G8TA,AXiCA,AyB3EA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AuCrHA,AENA,ACHA,AQxBA,ACHA,AGTA,AENA,AKfA,ACHA,AMlBA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3GiUA,AXiCA,AyB3EA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AyC3HA,ACHA,AS3BA,AGTA,AENA,AKfA,ACHA,AMlBA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3GiUA,AXiCA,AyB3EA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AyC3HA,ACHA,AS3BA,AGTA,AENA,AKfA,ACHA,AMlBA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3GiUA,AXiCA,AyB3EA,Af6CA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AyC3HA,ACHA,AS3BA,AGTA,AENA,AKfA,ACHA,AMlBA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5GoUA,AXiCA,AU9BA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,A0C9HA,AS3BA,AGTA,AENA,AKfA,ACHA,AMlBA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5GoUA,AXiCA,AU9BA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,A0C9HA,AS3BA,AGTA,AENA,AKfA,ACHA,AMlBA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5GoUA,AXiCA,AU9BA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,A0C9HA,AS3BA,AGTA,AENA,AKfA,ACHA,AMlBA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7GuUA,AXiCA,AU9BA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,A0C9HA,AS3BA,AGTA,AENA,AKfA,ACHA,AMlBA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7GuUA,AXiCA,AU9BA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,A0C9HA,AS3BA,AGTA,AENA,AKfA,ACHA,AMlBA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7GuUA,AXiCA,AU9BA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,A0C9HA,AS3BA,AGTA,AENA,AKfA,ACHA,AMlBA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9G0UA,AXiCA,AU9BA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,A0C9HA,AS3BA,AGTA,AENA,AKfA,ACHA,AMlBA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9G0UA,AXiCA,AU9BA;AmBxDA,ApC4GA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AMlBA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9G0UA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AMlBA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/G6UA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/G6UA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/G6UA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhHgVA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhHgVA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,ACHA,AENA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhHgVA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjHmVA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,ACHA,AMlBA,AGTA,ADGA,AENA,AENA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjHmVA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,ACHA,AMlBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjHmVA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,ACHA,AMlBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlHsVA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,ACHA,AMlBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlHsVA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,ACHA,AMlBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlHsVA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,ACHA,AMlBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnHyVA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,ACHA,AMlBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnHyVA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,ACHA,AMlBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnHyVA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,ACHA,AMlBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApH4VA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,ACHA,AMlBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApH4VA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,ACHA,AMlBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,AGTA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApH4VA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,ACHA,AMlBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,AGTA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArH+VA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,ACHA,AMlBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,AGTA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArH+VA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,ACHA,AMlBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,AGTA,ADGA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArH+VA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,ACHA,AMlBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,AGTA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtHkWA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,ACHA,AMlBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,AGTA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtHkWA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,ACHA,AMlBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,AGTA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtHkWA,AXiCA,AU9BA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,ACHA,AMlBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,AGTA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtHkWA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,AOrBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,AGTA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtHkWA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,AOrBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,AGTA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtHkWA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,AOrBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AENA,AGTA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AxHwWA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,AOrBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AxHwWA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,AOrBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AxHwWA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,AOrBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ADGA,AxHwWA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,AOrBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ADGA,AxHwWA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,AOrBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AIZA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ADGA,AxHwWA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,AOrBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AIZA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AFMA,AxHwWA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,AOrBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AIZA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AFMA,AxHwWA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,AOrBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AIZA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AFMA,AxHwWA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,AOrBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AIZA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AxHwWA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,AOrBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AGTA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AIZA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AxHwWA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,AOrBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AGTA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AIZA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AxHwWA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,AOrBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AGTA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AIZA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,A5HoXA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,AOrBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AGTA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AIZA,AGTA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,A5HoXA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AMlBA,AT2BA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,AOrBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AGTA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AIZA,AGTA,ACHA,ACHA,AENA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,A5HoXA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,AOrBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AGTA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AIZA,AGTA,ACHA,ACHA,AENA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,A7HuXA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,AOrBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AGTA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AIZA,AGTA,ACHA,ACHA,AENA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,A7HuXA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,AOrBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AGTA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AIZA,AGTA,ACHA,ACHA,AENA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,A7HuXA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,AOrBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AGTA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AIZA,AGTA,ACHA,ACHA,AENA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,A9H0XA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,ACHA,AOrBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AGTA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AIZA,AGTA,ACHA,ACHA,AENA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,A9H0XA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,AQxBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AGTA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AIZA,AGTA,ACHA,ACHA,AENA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,A9H0XA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,AQxBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AGTA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AOrBA,ACHA,ACHA,AENA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,A/H6XA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,AQxBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AGTA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AOrBA,ACHA,ACHA,AENA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,A/H6XA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,AQxBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AGTA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AOrBA,ACHA,ACHA,AENA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,A/H6XA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,AQxBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AGTA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AOrBA,ACHA,ACHA,AENA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,AhIgYA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,AQxBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AGTA,ACHA,AENA,ADGA,AKfA,ADGA,AENA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,AOrBA,ACHA,ACHA,AENA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,AhIgYA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,AQxBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AENA,AGTA,ACHA,AOrBA,ACHA,ACHA,AENA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,AhIgYA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,AQxBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AENA,AGTA,ACHA,AOrBA,ACHA,ACHA,AENA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AjImYA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,AQxBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AENA,AGTA,ACHA,AOrBA,ACHA,ACHA,AENA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AjImYA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,AQxBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AENA,AGTA,ACHA,AOrBA,ACHA,ACHA,AENA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AjImYA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,AQxBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AENA,AGTA,ACHA,AOrBA,ACHA,ACHA,AENA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlIsYA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,AQxBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AENA,AGTA,ACHA,AOrBA,ACHA,ACHA,AENA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlIsYA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,AQxBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AENA,AIZA,AOrBA,ACHA,ACHA,AENA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlIsYA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,AQxBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AENA,AIZA,AOrBA,ACHA,ACHA,AENA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnIyYA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,AQxBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AENA,AIZA,AOrBA,ACHA,ACHA,AENA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnIyYA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,AQxBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AENA,AIZA,AOrBA,ACHA,ACHA,AENA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnIyYA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,AQxBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AENA,AIZA,AOrBA,AENA,AENA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApI4YA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,AQxBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AENA,AIZA,AOrBA,AENA,AENA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApI4YA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AGTA,AQxBA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AENA,AIZA,AOrBA,AENA,AENA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApI4YA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AWjCA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AENA,AIZA,AOrBA,AENA,AENA,AENA,AIZA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArI+YA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AWjCA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AENA,AIZA,AOrBA,AENA,AENA,AENA,AIZA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArI+YA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AWjCA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AENA,AIZA,AOrBA,AENA,AENA,AENA,AIZA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArI+YA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AWjCA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AENA,AIZA,AOrBA,AENA,AENA,AENA,AIZA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtIkZA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AmDzJA,AGTA,AENA,AKfA,ACHA,AS3BA,AWjCA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AENA,AIZA,AOrBA,AENA,AENA,AENA,AIZA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtIkZA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AENA,AKfA,ACHA,AS3BA,AWjCA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AMlBA,AOrBA,AENA,AENA,AENA,AIZA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtIkZA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AENA,AKfA,ACHA,AS3BA,AWjCA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AMlBA,AOrBA,AENA,AENA,AENA,AIZA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvIqZA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AENA,AKfA,ACHA,AS3BA,AWjCA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AMlBA,AOrBA,AENA,AENA,AENA,AIZA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvIqZA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AENA,AKfA,ACHA,AS3BA,AWjCA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AMlBA,AOrBA,AENA,AENA,AENA,AIZA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvIqZA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AENA,AKfA,ACHA,AoB5DA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AIZA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxIwZA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AENA,AKfA,ACHA,AoB5DA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AIZA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxIwZA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AENA,AKfA,ACHA,AoB5DA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AIZA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxIwZA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AENA,AKfA,ACHA,AoB5DA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AIZA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzI2ZA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AENA,AKfA,ACHA,AoB5DA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AIZA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,AHSA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzI2ZA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AENA,AKfA,ACHA,AoB5DA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AIZA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,AFMA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzI2ZA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AENA,AKfA,ACHA,AoB5DA,AGTA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AIZA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,AFMA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1I8ZA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AENA,AKfA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AIZA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,AFMA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1I8ZA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AENA,AKfA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AIZA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,AFMA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1I8ZA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AENA,AKfA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AIZA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,AFMA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3IiaA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AENA,AKfA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AIZA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,AFMA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3IiaA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AENA,AKfA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AIZA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,AFMA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3IiaA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AENA,AKfA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AKfA,ACHA,AENA,ACHA,AGTA,ACHA,AFMA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5IoaA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AENA,AKfA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AKfA,ACHA,AENA,ACHA,AGTA,ACHA,AFMA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5IoaA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AENA,AKfA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AKfA,ACHA,AENA,ACHA,AGTA,ACHA,AFMA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5IoaA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AENA,AKfA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,ACHA,AIZA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AKfA,ACHA,AENA,ACHA,AGTA,ACHA,AFMA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7IuaA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AENA,AKfA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ADGA,AENA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AKfA,ACHA,AENA,ACHA,AGTA,ACHA,AFMA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7IuaA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AENA,AKfA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AKfA,ACHA,AENA,ACHA,AGTA,ACHA,AFMA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7IuaA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AENA,AKfA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AKfA,ACHA,AENA,ACHA,AGTA,ACHA,AFMA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9I0aA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AOrBA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AKfA,ACHA,AENA,ACHA,AGTA,ACHA,AFMA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9I0aA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AOrBA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AKfA,ACHA,AENA,ACHA,AIZA,AFMA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9I0aA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AOrBA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AKfA,ACHA,AENA,ACHA,AIZA,AFMA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/I6aA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AOrBA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AKfA,ACHA,AENA,ACHA,AIZA,AFMA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/I6aA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AOrBA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AKfA,ACHA,AENA,ACHA,AIZA,AFMA,AKfA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/I6aA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AOrBA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AKfA,ACHA,AENA,ACHA,AIZA,AFMA,AKfA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhJgbA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AOrBA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AKfA,ACHA,AENA,ACHA,AIZA,AFMA,AKfA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhJgbA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AOrBA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AKfA,ACHA,AENA,ACHA,AIZA,AFMA,AKfA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhJgbA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AOrBA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AKfA,ACHA,AENA,ACHA,AIZA,AFMA,AKfA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjJmbA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AOrBA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AKfA,ACHA,AENA,ACHA,AIZA,AFMA,AKfA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjJmbA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AOrBA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AKfA,ACHA,AENA,ACHA,AIZA,AFMA,AKfA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjJmbA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AOrBA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AKfA,ACHA,AENA,ACHA,AIZA,AFMA,AKfA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlJsbA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AOrBA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AKfA,ACHA,AENA,ACHA,AIZA,AFMA,AKfA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlJsbA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AOrBA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AENA,AKfA,ACHA,AENA,ACHA,AIZA,AFMA,AKfA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlJsbA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AOrBA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AOrBA,ACHA,AENA,ACHA,AIZA,AFMA,AKfA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnJybA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AOrBA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AOrBA,ACHA,AENA,ACHA,AIZA,AFMA,AKfA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnJybA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AOrBA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AOrBA,ACHA,AENA,ACHA,AIZA,AFMA,AKfA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnJybA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AOrBA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AOrBA,ACHA,AENA,ACHA,AIZA,AFMA,AKfA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApJ4bA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AOrBA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AOrBA,ACHA,AENA,ACHA,AIZA,AFMA,AKfA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApJ4bA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AOrBA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AOrBA,ACHA,AENA,ACHA,AIZA,AFMA,AKfA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApJ4bA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AOrBA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AOrBA,ACHA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArJ+bA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AOrBA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AOrBA,ACHA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArJ+bA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AOrBA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AOrBA,ACHA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArJ+bA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,AsDlKA,AOrBA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AOrBA,ACHA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtJkcA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AOrBA,ACHA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtJkcA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AIZA,ACHA,AENA,AENA,ACHA,AavCA,AENA,AENA,AOrBA,ACHA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtJkcA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AKfA,AENA,AENA,ACHA,AavCA,AENA,AENA,AOrBA,ACHA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvJqcA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AKfA,AENA,AENA,ACHA,AavCA,AIZA,AOrBA,ACHA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvJqcA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AKfA,AENA,AENA,ACHA,AavCA,AIZA,AOrBA,ACHA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvJqcA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AKfA,AENA,AENA,ACHA,AavCA,AIZA,AOrBA,ACHA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxJwcA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AKfA,AENA,AENA,ACHA,AavCA,AIZA,AOrBA,ACHA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxJwcA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AKfA,AENA,AENA,ACHA,AavCA,AIZA,AOrBA,ACHA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxJwcA,AXiCA,AkItYA,AxHwWA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AENA,AKfA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxJwcA,AXiCA,AkItYA,AxHwWA,A0J9cA;A3KkgBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxJwcA,AXiCA,AkItYA,AxHwWA,A0J9cA;A3KkgBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxJwcA,AXiCA,AkItYA,AxHwWA,A0J9cA;A3KkgBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxJwcA,AXiCA,AkItYA,AxHwWA,A0J9cA,ACHA;A5KqgBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxJwcA,AXiCA,AkItYA,AxHwWA,A0J9cA,ACHA;A5KqgBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxJwcA,AXiCA,AkItYA,AxHwWA,A0J9cA,ACHA;A5KqgBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxJwcA,AXiCA,AkItYA,AxHwWA,A0J9cA,ACHA,ACHA;A7KwgBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxJwcA,AXiCA,AkItYA,AxHwWA,A0J9cA,ACHA,ACHA;A7KwgBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxJwcA,AXiCA,AkItYA,AxHwWA,A0J9cA,ACHA,ACHA;A7KwgBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxJwcA,AXiCA,AkItYA,AxHwWA,A0J9cA,ACHA,ACHA,ACHA;A9K2gBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxJwcA,AXiCA,AkItYA,AxHwWA,A0J9cA,ACHA,ACHA,ACHA;A9K2gBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxJwcA,AXiCA,AkItYA,AxHwWA,A0J9cA,ACHA,ACHA,ACHA;A9K2gBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxJwcA,AXiCA,AkItYA,AxHwWA,A2JjdA,ACHA,ACHA,ACHA;A/K8gBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxJwcA,AXiCA,AkItYA,AxHwWA,A2JjdA,ACHA,ACHA,ACHA;A/K8gBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxJwcA,AXiCA,AkItYA,AxHwWA,A2JjdA,ACHA,ACHA,ACHA;A/K8gBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,A9J0dA,AXiCA,AkItYA,AxHwWA,A2JjdA,ACHA,ACHA,ACHA;A/K8gBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,A9J0dA,AXiCA,AkItYA,AxHwWA,A2JjdA,ACHA,ACHA,ACHA;A/K8gBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,A9J0dA,AXiCA,AkItYA,AxHwWA,A4JpdA,ACHA,ACHA;A/K8gBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,A/J6dA,AXiCA,AkItYA,AxHwWA,A4JpdA,ACHA,ACHA;A/K8gBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,A/J6dA,AXiCA,AU9BA,A4JpdA,ACHA,ACHA;A/K8gBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,A/J6dA,AXiCA,AU9BA,A6JvdA,ACHA;A/K8gBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,AhKgeA,AXiCA,AU9BA,A6JvdA,ACHA;A/K8gBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,AhKgeA,AXiCA,AU9BA,A6JvdA,ACHA;A/K8gBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,AhKgeA,AXiCA,AU9BA,A8J1dA;A/K8gBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,AjKmeA,AXiCA,AU9BA,A8J1dA;A/K8gBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,AjKmeA,AXiCA,AU9BA,A8J1dA;A/K8gBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,AjKmeA,AXiCA,AU9BA,A8J1dA;A/K8gBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,AlKseA,AXiCA,AU9BA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AQxBA,AENA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,AlKseA,AXiCA,AU9BA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,ACHA,AiBnDA,AU9BA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,AlKseA,AXiCA,AU9BA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AU9BA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,AnKyeA,AXiCA,AU9BA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AU9BA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,AnKyeA,AXiCA,AU9BA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AU9BA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,AnKyeA,AXiCA,AU9BA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AU9BA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApK4eA,AXiCA,AU9BA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AU9BA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApK4eA,AXiCA,AU9BA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AU9BA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApK4eA,AXiCA,AU9BA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AU9BA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArK+eA,AXiCA,AU9BA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AU9BA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArK+eA,AXiCA,AU9BA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AU9BA,ACHA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,AENA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArK+eA,AXiCA,AU9BA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,AENA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtKkfA,AXiCA,AU9BA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,AENA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtKkfA,AXiCA,AU9BA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,AENA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtKkfA,AXiCA,AU9BA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,AENA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvKqfA,AXiCA,AU9BA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,AENA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvKqfA,AXiCA,AU9BA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,AENA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvKqfA,AXiCA,AU9BA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,AENA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxKwfA,AXiCA,AU9BA;AjBoDA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,AENA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxKwfA,AXiCA;APsBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,AENA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxKwfA,AXiCA;APsBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,AENA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzK2fA,AXiCA;APsBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,AENA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzK2fA,AXiCA;APsBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,AENA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzK2fA,AXiCA;APsBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,AENA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AzK2fA,AXiCA;APsBA,AENA,AHSA,A6DvLA,ACHA,AuBrEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AzK2fA,AXiCA;APsBA,AENA,AHSA,A6DvLA,AwBxEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AzK2fA,AXiCA;APsBA,AENA,AHSA,A6DvLA,AwBxEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AzK2fA,AXiCA;APsBA,AENA,AHSA,A6DvLA,AwBxEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AzK2fA,AXiCA;APsBA,AENA,AHSA,A6DvLA,AwBxEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,AENA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AzK2fA,AXiCA;APsBA,AENA,AHSA,A6DvLA,AwBxEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AHSA,AzK2fA,AXiCA;APsBA,AENA,AHSA,A6DvLA,AwBxEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AHSA,AzK2fA,AXiCA;APsBA,AENA,AHSA,A6DvLA,AwBxEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AHSA,AzK2fA,AXiCA;APsBA,AENA,AHSA,A6DvLA,AwBxEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AJYA,AzK2fA,AXiCA;APsBA,AENA,AHSA,A6DvLA,AwBxEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AJYA,AzK2fA,AXiCA;APsBA,AENA,AHSA,A6DvLA,AwBxEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AJYA,AzK2fA,AXiCA;APsBA,AENA,AHSA,A6DvLA,AwBxEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ALeA,AzK2fA,AXiCA;APsBA,AENA,AHSA,A6DvLA,AwBxEA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AENA,AkBtDA,AWjCA,AIZA,AGTA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ALeA,AzK2fA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AoB5DA,AWjCA,AIZA,AGTA,AENA,ACHA,AENA,ACHA,AENA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ALeA,AzK2fA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AoB5DA,AWjCA,AIZA,AGTA,AENA,ACHA,AENA,ACHA,AENA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ALeA,AMlBA,A/K6gBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AoB5DA,AWjCA,AIZA,AGTA,AENA,ACHA,AENA,ACHA,AENA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ALeA,AMlBA,A/K6gBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AoB5DA,AWjCA,AIZA,AGTA,AENA,ACHA,AENA,ACHA,AENA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ALeA,AMlBA,A/K6gBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AoB5DA,AWjCA,AIZA,AGTA,AENA,ACHA,AENA,ACHA,AENA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ALeA,AMlBA,ACHA,AhLghBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AoB5DA,AWjCA,AIZA,AGTA,AENA,ACHA,AENA,ACHA,AENA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ALeA,AMlBA,ACHA,AhLghBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AoB5DA,AWjCA,AIZA,AGTA,AENA,ACHA,AENA,ACHA,AENA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ALeA,AMlBA,ACHA,AhLghBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AoB5DA,AWjCA,AIZA,AGTA,AENA,ACHA,AENA,ACHA,AENA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ALeA,AMlBA,AENA,ADGA,AhLghBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AoB5DA,AWjCA,AIZA,AGTA,AENA,ACHA,AENA,ACHA,AENA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ALeA,AMlBA,AENA,ADGA,AhLghBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AoB5DA,AWjCA,AIZA,AGTA,AENA,ACHA,AENA,ACHA,AENA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ALeA,AMlBA,AENA,ADGA,AhLghBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AoB5DA,AWjCA,AOrBA,AENA,ACHA,AENA,ACHA,AENA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ALeA,AMlBA,AENA,ADGA,AENA,AlLshBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AoB5DA,AWjCA,AOrBA,AENA,ACHA,AENA,ACHA,AENA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ALeA,AMlBA,AENA,ADGA,AENA,AlLshBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AoB5DA,AWjCA,AOrBA,AENA,ACHA,AENA,ACHA,AENA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ALeA,AMlBA,AENA,ADGA,AENA,AlLshBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AoB5DA,AWjCA,AOrBA,AENA,ACHA,AGTA,AENA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ALeA,AMlBA,AENA,ADGA,AENA,ACHA,AnLyhBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AoB5DA,AWjCA,AOrBA,AENA,ACHA,AGTA,AENA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ALeA,AMlBA,AENA,ADGA,AENA,ACHA,AnLyhBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AoB5DA,AWjCA,AOrBA,AENA,ACHA,AGTA,AENA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ALeA,AMlBA,AENA,ADGA,AENA,ACHA,AnLyhBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AoB5DA,AWjCA,AOrBA,AENA,ACHA,AGTA,AENA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ALeA,AMlBA,AENA,ADGA,AENA,ACHA,ACHA,ApL4hBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AoB5DA,AWjCA,AOrBA,AENA,ACHA,AGTA,AENA,AIZA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ALeA,AMlBA,AENA,ADGA,AENA,ACHA,ACHA,ApL4hBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AoB5DA,AWjCA,AOrBA,AENA,ACHA,AGTA,AMlBA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ALeA,AMlBA,AENA,ADGA,AENA,ACHA,ACHA,ApL4hBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AENA,AoB5DA,AWjCA,AOrBA,AENA,ACHA,AGTA,AMlBA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ALeA,AMlBA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ArL+hBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AsBlEA,AWjCA,AOrBA,AENA,ACHA,AGTA,AMlBA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ArL+hBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AsBlEA,AWjCA,AOrBA,AENA,ACHA,AGTA,AMlBA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ArL+hBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AsBlEA,AWjCA,AOrBA,AENA,ACHA,AGTA,AMlBA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,AtLkiBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AsBlEA,AWjCA,AOrBA,AENA,ACHA,AGTA,AMlBA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,AtLkiBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AsBlEA,AWjCA,AOrBA,AENA,ACHA,AGTA,AMlBA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,AtLkiBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AsBlEA,AWjCA,AOrBA,AENA,ACHA,AGTA,AMlBA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AvLqiBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AsBlEA,AWjCA,AOrBA,AENA,ACHA,AGTA,AMlBA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AvLqiBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AsBlEA,AWjCA,AOrBA,AENA,ACHA,AGTA,AMlBA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AvLqiBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AsBlEA,AWjCA,AOrBA,AENA,ACHA,AGTA,AMlBA,AENA,AGTA,ACHA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AIZA,AENA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxLwiBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AsBlEA,AWjCA,AOrBA,AENA,ACHA,AGTA,AMlBA,AENA,AIZA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AIZA,AENA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxLwiBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AOrBA,AsBlEA,AWjCA,AOrBA,AENA,ACHA,AGTA,AMlBA,AENA,AIZA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AIZA,AENA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxLwiBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,A6BvFA,AWjCA,AOrBA,AENA,ACHA,AGTA,AMlBA,AENA,AIZA,ACHA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AIZA,AGTA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzL2iBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,A6BvFA,AWjCA,AOrBA,AENA,ACHA,AGTA,AMlBA,AENA,AKfA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AIZA,AGTA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzL2iBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,A6BvFA,AWjCA,AOrBA,AENA,ACHA,AGTA,AMlBA,AENA,AKfA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AIZA,AGTA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzL2iBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,A6BvFA,AWjCA,AOrBA,AENA,AIZA,AMlBA,AENA,AKfA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AIZA,AGTA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1L8iBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,A6BvFA,AWjCA,AOrBA,AENA,AIZA,AMlBA,AENA,AKfA,AGTA,ACHA,AENA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AOrBA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1L8iBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,A6BvFA,AWjCA,AOrBA,AENA,AIZA,AMlBA,AENA,AKfA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AOrBA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1L8iBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AENA,AIZA,AMlBA,AENA,AKfA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AOrBA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3LijBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AENA,AIZA,AMlBA,AENA,AKfA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AOrBA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3LijBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AENA,AKfA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AOrBA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3LijBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AENA,AKfA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AOrBA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5LojBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AENA,AKfA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AOrBA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5LojBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AENA,AKfA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AS3BA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5LojBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AENA,AKfA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AS3BA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7LujBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AENA,AKfA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AWjCA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7LujBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AENA,AKfA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AWjCA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7LujBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AENA,AKfA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AWjCA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9L0jBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AENA,AKfA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AWjCA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9L0jBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AENA,AKfA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AWjCA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9L0jBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AENA,AKfA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AWjCA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/L6jBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AENA,AKfA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AWjCA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/L6jBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AENA,AKfA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AWjCA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/L6jBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AENA,AKfA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AWjCA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhMgkBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AENA,AKfA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AWjCA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhMgkBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AENA,AKfA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AWjCA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhMgkBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AENA,AKfA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AWjCA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjMmkBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AENA,AKfA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AWjCA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjMmkBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AENA,AKfA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AWjCA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjMmkBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AYpCA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlMskBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,AYpCA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlMskBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,AavCA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlMskBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,AavCA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnMykBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,AavCA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnMykBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AGTA,AGTA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,AavCA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnMykBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,ACHA,AavCA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApM4kBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApM4kBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApM4kBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArM+kBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArM+kBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArM+kBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtMklBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtMklBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtMklBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AtMklBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AtMklBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AtMklBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,AxMwlBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,AxMwlBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,AxMwlBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AzM2lBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AzM2lBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AzM2lBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,A1M8lBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,A1M8lBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,A1M8lBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,A3MimBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,A3MimBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,A3MimBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,A5MomBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,A5MomBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,A5MomBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,A7MumBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,A7MumBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,A7MumBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9M0mBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9M0mBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,AKfA,AwCxHA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,ACHA,ACHA,AMlBA,ACHA,ACHA,AENA,AENA,Ac1CA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9M0mBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,A6CvIA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,ACHA,AIZA,Ac1CA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/M6mBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,A6CvIA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,ACHA,AIZA,Ac1CA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/M6mBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AGTA,A6CvIA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,ACHA,AIZA,Ac1CA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/M6mBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AgDhJA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,ACHA,AIZA,Ac1CA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhNgnBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AgDhJA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,ACHA,AIZA,Ac1CA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhNgnBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AgDhJA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,ACHA,AIZA,Ac1CA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhNgnBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AgDhJA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,AKfA,Ac1CA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjNmnBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AgDhJA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,AKfA,Ac1CA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjNmnBA,AXiCA;APsBA,AENA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AgDhJA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,AKfA,Ac1CA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjNmnBA,AXiCA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AgDhJA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,AKfA,Ac1CA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AjNmnBA,AXiCA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AgDhJA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,AKfA,Ac1CA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AjNmnBA,AXiCA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AgDhJA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AjNmnBA,AXiCA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AgDhJA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,AnNynBA,AXiCA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AgDhJA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,A9N0pBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AgDhJA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,A9N0pBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AgDhJA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,A/N6pBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AgDhJA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,A/N6pBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AgDhJA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,A/N6pBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AgDhJA,AOrBA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AhOgqBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AhOgqBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AhOgqBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,AjOmqBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,AjOmqBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,AjOmqBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,AlOsqBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,AlOsqBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,AlOsqBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AnOyqBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,AMlBA,AENA,AMlBA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AnOyqBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,AMlBA,AQxBA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,AENA,AENA,ADGA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AnOyqBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,AMlBA,AQxBA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,AENA,AENA,ADGA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApO4qBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,AMlBA,AQxBA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,AENA,ADGA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApO4qBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,Ac1CA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,AENA,ADGA,AENA,AENA,ACHA,AGTA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApO4qBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,Ac1CA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,AENA,ADGA,AENA,AENA,ACHA,AGTA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArO+qBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,Ac1CA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,AENA,ADGA,AENA,AENA,ACHA,AGTA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArO+qBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,Ac1CA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,AENA,ADGA,AENA,AENA,ACHA,AGTA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArO+qBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,Ac1CA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,AENA,ADGA,AENA,AENA,ACHA,AGTA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtOkrBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,Ac1CA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,AENA,AENA,ACHA,AGTA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtOkrBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,Ac1CA,ACHA,AmBzDA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,AENA,AENA,ACHA,AGTA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtOkrBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,Ac1CA,ACHA,AmBzDA,AQxBA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,AENA,AENA,ACHA,AGTA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvOqrBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,Ac1CA,ACHA,AmBzDA,AQxBA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,AENA,AENA,ACHA,AGTA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvOqrBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,Ac1CA,ACHA,AmBzDA,AQxBA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,AENA,AENA,ACHA,AGTA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvOqrBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,Ac1CA,ACHA,AmBzDA,AQxBA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,AENA,AENA,ACHA,AGTA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxOwrBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,Ac1CA,ACHA,AmBzDA,AQxBA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,AENA,AGTA,AGTA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxOwrBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,Ac1CA,ACHA,AmBzDA,AQxBA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,AENA,AGTA,AGTA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxOwrBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,Ac1CA,ACHA,AmBzDA,AQxBA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,AENA,AGTA,AGTA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzO2rBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,Ac1CA,ACHA,AmBzDA,AQxBA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,AENA,AGTA,AGTA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzO2rBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,Ac1CA,ACHA,AmBzDA,AQxBA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,AENA,AGTA,AGTA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzO2rBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,Ac1CA,ACHA,AmBzDA,AQxBA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,AENA,AGTA,AGTA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1O8rBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,Ac1CA,ACHA,AmBzDA,AQxBA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,AENA,AGTA,AGTA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1O8rBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AOrBA,Ac1CA,ACHA,AmBzDA,AQxBA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,AENA,AGTA,AGTA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1O8rBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AqB/DA,ACHA,AmBzDA,AQxBA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,AENA,AGTA,AGTA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3OisBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AqB/DA,ACHA,AmBzDA,AQxBA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,AENA,AGTA,AGTA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3OisBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AqB/DA,ACHA,AmBzDA,AQxBA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,AENA,AGTA,AGTA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3OisBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AqB/DA,ACHA,AmBzDA,AS3BA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,AENA,AGTA,AGTA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5OosBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AqB/DA,ACHA,AmBzDA,AS3BA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,AENA,AGTA,AGTA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5OosBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AqB/DA,ACHA,AmBzDA,AS3BA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,AENA,AGTA,AGTA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5OosBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AqB/DA,ACHA,AmBzDA,AS3BA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,AENA,AMlBA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7OusBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AqB/DA,ACHA,AmBzDA,AS3BA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,AENA,AMlBA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7OusBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AqB/DA,ACHA,AmBzDA,AS3BA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,AQxBA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7OusBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AqB/DA,ACHA,AmBzDA,AS3BA,ACHA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9O0sBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AqB/DA,ACHA,AmBzDA,AS3BA,ACHA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9O0sBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AqB/DA,ACHA,AmBzDA,AS3BA,ACHA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9O0sBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AqB/DA,ACHA,AmBzDA,AS3BA,ACHA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/O6sBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AqB/DA,ACHA,AmBzDA,AU9BA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/O6sBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AqB/DA,ACHA,AmBzDA,AU9BA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/O6sBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AqB/DA,ACHA,AmBzDA,AU9BA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhPgtBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AqB/DA,ACHA,AmBzDA,AU9BA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhPgtBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,AuDrKA,AMlBA,AMlBA,AsBlEA,AmBzDA,AU9BA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhPgtBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AMlBA,AsBlEA,AmBzDA,AU9BA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjPmtBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AMlBA,AsBlEA,AmBzDA,AU9BA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjPmtBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AMlBA,AsBlEA,AmBzDA,AU9BA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjPmtBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AMlBA,AsBlEA,AmBzDA,AU9BA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlPstBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AMlBA,AsBlEA,AmBzDA,AU9BA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlPstBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AMlBA,AsBlEA,AmBzDA,AU9BA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlPstBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AMlBA,AsBlEA,AmBzDA,AU9BA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnPytBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AMlBA,AsBlEA,AmBzDA,AU9BA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnPytBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AMlBA,AsBlEA,AmBzDA,AU9BA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnPytBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AMlBA,AsBlEA,AmBzDA,AU9BA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApP4tBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AMlBA,AsBlEA,AmBzDA,AU9BA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApP4tBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AMlBA,AyC3HA,AU9BA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApP4tBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AMlBA,AyC3HA,AU9BA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArP+tBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AMlBA,AyC3HA,AU9BA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArP+tBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AMlBA,AyC3HA,AU9BA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArP+tBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AMlBA,AyC3HA,AU9BA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtPkuBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AMlBA,AyC3HA,AU9BA,ACHA,ACHA,AKfA,AENA,ACHA,AQxBA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtPkuBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AMlBA,AyC3HA,AU9BA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtPkuBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,A+C7IA,AU9BA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvPquBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,A+C7IA,AU9BA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvPquBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,A+C7IA,AU9BA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvPquBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,A+C7IA,AU9BA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxPwuBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,A+C7IA,AU9BA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxPwuBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,A+C7IA,AU9BA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxPwuBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,A+C7IA,AU9BA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzP2uBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,A+C7IA,AU9BA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzP2uBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,A+C7IA,AU9BA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzP2uBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,A+C7IA,AU9BA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1P8uBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,A+C7IA,AU9BA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1P8uBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1P8uBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3PivBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3PivBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3PivBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5PovBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5PovBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5PovBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,A5PovBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,A5PovBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,A5PovBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,A9P0vBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,A9P0vBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,A9P0vBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,A/P6vBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,A/P6vBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,A/P6vBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AhQgwBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AhQgwBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AhQgwBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,AjQmwBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,AjQmwBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,AjQmwBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,AlQswBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,AlQswBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,AlQswBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AnQywBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AnQywBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,ACHA,AKfA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AnQywBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,ACHA,AMlBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApQ4wBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApQ4wBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApQ4wBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArQ+wBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArQ+wBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArQ+wBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtQkxBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtQkxBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtQkxBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvQqxBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvQqxBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvQqxBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxQwxBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxQwxBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxQwxBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzQ2xBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzQ2xBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzQ2xBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1Q8xBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1Q8xBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1Q8xBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3QiyBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3QiyBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3QiyBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5QoyBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5QoyBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5QoyBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7QuyBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7QuyBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7QuyBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9Q0yBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9Q0yBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9Q0yBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/Q6yBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/Q6yBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/Q6yBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhRgzBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhRgzBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AGTA,AQxBA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhRgzBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AWjCA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjRmzBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AWjCA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjRmzBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AWjCA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjRmzBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AWjCA,AENA,AIZA,AENA,ACHA,ACHA,AGTA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlRszBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AWjCA,AENA,AIZA,AENA,ACHA,ACHA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlRszBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AWjCA,AENA,AIZA,AENA,ACHA,ACHA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlRszBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AWjCA,AENA,AIZA,AENA,ACHA,ACHA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnRyzBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AWjCA,AENA,AIZA,AENA,ACHA,ACHA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnRyzBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AWjCA,AENA,AIZA,AENA,ACHA,ACHA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnRyzBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AWjCA,AENA,AIZA,AENA,ACHA,ACHA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApR4zBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AWjCA,AENA,AIZA,AENA,ACHA,ACHA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApR4zBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AWjCA,AENA,AIZA,AENA,ACHA,ACHA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApR4zBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AWjCA,AENA,AIZA,AENA,ACHA,ACHA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArR+zBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AWjCA,AMlBA,AENA,ACHA,ACHA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArR+zBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,ACHA,A6DvLA,AyD3KA,AOrBA,AWjCA,AMlBA,AENA,ACHA,ACHA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArR+zBA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AOrBA,AWjCA,AMlBA,AENA,ACHA,ACHA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtRk0BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AOrBA,AWjCA,AMlBA,AENA,ACHA,ACHA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtRk0BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AOrBA,AWjCA,AMlBA,AENA,ACHA,ACHA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtRk0BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AOrBA,AWjCA,AMlBA,AENA,ACHA,ACHA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AtRk0BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AtRk0BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AtRk0BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AtRk0BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AtRk0BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AtRk0BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,AzR20BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,AzR20BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,AzR20BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,A1R80BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,A1R80BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,AENA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,A1R80BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,A3Ri1BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,A3Ri1BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,A3Ri1BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,A5Ro1BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,A5Ro1BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,A5Ro1BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,A7Ru1BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,A7Ru1BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,A7Ru1BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,A9R01BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,A9R01BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,A9R01BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/R61BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/R61BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/R61BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhSg2BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhSg2BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhSg2BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjSm2BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjSm2BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjSm2BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlSs2BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlSs2BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlSs2BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,AENA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnSy2BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,AENA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnSy2BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,AENA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnSy2BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,AENA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApS42BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,AENA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApS42BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AMlBA,AENA,AENA,AKfA,ACHA,AKfA,ACHA,AENA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApS42BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,AyD3KA,AkBtDA,AQxBA,AENA,AKfA,ACHA,AKfA,ACHA,AENA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArS+2BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,A2EjOA,AQxBA,AENA,AKfA,ACHA,AKfA,ACHA,AENA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArS+2BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,A2EjOA,AQxBA,AENA,AKfA,ACHA,AKfA,ACHA,AENA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArS+2BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,A2EjOA,AQxBA,AENA,AKfA,ACHA,AKfA,ACHA,AENA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtSk3BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,A2EjOA,AQxBA,AENA,AKfA,ACHA,AKfA,ACHA,AENA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtSk3BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,A2EjOA,AQxBA,AENA,AKfA,ACHA,AKfA,ACHA,AENA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtSk3BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,A2EjOA,AQxBA,AENA,AKfA,ACHA,AKfA,ACHA,AENA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvSq3BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,A2EjOA,AQxBA,AENA,AKfA,ACHA,AKfA,ACHA,AENA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvSq3BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,A2EjOA,AQxBA,AENA,AKfA,ACHA,AKfA,ACHA,AENA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvSq3BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,A2EjOA,AQxBA,AENA,AKfA,ACHA,AKfA,ACHA,AENA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxSw3BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,A2EjOA,AQxBA,AENA,AKfA,ACHA,AKfA,ACHA,AENA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxSw3BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,A2EjOA,AQxBA,AENA,AKfA,ACHA,AKfA,ACHA,AENA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxSw3BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,A2EjOA,AQxBA,AENA,AKfA,ACHA,AKfA,ACHA,AENA,ACHA,AENA,AIZA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzS23BA;ALgBA,AHSA,AqF/PA,ADGA,AIZA,A8D1LA,A2EjOA,AQxBA,AENA,AKfA,ACHA,AKfA,ACHA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzS23BA;ALgBA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AENA,AKfA,ACHA,AKfA,ACHA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzS23BA;ALgBA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AENA,AKfA,ACHA,AKfA,ACHA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1S83BA;ALgBA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AENA,AKfA,ACHA,AKfA,ACHA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1S83BA;ALgBA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AKfA,ACHA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1S83BA;ALgBA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AKfA,ACHA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3Si4BA;ALgBA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AKfA,ACHA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3Si4BA;ALgBA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AKfA,ACHA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3Si4BA;ALgBA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5So4BA;ALgBA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5So4BA;ALgBA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A5So4BA;ALgBA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7Su4BA;ALgBA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7Su4BA;ALgBA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A7Su4BA;ALgBA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9S04BA;ALgBA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9S04BA;ALgBA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9S04BA;ALgBA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA;ALgBA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA;ALgBA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA;ALgBA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AgTh5BA;ArTg6BA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AgTh5BA;ArTg6BA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AgTh5BA;ArTg6BA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,ADGA;ArTg6BA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,ADGA;ArTg6BA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,ADGA;AELA,AvTq6BA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,ADGA;AELA,AvTq6BA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,ADGA;AELA,AvTq6BA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,ADGA;AELA,AvTq6BA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AENA,AHSA;AELA,AvTq6BA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AENA,AHSA;AELA,AvTq6BA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AENA,AHSA;AELA,AENA,AzT26BA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AENA,AHSA;AELA,AENA,AzT26BA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AENA,AHSA;AELA,AENA,AzT26BA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AENA,AHSA;AKdA,AHSA,AENA,AzT26BA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AENA,AHSA;AKdA,AHSA,AENA,AzT26BA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AENA,AHSA;AKdA,AHSA,AENA,AzT26BA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AENA,AHSA;AKdA,AHSA,AENA,AzT26BA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AKfA,AHSA,AHSA;AKdA,AHSA,AENA,AzT26BA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AKfA,AHSA,AHSA;AKdA,AHSA,AENA,AzT26BA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AKfA,AHSA,AHSA;AKdA,AHSA,AENA,AzT26BA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,ACHA,AMlBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AKfA,ACHA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,AOrBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AKfA,ACHA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,AHSA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,AOrBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AKfA,ACHA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,A6Tv7BA,AhUg8BA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,AOrBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AKfA,ACHA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,A6Tv7BA,AhUg8BA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,AOrBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AKfA,ACHA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,A6Tv7BA,AhUg8BA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,AOrBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AKfA,ACHA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,A6Tv7BA,ACHA,AjUm8BA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,AOrBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AENA,AGTA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AKfA,ACHA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,A6Tv7BA,ACHA,AjUm8BA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,AOrBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AKfA,ACHA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,A6Tv7BA,ACHA,AjUm8BA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,AOrBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AKfA,ACHA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,A6Tv7BA,ACHA,AjUm8BA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,AOrBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AKfA,AIZA,AHSA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,A6Tv7BA,ACHA,AjUm8BA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,AOrBA,AENA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AKfA,AIZA,AHSA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,A6Tv7BA,ACHA,AjUm8BA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AKfA,AIZA,AHSA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,A6Tv7BA,ACHA,AjUm8BA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AKfA,AIZA,ACHA,AJYA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,A6Tv7BA,ACHA,AjUm8BA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AKfA,AIZA,ACHA,AJYA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,A6Tv7BA,ACHA,AjUm8BA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AKfA,AIZA,ACHA,AJYA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AjUm8BA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AKfA,AIZA,ACHA,AJYA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AjUm8BA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,ACHA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AKfA,AIZA,ACHA,AJYA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AjUm8BA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AKfA,AIZA,ACHA,AJYA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AKfA,AIZA,ACHA,AJYA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,A2EjOA,AQxBA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AKfA,AIZA,ACHA,AJYA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AKfA,AIZA,ACHA,AJYA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AavCA,ARwBA,AIZA,ACHA,AJYA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AavCA,ARwBA,AIZA,ACHA,AJYA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AavCA,ARwBA,AIZA,ACHA,AJYA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AavCA,ARwBA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AKdA,AHSA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AavCA,ARwBA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AavCA,ARwBA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AavCA,AENA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AavCA,AENA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/S64BA,AiTn5BA,AavCA,AENA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,AENA,ACHA,A/S64BA,AiTn5BA,AavCA,AGTA,ADGA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,AENA,ACHA,A/S64BA,AiTn5BA,AavCA,AGTA,ADGA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,AENA,ACHA,A/S64BA,AiTn5BA,AavCA,AGTA,ADGA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,AENA,ACHA,A/S64BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,ACHA,ACHA,AENA,ACHA,A/S64BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,ACHA,ACHA,AENA,ACHA,A/S64BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,ACHA,ACHA,AENA,ACHA,A/S64BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,ACHA,ACHA,AENA,ACHA,A/S64BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,ACHA,ACHA,AENA,ACHA,A/S64BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,ACHA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,ACHA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,ACHA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,ACHA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,ACHA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,ACHA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,ACHA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,ACHA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,ACHA,AFMA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AFMA,AV8BA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AIZA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,AJYA,AJYA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AMlBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,A2Uj+BA,AtPkuBA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AOrBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AS3BA,ACHA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AU9BA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AU9BA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,ALeA,ACHA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AU9BA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,ACHA,ACHA,ACHA,ACHA,AOrBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AU9BA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AU9BA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AU9BA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,ACHA,AZoCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AU9BA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AU9BA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AU9BA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AU9BA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AENA,ACHA,AENA,ACHA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AU9BA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AENA,ACHA,AGTA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AU9BA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AENA,ACHA,AGTA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AU9BA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AENA,ACHA,AGTA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AU9BA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AENA,ACHA,AGTA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AU9BA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AENA,ACHA,AGTA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AU9BA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AENA,ACHA,AGTA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AU9BA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AENA,ACHA,AGTA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AU9BA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AENA,ACHA,AGTA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AU9BA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AGTA,AGTA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AU9BA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AGTA,AGTA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,AmFzPA,AOrBA,AU9BA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AGTA,AGTA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,A0F9QA,AU9BA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AGTA,AGTA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,A0F9QA,AU9BA,AMlBA,ACHA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AGTA,AGTA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,A0F9QA,AU9BA,AOrBA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AGTA,AGTA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,A0F9QA,AU9BA,AOrBA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AGTA,AGTA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,A0F9QA,AU9BA,AOrBA,AENA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AOrBA,ADGA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AGTA,AGTA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,A0F9QA,AU9BA,AS3BA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AMlBA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AGTA,AGTA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,A0F9QA,AU9BA,AS3BA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AMlBA,AGTA,AKfA,AENA,ACHA,ACHA,AOrBA,AGTA,AGTA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AJYA,ARwBA,AHSA;AELA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,A0F9QA,AU9BA,AS3BA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AGTA,AGTA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AJYA,ARwBA;ADIA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,A0F9QA,AU9BA,AS3BA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AGTA,AGTA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AZoCA;ADIA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,A0F9QA,AU9BA,AS3BA,ACHA,AKfA,ACHA,ACHA,ACHA,AGTA,AKfA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AGTA,AGTA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AZoCA;ADIA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,A0F9QA,AU9BA,AS3BA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AGTA,AGTA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AZoCA;ADIA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,A0F9QA,AU9BA,AS3BA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AGTA,AGTA,AqB/DA,ApU48BA,AiTn5BA,AavCA,AGTA,AXiCA,AS3BA,AZoCA;ADIA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,A0F9QA,AU9BA,AS3BA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AGTA,AGTA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA,AZoCA;ADIA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AGTA,AGTA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA,AZoCA;ADIA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AGTA,AGTA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA,AZoCA;ADIA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AGTA,AGTA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA,AZoCA;ADIA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,ArU+8BA,AqF/PA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA,AZoCA;ADIA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA,AZoCA;ADIA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA,AZoCA;ADIA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA,AZoCA;ADIA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA,AZoCA;ADIA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA,AZoCA;ADIA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA,AZoCA;ADIA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA,AZoCA;ADIA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA,AZoCA;ADIA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA,AZoCA;ADIA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA,AZoCA;ADIA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA,AZoCA;ADIA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA,AZoCA;ADIA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AbwCA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AbwCA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AbwCA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AbwCA,AENA,AzT26BA,A6Tv7BA,AIZA,AHSA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AbwCA,AENA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,ACHA,ACHA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AS3BA,ACHA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AU9BA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AU9BA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AU9BA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AU9BA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AU9BA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,A8T17BA,AGTA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AU9BA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AU9BA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AU9BA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AU9BA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AU9BA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA,AS3BA;AXkCA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AU9BA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AU9BA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AU9BA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AU9BA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AU9BA,ACHA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AENA,AMlBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AQxBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AQxBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AQxBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,AIZA,AhPgtBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AQxBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AQxBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AQxBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AQxBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AQxBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AQxBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AQxBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AQxBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AQxBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AQxBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AQxBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AQxBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AQxBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AWjCA,AQxBA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AQxBA,AENA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,ACHA,AOrBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,AmBzDA,AU9BA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,A6BvFA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,A6BvFA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,A6BvFA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,A6BvFA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,A6BvFA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,A6BvFA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,A6BvFA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,A6BvFA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,A6BvFA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,A6BvFA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,A6BvFA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,A6BvFA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,A6BvFA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,A6BvFA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,A6BvFA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,A6BvFA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,A6BvFA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,A6BvFA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,A6BvFA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,AkEtMA,A0F9QA,AmBzDA,ACHA,AKfA,AENA,A6BvFA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A6BvFA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A6BvFA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A6BvFA,ACHA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AmBzDA,ACHA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,AMlBA,AqB/DA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,A2BjFA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,A2BjFA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,A2BjFA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,A2BjFA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,A2BjFA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,A2BjFA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,A2BjFA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,A2BjFA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,A2BjFA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,A2BjFA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,A2BjFA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,A2BjFA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,A2BjFA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,A2BjFA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,A8B1FA,AQxBA,A2BjFA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,AsClHA,A2BjFA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,AsClHA,A2BjFA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,AsClHA,A2BjFA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,AsClHA,A2BjFA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,AsClHA,A2BjFA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AENA,AsClHA,A2BjFA,ApU48BA,AiUn8BA,AXiCA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AoB5DA,AKfA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA,AsTl6BA;AFOA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A6Tv7BA,ACHA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA,ApU48BA;AoT35BA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,A4JpdA,AyB3EA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A5OosBA,ADGA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AwCxHA,A2BjFA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AmEzMA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AmEzMA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AmEzMA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AmEzMA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AmEzMA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AmEzMA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AmEzMA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AqL/hBA,AmEzMA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AwPxuBA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AwPxuBA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AwPxuBA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AwPxuBA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AwPxuBA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AwPxuBA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AwPxuBA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AwPxuBA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AwPxuBA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AwPxuBA;AhBiDA,AzT26BA,A8T17BA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA,AwPxuBA;AhBiDA,AKfA,A7OusBA;AwOvrBA,AKfA,A7OusBA;AwOvrBA,AKfA,A7OusBA;AwOvrBA,AKfA,A7OusBA;AwOvrBA,AKfA,A7OusBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AwOvrBA,AxOwrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/**\n * @fileoverview Expose out ESLint and CLI to require.\n * @author Ian Christian Myers\n */\n\n\n\nconst Linter = require(\"./linter\");\n\nmodule.exports = {\n    Linter,\n    CLIEngine: require(\"./cli-engine\"),\n    RuleTester: require(\"./testers/rule-tester\"),\n    SourceCode: require(\"./util/source-code\")\n};\n\nlet deprecatedLinterInstance = null;\n\nObject.defineProperty(module.exports, \"linter\", {\n    enumerable: false,\n    get() {\n        if (!deprecatedLinterInstance) {\n            deprecatedLinterInstance = new Linter();\n        }\n\n        return deprecatedLinterInstance;\n    }\n});\n","/**\n * @fileoverview Main Linter Class\n * @author Gyandeep Singh\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst eslintScope = require(\"eslint-scope\"),\n    evk = require(\"eslint-visitor-keys\"),\n    espree = require(\"espree\"),\n    lodash = require(\"lodash\"),\n    CodePathAnalyzer = require(\"./code-path-analysis/code-path-analyzer\"),\n    ConfigOps = require(\"./config/config-ops\"),\n    validator = require(\"./config/config-validator\"),\n    Environments = require(\"./config/environments\"),\n    applyDisableDirectives = require(\"./util/apply-disable-directives\"),\n    createEmitter = require(\"./util/safe-emitter\"),\n    NodeEventGenerator = require(\"./util/node-event-generator\"),\n    SourceCode = require(\"./util/source-code\"),\n    Traverser = require(\"./util/traverser\"),\n    createReportTranslator = require(\"./util/report-translator\"),\n    Rules = require(\"./rules\"),\n    timing = require(\"./util/timing\"),\n    ConfigCommentParser = require(\"./util/config-comment-parser\"),\n    astUtils = require(\"./util/ast-utils\"),\n    pkg = require(\"../package.json\"),\n    SourceCodeFixer = require(\"./util/source-code-fixer\");\n\nconst debug = require(\"debug\")(\"eslint:linter\");\nconst MAX_AUTOFIX_PASSES = 10;\nconst DEFAULT_PARSER_NAME = \"espree\";\nconst commentParser = new ConfigCommentParser();\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * The result of a parsing operation from parseForESLint()\n * @typedef {Object} CustomParseResult\n * @property {ASTNode} ast The ESTree AST Program node.\n * @property {Object} services An object containing additional services related\n *      to the parser.\n * @property {ScopeManager|null} scopeManager The scope manager object of this AST.\n * @property {Object|null} visitorKeys The visitor keys to traverse this AST.\n */\n\n/**\n * @typedef {Object} DisableDirective\n * @property {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} type\n * @property {number} line\n * @property {number} column\n * @property {(string|null)} ruleId\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Ensures that variables representing built-in properties of the Global Object,\n * and any globals declared by special block comments, are present in the global\n * scope.\n * @param {Scope} globalScope The global scope.\n * @param {Object} configGlobals The globals declared in configuration\n * @param {{exportedVariables: Object, enabledGlobals: Object}} commentDirectives Directives from comment configuration\n * @returns {void}\n */\nfunction addDeclaredGlobals(globalScope, configGlobals, commentDirectives) {\n    const mergedGlobalsInfo = Object.assign(\n        {},\n        lodash.mapValues(configGlobals, value => ({ sourceComment: null, value: ConfigOps.normalizeConfigGlobal(value) })),\n        lodash.mapValues(commentDirectives.enabledGlobals, ({ comment, value }) => ({ sourceComment: comment, value: ConfigOps.normalizeConfigGlobal(value) }))\n    );\n\n    Object.keys(mergedGlobalsInfo)\n        .filter(name => mergedGlobalsInfo[name].value !== \"off\")\n        .forEach(name => {\n            let variable = globalScope.set.get(name);\n\n            if (!variable) {\n                variable = new eslintScope.Variable(name, globalScope);\n                if (mergedGlobalsInfo[name].sourceComment === null) {\n                    variable.eslintExplicitGlobal = false;\n                } else {\n                    variable.eslintExplicitGlobal = true;\n                    variable.eslintExplicitGlobalComment = mergedGlobalsInfo[name].sourceComment;\n                }\n                globalScope.variables.push(variable);\n                globalScope.set.set(name, variable);\n            }\n            variable.writeable = (mergedGlobalsInfo[name].value === \"writeable\");\n        });\n\n    // mark all exported variables as such\n    Object.keys(commentDirectives.exportedVariables).forEach(name => {\n        const variable = globalScope.set.get(name);\n\n        if (variable) {\n            variable.eslintUsed = true;\n        }\n    });\n\n    /*\n     * \"through\" contains all references which definitions cannot be found.\n     * Since we augment the global scope using configuration, we need to update\n     * references and remove the ones that were added by configuration.\n     */\n    globalScope.through = globalScope.through.filter(reference => {\n        const name = reference.identifier.name;\n        const variable = globalScope.set.get(name);\n\n        if (variable) {\n\n            /*\n             * Links the variable and the reference.\n             * And this reference is removed from `Scope#through`.\n             */\n            reference.resolved = variable;\n            variable.references.push(reference);\n\n            return false;\n        }\n\n        return true;\n    });\n}\n\n/**\n * Creates a collection of disable directives from a comment\n * @param {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} type The type of directive comment\n * @param {{line: number, column: number}} loc The 0-based location of the comment token\n * @param {string} value The value after the directive in the comment\n * comment specified no specific rules, so it applies to all rules (e.g. `eslint-disable`)\n * @returns {DisableDirective[]} Directives from the comment\n */\nfunction createDisableDirectives(type, loc, value) {\n    const ruleIds = Object.keys(commentParser.parseListConfig(value));\n    const directiveRules = ruleIds.length ? ruleIds : [null];\n\n    return directiveRules.map(ruleId => ({ type, line: loc.line, column: loc.column + 1, ruleId }));\n}\n\n/**\n * Parses comments in file to extract file-specific config of rules, globals\n * and environments and merges them with global config; also code blocks\n * where reporting is disabled or enabled and merges them with reporting config.\n * @param {string} filename The file being checked.\n * @param {ASTNode} ast The top node of the AST.\n * @param {function(string): {create: Function}} ruleMapper A map from rule IDs to defined rules\n * @returns {{configuredRules: Object, enabledGlobals: Object, exportedVariables: Object, problems: Problem[], disableDirectives: DisableDirective[]}}\n * A collection of the directive comments that were found, along with any problems that occurred when parsing\n */\nfunction getDirectiveComments(filename, ast, ruleMapper) {\n    const configuredRules = {};\n    const enabledGlobals = {};\n    const exportedVariables = {};\n    const problems = [];\n    const disableDirectives = [];\n\n    ast.comments.filter(token => token.type !== \"Shebang\").forEach(comment => {\n        const trimmedCommentText = comment.value.trim();\n        const match = /^(eslint(-\\w+){0,3}|exported|globals?)(\\s|$)/u.exec(trimmedCommentText);\n\n        if (!match) {\n            return;\n        }\n\n        const directiveValue = trimmedCommentText.slice(match.index + match[1].length);\n\n        if (/^eslint-disable-(next-)?line$/u.test(match[1])) {\n            if (comment.loc.start.line === comment.loc.end.line) {\n                const directiveType = match[1].slice(\"eslint-\".length);\n\n                disableDirectives.push(...createDisableDirectives(directiveType, comment.loc.start, directiveValue));\n            } else {\n                problems.push({\n                    ruleId: null,\n                    severity: 2,\n                    message: `${match[1]} comment should not span multiple lines.`,\n                    line: comment.loc.start.line,\n                    column: comment.loc.start.column + 1,\n                    endLine: comment.loc.end.line,\n                    endColumn: comment.loc.end.column + 1,\n                    nodeType: null\n                });\n            }\n        } else if (comment.type === \"Block\") {\n            switch (match[1]) {\n                case \"exported\":\n                    Object.assign(exportedVariables, commentParser.parseStringConfig(directiveValue, comment));\n                    break;\n\n                case \"globals\":\n                case \"global\":\n                    Object.assign(enabledGlobals, commentParser.parseStringConfig(directiveValue, comment));\n                    break;\n\n                case \"eslint-disable\":\n                    disableDirectives.push(...createDisableDirectives(\"disable\", comment.loc.start, directiveValue));\n                    break;\n\n                case \"eslint-enable\":\n                    disableDirectives.push(...createDisableDirectives(\"enable\", comment.loc.start, directiveValue));\n                    break;\n\n                case \"eslint\": {\n                    const parseResult = commentParser.parseJsonConfig(directiveValue, comment.loc);\n\n                    if (parseResult.success) {\n                        Object.keys(parseResult.config).forEach(name => {\n                            const ruleValue = parseResult.config[name];\n\n                            try {\n                                validator.validateRuleOptions(ruleMapper(name), name, ruleValue);\n                            } catch (err) {\n                                problems.push({\n                                    ruleId: name,\n                                    severity: 2,\n                                    message: err.message,\n                                    line: comment.loc.start.line,\n                                    column: comment.loc.start.column + 1,\n                                    endLine: comment.loc.end.line,\n                                    endColumn: comment.loc.end.column + 1,\n                                    nodeType: null\n                                });\n                            }\n                            configuredRules[name] = ruleValue;\n                        });\n                    } else {\n                        problems.push(parseResult.error);\n                    }\n\n                    break;\n                }\n\n                // no default\n            }\n        }\n    });\n\n    return {\n        configuredRules,\n        enabledGlobals,\n        exportedVariables,\n        problems,\n        disableDirectives\n    };\n}\n\n/**\n * Normalize ECMAScript version from the initial config\n * @param  {number} ecmaVersion ECMAScript version from the initial config\n * @param  {boolean} isModule Whether the source type is module or not\n * @returns {number} normalized ECMAScript version\n */\nfunction normalizeEcmaVersion(ecmaVersion, isModule) {\n\n    // Need at least ES6 for modules\n    if (isModule && (!ecmaVersion || ecmaVersion < 6)) {\n        return 6;\n    }\n\n    /*\n     * Calculate ECMAScript edition number from official year version starting with\n     * ES2015, which corresponds with ES6 (or a difference of 2009).\n     */\n    if (ecmaVersion >= 2015) {\n        return ecmaVersion - 2009;\n    }\n\n    return ecmaVersion;\n}\n\nconst eslintEnvPattern = /\\/\\*\\s*eslint-env\\s(.+?)\\*\\//gu;\n\n/**\n * Checks whether or not there is a comment which has \"eslint-env *\" in a given text.\n * @param {string} text - A source code text to check.\n * @returns {Object|null} A result of parseListConfig() with \"eslint-env *\" comment.\n */\nfunction findEslintEnv(text) {\n    let match, retv;\n\n    eslintEnvPattern.lastIndex = 0;\n\n    while ((match = eslintEnvPattern.exec(text))) {\n        retv = Object.assign(retv || {}, commentParser.parseListConfig(match[1]));\n    }\n\n    return retv;\n}\n\n/**\n * Normalizes the possible options for `linter.verify` and `linter.verifyAndFix` to a\n * consistent shape.\n * @param {(string|{reportUnusedDisableDirectives: boolean, filename: string, allowInlineConfig: boolean})} providedOptions Options\n * @returns {{reportUnusedDisableDirectives: boolean, filename: string, allowInlineConfig: boolean}} Normalized options\n */\nfunction normalizeVerifyOptions(providedOptions) {\n    const isObjectOptions = typeof providedOptions === \"object\";\n    const providedFilename = isObjectOptions ? providedOptions.filename : providedOptions;\n\n    return {\n        filename: typeof providedFilename === \"string\" ? providedFilename : \"<input>\",\n        allowInlineConfig: !isObjectOptions || providedOptions.allowInlineConfig !== false,\n        reportUnusedDisableDirectives: isObjectOptions && !!providedOptions.reportUnusedDisableDirectives\n    };\n}\n\n/**\n * Combines the provided parserOptions with the options from environments\n * @param {string} parserName The parser name which uses this options.\n * @param {Object} providedOptions The provided 'parserOptions' key in a config\n * @param {Environment[]} enabledEnvironments The environments enabled in configuration and with inline comments\n * @returns {Object} Resulting parser options after merge\n */\nfunction resolveParserOptions(parserName, providedOptions, enabledEnvironments) {\n    const parserOptionsFromEnv = enabledEnvironments\n        .filter(env => env.parserOptions)\n        .reduce((parserOptions, env) => ConfigOps.merge(parserOptions, env.parserOptions), {});\n\n    const mergedParserOptions = ConfigOps.merge(parserOptionsFromEnv, providedOptions || {});\n\n    const isModule = mergedParserOptions.sourceType === \"module\";\n\n    if (isModule) {\n\n        // can't have global return inside of modules\n        mergedParserOptions.ecmaFeatures = Object.assign({}, mergedParserOptions.ecmaFeatures, { globalReturn: false });\n    }\n\n    mergedParserOptions.ecmaVersion = normalizeEcmaVersion(mergedParserOptions.ecmaVersion, isModule);\n\n    // TODO: For backward compatibility. Will remove on v6.0.0.\n    if (\n        parserName === DEFAULT_PARSER_NAME &&\n        mergedParserOptions.ecmaFeatures &&\n        mergedParserOptions.ecmaFeatures.experimentalObjectRestSpread &&\n        (!mergedParserOptions.ecmaVersion || mergedParserOptions.ecmaVersion < 9)\n    ) {\n        mergedParserOptions.ecmaVersion = 9;\n    }\n\n    return mergedParserOptions;\n}\n\n/**\n * Combines the provided globals object with the globals from environments\n * @param {Object} providedGlobals The 'globals' key in a config\n * @param {Environments[]} enabledEnvironments The environments enabled in configuration and with inline comments\n * @returns {Object} The resolved globals object\n */\nfunction resolveGlobals(providedGlobals, enabledEnvironments) {\n    return Object.assign(\n        {},\n        ...enabledEnvironments.filter(env => env.globals).map(env => env.globals),\n        providedGlobals\n    );\n}\n\n/**\n * Strips Unicode BOM from a given text.\n *\n * @param {string} text - A text to strip.\n * @returns {string} The stripped text.\n */\nfunction stripUnicodeBOM(text) {\n\n    /*\n     * Check Unicode BOM.\n     * In JavaScript, string data is stored as UTF-16, so BOM is 0xFEFF.\n     * http://www.ecma-international.org/ecma-262/6.0/#sec-unicode-format-control-characters\n     */\n    if (text.charCodeAt(0) === 0xFEFF) {\n        return text.slice(1);\n    }\n    return text;\n}\n\n/**\n * Get the options for a rule (not including severity), if any\n * @param {Array|number} ruleConfig rule configuration\n * @returns {Array} of rule options, empty Array if none\n */\nfunction getRuleOptions(ruleConfig) {\n    if (Array.isArray(ruleConfig)) {\n        return ruleConfig.slice(1);\n    }\n    return [];\n\n}\n\n/**\n * Analyze scope of the given AST.\n * @param {ASTNode} ast The `Program` node to analyze.\n * @param {Object} parserOptions The parser options.\n * @param {Object} visitorKeys The visitor keys.\n * @returns {ScopeManager} The analysis result.\n */\nfunction analyzeScope(ast, parserOptions, visitorKeys) {\n    const ecmaFeatures = parserOptions.ecmaFeatures || {};\n    const ecmaVersion = parserOptions.ecmaVersion || 5;\n\n    return eslintScope.analyze(ast, {\n        ignoreEval: true,\n        nodejsScope: ecmaFeatures.globalReturn,\n        impliedStrict: ecmaFeatures.impliedStrict,\n        ecmaVersion,\n        sourceType: parserOptions.sourceType || \"script\",\n        childVisitorKeys: visitorKeys || evk.KEYS,\n        fallback: Traverser.getKeys\n    });\n}\n\n/**\n * Parses text into an AST. Moved out here because the try-catch prevents\n * optimization of functions, so it's best to keep the try-catch as isolated\n * as possible\n * @param {string} text The text to parse.\n * @param {Object} providedParserOptions Options to pass to the parser\n * @param {string} parserName The name of the parser\n * @param {Map<string, Object>} parserMap A map from names to loaded parsers\n * @param {string} filePath The path to the file being parsed.\n * @returns {{success: false, error: Problem}|{success: true, sourceCode: SourceCode}}\n * An object containing the AST and parser services if parsing was successful, or the error if parsing failed\n * @private\n */\nfunction parse(text, providedParserOptions, parserName, parserMap, filePath) {\n\n\n    const textToParse = stripUnicodeBOM(text).replace(astUtils.SHEBANG_MATCHER, (match, captured) => `//${captured}`);\n    const parserOptions = Object.assign({}, providedParserOptions, {\n        loc: true,\n        range: true,\n        raw: true,\n        tokens: true,\n        comment: true,\n        eslintVisitorKeys: true,\n        eslintScopeManager: true,\n        filePath\n    });\n\n    let parser;\n\n    try {\n        parser = parserMap.get(parserName) || require(parserName);\n    } catch (ex) {\n        return {\n            success: false,\n            error: {\n                ruleId: null,\n                fatal: true,\n                severity: 2,\n                message: ex.message,\n                line: 0,\n                column: 0\n            }\n        };\n    }\n\n    /*\n     * Check for parsing errors first. If there's a parsing error, nothing\n     * else can happen. However, a parsing error does not throw an error\n     * from this method - it's just considered a fatal error message, a\n     * problem that ESLint identified just like any other.\n     */\n    try {\n        const parseResult = (typeof parser.parseForESLint === \"function\")\n            ? parser.parseForESLint(textToParse, parserOptions)\n            : { ast: parser.parse(textToParse, parserOptions) };\n        const ast = parseResult.ast;\n        const parserServices = parseResult.services || {};\n        const visitorKeys = parseResult.visitorKeys || evk.KEYS;\n        const scopeManager = parseResult.scopeManager || analyzeScope(ast, parserOptions, visitorKeys);\n\n        return {\n            success: true,\n\n            /*\n             * Save all values that `parseForESLint()` returned.\n             * If a `SourceCode` object is given as the first parameter instead of source code text,\n             * linter skips the parsing process and reuses the source code object.\n             * In that case, linter needs all the values that `parseForESLint()` returned.\n             */\n            sourceCode: new SourceCode({\n                text,\n                ast,\n                parserServices,\n                scopeManager,\n                visitorKeys\n            })\n        };\n    } catch (ex) {\n\n        // If the message includes a leading line number, strip it:\n        const message = `Parsing error: ${ex.message.replace(/^line \\d+:/iu, \"\").trim()}`;\n\n        return {\n            success: false,\n            error: {\n                ruleId: null,\n                fatal: true,\n                severity: 2,\n                message,\n                line: ex.lineNumber,\n                column: ex.column\n            }\n        };\n    }\n}\n\n/**\n * Gets the scope for the current node\n * @param {ScopeManager} scopeManager The scope manager for this AST\n * @param {ASTNode} currentNode The node to get the scope of\n * @returns {eslint-scope.Scope} The scope information for this node\n */\nfunction getScope(scopeManager, currentNode) {\n\n    // On Program node, get the outermost scope to avoid return Node.js special function scope or ES modules scope.\n    const inner = currentNode.type !== \"Program\";\n\n    for (let node = currentNode; node; node = node.parent) {\n        const scope = scopeManager.acquire(node, inner);\n\n        if (scope) {\n            if (scope.type === \"function-expression-name\") {\n                return scope.childScopes[0];\n            }\n            return scope;\n        }\n    }\n\n    return scopeManager.scopes[0];\n}\n\n/**\n * Marks a variable as used in the current scope\n * @param {ScopeManager} scopeManager The scope manager for this AST. The scope may be mutated by this function.\n * @param {ASTNode} currentNode The node currently being traversed\n * @param {Object} parserOptions The options used to parse this text\n * @param {string} name The name of the variable that should be marked as used.\n * @returns {boolean} True if the variable was found and marked as used, false if not.\n */\nfunction markVariableAsUsed(scopeManager, currentNode, parserOptions, name) {\n    const hasGlobalReturn = parserOptions.ecmaFeatures && parserOptions.ecmaFeatures.globalReturn;\n    const specialScope = hasGlobalReturn || parserOptions.sourceType === \"module\";\n    const currentScope = getScope(scopeManager, currentNode);\n\n    // Special Node.js scope means we need to start one level deeper\n    const initialScope = currentScope.type === \"global\" && specialScope ? currentScope.childScopes[0] : currentScope;\n\n    for (let scope = initialScope; scope; scope = scope.upper) {\n        const variable = scope.variables.find(scopeVar => scopeVar.name === name);\n\n        if (variable) {\n            variable.eslintUsed = true;\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Runs a rule, and gets its listeners\n * @param {Rule} rule A normalized rule with a `create` method\n * @param {Context} ruleContext The context that should be passed to the rule\n * @returns {Object} A map of selector listeners provided by the rule\n */\nfunction createRuleListeners(rule, ruleContext) {\n    try {\n        return rule.create(ruleContext);\n    } catch (ex) {\n        ex.message = `Error while loading rule '${ruleContext.id}': ${ex.message}`;\n        throw ex;\n    }\n}\n\n/**\n * Gets all the ancestors of a given node\n * @param {ASTNode} node The node\n * @returns {ASTNode[]} All the ancestor nodes in the AST, not including the provided node, starting\n * from the root node and going inwards to the parent node.\n */\nfunction getAncestors(node) {\n    const ancestorsStartingAtParent = [];\n\n    for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {\n        ancestorsStartingAtParent.push(ancestor);\n    }\n\n    return ancestorsStartingAtParent.reverse();\n}\n\n// methods that exist on SourceCode object\nconst DEPRECATED_SOURCECODE_PASSTHROUGHS = {\n    getSource: \"getText\",\n    getSourceLines: \"getLines\",\n    getAllComments: \"getAllComments\",\n    getNodeByRangeIndex: \"getNodeByRangeIndex\",\n    getComments: \"getComments\",\n    getCommentsBefore: \"getCommentsBefore\",\n    getCommentsAfter: \"getCommentsAfter\",\n    getCommentsInside: \"getCommentsInside\",\n    getJSDocComment: \"getJSDocComment\",\n    getFirstToken: \"getFirstToken\",\n    getFirstTokens: \"getFirstTokens\",\n    getLastToken: \"getLastToken\",\n    getLastTokens: \"getLastTokens\",\n    getTokenAfter: \"getTokenAfter\",\n    getTokenBefore: \"getTokenBefore\",\n    getTokenByRangeStart: \"getTokenByRangeStart\",\n    getTokens: \"getTokens\",\n    getTokensAfter: \"getTokensAfter\",\n    getTokensBefore: \"getTokensBefore\",\n    getTokensBetween: \"getTokensBetween\"\n};\n\nconst BASE_TRAVERSAL_CONTEXT = Object.freeze(\n    Object.keys(DEPRECATED_SOURCECODE_PASSTHROUGHS).reduce(\n        (contextInfo, methodName) =>\n            Object.assign(contextInfo, {\n                [methodName](...args) {\n                    return this.getSourceCode()[DEPRECATED_SOURCECODE_PASSTHROUGHS[methodName]](...args);\n                }\n            }),\n        {}\n    )\n);\n\n/**\n * Runs the given rules on the given SourceCode object\n * @param {SourceCode} sourceCode A SourceCode object for the given text\n * @param {Object} configuredRules The rules configuration\n * @param {function(string): Rule} ruleMapper A mapper function from rule names to rules\n * @param {Object} parserOptions The options that were passed to the parser\n * @param {string} parserName The name of the parser in the config\n * @param {Object} settings The settings that were enabled in the config\n * @param {string} filename The reported filename of the code\n * @returns {Problem[]} An array of reported problems\n */\nfunction runRules(sourceCode, configuredRules, ruleMapper, parserOptions, parserName, settings, filename) {\n    const emitter = createEmitter();\n    const nodeQueue = [];\n    let currentNode = sourceCode.ast;\n\n    Traverser.traverse(sourceCode.ast, {\n        enter(node, parent) {\n            node.parent = parent;\n            nodeQueue.push({ isEntering: true, node });\n        },\n        leave(node) {\n            nodeQueue.push({ isEntering: false, node });\n        },\n        visitorKeys: sourceCode.visitorKeys\n    });\n\n    /*\n     * Create a frozen object with the ruleContext properties and methods that are shared by all rules.\n     * All rule contexts will inherit from this object. This avoids the performance penalty of copying all the\n     * properties once for each rule.\n     */\n    const sharedTraversalContext = Object.freeze(\n        Object.assign(\n            Object.create(BASE_TRAVERSAL_CONTEXT),\n            {\n                getAncestors: () => getAncestors(currentNode),\n                getDeclaredVariables: sourceCode.scopeManager.getDeclaredVariables.bind(sourceCode.scopeManager),\n                getFilename: () => filename,\n                getScope: () => getScope(sourceCode.scopeManager, currentNode),\n                getSourceCode: () => sourceCode,\n                markVariableAsUsed: name => markVariableAsUsed(sourceCode.scopeManager, currentNode, parserOptions, name),\n                parserOptions,\n                parserPath: parserName,\n                parserServices: sourceCode.parserServices,\n                settings\n            }\n        )\n    );\n\n\n    const lintingProblems = [];\n\n    Object.keys(configuredRules).forEach(ruleId => {\n        const severity = ConfigOps.getRuleSeverity(configuredRules[ruleId]);\n\n        if (severity === 0) {\n            return;\n        }\n\n        const rule = ruleMapper(ruleId);\n        const messageIds = rule.meta && rule.meta.messages;\n        let reportTranslator = null;\n        const ruleContext = Object.freeze(\n            Object.assign(\n                Object.create(sharedTraversalContext),\n                {\n                    id: ruleId,\n                    options: getRuleOptions(configuredRules[ruleId]),\n                    report(...args) {\n\n                        /*\n                         * Create a report translator lazily.\n                         * In a vast majority of cases, any given rule reports zero errors on a given\n                         * piece of code. Creating a translator lazily avoids the performance cost of\n                         * creating a new translator function for each rule that usually doesn't get\n                         * called.\n                         *\n                         * Using lazy report translators improves end-to-end performance by about 3%\n                         * with Node 8.4.0.\n                         */\n                        if (reportTranslator === null) {\n                            reportTranslator = createReportTranslator({ ruleId, severity, sourceCode, messageIds });\n                        }\n                        const problem = reportTranslator(...args);\n\n                        if (problem.fix && rule.meta && !rule.meta.fixable) {\n                            throw new Error(\"Fixable rules should export a `meta.fixable` property.\");\n                        }\n                        lintingProblems.push(problem);\n                    }\n                }\n            )\n        );\n\n        const ruleListeners = createRuleListeners(rule, ruleContext);\n\n        // add all the selectors from the rule as listeners\n        Object.keys(ruleListeners).forEach(selector => {\n            emitter.on(\n                selector,\n                timing.enabled\n                    ? timing.time(ruleId, ruleListeners[selector])\n                    : ruleListeners[selector]\n            );\n        });\n    });\n\n    const eventGenerator = new CodePathAnalyzer(new NodeEventGenerator(emitter));\n\n    nodeQueue.forEach(traversalInfo => {\n        currentNode = traversalInfo.node;\n\n        try {\n            if (traversalInfo.isEntering) {\n                eventGenerator.enterNode(currentNode);\n            } else {\n                eventGenerator.leaveNode(currentNode);\n            }\n        } catch (err) {\n            err.currentNode = currentNode;\n            throw err;\n        }\n    });\n\n    return lintingProblems;\n}\n\nconst lastSourceCodes = new WeakMap();\nconst loadedParserMaps = new WeakMap();\nconst ruleMaps = new WeakMap();\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object that is responsible for verifying JavaScript text\n * @name eslint\n */\nmodule.exports = class Linter {\n\n    constructor() {\n        lastSourceCodes.set(this, null);\n        loadedParserMaps.set(this, new Map());\n        ruleMaps.set(this, new Rules());\n        this.version = pkg.version;\n        this.environments = new Environments();\n\n        this.defineParser(\"espree\", espree);\n    }\n\n    /**\n     * Getter for package version.\n     * @static\n     * @returns {string} The version from package.json.\n     */\n    static get version() {\n        return pkg.version;\n    }\n\n    /**\n     * Configuration object for the `verify` API. A JS representation of the eslintrc files.\n     * @typedef {Object} ESLintConfig\n     * @property {Object} rules The rule configuration to verify against.\n     * @property {string} [parser] Parser to use when generatig the AST.\n     * @property {Object} [parserOptions] Options for the parsed used.\n     * @property {Object} [settings] Global settings passed to each rule.\n     * @property {Object} [env] The environment to verify in.\n     * @property {Object} [globals] Available globals to the code.\n     */\n\n    /**\n     * Same as linter.verify, except without support for processors.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {ESLintConfig} providedConfig An ESLintConfig instance to configure everything.\n     * @param {(string|Object)} [filenameOrOptions] The optional filename of the file being checked.\n     *      If this is not set, the filename will default to '<input>' in the rule context. If\n     *      an object, then it has \"filename\", \"saveState\", and \"allowInlineConfig\" properties.\n     * @param {boolean} [filenameOrOptions.allowInlineConfig=true] Allow/disallow inline comments' ability to change config once it is set. Defaults to true if not supplied.\n     *      Useful if you want to validate JS without comments overriding rules.\n     * @param {boolean} [filenameOrOptions.reportUnusedDisableDirectives=false] Adds reported errors for unused\n     *      eslint-disable directives\n     * @returns {Object[]} The results as an array of messages or an empty array if no messages.\n     */\n    _verifyWithoutProcessors(textOrSourceCode, providedConfig, filenameOrOptions) {\n        const config = providedConfig || {};\n        const options = normalizeVerifyOptions(filenameOrOptions);\n        let text;\n\n        // evaluate arguments\n        if (typeof textOrSourceCode === \"string\") {\n            lastSourceCodes.set(this, null);\n            text = textOrSourceCode;\n        } else {\n            lastSourceCodes.set(this, textOrSourceCode);\n            text = textOrSourceCode.text;\n        }\n\n        // search and apply \"eslint-env *\".\n        const envInFile = findEslintEnv(text);\n        const resolvedEnvConfig = Object.assign({ builtin: true }, config.env, envInFile);\n        const enabledEnvs = Object.keys(resolvedEnvConfig)\n            .filter(envName => resolvedEnvConfig[envName])\n            .map(envName => this.environments.get(envName))\n            .filter(env => env);\n\n        const parserName = config.parser || DEFAULT_PARSER_NAME;\n        const parserOptions = resolveParserOptions(parserName, config.parserOptions || {}, enabledEnvs);\n        const configuredGlobals = resolveGlobals(config.globals || {}, enabledEnvs);\n        const settings = config.settings || {};\n\n        if (!lastSourceCodes.get(this)) {\n            const parseResult = parse(\n                text,\n                parserOptions,\n                parserName,\n                loadedParserMaps.get(this),\n                options.filename\n            );\n\n            if (!parseResult.success) {\n                return [parseResult.error];\n            }\n\n            lastSourceCodes.set(this, parseResult.sourceCode);\n        } else {\n\n            /*\n             * If the given source code object as the first argument does not have scopeManager, analyze the scope.\n             * This is for backward compatibility (SourceCode is frozen so it cannot rebind).\n             */\n            const lastSourceCode = lastSourceCodes.get(this);\n\n            if (!lastSourceCode.scopeManager) {\n                lastSourceCodes.set(this, new SourceCode({\n                    text: lastSourceCode.text,\n                    ast: lastSourceCode.ast,\n                    parserServices: lastSourceCode.parserServices,\n                    visitorKeys: lastSourceCode.visitorKeys,\n                    scopeManager: analyzeScope(lastSourceCode.ast, parserOptions)\n                }));\n            }\n        }\n\n        const sourceCode = lastSourceCodes.get(this);\n        const commentDirectives = options.allowInlineConfig\n            ? getDirectiveComments(options.filename, sourceCode.ast, ruleId => ruleMaps.get(this).get(ruleId))\n            : { configuredRules: {}, enabledGlobals: {}, exportedVariables: {}, problems: [], disableDirectives: [] };\n\n        // augment global scope with declared global variables\n        addDeclaredGlobals(\n            sourceCode.scopeManager.scopes[0],\n            configuredGlobals,\n            { exportedVariables: commentDirectives.exportedVariables, enabledGlobals: commentDirectives.enabledGlobals }\n        );\n\n        const configuredRules = Object.assign({}, config.rules, commentDirectives.configuredRules);\n\n        let lintingProblems;\n\n        try {\n            lintingProblems = runRules(\n                sourceCode,\n                configuredRules,\n                ruleId => ruleMaps.get(this).get(ruleId),\n                parserOptions,\n                parserName,\n                settings,\n                options.filename\n            );\n        } catch (err) {\n            err.message += `\\nOccurred while linting ${options.filename}`;\n            debug(\"An error occurred while traversing\");\n            debug(\"Filename:\", options.filename);\n            if (err.currentNode) {\n                const { line } = err.currentNode.loc.start;\n\n                debug(\"Line:\", line);\n                err.message += `:${line}`;\n            }\n            debug(\"Parser Options:\", parserOptions);\n            debug(\"Parser Path:\", parserName);\n            debug(\"Settings:\", settings);\n            throw err;\n        }\n\n        return applyDisableDirectives({\n            directives: commentDirectives.disableDirectives,\n            problems: lintingProblems\n                .concat(commentDirectives.problems)\n                .sort((problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column),\n            reportUnusedDisableDirectives: options.reportUnusedDisableDirectives\n        });\n    }\n\n    /**\n     * Verifies the text against the rules specified by the second argument.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {ESLintConfig} config An ESLintConfig instance to configure everything.\n     * @param {(string|Object)} [filenameOrOptions] The optional filename of the file being checked.\n     *      If this is not set, the filename will default to '<input>' in the rule context. If\n     *      an object, then it has \"filename\", \"saveState\", and \"allowInlineConfig\" properties.\n     * @param {boolean} [filenameOrOptions.allowInlineConfig] Allow/disallow inline comments' ability to change config once it is set. Defaults to true if not supplied.\n     *      Useful if you want to validate JS without comments overriding rules.\n     * @param {function(string): string[]} [filenameOrOptions.preprocess] preprocessor for source text. If provided,\n     *      this should accept a string of source text, and return an array of code blocks to lint.\n     * @param {function(Array<Object[]>): Object[]} [filenameOrOptions.postprocess] postprocessor for report messages. If provided,\n     *      this should accept an array of the message lists for each code block returned from the preprocessor,\n     *      apply a mapping to the messages as appropriate, and return a one-dimensional array of messages\n     * @returns {Object[]} The results as an array of messages or an empty array if no messages.\n     */\n    verify(textOrSourceCode, config, filenameOrOptions) {\n        const preprocess = filenameOrOptions && filenameOrOptions.preprocess || (rawText => [rawText]);\n        const postprocess = filenameOrOptions && filenameOrOptions.postprocess || lodash.flatten;\n\n        return postprocess(\n            preprocess(textOrSourceCode).map(\n                textBlock => this._verifyWithoutProcessors(textBlock, config, filenameOrOptions)\n            )\n        );\n    }\n\n    /**\n     * Gets the SourceCode object representing the parsed source.\n     * @returns {SourceCode} The SourceCode object.\n     */\n    getSourceCode() {\n        return lastSourceCodes.get(this);\n    }\n\n    /**\n     * Defines a new linting rule.\n     * @param {string} ruleId A unique rule identifier\n     * @param {Function} ruleModule Function from context to object mapping AST node types to event handlers\n     * @returns {void}\n     */\n    defineRule(ruleId, ruleModule) {\n        ruleMaps.get(this).define(ruleId, ruleModule);\n    }\n\n    /**\n     * Defines many new linting rules.\n     * @param {Object} rulesToDefine map from unique rule identifier to rule\n     * @returns {void}\n     */\n    defineRules(rulesToDefine) {\n        Object.getOwnPropertyNames(rulesToDefine).forEach(ruleId => {\n            this.defineRule(ruleId, rulesToDefine[ruleId]);\n        });\n    }\n\n    /**\n     * Gets an object with all loaded rules.\n     * @returns {Map} All loaded rules\n     */\n    getRules() {\n        return ruleMaps.get(this).getAllLoadedRules();\n    }\n\n    /**\n     * Define a new parser module\n     * @param {any} parserId Name of the parser\n     * @param {any} parserModule The parser object\n     * @returns {void}\n     */\n    defineParser(parserId, parserModule) {\n        loadedParserMaps.get(this).set(parserId, parserModule);\n    }\n\n    /**\n     * Performs multiple autofix passes over the text until as many fixes as possible\n     * have been applied.\n     * @param {string} text The source text to apply fixes to.\n     * @param {Object} config The ESLint config object to use.\n     * @param {Object} options The ESLint options object to use.\n     * @param {string} options.filename The filename from which the text was read.\n     * @param {boolean} options.allowInlineConfig Flag indicating if inline comments\n     *      should be allowed.\n     * @param {boolean|Function} options.fix Determines whether fixes should be applied\n     * @param {Function} options.preprocess preprocessor for source text. If provided, this should\n     *      accept a string of source text, and return an array of code blocks to lint.\n     * @param {Function} options.postprocess postprocessor for report messages. If provided,\n     *      this should accept an array of the message lists for each code block returned from the preprocessor,\n     *      apply a mapping to the messages as appropriate, and return a one-dimensional array of messages\n     * @returns {Object} The result of the fix operation as returned from the\n     *      SourceCodeFixer.\n     */\n    verifyAndFix(text, config, options) {\n        let messages = [],\n            fixedResult,\n            fixed = false,\n            passNumber = 0,\n            currentText = text;\n        const debugTextDescription = options && options.filename || `${text.slice(0, 10)}...`;\n        const shouldFix = options && typeof options.fix !== \"undefined\" ? options.fix : true;\n\n        /**\n         * This loop continues until one of the following is true:\n         *\n         * 1. No more fixes have been applied.\n         * 2. Ten passes have been made.\n         *\n         * That means anytime a fix is successfully applied, there will be another pass.\n         * Essentially, guaranteeing a minimum of two passes.\n         */\n        do {\n            passNumber++;\n\n            debug(`Linting code for ${debugTextDescription} (pass ${passNumber})`);\n            messages = this.verify(currentText, config, options);\n\n            debug(`Generating fixed text for ${debugTextDescription} (pass ${passNumber})`);\n            fixedResult = SourceCodeFixer.applyFixes(currentText, messages, shouldFix);\n\n            /*\n             * stop if there are any syntax errors.\n             * 'fixedResult.output' is a empty string.\n             */\n            if (messages.length === 1 && messages[0].fatal) {\n                break;\n            }\n\n            // keep track if any fixes were ever applied - important for return value\n            fixed = fixed || fixedResult.fixed;\n\n            // update to use the fixed output instead of the original text\n            currentText = fixedResult.output;\n\n        } while (\n            fixedResult.fixed &&\n            passNumber < MAX_AUTOFIX_PASSES\n        );\n\n        /*\n         * If the last result had fixes, we need to lint again to be sure we have\n         * the most up-to-date information.\n         */\n        if (fixedResult.fixed) {\n            fixedResult.messages = this.verify(currentText, config, options);\n        }\n\n        // ensure the last result properly reflects if fixes were done\n        fixedResult.fixed = fixed;\n        fixedResult.output = currentText;\n\n        return fixedResult;\n    }\n};\n","/**\n * @fileoverview A class of the code path analyzer.\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n    CodePath = require(\"./code-path\"),\n    CodePathSegment = require(\"./code-path-segment\"),\n    IdGenerator = require(\"./id-generator\"),\n    debug = require(\"./debug-helpers\"),\n    astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a `case` node (not `default` node).\n *\n * @param {ASTNode} node - A `SwitchCase` node to check.\n * @returns {boolean} `true` if the node is a `case` node (not `default` node).\n */\nfunction isCaseNode(node) {\n    return Boolean(node.test);\n}\n\n/**\n * Checks whether the given logical operator is taken into account for the code\n * path analysis.\n *\n * @param {string} operator - The operator found in the LogicalExpression node\n * @returns {boolean} `true` if the operator is \"&&\" or \"||\"\n */\nfunction isHandledLogicalOperator(operator) {\n    return operator === \"&&\" || operator === \"||\";\n}\n\n/**\n * Checks whether or not a given logical expression node goes different path\n * between the `true` case and the `false` case.\n *\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a test of a choice statement.\n */\nfunction isForkingByTrueOrFalse(node) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n            return parent.test === node;\n\n        case \"LogicalExpression\":\n            return isHandledLogicalOperator(parent.operator);\n\n        default:\n            return false;\n    }\n}\n\n/**\n * Gets the boolean value of a given literal node.\n *\n * This is used to detect infinity loops (e.g. `while (true) {}`).\n * Statements preceded by an infinity loop are unreachable if the loop didn't\n * have any `break` statement.\n *\n * @param {ASTNode} node - A node to get.\n * @returns {boolean|undefined} a boolean value if the node is a Literal node,\n *   otherwise `undefined`.\n */\nfunction getBooleanValueIfSimpleConstant(node) {\n    if (node.type === \"Literal\") {\n        return Boolean(node.value);\n    }\n    return void 0;\n}\n\n/**\n * Checks that a given identifier node is a reference or not.\n *\n * This is used to detect the first throwable node in a `try` block.\n *\n * @param {ASTNode} node - An Identifier node to check.\n * @returns {boolean} `true` if the node is a reference.\n */\nfunction isIdentifierReference(node) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"LabeledStatement\":\n        case \"BreakStatement\":\n        case \"ContinueStatement\":\n        case \"ArrayPattern\":\n        case \"RestElement\":\n        case \"ImportSpecifier\":\n        case \"ImportDefaultSpecifier\":\n        case \"ImportNamespaceSpecifier\":\n        case \"CatchClause\":\n            return false;\n\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n        case \"ClassDeclaration\":\n        case \"ClassExpression\":\n        case \"VariableDeclarator\":\n            return parent.id !== node;\n\n        case \"Property\":\n        case \"MethodDefinition\":\n            return (\n                parent.key !== node ||\n                parent.computed ||\n                parent.shorthand\n            );\n\n        case \"AssignmentPattern\":\n            return parent.key !== node;\n\n        default:\n            return true;\n    }\n}\n\n/**\n * Updates the current segment with the head segment.\n * This is similar to local branches and tracking branches of git.\n *\n * To separate the current and the head is in order to not make useless segments.\n *\n * In this process, both \"onCodePathSegmentStart\" and \"onCodePathSegmentEnd\"\n * events are fired.\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction forwardCurrentToHead(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    const currentSegments = state.currentSegments;\n    const headSegments = state.headSegments;\n    const end = Math.max(currentSegments.length, headSegments.length);\n    let i, currentSegment, headSegment;\n\n    // Fires leaving events.\n    for (i = 0; i < end; ++i) {\n        currentSegment = currentSegments[i];\n        headSegment = headSegments[i];\n\n        if (currentSegment !== headSegment && currentSegment) {\n            debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n\n            if (currentSegment.reachable) {\n                analyzer.emitter.emit(\n                    \"onCodePathSegmentEnd\",\n                    currentSegment,\n                    node\n                );\n            }\n        }\n    }\n\n    // Update state.\n    state.currentSegments = headSegments;\n\n    // Fires entering events.\n    for (i = 0; i < end; ++i) {\n        currentSegment = currentSegments[i];\n        headSegment = headSegments[i];\n\n        if (currentSegment !== headSegment && headSegment) {\n            debug.dump(`onCodePathSegmentStart ${headSegment.id}`);\n\n            CodePathSegment.markUsed(headSegment);\n            if (headSegment.reachable) {\n                analyzer.emitter.emit(\n                    \"onCodePathSegmentStart\",\n                    headSegment,\n                    node\n                );\n            }\n        }\n    }\n\n}\n\n/**\n * Updates the current segment with empty.\n * This is called at the last of functions or the program.\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction leaveFromCurrentSegment(analyzer, node) {\n    const state = CodePath.getState(analyzer.codePath);\n    const currentSegments = state.currentSegments;\n\n    for (let i = 0; i < currentSegments.length; ++i) {\n        const currentSegment = currentSegments[i];\n\n        debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n        if (currentSegment.reachable) {\n            analyzer.emitter.emit(\n                \"onCodePathSegmentEnd\",\n                currentSegment,\n                node\n            );\n        }\n    }\n\n    state.currentSegments = [];\n}\n\n/**\n * Updates the code path due to the position of a given node in the parent node\n * thereof.\n *\n * For example, if the node is `parent.consequent`, this creates a fork from the\n * current path.\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction preprocess(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"LogicalExpression\":\n            if (\n                parent.right === node &&\n                isHandledLogicalOperator(parent.operator)\n            ) {\n                state.makeLogicalRight();\n            }\n            break;\n\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n\n            /*\n             * Fork if this node is at `consequent`/`alternate`.\n             * `popForkContext()` exists at `IfStatement:exit` and\n             * `ConditionalExpression:exit`.\n             */\n            if (parent.consequent === node) {\n                state.makeIfConsequent();\n            } else if (parent.alternate === node) {\n                state.makeIfAlternate();\n            }\n            break;\n\n        case \"SwitchCase\":\n            if (parent.consequent[0] === node) {\n                state.makeSwitchCaseBody(false, !parent.test);\n            }\n            break;\n\n        case \"TryStatement\":\n            if (parent.handler === node) {\n                state.makeCatchBlock();\n            } else if (parent.finalizer === node) {\n                state.makeFinallyBlock();\n            }\n            break;\n\n        case \"WhileStatement\":\n            if (parent.test === node) {\n                state.makeWhileTest(getBooleanValueIfSimpleConstant(node));\n            } else {\n                assert(parent.body === node);\n                state.makeWhileBody();\n            }\n            break;\n\n        case \"DoWhileStatement\":\n            if (parent.body === node) {\n                state.makeDoWhileBody();\n            } else {\n                assert(parent.test === node);\n                state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));\n            }\n            break;\n\n        case \"ForStatement\":\n            if (parent.test === node) {\n                state.makeForTest(getBooleanValueIfSimpleConstant(node));\n            } else if (parent.update === node) {\n                state.makeForUpdate();\n            } else if (parent.body === node) {\n                state.makeForBody();\n            }\n            break;\n\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            if (parent.left === node) {\n                state.makeForInOfLeft();\n            } else if (parent.right === node) {\n                state.makeForInOfRight();\n            } else {\n                assert(parent.body === node);\n                state.makeForInOfBody();\n            }\n            break;\n\n        case \"AssignmentPattern\":\n\n            /*\n             * Fork if this node is at `right`.\n             * `left` is executed always, so it uses the current path.\n             * `popForkContext()` exists at `AssignmentPattern:exit`.\n             */\n            if (parent.right === node) {\n                state.pushForkContext();\n                state.forkBypassPath();\n                state.forkPath();\n            }\n            break;\n\n        default:\n            break;\n    }\n}\n\n/**\n * Updates the code path due to the type of a given node in entering.\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction processCodePathToEnter(analyzer, node) {\n    let codePath = analyzer.codePath;\n    let state = codePath && CodePath.getState(codePath);\n    const parent = node.parent;\n\n    switch (node.type) {\n        case \"Program\":\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n            if (codePath) {\n\n                // Emits onCodePathSegmentStart events if updated.\n                forwardCurrentToHead(analyzer, node);\n                debug.dumpState(node, state, false);\n            }\n\n            // Create the code path of this scope.\n            codePath = analyzer.codePath = new CodePath(\n                analyzer.idGenerator.next(),\n                codePath,\n                analyzer.onLooped\n            );\n            state = CodePath.getState(codePath);\n\n            // Emits onCodePathStart events.\n            debug.dump(`onCodePathStart ${codePath.id}`);\n            analyzer.emitter.emit(\"onCodePathStart\", codePath, node);\n            break;\n\n        case \"LogicalExpression\":\n            if (isHandledLogicalOperator(node.operator)) {\n                state.pushChoiceContext(\n                    node.operator,\n                    isForkingByTrueOrFalse(node)\n                );\n            }\n            break;\n\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n            state.pushChoiceContext(\"test\", false);\n            break;\n\n        case \"SwitchStatement\":\n            state.pushSwitchContext(\n                node.cases.some(isCaseNode),\n                astUtils.getLabel(node)\n            );\n            break;\n\n        case \"TryStatement\":\n            state.pushTryContext(Boolean(node.finalizer));\n            break;\n\n        case \"SwitchCase\":\n\n            /*\n             * Fork if this node is after the 2st node in `cases`.\n             * It's similar to `else` blocks.\n             * The next `test` node is processed in this path.\n             */\n            if (parent.discriminant !== node && parent.cases[0] !== node) {\n                state.forkPath();\n            }\n            break;\n\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            state.pushLoopContext(node.type, astUtils.getLabel(node));\n            break;\n\n        case \"LabeledStatement\":\n            if (!astUtils.isBreakableStatement(node.body)) {\n                state.pushBreakContext(false, node.label.name);\n            }\n            break;\n\n        default:\n            break;\n    }\n\n    // Emits onCodePathSegmentStart events if updated.\n    forwardCurrentToHead(analyzer, node);\n    debug.dumpState(node, state, false);\n}\n\n/**\n * Updates the code path due to the type of a given node in leaving.\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction processCodePathToExit(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    let dontForward = false;\n\n    switch (node.type) {\n        case \"IfStatement\":\n        case \"ConditionalExpression\":\n            state.popChoiceContext();\n            break;\n\n        case \"LogicalExpression\":\n            if (isHandledLogicalOperator(node.operator)) {\n                state.popChoiceContext();\n            }\n            break;\n\n        case \"SwitchStatement\":\n            state.popSwitchContext();\n            break;\n\n        case \"SwitchCase\":\n\n            /*\n             * This is the same as the process at the 1st `consequent` node in\n             * `preprocess` function.\n             * Must do if this `consequent` is empty.\n             */\n            if (node.consequent.length === 0) {\n                state.makeSwitchCaseBody(true, !node.test);\n            }\n            if (state.forkContext.reachable) {\n                dontForward = true;\n            }\n            break;\n\n        case \"TryStatement\":\n            state.popTryContext();\n            break;\n\n        case \"BreakStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeBreak(node.label && node.label.name);\n            dontForward = true;\n            break;\n\n        case \"ContinueStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeContinue(node.label && node.label.name);\n            dontForward = true;\n            break;\n\n        case \"ReturnStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeReturn();\n            dontForward = true;\n            break;\n\n        case \"ThrowStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeThrow();\n            dontForward = true;\n            break;\n\n        case \"Identifier\":\n            if (isIdentifierReference(node)) {\n                state.makeFirstThrowablePathInTryBlock();\n                dontForward = true;\n            }\n            break;\n\n        case \"CallExpression\":\n        case \"MemberExpression\":\n        case \"NewExpression\":\n            state.makeFirstThrowablePathInTryBlock();\n            break;\n\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            state.popLoopContext();\n            break;\n\n        case \"AssignmentPattern\":\n            state.popForkContext();\n            break;\n\n        case \"LabeledStatement\":\n            if (!astUtils.isBreakableStatement(node.body)) {\n                state.popBreakContext();\n            }\n            break;\n\n        default:\n            break;\n    }\n\n    // Emits onCodePathSegmentStart events if updated.\n    if (!dontForward) {\n        forwardCurrentToHead(analyzer, node);\n    }\n    debug.dumpState(node, state, true);\n}\n\n/**\n * Updates the code path to finalize the current code path.\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction postprocess(analyzer, node) {\n    switch (node.type) {\n        case \"Program\":\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\": {\n            let codePath = analyzer.codePath;\n\n            // Mark the current path as the final node.\n            CodePath.getState(codePath).makeFinal();\n\n            // Emits onCodePathSegmentEnd event of the current segments.\n            leaveFromCurrentSegment(analyzer, node);\n\n            // Emits onCodePathEnd event of this code path.\n            debug.dump(`onCodePathEnd ${codePath.id}`);\n            analyzer.emitter.emit(\"onCodePathEnd\", codePath, node);\n            debug.dumpDot(codePath);\n\n            codePath = analyzer.codePath = analyzer.codePath.upper;\n            if (codePath) {\n                debug.dumpState(node, CodePath.getState(codePath), true);\n            }\n            break;\n        }\n\n        default:\n            break;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The class to analyze code paths.\n * This class implements the EventGenerator interface.\n */\nclass CodePathAnalyzer {\n\n    /**\n     * @param {EventGenerator} eventGenerator - An event generator to wrap.\n     */\n    constructor(eventGenerator) {\n        this.original = eventGenerator;\n        this.emitter = eventGenerator.emitter;\n        this.codePath = null;\n        this.idGenerator = new IdGenerator(\"s\");\n        this.currentNode = null;\n        this.onLooped = this.onLooped.bind(this);\n    }\n\n    /**\n     * Does the process to enter a given AST node.\n     * This updates state of analysis and calls `enterNode` of the wrapped.\n     *\n     * @param {ASTNode} node - A node which is entering.\n     * @returns {void}\n     */\n    enterNode(node) {\n        this.currentNode = node;\n\n        // Updates the code path due to node's position in its parent node.\n        if (node.parent) {\n            preprocess(this, node);\n        }\n\n        /*\n         * Updates the code path.\n         * And emits onCodePathStart/onCodePathSegmentStart events.\n         */\n        processCodePathToEnter(this, node);\n\n        // Emits node events.\n        this.original.enterNode(node);\n\n        this.currentNode = null;\n    }\n\n    /**\n     * Does the process to leave a given AST node.\n     * This updates state of analysis and calls `leaveNode` of the wrapped.\n     *\n     * @param {ASTNode} node - A node which is leaving.\n     * @returns {void}\n     */\n    leaveNode(node) {\n        this.currentNode = node;\n\n        /*\n         * Updates the code path.\n         * And emits onCodePathStart/onCodePathSegmentStart events.\n         */\n        processCodePathToExit(this, node);\n\n        // Emits node events.\n        this.original.leaveNode(node);\n\n        // Emits the last onCodePathStart/onCodePathSegmentStart events.\n        postprocess(this, node);\n\n        this.currentNode = null;\n    }\n\n    /**\n     * This is called on a code path looped.\n     * Then this raises a looped event.\n     *\n     * @param {CodePathSegment} fromSegment - A segment of prev.\n     * @param {CodePathSegment} toSegment - A segment of next.\n     * @returns {void}\n     */\n    onLooped(fromSegment, toSegment) {\n        if (fromSegment.reachable && toSegment.reachable) {\n            debug.dump(`onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`);\n            this.emitter.emit(\n                \"onCodePathSegmentLoop\",\n                fromSegment,\n                toSegment,\n                this.currentNode\n            );\n        }\n    }\n}\n\nmodule.exports = CodePathAnalyzer;\n","/**\n * @fileoverview A class of the code path.\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst CodePathState = require(\"./code-path-state\");\nconst IdGenerator = require(\"./id-generator\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path.\n */\nclass CodePath {\n\n    /**\n     * @param {string} id - An identifier.\n     * @param {CodePath|null} upper - The code path of the upper function scope.\n     * @param {Function} onLooped - A callback function to notify looping.\n     */\n    constructor(id, upper, onLooped) {\n\n        /**\n         * The identifier of this code path.\n         * Rules use it to store additional information of each rule.\n         * @type {string}\n         */\n        this.id = id;\n\n        /**\n         * The code path of the upper function scope.\n         * @type {CodePath|null}\n         */\n        this.upper = upper;\n\n        /**\n         * The code paths of nested function scopes.\n         * @type {CodePath[]}\n         */\n        this.childCodePaths = [];\n\n        // Initializes internal state.\n        Object.defineProperty(\n            this,\n            \"internal\",\n            { value: new CodePathState(new IdGenerator(`${id}_`), onLooped) }\n        );\n\n        // Adds this into `childCodePaths` of `upper`.\n        if (upper) {\n            upper.childCodePaths.push(this);\n        }\n    }\n\n    /**\n     * Gets the state of a given code path.\n     *\n     * @param {CodePath} codePath - A code path to get.\n     * @returns {CodePathState} The state of the code path.\n     */\n    static getState(codePath) {\n        return codePath.internal;\n    }\n\n    /**\n     * The initial code path segment.\n     * @type {CodePathSegment}\n     */\n    get initialSegment() {\n        return this.internal.initialSegment;\n    }\n\n    /**\n     * Final code path segments.\n     * This array is a mix of `returnedSegments` and `thrownSegments`.\n     * @type {CodePathSegment[]}\n     */\n    get finalSegments() {\n        return this.internal.finalSegments;\n    }\n\n    /**\n     * Final code path segments which is with `return` statements.\n     * This array contains the last path segment if it's reachable.\n     * Since the reachable last path returns `undefined`.\n     * @type {CodePathSegment[]}\n     */\n    get returnedSegments() {\n        return this.internal.returnedForkContext;\n    }\n\n    /**\n     * Final code path segments which is with `throw` statements.\n     * @type {CodePathSegment[]}\n     */\n    get thrownSegments() {\n        return this.internal.thrownForkContext;\n    }\n\n    /**\n     * Current code path segments.\n     * @type {CodePathSegment[]}\n     */\n    get currentSegments() {\n        return this.internal.currentSegments;\n    }\n\n    /**\n     * Traverses all segments in this code path.\n     *\n     *     codePath.traverseSegments(function(segment, controller) {\n     *         // do something.\n     *     });\n     *\n     * This method enumerates segments in order from the head.\n     *\n     * The `controller` object has two methods.\n     *\n     * - `controller.skip()` - Skip the following segments in this branch.\n     * - `controller.break()` - Skip all following segments.\n     *\n     * @param {Object} [options] - Omittable.\n     * @param {CodePathSegment} [options.first] - The first segment to traverse.\n     * @param {CodePathSegment} [options.last] - The last segment to traverse.\n     * @param {Function} callback - A callback function.\n     * @returns {void}\n     */\n    traverseSegments(options, callback) {\n        let resolvedOptions;\n        let resolvedCallback;\n\n        if (typeof options === \"function\") {\n            resolvedCallback = options;\n            resolvedOptions = {};\n        } else {\n            resolvedOptions = options || {};\n            resolvedCallback = callback;\n        }\n\n        const startSegment = resolvedOptions.first || this.internal.initialSegment;\n        const lastSegment = resolvedOptions.last;\n\n        let item = null;\n        let index = 0;\n        let end = 0;\n        let segment = null;\n        const visited = Object.create(null);\n        const stack = [[startSegment, 0]];\n        let skippedSegment = null;\n        let broken = false;\n        const controller = {\n            skip() {\n                if (stack.length <= 1) {\n                    broken = true;\n                } else {\n                    skippedSegment = stack[stack.length - 2][0];\n                }\n            },\n            break() {\n                broken = true;\n            }\n        };\n\n        /**\n         * Checks a given previous segment has been visited.\n         * @param {CodePathSegment} prevSegment - A previous segment to check.\n         * @returns {boolean} `true` if the segment has been visited.\n         */\n        function isVisited(prevSegment) {\n            return (\n                visited[prevSegment.id] ||\n                segment.isLoopedPrevSegment(prevSegment)\n            );\n        }\n\n        while (stack.length > 0) {\n            item = stack[stack.length - 1];\n            segment = item[0];\n            index = item[1];\n\n            if (index === 0) {\n\n                // Skip if this segment has been visited already.\n                if (visited[segment.id]) {\n                    stack.pop();\n                    continue;\n                }\n\n                // Skip if all previous segments have not been visited.\n                if (segment !== startSegment &&\n                    segment.prevSegments.length > 0 &&\n                    !segment.prevSegments.every(isVisited)\n                ) {\n                    stack.pop();\n                    continue;\n                }\n\n                // Reset the flag of skipping if all branches have been skipped.\n                if (skippedSegment && segment.prevSegments.indexOf(skippedSegment) !== -1) {\n                    skippedSegment = null;\n                }\n                visited[segment.id] = true;\n\n                // Call the callback when the first time.\n                if (!skippedSegment) {\n                    resolvedCallback.call(this, segment, controller);\n                    if (segment === lastSegment) {\n                        controller.skip();\n                    }\n                    if (broken) {\n                        break;\n                    }\n                }\n            }\n\n            // Update the stack.\n            end = segment.nextSegments.length - 1;\n            if (index < end) {\n                item[1] += 1;\n                stack.push([segment.nextSegments[index], 0]);\n            } else if (index === end) {\n                item[0] = segment.nextSegments[index];\n                item[1] = 0;\n            } else {\n                stack.pop();\n            }\n        }\n    }\n}\n\nmodule.exports = CodePath;\n","/**\n * @fileoverview A class to manage state of generating a code path.\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst CodePathSegment = require(\"./code-path-segment\"),\n    ForkContext = require(\"./fork-context\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Adds given segments into the `dest` array.\n * If the `others` array does not includes the given segments, adds to the `all`\n * array as well.\n *\n * This adds only reachable and used segments.\n *\n * @param {CodePathSegment[]} dest - A destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} others - Another destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} all - The unified destination array (`finalSegments`).\n * @param {CodePathSegment[]} segments - Segments to add.\n * @returns {void}\n */\nfunction addToReturnedOrThrown(dest, others, all, segments) {\n    for (let i = 0; i < segments.length; ++i) {\n        const segment = segments[i];\n\n        dest.push(segment);\n        if (others.indexOf(segment) === -1) {\n            all.push(segment);\n        }\n    }\n}\n\n/**\n * Gets a loop-context for a `continue` statement.\n *\n * @param {CodePathState} state - A state to get.\n * @param {string} label - The label of a `continue` statement.\n * @returns {LoopContext} A loop-context for a `continue` statement.\n */\nfunction getContinueContext(state, label) {\n    if (!label) {\n        return state.loopContext;\n    }\n\n    let context = state.loopContext;\n\n    while (context) {\n        if (context.label === label) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    /* istanbul ignore next: foolproof (syntax error) */\n    return null;\n}\n\n/**\n * Gets a context for a `break` statement.\n *\n * @param {CodePathState} state - A state to get.\n * @param {string} label - The label of a `break` statement.\n * @returns {LoopContext|SwitchContext} A context for a `break` statement.\n */\nfunction getBreakContext(state, label) {\n    let context = state.breakContext;\n\n    while (context) {\n        if (label ? context.label === label : context.breakable) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    /* istanbul ignore next: foolproof (syntax error) */\n    return null;\n}\n\n/**\n * Gets a context for a `return` statement.\n *\n * @param {CodePathState} state - A state to get.\n * @returns {TryContext|CodePathState} A context for a `return` statement.\n */\nfunction getReturnContext(state) {\n    let context = state.tryContext;\n\n    while (context) {\n        if (context.hasFinalizer && context.position !== \"finally\") {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    return state;\n}\n\n/**\n * Gets a context for a `throw` statement.\n *\n * @param {CodePathState} state - A state to get.\n * @returns {TryContext|CodePathState} A context for a `throw` statement.\n */\nfunction getThrowContext(state) {\n    let context = state.tryContext;\n\n    while (context) {\n        if (context.position === \"try\" ||\n            (context.hasFinalizer && context.position === \"catch\")\n        ) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    return state;\n}\n\n/**\n * Removes a given element from a given array.\n *\n * @param {any[]} xs - An array to remove the specific element.\n * @param {any} x - An element to be removed.\n * @returns {void}\n */\nfunction remove(xs, x) {\n    xs.splice(xs.indexOf(x), 1);\n}\n\n/**\n * Disconnect given segments.\n *\n * This is used in a process for switch statements.\n * If there is the \"default\" chunk before other cases, the order is different\n * between node's and running's.\n *\n * @param {CodePathSegment[]} prevSegments - Forward segments to disconnect.\n * @param {CodePathSegment[]} nextSegments - Backward segments to disconnect.\n * @returns {void}\n */\nfunction removeConnection(prevSegments, nextSegments) {\n    for (let i = 0; i < prevSegments.length; ++i) {\n        const prevSegment = prevSegments[i];\n        const nextSegment = nextSegments[i];\n\n        remove(prevSegment.nextSegments, nextSegment);\n        remove(prevSegment.allNextSegments, nextSegment);\n        remove(nextSegment.prevSegments, prevSegment);\n        remove(nextSegment.allPrevSegments, prevSegment);\n    }\n}\n\n/**\n * Creates looping path.\n *\n * @param {CodePathState} state - The instance.\n * @param {CodePathSegment[]} unflattenedFromSegments - Segments which are source.\n * @param {CodePathSegment[]} unflattenedToSegments - Segments which are destination.\n * @returns {void}\n */\nfunction makeLooped(state, unflattenedFromSegments, unflattenedToSegments) {\n    const fromSegments = CodePathSegment.flattenUnusedSegments(unflattenedFromSegments);\n    const toSegments = CodePathSegment.flattenUnusedSegments(unflattenedToSegments);\n\n    const end = Math.min(fromSegments.length, toSegments.length);\n\n    for (let i = 0; i < end; ++i) {\n        const fromSegment = fromSegments[i];\n        const toSegment = toSegments[i];\n\n        if (toSegment.reachable) {\n            fromSegment.nextSegments.push(toSegment);\n        }\n        if (fromSegment.reachable) {\n            toSegment.prevSegments.push(fromSegment);\n        }\n        fromSegment.allNextSegments.push(toSegment);\n        toSegment.allPrevSegments.push(fromSegment);\n\n        if (toSegment.allPrevSegments.length >= 2) {\n            CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);\n        }\n\n        state.notifyLooped(fromSegment, toSegment);\n    }\n}\n\n/**\n * Finalizes segments of `test` chunk of a ForStatement.\n *\n * - Adds `false` paths to paths which are leaving from the loop.\n * - Sets `true` paths to paths which go to the body.\n *\n * @param {LoopContext} context - A loop context to modify.\n * @param {ChoiceContext} choiceContext - A choice context of this loop.\n * @param {CodePathSegment[]} head - The current head paths.\n * @returns {void}\n */\nfunction finalizeTestSegmentsOfFor(context, choiceContext, head) {\n    if (!choiceContext.processed) {\n        choiceContext.trueForkContext.add(head);\n        choiceContext.falseForkContext.add(head);\n    }\n\n    if (context.test !== true) {\n        context.brokenForkContext.addAll(choiceContext.falseForkContext);\n    }\n    context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class which manages state to analyze code paths.\n */\nclass CodePathState {\n\n    /**\n     * @param {IdGenerator} idGenerator - An id generator to generate id for code\n     *   path segments.\n     * @param {Function} onLooped - A callback function to notify looping.\n     */\n    constructor(idGenerator, onLooped) {\n        this.idGenerator = idGenerator;\n        this.notifyLooped = onLooped;\n        this.forkContext = ForkContext.newRoot(idGenerator);\n        this.choiceContext = null;\n        this.switchContext = null;\n        this.tryContext = null;\n        this.loopContext = null;\n        this.breakContext = null;\n\n        this.currentSegments = [];\n        this.initialSegment = this.forkContext.head[0];\n\n        // returnedSegments and thrownSegments push elements into finalSegments also.\n        const final = this.finalSegments = [];\n        const returned = this.returnedForkContext = [];\n        const thrown = this.thrownForkContext = [];\n\n        returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);\n        thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);\n    }\n\n    /**\n     * The head segments.\n     * @type {CodePathSegment[]}\n     */\n    get headSegments() {\n        return this.forkContext.head;\n    }\n\n    /**\n     * The parent forking context.\n     * This is used for the root of new forks.\n     * @type {ForkContext}\n     */\n    get parentForkContext() {\n        const current = this.forkContext;\n\n        return current && current.upper;\n    }\n\n    /**\n     * Creates and stacks new forking context.\n     *\n     * @param {boolean} forkLeavingPath - A flag which shows being in a\n     *   \"finally\" block.\n     * @returns {ForkContext} The created context.\n     */\n    pushForkContext(forkLeavingPath) {\n        this.forkContext = ForkContext.newEmpty(\n            this.forkContext,\n            forkLeavingPath\n        );\n\n        return this.forkContext;\n    }\n\n    /**\n     * Pops and merges the last forking context.\n     * @returns {ForkContext} The last context.\n     */\n    popForkContext() {\n        const lastContext = this.forkContext;\n\n        this.forkContext = lastContext.upper;\n        this.forkContext.replaceHead(lastContext.makeNext(0, -1));\n\n        return lastContext;\n    }\n\n    /**\n     * Creates a new path.\n     * @returns {void}\n     */\n    forkPath() {\n        this.forkContext.add(this.parentForkContext.makeNext(-1, -1));\n    }\n\n    /**\n     * Creates a bypass path.\n     * This is used for such as IfStatement which does not have \"else\" chunk.\n     *\n     * @returns {void}\n     */\n    forkBypassPath() {\n        this.forkContext.add(this.parentForkContext.head);\n    }\n\n    //--------------------------------------------------------------------------\n    // ConditionalExpression, LogicalExpression, IfStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context for ConditionalExpression, LogicalExpression,\n     * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.\n     *\n     * LogicalExpressions have cases that it goes different paths between the\n     * `true` case and the `false` case.\n     *\n     * For Example:\n     *\n     *     if (a || b) {\n     *         foo();\n     *     } else {\n     *         bar();\n     *     }\n     *\n     * In this case, `b` is evaluated always in the code path of the `else`\n     * block, but it's not so in the code path of the `if` block.\n     * So there are 3 paths.\n     *\n     *     a -> foo();\n     *     a -> b -> foo();\n     *     a -> b -> bar();\n     *\n     * @param {string} kind - A kind string.\n     *   If the new context is LogicalExpression's, this is `\"&&\"` or `\"||\"`.\n     *   If it's IfStatement's or ConditionalExpression's, this is `\"test\"`.\n     *   Otherwise, this is `\"loop\"`.\n     * @param {boolean} isForkingAsResult - A flag that shows that goes different\n     *   paths between `true` and `false`.\n     * @returns {void}\n     */\n    pushChoiceContext(kind, isForkingAsResult) {\n        this.choiceContext = {\n            upper: this.choiceContext,\n            kind,\n            isForkingAsResult,\n            trueForkContext: ForkContext.newEmpty(this.forkContext),\n            falseForkContext: ForkContext.newEmpty(this.forkContext),\n            processed: false\n        };\n    }\n\n    /**\n     * Pops the last choice context and finalizes it.\n     *\n     * @returns {ChoiceContext} The popped context.\n     */\n    popChoiceContext() {\n        const context = this.choiceContext;\n\n        this.choiceContext = context.upper;\n\n        const forkContext = this.forkContext;\n        const headSegments = forkContext.head;\n\n        switch (context.kind) {\n            case \"&&\":\n            case \"||\":\n\n                /*\n                 * If any result were not transferred from child contexts,\n                 * this sets the head segments to both cases.\n                 * The head segments are the path of the right-hand operand.\n                 */\n                if (!context.processed) {\n                    context.trueForkContext.add(headSegments);\n                    context.falseForkContext.add(headSegments);\n                }\n\n                /*\n                 * Transfers results to upper context if this context is in\n                 * test chunk.\n                 */\n                if (context.isForkingAsResult) {\n                    const parentContext = this.choiceContext;\n\n                    parentContext.trueForkContext.addAll(context.trueForkContext);\n                    parentContext.falseForkContext.addAll(context.falseForkContext);\n                    parentContext.processed = true;\n\n                    return context;\n                }\n\n                break;\n\n            case \"test\":\n                if (!context.processed) {\n\n                    /*\n                     * The head segments are the path of the `if` block here.\n                     * Updates the `true` path with the end of the `if` block.\n                     */\n                    context.trueForkContext.clear();\n                    context.trueForkContext.add(headSegments);\n                } else {\n\n                    /*\n                     * The head segments are the path of the `else` block here.\n                     * Updates the `false` path with the end of the `else`\n                     * block.\n                     */\n                    context.falseForkContext.clear();\n                    context.falseForkContext.add(headSegments);\n                }\n\n                break;\n\n            case \"loop\":\n\n                /*\n                 * Loops are addressed in popLoopContext().\n                 * This is called from popLoopContext().\n                 */\n                return context;\n\n            /* istanbul ignore next */\n            default:\n                throw new Error(\"unreachable\");\n        }\n\n        // Merges all paths.\n        const prevForkContext = context.trueForkContext;\n\n        prevForkContext.addAll(context.falseForkContext);\n        forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n\n        return context;\n    }\n\n    /**\n     * Makes a code path segment of the right-hand operand of a logical\n     * expression.\n     *\n     * @returns {void}\n     */\n    makeLogicalRight() {\n        const context = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        if (context.processed) {\n\n            /*\n             * This got segments already from the child choice context.\n             * Creates the next path from own true/false fork context.\n             */\n            const prevForkContext =\n                context.kind === \"&&\" ? context.trueForkContext\n                /* kind === \"||\" */ : context.falseForkContext;\n\n            forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n            prevForkContext.clear();\n\n            context.processed = false;\n        } else {\n\n            /*\n             * This did not get segments from the child choice context.\n             * So addresses the head segments.\n             * The head segments are the path of the left-hand operand.\n             */\n            if (context.kind === \"&&\") {\n\n                // The path does short-circuit if false.\n                context.falseForkContext.add(forkContext.head);\n            } else {\n\n                // The path does short-circuit if true.\n                context.trueForkContext.add(forkContext.head);\n            }\n\n            forkContext.replaceHead(forkContext.makeNext(-1, -1));\n        }\n    }\n\n    /**\n     * Makes a code path segment of the `if` block.\n     *\n     * @returns {void}\n     */\n    makeIfConsequent() {\n        const context = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        /*\n         * If any result were not transferred from child contexts,\n         * this sets the head segments to both cases.\n         * The head segments are the path of the test expression.\n         */\n        if (!context.processed) {\n            context.trueForkContext.add(forkContext.head);\n            context.falseForkContext.add(forkContext.head);\n        }\n\n        context.processed = false;\n\n        // Creates new path from the `true` case.\n        forkContext.replaceHead(\n            context.trueForkContext.makeNext(0, -1)\n        );\n    }\n\n    /**\n     * Makes a code path segment of the `else` block.\n     *\n     * @returns {void}\n     */\n    makeIfAlternate() {\n        const context = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        /*\n         * The head segments are the path of the `if` block.\n         * Updates the `true` path with the end of the `if` block.\n         */\n        context.trueForkContext.clear();\n        context.trueForkContext.add(forkContext.head);\n        context.processed = true;\n\n        // Creates new path from the `false` case.\n        forkContext.replaceHead(\n            context.falseForkContext.makeNext(0, -1)\n        );\n    }\n\n    //--------------------------------------------------------------------------\n    // SwitchStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of SwitchStatement and stacks it.\n     *\n     * @param {boolean} hasCase - `true` if the switch statement has one or more\n     *   case parts.\n     * @param {string|null} label - The label text.\n     * @returns {void}\n     */\n    pushSwitchContext(hasCase, label) {\n        this.switchContext = {\n            upper: this.switchContext,\n            hasCase,\n            defaultSegments: null,\n            defaultBodySegments: null,\n            foundDefault: false,\n            lastIsDefault: false,\n            countForks: 0\n        };\n\n        this.pushBreakContext(true, label);\n    }\n\n    /**\n     * Pops the last context of SwitchStatement and finalizes it.\n     *\n     * - Disposes all forking stack for `case` and `default`.\n     * - Creates the next code path segment from `context.brokenForkContext`.\n     * - If the last `SwitchCase` node is not a `default` part, creates a path\n     *   to the `default` body.\n     *\n     * @returns {void}\n     */\n    popSwitchContext() {\n        const context = this.switchContext;\n\n        this.switchContext = context.upper;\n\n        const forkContext = this.forkContext;\n        const brokenForkContext = this.popBreakContext().brokenForkContext;\n\n        if (context.countForks === 0) {\n\n            /*\n             * When there is only one `default` chunk and there is one or more\n             * `break` statements, even if forks are nothing, it needs to merge\n             * those.\n             */\n            if (!brokenForkContext.empty) {\n                brokenForkContext.add(forkContext.makeNext(-1, -1));\n                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n            }\n\n            return;\n        }\n\n        const lastSegments = forkContext.head;\n\n        this.forkBypassPath();\n        const lastCaseSegments = forkContext.head;\n\n        /*\n         * `brokenForkContext` is used to make the next segment.\n         * It must add the last segment into `brokenForkContext`.\n         */\n        brokenForkContext.add(lastSegments);\n\n        /*\n         * A path which is failed in all case test should be connected to path\n         * of `default` chunk.\n         */\n        if (!context.lastIsDefault) {\n            if (context.defaultBodySegments) {\n\n                /*\n                 * Remove a link from `default` label to its chunk.\n                 * It's false route.\n                 */\n                removeConnection(context.defaultSegments, context.defaultBodySegments);\n                makeLooped(this, lastCaseSegments, context.defaultBodySegments);\n            } else {\n\n                /*\n                 * It handles the last case body as broken if `default` chunk\n                 * does not exist.\n                 */\n                brokenForkContext.add(lastCaseSegments);\n            }\n        }\n\n        // Pops the segment context stack until the entry segment.\n        for (let i = 0; i < context.countForks; ++i) {\n            this.forkContext = this.forkContext.upper;\n        }\n\n        /*\n         * Creates a path from all brokenForkContext paths.\n         * This is a path after switch statement.\n         */\n        this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n    }\n\n    /**\n     * Makes a code path segment for a `SwitchCase` node.\n     *\n     * @param {boolean} isEmpty - `true` if the body is empty.\n     * @param {boolean} isDefault - `true` if the body is the default case.\n     * @returns {void}\n     */\n    makeSwitchCaseBody(isEmpty, isDefault) {\n        const context = this.switchContext;\n\n        if (!context.hasCase) {\n            return;\n        }\n\n        /*\n         * Merge forks.\n         * The parent fork context has two segments.\n         * Those are from the current case and the body of the previous case.\n         */\n        const parentForkContext = this.forkContext;\n        const forkContext = this.pushForkContext();\n\n        forkContext.add(parentForkContext.makeNext(0, -1));\n\n        /*\n         * Save `default` chunk info.\n         * If the `default` label is not at the last, we must make a path from\n         * the last `case` to the `default` chunk.\n         */\n        if (isDefault) {\n            context.defaultSegments = parentForkContext.head;\n            if (isEmpty) {\n                context.foundDefault = true;\n            } else {\n                context.defaultBodySegments = forkContext.head;\n            }\n        } else {\n            if (!isEmpty && context.foundDefault) {\n                context.foundDefault = false;\n                context.defaultBodySegments = forkContext.head;\n            }\n        }\n\n        context.lastIsDefault = isDefault;\n        context.countForks += 1;\n    }\n\n    //--------------------------------------------------------------------------\n    // TryStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of TryStatement and stacks it.\n     *\n     * @param {boolean} hasFinalizer - `true` if the try statement has a\n     *   `finally` block.\n     * @returns {void}\n     */\n    pushTryContext(hasFinalizer) {\n        this.tryContext = {\n            upper: this.tryContext,\n            position: \"try\",\n            hasFinalizer,\n\n            returnedForkContext: hasFinalizer\n                ? ForkContext.newEmpty(this.forkContext)\n                : null,\n\n            thrownForkContext: ForkContext.newEmpty(this.forkContext),\n            lastOfTryIsReachable: false,\n            lastOfCatchIsReachable: false\n        };\n    }\n\n    /**\n     * Pops the last context of TryStatement and finalizes it.\n     *\n     * @returns {void}\n     */\n    popTryContext() {\n        const context = this.tryContext;\n\n        this.tryContext = context.upper;\n\n        if (context.position === \"catch\") {\n\n            // Merges two paths from the `try` block and `catch` block merely.\n            this.popForkContext();\n            return;\n        }\n\n        /*\n         * The following process is executed only when there is the `finally`\n         * block.\n         */\n\n        const returned = context.returnedForkContext;\n        const thrown = context.thrownForkContext;\n\n        if (returned.empty && thrown.empty) {\n            return;\n        }\n\n        // Separate head to normal paths and leaving paths.\n        const headSegments = this.forkContext.head;\n\n        this.forkContext = this.forkContext.upper;\n        const normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);\n        const leavingSegments = headSegments.slice(headSegments.length / 2 | 0);\n\n        // Forwards the leaving path to upper contexts.\n        if (!returned.empty) {\n            getReturnContext(this).returnedForkContext.add(leavingSegments);\n        }\n        if (!thrown.empty) {\n            getThrowContext(this).thrownForkContext.add(leavingSegments);\n        }\n\n        // Sets the normal path as the next.\n        this.forkContext.replaceHead(normalSegments);\n\n        /*\n         * If both paths of the `try` block and the `catch` block are\n         * unreachable, the next path becomes unreachable as well.\n         */\n        if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {\n            this.forkContext.makeUnreachable();\n        }\n    }\n\n    /**\n     * Makes a code path segment for a `catch` block.\n     *\n     * @returns {void}\n     */\n    makeCatchBlock() {\n        const context = this.tryContext;\n        const forkContext = this.forkContext;\n        const thrown = context.thrownForkContext;\n\n        // Update state.\n        context.position = \"catch\";\n        context.thrownForkContext = ForkContext.newEmpty(forkContext);\n        context.lastOfTryIsReachable = forkContext.reachable;\n\n        // Merge thrown paths.\n        thrown.add(forkContext.head);\n        const thrownSegments = thrown.makeNext(0, -1);\n\n        // Fork to a bypass and the merged thrown path.\n        this.pushForkContext();\n        this.forkBypassPath();\n        this.forkContext.add(thrownSegments);\n    }\n\n    /**\n     * Makes a code path segment for a `finally` block.\n     *\n     * In the `finally` block, parallel paths are created. The parallel paths\n     * are used as leaving-paths. The leaving-paths are paths from `return`\n     * statements and `throw` statements in a `try` block or a `catch` block.\n     *\n     * @returns {void}\n     */\n    makeFinallyBlock() {\n        const context = this.tryContext;\n        let forkContext = this.forkContext;\n        const returned = context.returnedForkContext;\n        const thrown = context.thrownForkContext;\n        const headOfLeavingSegments = forkContext.head;\n\n        // Update state.\n        if (context.position === \"catch\") {\n\n            // Merges two paths from the `try` block and `catch` block.\n            this.popForkContext();\n            forkContext = this.forkContext;\n\n            context.lastOfCatchIsReachable = forkContext.reachable;\n        } else {\n            context.lastOfTryIsReachable = forkContext.reachable;\n        }\n        context.position = \"finally\";\n\n        if (returned.empty && thrown.empty) {\n\n            // This path does not leave.\n            return;\n        }\n\n        /*\n         * Create a parallel segment from merging returned and thrown.\n         * This segment will leave at the end of this finally block.\n         */\n        const segments = forkContext.makeNext(-1, -1);\n\n        for (let i = 0; i < forkContext.count; ++i) {\n            const prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];\n\n            for (let j = 0; j < returned.segmentsList.length; ++j) {\n                prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);\n            }\n            for (let j = 0; j < thrown.segmentsList.length; ++j) {\n                prevSegsOfLeavingSegment.push(thrown.segmentsList[j][i]);\n            }\n\n            segments.push(\n                CodePathSegment.newNext(\n                    this.idGenerator.next(),\n                    prevSegsOfLeavingSegment\n                )\n            );\n        }\n\n        this.pushForkContext(true);\n        this.forkContext.add(segments);\n    }\n\n    /**\n     * Makes a code path segment from the first throwable node to the `catch`\n     * block or the `finally` block.\n     *\n     * @returns {void}\n     */\n    makeFirstThrowablePathInTryBlock() {\n        const forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        const context = getThrowContext(this);\n\n        if (context === this ||\n            context.position !== \"try\" ||\n            !context.thrownForkContext.empty\n        ) {\n            return;\n        }\n\n        context.thrownForkContext.add(forkContext.head);\n        forkContext.replaceHead(forkContext.makeNext(-1, -1));\n    }\n\n    //--------------------------------------------------------------------------\n    // Loop Statements\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of a loop statement and stacks it.\n     *\n     * @param {string} type - The type of the node which was triggered. One of\n     *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,\n     *   and `ForStatement`.\n     * @param {string|null} label - A label of the node which was triggered.\n     * @returns {void}\n     */\n    pushLoopContext(type, label) {\n        const forkContext = this.forkContext;\n        const breakContext = this.pushBreakContext(true, label);\n\n        switch (type) {\n            case \"WhileStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    test: void 0,\n                    continueDestSegments: null,\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            case \"DoWhileStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    test: void 0,\n                    entrySegments: null,\n                    continueForkContext: ForkContext.newEmpty(forkContext),\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            case \"ForStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    test: void 0,\n                    endOfInitSegments: null,\n                    testSegments: null,\n                    endOfTestSegments: null,\n                    updateSegments: null,\n                    endOfUpdateSegments: null,\n                    continueDestSegments: null,\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    prevSegments: null,\n                    leftSegments: null,\n                    endOfLeftSegments: null,\n                    continueDestSegments: null,\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            /* istanbul ignore next */\n            default:\n                throw new Error(`unknown type: \"${type}\"`);\n        }\n    }\n\n    /**\n     * Pops the last context of a loop statement and finalizes it.\n     *\n     * @returns {void}\n     */\n    popLoopContext() {\n        const context = this.loopContext;\n\n        this.loopContext = context.upper;\n\n        const forkContext = this.forkContext;\n        const brokenForkContext = this.popBreakContext().brokenForkContext;\n\n        // Creates a looped path.\n        switch (context.type) {\n            case \"WhileStatement\":\n            case \"ForStatement\":\n                this.popChoiceContext();\n                makeLooped(\n                    this,\n                    forkContext.head,\n                    context.continueDestSegments\n                );\n                break;\n\n            case \"DoWhileStatement\": {\n                const choiceContext = this.popChoiceContext();\n\n                if (!choiceContext.processed) {\n                    choiceContext.trueForkContext.add(forkContext.head);\n                    choiceContext.falseForkContext.add(forkContext.head);\n                }\n                if (context.test !== true) {\n                    brokenForkContext.addAll(choiceContext.falseForkContext);\n                }\n\n                // `true` paths go to looping.\n                const segmentsList = choiceContext.trueForkContext.segmentsList;\n\n                for (let i = 0; i < segmentsList.length; ++i) {\n                    makeLooped(\n                        this,\n                        segmentsList[i],\n                        context.entrySegments\n                    );\n                }\n                break;\n            }\n\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n                brokenForkContext.add(forkContext.head);\n                makeLooped(\n                    this,\n                    forkContext.head,\n                    context.leftSegments\n                );\n                break;\n\n            /* istanbul ignore next */\n            default:\n                throw new Error(\"unreachable\");\n        }\n\n        // Go next.\n        if (brokenForkContext.empty) {\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        } else {\n            forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n        }\n    }\n\n    /**\n     * Makes a code path segment for the test part of a WhileStatement.\n     *\n     * @param {boolean|undefined} test - The test value (only when constant).\n     * @returns {void}\n     */\n    makeWhileTest(test) {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const testSegments = forkContext.makeNext(0, -1);\n\n        // Update state.\n        context.test = test;\n        context.continueDestSegments = testSegments;\n        forkContext.replaceHead(testSegments);\n    }\n\n    /**\n     * Makes a code path segment for the body part of a WhileStatement.\n     *\n     * @returns {void}\n     */\n    makeWhileBody() {\n        const context = this.loopContext;\n        const choiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        if (!choiceContext.processed) {\n            choiceContext.trueForkContext.add(forkContext.head);\n            choiceContext.falseForkContext.add(forkContext.head);\n        }\n\n        // Update state.\n        if (context.test !== true) {\n            context.brokenForkContext.addAll(choiceContext.falseForkContext);\n        }\n        forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));\n    }\n\n    /**\n     * Makes a code path segment for the body part of a DoWhileStatement.\n     *\n     * @returns {void}\n     */\n    makeDoWhileBody() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const bodySegments = forkContext.makeNext(-1, -1);\n\n        // Update state.\n        context.entrySegments = bodySegments;\n        forkContext.replaceHead(bodySegments);\n    }\n\n    /**\n     * Makes a code path segment for the test part of a DoWhileStatement.\n     *\n     * @param {boolean|undefined} test - The test value (only when constant).\n     * @returns {void}\n     */\n    makeDoWhileTest(test) {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n\n        context.test = test;\n\n        // Creates paths of `continue` statements.\n        if (!context.continueForkContext.empty) {\n            context.continueForkContext.add(forkContext.head);\n            const testSegments = context.continueForkContext.makeNext(0, -1);\n\n            forkContext.replaceHead(testSegments);\n        }\n    }\n\n    /**\n     * Makes a code path segment for the test part of a ForStatement.\n     *\n     * @param {boolean|undefined} test - The test value (only when constant).\n     * @returns {void}\n     */\n    makeForTest(test) {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const endOfInitSegments = forkContext.head;\n        const testSegments = forkContext.makeNext(-1, -1);\n\n        // Update state.\n        context.test = test;\n        context.endOfInitSegments = endOfInitSegments;\n        context.continueDestSegments = context.testSegments = testSegments;\n        forkContext.replaceHead(testSegments);\n    }\n\n    /**\n     * Makes a code path segment for the update part of a ForStatement.\n     *\n     * @returns {void}\n     */\n    makeForUpdate() {\n        const context = this.loopContext;\n        const choiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        // Make the next paths of the test.\n        if (context.testSegments) {\n            finalizeTestSegmentsOfFor(\n                context,\n                choiceContext,\n                forkContext.head\n            );\n        } else {\n            context.endOfInitSegments = forkContext.head;\n        }\n\n        // Update state.\n        const updateSegments = forkContext.makeDisconnected(-1, -1);\n\n        context.continueDestSegments = context.updateSegments = updateSegments;\n        forkContext.replaceHead(updateSegments);\n    }\n\n    /**\n     * Makes a code path segment for the body part of a ForStatement.\n     *\n     * @returns {void}\n     */\n    makeForBody() {\n        const context = this.loopContext;\n        const choiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        // Update state.\n        if (context.updateSegments) {\n            context.endOfUpdateSegments = forkContext.head;\n\n            // `update` -> `test`\n            if (context.testSegments) {\n                makeLooped(\n                    this,\n                    context.endOfUpdateSegments,\n                    context.testSegments\n                );\n            }\n        } else if (context.testSegments) {\n            finalizeTestSegmentsOfFor(\n                context,\n                choiceContext,\n                forkContext.head\n            );\n        } else {\n            context.endOfInitSegments = forkContext.head;\n        }\n\n        let bodySegments = context.endOfTestSegments;\n\n        if (!bodySegments) {\n\n            /*\n             * If there is not the `test` part, the `body` path comes from the\n             * `init` part and the `update` part.\n             */\n            const prevForkContext = ForkContext.newEmpty(forkContext);\n\n            prevForkContext.add(context.endOfInitSegments);\n            if (context.endOfUpdateSegments) {\n                prevForkContext.add(context.endOfUpdateSegments);\n            }\n\n            bodySegments = prevForkContext.makeNext(0, -1);\n        }\n        context.continueDestSegments = context.continueDestSegments || bodySegments;\n        forkContext.replaceHead(bodySegments);\n    }\n\n    /**\n     * Makes a code path segment for the left part of a ForInStatement and a\n     * ForOfStatement.\n     *\n     * @returns {void}\n     */\n    makeForInOfLeft() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const leftSegments = forkContext.makeDisconnected(-1, -1);\n\n        // Update state.\n        context.prevSegments = forkContext.head;\n        context.leftSegments = context.continueDestSegments = leftSegments;\n        forkContext.replaceHead(leftSegments);\n    }\n\n    /**\n     * Makes a code path segment for the right part of a ForInStatement and a\n     * ForOfStatement.\n     *\n     * @returns {void}\n     */\n    makeForInOfRight() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const temp = ForkContext.newEmpty(forkContext);\n\n        temp.add(context.prevSegments);\n        const rightSegments = temp.makeNext(-1, -1);\n\n        // Update state.\n        context.endOfLeftSegments = forkContext.head;\n        forkContext.replaceHead(rightSegments);\n    }\n\n    /**\n     * Makes a code path segment for the body part of a ForInStatement and a\n     * ForOfStatement.\n     *\n     * @returns {void}\n     */\n    makeForInOfBody() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const temp = ForkContext.newEmpty(forkContext);\n\n        temp.add(context.endOfLeftSegments);\n        const bodySegments = temp.makeNext(-1, -1);\n\n        // Make a path: `right` -> `left`.\n        makeLooped(this, forkContext.head, context.leftSegments);\n\n        // Update state.\n        context.brokenForkContext.add(forkContext.head);\n        forkContext.replaceHead(bodySegments);\n    }\n\n    //--------------------------------------------------------------------------\n    // Control Statements\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates new context for BreakStatement.\n     *\n     * @param {boolean} breakable - The flag to indicate it can break by\n     *      an unlabeled BreakStatement.\n     * @param {string|null} label - The label of this context.\n     * @returns {Object} The new context.\n     */\n    pushBreakContext(breakable, label) {\n        this.breakContext = {\n            upper: this.breakContext,\n            breakable,\n            label,\n            brokenForkContext: ForkContext.newEmpty(this.forkContext)\n        };\n        return this.breakContext;\n    }\n\n    /**\n     * Removes the top item of the break context stack.\n     *\n     * @returns {Object} The removed context.\n     */\n    popBreakContext() {\n        const context = this.breakContext;\n        const forkContext = this.forkContext;\n\n        this.breakContext = context.upper;\n\n        // Process this context here for other than switches and loops.\n        if (!context.breakable) {\n            const brokenForkContext = context.brokenForkContext;\n\n            if (!brokenForkContext.empty) {\n                brokenForkContext.add(forkContext.head);\n                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n            }\n        }\n\n        return context;\n    }\n\n    /**\n     * Makes a path for a `break` statement.\n     *\n     * It registers the head segment to a context of `break`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     *\n     * @param {string} label - A label of the break statement.\n     * @returns {void}\n     */\n    makeBreak(label) {\n        const forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        const context = getBreakContext(this, label);\n\n        /* istanbul ignore else: foolproof (syntax error) */\n        if (context) {\n            context.brokenForkContext.add(forkContext.head);\n        }\n\n        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n\n    /**\n     * Makes a path for a `continue` statement.\n     *\n     * It makes a looping path.\n     * It makes new unreachable segment, then it set the head with the segment.\n     *\n     * @param {string} label - A label of the continue statement.\n     * @returns {void}\n     */\n    makeContinue(label) {\n        const forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        const context = getContinueContext(this, label);\n\n        /* istanbul ignore else: foolproof (syntax error) */\n        if (context) {\n            if (context.continueDestSegments) {\n                makeLooped(this, forkContext.head, context.continueDestSegments);\n\n                // If the context is a for-in/of loop, this effects a break also.\n                if (context.type === \"ForInStatement\" ||\n                    context.type === \"ForOfStatement\"\n                ) {\n                    context.brokenForkContext.add(forkContext.head);\n                }\n            } else {\n                context.continueForkContext.add(forkContext.head);\n            }\n        }\n        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n\n    /**\n     * Makes a path for a `return` statement.\n     *\n     * It registers the head segment to a context of `return`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     *\n     * @returns {void}\n     */\n    makeReturn() {\n        const forkContext = this.forkContext;\n\n        if (forkContext.reachable) {\n            getReturnContext(this).returnedForkContext.add(forkContext.head);\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        }\n    }\n\n    /**\n     * Makes a path for a `throw` statement.\n     *\n     * It registers the head segment to a context of `throw`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     *\n     * @returns {void}\n     */\n    makeThrow() {\n        const forkContext = this.forkContext;\n\n        if (forkContext.reachable) {\n            getThrowContext(this).thrownForkContext.add(forkContext.head);\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        }\n    }\n\n    /**\n     * Makes the final path.\n     * @returns {void}\n     */\n    makeFinal() {\n        const segments = this.currentSegments;\n\n        if (segments.length > 0 && segments[0].reachable) {\n            this.returnedForkContext.add(segments);\n        }\n    }\n}\n\nmodule.exports = CodePathState;\n","/**\n * @fileoverview A class of the code path segment.\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"./debug-helpers\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given segment is reachable.\n *\n * @param {CodePathSegment} segment - A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path segment.\n */\nclass CodePathSegment {\n\n    /**\n     * @param {string} id - An identifier.\n     * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.\n     *   This array includes unreachable segments.\n     * @param {boolean} reachable - A flag which shows this is reachable.\n     */\n    constructor(id, allPrevSegments, reachable) {\n\n        /**\n         * The identifier of this code path.\n         * Rules use it to store additional information of each rule.\n         * @type {string}\n         */\n        this.id = id;\n\n        /**\n         * An array of the next segments.\n         * @type {CodePathSegment[]}\n         */\n        this.nextSegments = [];\n\n        /**\n         * An array of the previous segments.\n         * @type {CodePathSegment[]}\n         */\n        this.prevSegments = allPrevSegments.filter(isReachable);\n\n        /**\n         * An array of the next segments.\n         * This array includes unreachable segments.\n         * @type {CodePathSegment[]}\n         */\n        this.allNextSegments = [];\n\n        /**\n         * An array of the previous segments.\n         * This array includes unreachable segments.\n         * @type {CodePathSegment[]}\n         */\n        this.allPrevSegments = allPrevSegments;\n\n        /**\n         * A flag which shows this is reachable.\n         * @type {boolean}\n         */\n        this.reachable = reachable;\n\n        // Internal data.\n        Object.defineProperty(this, \"internal\", {\n            value: {\n                used: false,\n                loopedPrevSegments: []\n            }\n        });\n\n        /* istanbul ignore if */\n        if (debug.enabled) {\n            this.internal.nodes = [];\n            this.internal.exitNodes = [];\n        }\n    }\n\n    /**\n     * Checks a given previous segment is coming from the end of a loop.\n     *\n     * @param {CodePathSegment} segment - A previous segment to check.\n     * @returns {boolean} `true` if the segment is coming from the end of a loop.\n     */\n    isLoopedPrevSegment(segment) {\n        return this.internal.loopedPrevSegments.indexOf(segment) !== -1;\n    }\n\n    /**\n     * Creates the root segment.\n     *\n     * @param {string} id - An identifier.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newRoot(id) {\n        return new CodePathSegment(id, [], true);\n    }\n\n    /**\n     * Creates a segment that follows given segments.\n     *\n     * @param {string} id - An identifier.\n     * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newNext(id, allPrevSegments) {\n        return new CodePathSegment(\n            id,\n            CodePathSegment.flattenUnusedSegments(allPrevSegments),\n            allPrevSegments.some(isReachable)\n        );\n    }\n\n    /**\n     * Creates an unreachable segment that follows given segments.\n     *\n     * @param {string} id - An identifier.\n     * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newUnreachable(id, allPrevSegments) {\n        const segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);\n\n        /*\n         * In `if (a) return a; foo();` case, the unreachable segment preceded by\n         * the return statement is not used but must not be remove.\n         */\n        CodePathSegment.markUsed(segment);\n\n        return segment;\n    }\n\n    /**\n     * Creates a segment that follows given segments.\n     * This factory method does not connect with `allPrevSegments`.\n     * But this inherits `reachable` flag.\n     *\n     * @param {string} id - An identifier.\n     * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newDisconnected(id, allPrevSegments) {\n        return new CodePathSegment(id, [], allPrevSegments.some(isReachable));\n    }\n\n    /**\n     * Makes a given segment being used.\n     *\n     * And this function registers the segment into the previous segments as a next.\n     *\n     * @param {CodePathSegment} segment - A segment to mark.\n     * @returns {void}\n     */\n    static markUsed(segment) {\n        if (segment.internal.used) {\n            return;\n        }\n        segment.internal.used = true;\n\n        let i;\n\n        if (segment.reachable) {\n            for (i = 0; i < segment.allPrevSegments.length; ++i) {\n                const prevSegment = segment.allPrevSegments[i];\n\n                prevSegment.allNextSegments.push(segment);\n                prevSegment.nextSegments.push(segment);\n            }\n        } else {\n            for (i = 0; i < segment.allPrevSegments.length; ++i) {\n                segment.allPrevSegments[i].allNextSegments.push(segment);\n            }\n        }\n    }\n\n    /**\n     * Marks a previous segment as looped.\n     *\n     * @param {CodePathSegment} segment - A segment.\n     * @param {CodePathSegment} prevSegment - A previous segment to mark.\n     * @returns {void}\n     */\n    static markPrevSegmentAsLooped(segment, prevSegment) {\n        segment.internal.loopedPrevSegments.push(prevSegment);\n    }\n\n    /**\n     * Replaces unused segments with the previous segments of each unused segment.\n     *\n     * @param {CodePathSegment[]} segments - An array of segments to replace.\n     * @returns {CodePathSegment[]} The replaced array.\n     */\n    static flattenUnusedSegments(segments) {\n        const done = Object.create(null);\n        const retv = [];\n\n        for (let i = 0; i < segments.length; ++i) {\n            const segment = segments[i];\n\n            // Ignores duplicated.\n            if (done[segment.id]) {\n                continue;\n            }\n\n            // Use previous segments if unused.\n            if (!segment.internal.used) {\n                for (let j = 0; j < segment.allPrevSegments.length; ++j) {\n                    const prevSegment = segment.allPrevSegments[j];\n\n                    if (!done[prevSegment.id]) {\n                        done[prevSegment.id] = true;\n                        retv.push(prevSegment);\n                    }\n                }\n            } else {\n                done[segment.id] = true;\n                retv.push(segment);\n            }\n        }\n\n        return retv;\n    }\n}\n\nmodule.exports = CodePathSegment;\n","/**\n * @fileoverview Helpers to debug for code path analysis.\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"debug\")(\"eslint:code-path\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets id of a given segment.\n * @param {CodePathSegment} segment - A segment to get.\n * @returns {string} Id of the segment.\n */\n/* istanbul ignore next */\nfunction getId(segment) { // eslint-disable-line require-jsdoc\n    return segment.id + (segment.reachable ? \"\" : \"!\");\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n\n    /**\n     * A flag that debug dumping is enabled or not.\n     * @type {boolean}\n     */\n    enabled: debug.enabled,\n\n    /**\n     * Dumps given objects.\n     *\n     * @param {...any} args - objects to dump.\n     * @returns {void}\n     */\n    dump: debug,\n\n    /**\n     * Dumps the current analyzing state.\n     *\n     * @param {ASTNode} node - A node to dump.\n     * @param {CodePathState} state - A state to dump.\n     * @param {boolean} leaving - A flag whether or not it's leaving\n     * @returns {void}\n     */\n    dumpState: !debug.enabled ? debug : /* istanbul ignore next */ function(node, state, leaving) {\n        for (let i = 0; i < state.currentSegments.length; ++i) {\n            const segInternal = state.currentSegments[i].internal;\n\n            if (leaving) {\n                segInternal.exitNodes.push(node);\n            } else {\n                segInternal.nodes.push(node);\n            }\n        }\n\n        debug([\n            `${state.currentSegments.map(getId).join(\",\")})`,\n            `${node.type}${leaving ? \":exit\" : \"\"}`\n        ].join(\" \"));\n    },\n\n    /**\n     * Dumps a DOT code of a given code path.\n     * The DOT code can be visialized with Graphvis.\n     *\n     * @param {CodePath} codePath - A code path to dump.\n     * @returns {void}\n     * @see http://www.graphviz.org\n     * @see http://www.webgraphviz.com\n     */\n    dumpDot: !debug.enabled ? debug : /* istanbul ignore next */ function(codePath) {\n        let text =\n            \"\\n\" +\n            \"digraph {\\n\" +\n            \"node[shape=box,style=\\\"rounded,filled\\\",fillcolor=white];\\n\" +\n            \"initial[label=\\\"\\\",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\n\n        if (codePath.returnedSegments.length > 0) {\n            text += \"final[label=\\\"\\\",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\n        }\n        if (codePath.thrownSegments.length > 0) {\n            text += \"thrown[label=\\\"✘\\\",shape=circle,width=0.3,height=0.3,fixedsize];\\n\";\n        }\n\n        const traceMap = Object.create(null);\n        const arrows = this.makeDotArrows(codePath, traceMap);\n\n        for (const id in traceMap) { // eslint-disable-line guard-for-in\n            const segment = traceMap[id];\n\n            text += `${id}[`;\n\n            if (segment.reachable) {\n                text += \"label=\\\"\";\n            } else {\n                text += \"style=\\\"rounded,dashed,filled\\\",fillcolor=\\\"#FF9800\\\",label=\\\"<<unreachable>>\\\\n\";\n            }\n\n            if (segment.internal.nodes.length > 0 || segment.internal.exitNodes.length > 0) {\n                text += [].concat(\n                    segment.internal.nodes.map(node => {\n                        switch (node.type) {\n                            case \"Identifier\": return `${node.type} (${node.name})`;\n                            case \"Literal\": return `${node.type} (${node.value})`;\n                            default: return node.type;\n                        }\n                    }),\n                    segment.internal.exitNodes.map(node => {\n                        switch (node.type) {\n                            case \"Identifier\": return `${node.type}:exit (${node.name})`;\n                            case \"Literal\": return `${node.type}:exit (${node.value})`;\n                            default: return `${node.type}:exit`;\n                        }\n                    })\n                ).join(\"\\\\n\");\n            } else {\n                text += \"????\";\n            }\n\n            text += \"\\\"];\\n\";\n        }\n\n        text += `${arrows}\\n`;\n        text += \"}\";\n        debug(\"DOT\", text);\n    },\n\n    /**\n     * Makes a DOT code of a given code path.\n     * The DOT code can be visialized with Graphvis.\n     *\n     * @param {CodePath} codePath - A code path to make DOT.\n     * @param {Object} traceMap - Optional. A map to check whether or not segments had been done.\n     * @returns {string} A DOT code of the code path.\n     */\n    makeDotArrows(codePath, traceMap) {\n        const stack = [[codePath.initialSegment, 0]];\n        const done = traceMap || Object.create(null);\n        let lastId = codePath.initialSegment.id;\n        let text = `initial->${codePath.initialSegment.id}`;\n\n        while (stack.length > 0) {\n            const item = stack.pop();\n            const segment = item[0];\n            const index = item[1];\n\n            if (done[segment.id] && index === 0) {\n                continue;\n            }\n            done[segment.id] = segment;\n\n            const nextSegment = segment.allNextSegments[index];\n\n            if (!nextSegment) {\n                continue;\n            }\n\n            if (lastId === segment.id) {\n                text += `->${nextSegment.id}`;\n            } else {\n                text += `;\\n${segment.id}->${nextSegment.id}`;\n            }\n            lastId = nextSegment.id;\n\n            stack.unshift([segment, 1 + index]);\n            stack.push([nextSegment, 0]);\n        }\n\n        codePath.returnedSegments.forEach(finalSegment => {\n            if (lastId === finalSegment.id) {\n                text += \"->final\";\n            } else {\n                text += `;\\n${finalSegment.id}->final`;\n            }\n            lastId = null;\n        });\n\n        codePath.thrownSegments.forEach(finalSegment => {\n            if (lastId === finalSegment.id) {\n                text += \"->thrown\";\n            } else {\n                text += `;\\n${finalSegment.id}->thrown`;\n            }\n            lastId = null;\n        });\n\n        return `${text};`;\n    }\n};\n","/**\n * @fileoverview A class to operate forking.\n *\n * This is state of forking.\n * This has a fork list and manages it.\n *\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n    CodePathSegment = require(\"./code-path-segment\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets whether or not a given segment is reachable.\n *\n * @param {CodePathSegment} segment - A segment to get.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Creates new segments from the specific range of `context.segmentsList`.\n *\n * When `context.segmentsList` is `[[a, b], [c, d], [e, f]]`, `begin` is `0`, and\n * `end` is `-1`, this creates `[g, h]`. This `g` is from `a`, `c`, and `e`.\n * This `h` is from `b`, `d`, and `f`.\n *\n * @param {ForkContext} context - An instance.\n * @param {number} begin - The first index of the previous segments.\n * @param {number} end - The last index of the previous segments.\n * @param {Function} create - A factory function of new segments.\n * @returns {CodePathSegment[]} New segments.\n */\nfunction makeSegments(context, begin, end, create) {\n    const list = context.segmentsList;\n\n    const normalizedBegin = begin >= 0 ? begin : list.length + begin;\n    const normalizedEnd = end >= 0 ? end : list.length + end;\n\n    const segments = [];\n\n    for (let i = 0; i < context.count; ++i) {\n        const allPrevSegments = [];\n\n        for (let j = normalizedBegin; j <= normalizedEnd; ++j) {\n            allPrevSegments.push(list[j][i]);\n        }\n\n        segments.push(create(context.idGenerator.next(), allPrevSegments));\n    }\n\n    return segments;\n}\n\n/**\n * `segments` becomes doubly in a `finally` block. Then if a code path exits by a\n * control statement (such as `break`, `continue`) from the `finally` block, the\n * destination's segments may be half of the source segments. In that case, this\n * merges segments.\n *\n * @param {ForkContext} context - An instance.\n * @param {CodePathSegment[]} segments - Segments to merge.\n * @returns {CodePathSegment[]} The merged segments.\n */\nfunction mergeExtraSegments(context, segments) {\n    let currentSegments = segments;\n\n    while (currentSegments.length > context.count) {\n        const merged = [];\n\n        for (let i = 0, length = currentSegments.length / 2 | 0; i < length; ++i) {\n            merged.push(CodePathSegment.newNext(\n                context.idGenerator.next(),\n                [currentSegments[i], currentSegments[i + length]]\n            ));\n        }\n        currentSegments = merged;\n    }\n    return currentSegments;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class to manage forking.\n */\nclass ForkContext {\n\n    /**\n     * @param {IdGenerator} idGenerator - An identifier generator for segments.\n     * @param {ForkContext|null} upper - An upper fork context.\n     * @param {number} count - A number of parallel segments.\n     */\n    constructor(idGenerator, upper, count) {\n        this.idGenerator = idGenerator;\n        this.upper = upper;\n        this.count = count;\n        this.segmentsList = [];\n    }\n\n    /**\n     * The head segments.\n     * @type {CodePathSegment[]}\n     */\n    get head() {\n        const list = this.segmentsList;\n\n        return list.length === 0 ? [] : list[list.length - 1];\n    }\n\n    /**\n     * A flag which shows empty.\n     * @type {boolean}\n     */\n    get empty() {\n        return this.segmentsList.length === 0;\n    }\n\n    /**\n     * A flag which shows reachable.\n     * @type {boolean}\n     */\n    get reachable() {\n        const segments = this.head;\n\n        return segments.length > 0 && segments.some(isReachable);\n    }\n\n    /**\n     * Creates new segments from this context.\n     *\n     * @param {number} begin - The first index of previous segments.\n     * @param {number} end - The last index of previous segments.\n     * @returns {CodePathSegment[]} New segments.\n     */\n    makeNext(begin, end) {\n        return makeSegments(this, begin, end, CodePathSegment.newNext);\n    }\n\n    /**\n     * Creates new segments from this context.\n     * The new segments is always unreachable.\n     *\n     * @param {number} begin - The first index of previous segments.\n     * @param {number} end - The last index of previous segments.\n     * @returns {CodePathSegment[]} New segments.\n     */\n    makeUnreachable(begin, end) {\n        return makeSegments(this, begin, end, CodePathSegment.newUnreachable);\n    }\n\n    /**\n     * Creates new segments from this context.\n     * The new segments don't have connections for previous segments.\n     * But these inherit the reachable flag from this context.\n     *\n     * @param {number} begin - The first index of previous segments.\n     * @param {number} end - The last index of previous segments.\n     * @returns {CodePathSegment[]} New segments.\n     */\n    makeDisconnected(begin, end) {\n        return makeSegments(this, begin, end, CodePathSegment.newDisconnected);\n    }\n\n    /**\n     * Adds segments into this context.\n     * The added segments become the head.\n     *\n     * @param {CodePathSegment[]} segments - Segments to add.\n     * @returns {void}\n     */\n    add(segments) {\n        assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n\n        this.segmentsList.push(mergeExtraSegments(this, segments));\n    }\n\n    /**\n     * Replaces the head segments with given segments.\n     * The current head segments are removed.\n     *\n     * @param {CodePathSegment[]} segments - Segments to add.\n     * @returns {void}\n     */\n    replaceHead(segments) {\n        assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n\n        this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));\n    }\n\n    /**\n     * Adds all segments of a given fork context into this context.\n     *\n     * @param {ForkContext} context - A fork context to add.\n     * @returns {void}\n     */\n    addAll(context) {\n        assert(context.count === this.count);\n\n        const source = context.segmentsList;\n\n        for (let i = 0; i < source.length; ++i) {\n            this.segmentsList.push(source[i]);\n        }\n    }\n\n    /**\n     * Clears all secments in this context.\n     *\n     * @returns {void}\n     */\n    clear() {\n        this.segmentsList = [];\n    }\n\n    /**\n     * Creates the root fork context.\n     *\n     * @param {IdGenerator} idGenerator - An identifier generator for segments.\n     * @returns {ForkContext} New fork context.\n     */\n    static newRoot(idGenerator) {\n        const context = new ForkContext(idGenerator, null, 1);\n\n        context.add([CodePathSegment.newRoot(idGenerator.next())]);\n\n        return context;\n    }\n\n    /**\n     * Creates an empty fork context preceded by a given context.\n     *\n     * @param {ForkContext} parentContext - The parent fork context.\n     * @param {boolean} forkLeavingPath - A flag which shows inside of `finally` block.\n     * @returns {ForkContext} New fork context.\n     */\n    static newEmpty(parentContext, forkLeavingPath) {\n        return new ForkContext(\n            parentContext.idGenerator,\n            parentContext,\n            (forkLeavingPath ? 2 : 1) * parentContext.count\n        );\n    }\n}\n\nmodule.exports = ForkContext;\n","/**\n * @fileoverview A class of identifiers generator for code path segments.\n *\n * Each rule uses the identifier of code path segments to store additional\n * information of the code path.\n *\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A generator for unique ids.\n */\nclass IdGenerator {\n\n    /**\n     * @param {string} prefix - Optional. A prefix of generated ids.\n     */\n    constructor(prefix) {\n        this.prefix = String(prefix);\n        this.n = 0;\n    }\n\n    /**\n     * Generates id.\n     *\n     * @returns {string} A generated id.\n     */\n    next() {\n        this.n = 1 + this.n | 0;\n\n        /* istanbul ignore if */\n        if (this.n < 0) {\n            this.n = 1;\n        }\n\n        return this.prefix + this.n;\n    }\n}\n\nmodule.exports = IdGenerator;\n","/**\n * @fileoverview Common utils for AST.\n * @author Gyandeep Singh\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst esutils = require(\"esutils\");\nconst espree = require(\"espree\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/u;\nconst anyLoopPattern = /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/u;\nconst arrayOrTypedArrayPattern = /Array$/u;\nconst arrayMethodPattern = /^(?:every|filter|find|findIndex|forEach|map|some)$/u;\nconst bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/u;\nconst breakableTypePattern = /^(?:(?:Do)?While|For(?:In|Of)?|Switch)Statement$/u;\nconst thisTagPattern = /^[\\s*]*@this/mu;\n\n\nconst COMMENTS_IGNORE_PATTERN = /^\\s*(?:eslint|jshint\\s+|jslint\\s+|istanbul\\s+|globals?\\s+|exported\\s+|jscs)/u;\nconst LINEBREAKS = new Set([\"\\r\\n\", \"\\r\", \"\\n\", \"\\u2028\", \"\\u2029\"]);\nconst LINEBREAK_MATCHER = /\\r\\n|[\\r\\n\\u2028\\u2029]/u;\nconst SHEBANG_MATCHER = /^#!([^\\r\\n]+)/u;\n\n// A set of node types that can contain a list of statements\nconst STATEMENT_LIST_PARENTS = new Set([\"Program\", \"BlockStatement\", \"SwitchCase\"]);\n\n/**\n * Checks reference if is non initializer and writable.\n * @param {Reference} reference - A reference to check.\n * @param {int} index - The index of the reference in the references.\n * @param {Reference[]} references - The array that the reference belongs to.\n * @returns {boolean} Success/Failure\n * @private\n */\nfunction isModifyingReference(reference, index, references) {\n    const identifier = reference.identifier;\n\n    /*\n     * Destructuring assignments can have multiple default value, so\n     * possibly there are multiple writeable references for the same\n     * identifier.\n     */\n    const modifyingDifferentIdentifier = index === 0 ||\n        references[index - 1].identifier !== identifier;\n\n    return (identifier &&\n        reference.init === false &&\n        reference.isWrite() &&\n        modifyingDifferentIdentifier\n    );\n}\n\n/**\n * Checks whether the given string starts with uppercase or not.\n *\n * @param {string} s - The string to check.\n * @returns {boolean} `true` if the string starts with uppercase.\n */\nfunction startsWithUpperCase(s) {\n    return s[0] !== s[0].toLocaleLowerCase();\n}\n\n/**\n * Checks whether or not a node is a constructor.\n * @param {ASTNode} node - A function node to check.\n * @returns {boolean} Wehether or not a node is a constructor.\n */\nfunction isES5Constructor(node) {\n    return (node.id && startsWithUpperCase(node.id.name));\n}\n\n/**\n * Finds a function node from ancestors of a node.\n * @param {ASTNode} node - A start node to find.\n * @returns {Node|null} A found function node.\n */\nfunction getUpperFunction(node) {\n    for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n        if (anyFunctionPattern.test(currentNode.type)) {\n            return currentNode;\n        }\n    }\n    return null;\n}\n\n/**\n * Checks whether a given node is a function node or not.\n * The following types are function nodes:\n *\n * - ArrowFunctionExpression\n * - FunctionDeclaration\n * - FunctionExpression\n *\n * @param {ASTNode|null} node - A node to check.\n * @returns {boolean} `true` if the node is a function node.\n */\nfunction isFunction(node) {\n    return Boolean(node && anyFunctionPattern.test(node.type));\n}\n\n/**\n * Checks whether a given node is a loop node or not.\n * The following types are loop nodes:\n *\n * - DoWhileStatement\n * - ForInStatement\n * - ForOfStatement\n * - ForStatement\n * - WhileStatement\n *\n * @param {ASTNode|null} node - A node to check.\n * @returns {boolean} `true` if the node is a loop node.\n */\nfunction isLoop(node) {\n    return Boolean(node && anyLoopPattern.test(node.type));\n}\n\n/**\n * Checks whether the given node is in a loop or not.\n *\n * @param {ASTNode} node - The node to check.\n * @returns {boolean} `true` if the node is in a loop.\n */\nfunction isInLoop(node) {\n    for (let currentNode = node; currentNode && !isFunction(currentNode); currentNode = currentNode.parent) {\n        if (isLoop(currentNode)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Checks whether or not a node is `null` or `undefined`.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is a `null` or `undefined`.\n * @public\n */\nfunction isNullOrUndefined(node) {\n    return (\n        module.exports.isNullLiteral(node) ||\n        (node.type === \"Identifier\" && node.name === \"undefined\") ||\n        (node.type === \"UnaryExpression\" && node.operator === \"void\")\n    );\n}\n\n/**\n * Checks whether or not a node is callee.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is callee.\n */\nfunction isCallee(node) {\n    return node.parent.type === \"CallExpression\" && node.parent.callee === node;\n}\n\n/**\n * Checks whether or not a node is `Reflect.apply`.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is a `Reflect.apply`.\n */\nfunction isReflectApply(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        node.object.type === \"Identifier\" &&\n        node.object.name === \"Reflect\" &&\n        node.property.type === \"Identifier\" &&\n        node.property.name === \"apply\" &&\n        node.computed === false\n    );\n}\n\n/**\n * Checks whether or not a node is `Array.from`.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is a `Array.from`.\n */\nfunction isArrayFromMethod(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        node.object.type === \"Identifier\" &&\n        arrayOrTypedArrayPattern.test(node.object.name) &&\n        node.property.type === \"Identifier\" &&\n        node.property.name === \"from\" &&\n        node.computed === false\n    );\n}\n\n/**\n * Checks whether or not a node is a method which has `thisArg`.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is a method which has `thisArg`.\n */\nfunction isMethodWhichHasThisArg(node) {\n    for (\n        let currentNode = node;\n        currentNode.type === \"MemberExpression\" && !currentNode.computed;\n        currentNode = currentNode.property\n    ) {\n        if (currentNode.property.type === \"Identifier\") {\n            return arrayMethodPattern.test(currentNode.property.name);\n        }\n    }\n\n    return false;\n}\n\n/**\n * Creates the negate function of the given function.\n * @param {Function} f - The function to negate.\n * @returns {Function} Negated function.\n */\nfunction negate(f) {\n    return token => !f(token);\n}\n\n/**\n * Checks whether or not a node has a `@this` tag in its comments.\n * @param {ASTNode} node - A node to check.\n * @param {SourceCode} sourceCode - A SourceCode instance to get comments.\n * @returns {boolean} Whether or not the node has a `@this` tag in its comments.\n */\nfunction hasJSDocThisTag(node, sourceCode) {\n    const jsdocComment = sourceCode.getJSDocComment(node);\n\n    if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {\n        return true;\n    }\n\n    // Checks `@this` in its leading comments for callbacks,\n    // because callbacks don't have its JSDoc comment.\n    // e.g.\n    //     sinon.test(/* @this sinon.Sandbox */function() { this.spy(); });\n    return sourceCode.getCommentsBefore(node).some(comment => thisTagPattern.test(comment.value));\n}\n\n/**\n * Determines if a node is surrounded by parentheses.\n * @param {SourceCode} sourceCode The ESLint source code object\n * @param {ASTNode} node The node to be checked.\n * @returns {boolean} True if the node is parenthesised.\n * @private\n */\nfunction isParenthesised(sourceCode, node) {\n    const previousToken = sourceCode.getTokenBefore(node),\n        nextToken = sourceCode.getTokenAfter(node);\n\n    return Boolean(previousToken && nextToken) &&\n        previousToken.value === \"(\" && previousToken.range[1] <= node.range[0] &&\n        nextToken.value === \")\" && nextToken.range[0] >= node.range[1];\n}\n\n/**\n * Checks if the given token is an arrow token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is an arrow token.\n */\nfunction isArrowToken(token) {\n    return token.value === \"=>\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a comma token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a comma token.\n */\nfunction isCommaToken(token) {\n    return token.value === \",\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a semicolon token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a semicolon token.\n */\nfunction isSemicolonToken(token) {\n    return token.value === \";\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a colon token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a colon token.\n */\nfunction isColonToken(token) {\n    return token.value === \":\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is an opening parenthesis token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is an opening parenthesis token.\n */\nfunction isOpeningParenToken(token) {\n    return token.value === \"(\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a closing parenthesis token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a closing parenthesis token.\n */\nfunction isClosingParenToken(token) {\n    return token.value === \")\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is an opening square bracket token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is an opening square bracket token.\n */\nfunction isOpeningBracketToken(token) {\n    return token.value === \"[\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a closing square bracket token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a closing square bracket token.\n */\nfunction isClosingBracketToken(token) {\n    return token.value === \"]\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is an opening brace token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is an opening brace token.\n */\nfunction isOpeningBraceToken(token) {\n    return token.value === \"{\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a closing brace token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a closing brace token.\n */\nfunction isClosingBraceToken(token) {\n    return token.value === \"}\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a comment token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a comment token.\n */\nfunction isCommentToken(token) {\n    return token.type === \"Line\" || token.type === \"Block\" || token.type === \"Shebang\";\n}\n\n/**\n * Checks if the given token is a keyword token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a keyword token.\n */\nfunction isKeywordToken(token) {\n    return token.type === \"Keyword\";\n}\n\n/**\n * Gets the `(` token of the given function node.\n *\n * @param {ASTNode} node - The function node to get.\n * @param {SourceCode} sourceCode - The source code object to get tokens.\n * @returns {Token} `(` token.\n */\nfunction getOpeningParenOfParams(node, sourceCode) {\n    return node.id\n        ? sourceCode.getTokenAfter(node.id, isOpeningParenToken)\n        : sourceCode.getFirstToken(node, isOpeningParenToken);\n}\n\n/**\n * Creates a version of the LINEBREAK_MATCHER regex with the global flag.\n * Global regexes are mutable, so this needs to be a function instead of a constant.\n * @returns {RegExp} A global regular expression that matches line terminators\n */\nfunction createGlobalLinebreakMatcher() {\n    return new RegExp(LINEBREAK_MATCHER.source, \"gu\");\n}\n\n/**\n * Checks whether or not the tokens of two given nodes are same.\n * @param {ASTNode} left - A node 1 to compare.\n * @param {ASTNode} right - A node 2 to compare.\n * @param {SourceCode} sourceCode - The ESLint source code object.\n * @returns {boolean} the source code for the given node.\n */\nfunction equalTokens(left, right, sourceCode) {\n    const tokensL = sourceCode.getTokens(left);\n    const tokensR = sourceCode.getTokens(right);\n\n    if (tokensL.length !== tokensR.length) {\n        return false;\n    }\n    for (let i = 0; i < tokensL.length; ++i) {\n        if (tokensL[i].type !== tokensR[i].type ||\n            tokensL[i].value !== tokensR[i].value\n        ) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    COMMENTS_IGNORE_PATTERN,\n    LINEBREAKS,\n    LINEBREAK_MATCHER,\n    SHEBANG_MATCHER,\n    STATEMENT_LIST_PARENTS,\n\n    /**\n     * Determines whether two adjacent tokens are on the same line.\n     * @param {Object} left - The left token object.\n     * @param {Object} right - The right token object.\n     * @returns {boolean} Whether or not the tokens are on the same line.\n     * @public\n     */\n    isTokenOnSameLine(left, right) {\n        return left.loc.end.line === right.loc.start.line;\n    },\n\n    isNullOrUndefined,\n    isCallee,\n    isES5Constructor,\n    getUpperFunction,\n    isFunction,\n    isLoop,\n    isInLoop,\n    isArrayFromMethod,\n    isParenthesised,\n    createGlobalLinebreakMatcher,\n    equalTokens,\n\n    isArrowToken,\n    isClosingBraceToken,\n    isClosingBracketToken,\n    isClosingParenToken,\n    isColonToken,\n    isCommaToken,\n    isCommentToken,\n    isKeywordToken,\n    isNotClosingBraceToken: negate(isClosingBraceToken),\n    isNotClosingBracketToken: negate(isClosingBracketToken),\n    isNotClosingParenToken: negate(isClosingParenToken),\n    isNotColonToken: negate(isColonToken),\n    isNotCommaToken: negate(isCommaToken),\n    isNotOpeningBraceToken: negate(isOpeningBraceToken),\n    isNotOpeningBracketToken: negate(isOpeningBracketToken),\n    isNotOpeningParenToken: negate(isOpeningParenToken),\n    isNotSemicolonToken: negate(isSemicolonToken),\n    isOpeningBraceToken,\n    isOpeningBracketToken,\n    isOpeningParenToken,\n    isSemicolonToken,\n\n    /**\n     * Checks whether or not a given node is a string literal.\n     * @param {ASTNode} node - A node to check.\n     * @returns {boolean} `true` if the node is a string literal.\n     */\n    isStringLiteral(node) {\n        return (\n            (node.type === \"Literal\" && typeof node.value === \"string\") ||\n            node.type === \"TemplateLiteral\"\n        );\n    },\n\n    /**\n     * Checks whether a given node is a breakable statement or not.\n     * The node is breakable if the node is one of the following type:\n     *\n     * - DoWhileStatement\n     * - ForInStatement\n     * - ForOfStatement\n     * - ForStatement\n     * - SwitchStatement\n     * - WhileStatement\n     *\n     * @param {ASTNode} node - A node to check.\n     * @returns {boolean} `true` if the node is breakable.\n     */\n    isBreakableStatement(node) {\n        return breakableTypePattern.test(node.type);\n    },\n\n    /**\n     * Gets the label if the parent node of a given node is a LabeledStatement.\n     *\n     * @param {ASTNode} node - A node to get.\n     * @returns {string|null} The label or `null`.\n     */\n    getLabel(node) {\n        if (node.parent.type === \"LabeledStatement\") {\n            return node.parent.label.name;\n        }\n        return null;\n    },\n\n    /**\n     * Gets references which are non initializer and writable.\n     * @param {Reference[]} references - An array of references.\n     * @returns {Reference[]} An array of only references which are non initializer and writable.\n     * @public\n     */\n    getModifyingReferences(references) {\n        return references.filter(isModifyingReference);\n    },\n\n    /**\n     * Validate that a string passed in is surrounded by the specified character\n     * @param  {string} val The text to check.\n     * @param  {string} character The character to see if it's surrounded by.\n     * @returns {boolean} True if the text is surrounded by the character, false if not.\n     * @private\n     */\n    isSurroundedBy(val, character) {\n        return val[0] === character && val[val.length - 1] === character;\n    },\n\n    /**\n     * Returns whether the provided node is an ESLint directive comment or not\n     * @param {Line|Block} node The comment token to be checked\n     * @returns {boolean} `true` if the node is an ESLint directive comment\n     */\n    isDirectiveComment(node) {\n        const comment = node.value.trim();\n\n        return (\n            node.type === \"Line\" && comment.indexOf(\"eslint-\") === 0 ||\n            node.type === \"Block\" && (\n                comment.indexOf(\"global \") === 0 ||\n                comment.indexOf(\"eslint \") === 0 ||\n                comment.indexOf(\"eslint-\") === 0\n            )\n        );\n    },\n\n    /**\n     * Gets the trailing statement of a given node.\n     *\n     *     if (code)\n     *         consequent;\n     *\n     * When taking this `IfStatement`, returns `consequent;` statement.\n     *\n     * @param {ASTNode} A node to get.\n     * @returns {ASTNode|null} The trailing statement's node.\n     */\n    getTrailingStatement: esutils.ast.trailingStatement,\n\n    /**\n     * Finds the variable by a given name in a given scope and its upper scopes.\n     *\n     * @param {eslint-scope.Scope} initScope - A scope to start find.\n     * @param {string} name - A variable name to find.\n     * @returns {eslint-scope.Variable|null} A found variable or `null`.\n     */\n    getVariableByName(initScope, name) {\n        let scope = initScope;\n\n        while (scope) {\n            const variable = scope.set.get(name);\n\n            if (variable) {\n                return variable;\n            }\n\n            scope = scope.upper;\n        }\n\n        return null;\n    },\n\n    /**\n     * Checks whether or not a given function node is the default `this` binding.\n     *\n     * First, this checks the node:\n     *\n     * - The function name does not start with uppercase (it's a constructor).\n     * - The function does not have a JSDoc comment that has a @this tag.\n     *\n     * Next, this checks the location of the node.\n     * If the location is below, this judges `this` is valid.\n     *\n     * - The location is not on an object literal.\n     * - The location is not assigned to a variable which starts with an uppercase letter.\n     * - The location is not on an ES2015 class.\n     * - Its `bind`/`call`/`apply` method is not called directly.\n     * - The function is not a callback of array methods (such as `.forEach()`) if `thisArg` is given.\n     *\n     * @param {ASTNode} node - A function node to check.\n     * @param {SourceCode} sourceCode - A SourceCode instance to get comments.\n     * @returns {boolean} The function node is the default `this` binding.\n     */\n    isDefaultThisBinding(node, sourceCode) {\n        if (isES5Constructor(node) || hasJSDocThisTag(node, sourceCode)) {\n            return false;\n        }\n        const isAnonymous = node.id === null;\n        let currentNode = node;\n\n        while (currentNode) {\n            const parent = currentNode.parent;\n\n            switch (parent.type) {\n\n                /*\n                 * Looks up the destination.\n                 * e.g., obj.foo = nativeFoo || function foo() { ... };\n                 */\n                case \"LogicalExpression\":\n                case \"ConditionalExpression\":\n                    currentNode = parent;\n                    break;\n\n                /*\n                 * If the upper function is IIFE, checks the destination of the return value.\n                 * e.g.\n                 *   obj.foo = (function() {\n                 *     // setup...\n                 *     return function foo() { ... };\n                 *   })();\n                 *   obj.foo = (() =>\n                 *     function foo() { ... }\n                 *   )();\n                 */\n                case \"ReturnStatement\": {\n                    const func = getUpperFunction(parent);\n\n                    if (func === null || !isCallee(func)) {\n                        return true;\n                    }\n                    currentNode = func.parent;\n                    break;\n                }\n                case \"ArrowFunctionExpression\":\n                    if (currentNode !== parent.body || !isCallee(parent)) {\n                        return true;\n                    }\n                    currentNode = parent.parent;\n                    break;\n\n                /*\n                 * e.g.\n                 *   var obj = { foo() { ... } };\n                 *   var obj = { foo: function() { ... } };\n                 *   class A { constructor() { ... } }\n                 *   class A { foo() { ... } }\n                 *   class A { get foo() { ... } }\n                 *   class A { set foo() { ... } }\n                 *   class A { static foo() { ... } }\n                 */\n                case \"Property\":\n                case \"MethodDefinition\":\n                    return parent.value !== currentNode;\n\n                /*\n                 * e.g.\n                 *   obj.foo = function foo() { ... };\n                 *   Foo = function() { ... };\n                 *   [obj.foo = function foo() { ... }] = a;\n                 *   [Foo = function() { ... }] = a;\n                 */\n                case \"AssignmentExpression\":\n                case \"AssignmentPattern\":\n                    if (parent.left.type === \"MemberExpression\") {\n                        return false;\n                    }\n                    if (\n                        isAnonymous &&\n                        parent.left.type === \"Identifier\" &&\n                        startsWithUpperCase(parent.left.name)\n                    ) {\n                        return false;\n                    }\n                    return true;\n\n                /*\n                 * e.g.\n                 *   var Foo = function() { ... };\n                 */\n                case \"VariableDeclarator\":\n                    return !(\n                        isAnonymous &&\n                        parent.init === currentNode &&\n                        parent.id.type === \"Identifier\" &&\n                        startsWithUpperCase(parent.id.name)\n                    );\n\n                /*\n                 * e.g.\n                 *   var foo = function foo() { ... }.bind(obj);\n                 *   (function foo() { ... }).call(obj);\n                 *   (function foo() { ... }).apply(obj, []);\n                 */\n                case \"MemberExpression\":\n                    return (\n                        parent.object !== currentNode ||\n                        parent.property.type !== \"Identifier\" ||\n                        !bindOrCallOrApplyPattern.test(parent.property.name) ||\n                        !isCallee(parent) ||\n                        parent.parent.arguments.length === 0 ||\n                        isNullOrUndefined(parent.parent.arguments[0])\n                    );\n\n                /*\n                 * e.g.\n                 *   Reflect.apply(function() {}, obj, []);\n                 *   Array.from([], function() {}, obj);\n                 *   list.forEach(function() {}, obj);\n                 */\n                case \"CallExpression\":\n                    if (isReflectApply(parent.callee)) {\n                        return (\n                            parent.arguments.length !== 3 ||\n                            parent.arguments[0] !== currentNode ||\n                            isNullOrUndefined(parent.arguments[1])\n                        );\n                    }\n                    if (isArrayFromMethod(parent.callee)) {\n                        return (\n                            parent.arguments.length !== 3 ||\n                            parent.arguments[1] !== currentNode ||\n                            isNullOrUndefined(parent.arguments[2])\n                        );\n                    }\n                    if (isMethodWhichHasThisArg(parent.callee)) {\n                        return (\n                            parent.arguments.length !== 2 ||\n                            parent.arguments[0] !== currentNode ||\n                            isNullOrUndefined(parent.arguments[1])\n                        );\n                    }\n                    return true;\n\n                // Otherwise `this` is default.\n                default:\n                    return true;\n            }\n        }\n\n        /* istanbul ignore next */\n        return true;\n    },\n\n    /**\n     * Get the precedence level based on the node type\n     * @param {ASTNode} node node to evaluate\n     * @returns {int} precedence level\n     * @private\n     */\n    getPrecedence(node) {\n        switch (node.type) {\n            case \"SequenceExpression\":\n                return 0;\n\n            case \"AssignmentExpression\":\n            case \"ArrowFunctionExpression\":\n            case \"YieldExpression\":\n                return 1;\n\n            case \"ConditionalExpression\":\n                return 3;\n\n            case \"LogicalExpression\":\n                switch (node.operator) {\n                    case \"||\":\n                        return 4;\n                    case \"&&\":\n                        return 5;\n\n                    // no default\n                }\n\n                /* falls through */\n\n            case \"BinaryExpression\":\n\n                switch (node.operator) {\n                    case \"|\":\n                        return 6;\n                    case \"^\":\n                        return 7;\n                    case \"&\":\n                        return 8;\n                    case \"==\":\n                    case \"!=\":\n                    case \"===\":\n                    case \"!==\":\n                        return 9;\n                    case \"<\":\n                    case \"<=\":\n                    case \">\":\n                    case \">=\":\n                    case \"in\":\n                    case \"instanceof\":\n                        return 10;\n                    case \"<<\":\n                    case \">>\":\n                    case \">>>\":\n                        return 11;\n                    case \"+\":\n                    case \"-\":\n                        return 12;\n                    case \"*\":\n                    case \"/\":\n                    case \"%\":\n                        return 13;\n                    case \"**\":\n                        return 15;\n\n                    // no default\n                }\n\n                /* falls through */\n\n            case \"UnaryExpression\":\n            case \"AwaitExpression\":\n                return 16;\n\n            case \"UpdateExpression\":\n                return 17;\n\n            case \"CallExpression\":\n                return 18;\n\n            case \"NewExpression\":\n                return 19;\n\n            default:\n                return 20;\n        }\n    },\n\n    /**\n     * Checks whether the given node is an empty block node or not.\n     *\n     * @param {ASTNode|null} node - The node to check.\n     * @returns {boolean} `true` if the node is an empty block.\n     */\n    isEmptyBlock(node) {\n        return Boolean(node && node.type === \"BlockStatement\" && node.body.length === 0);\n    },\n\n    /**\n     * Checks whether the given node is an empty function node or not.\n     *\n     * @param {ASTNode|null} node - The node to check.\n     * @returns {boolean} `true` if the node is an empty function.\n     */\n    isEmptyFunction(node) {\n        return isFunction(node) && module.exports.isEmptyBlock(node.body);\n    },\n\n    /**\n     * Gets the property name of a given node.\n     * The node can be a MemberExpression, a Property, or a MethodDefinition.\n     *\n     * If the name is dynamic, this returns `null`.\n     *\n     * For examples:\n     *\n     *     a.b           // => \"b\"\n     *     a[\"b\"]        // => \"b\"\n     *     a['b']        // => \"b\"\n     *     a[`b`]        // => \"b\"\n     *     a[100]        // => \"100\"\n     *     a[b]          // => null\n     *     a[\"a\" + \"b\"]  // => null\n     *     a[tag`b`]     // => null\n     *     a[`${b}`]     // => null\n     *\n     *     let a = {b: 1}            // => \"b\"\n     *     let a = {[\"b\"]: 1}        // => \"b\"\n     *     let a = {['b']: 1}        // => \"b\"\n     *     let a = {[`b`]: 1}        // => \"b\"\n     *     let a = {[100]: 1}        // => \"100\"\n     *     let a = {[b]: 1}          // => null\n     *     let a = {[\"a\" + \"b\"]: 1}  // => null\n     *     let a = {[tag`b`]: 1}     // => null\n     *     let a = {[`${b}`]: 1}     // => null\n     *\n     * @param {ASTNode} node - The node to get.\n     * @returns {string|null} The property name if static. Otherwise, null.\n     */\n    getStaticPropertyName(node) {\n        let prop;\n\n        switch (node && node.type) {\n            case \"Property\":\n            case \"MethodDefinition\":\n                prop = node.key;\n                break;\n\n            case \"MemberExpression\":\n                prop = node.property;\n                break;\n\n            // no default\n        }\n\n        switch (prop && prop.type) {\n            case \"Literal\":\n                return String(prop.value);\n\n            case \"TemplateLiteral\":\n                if (prop.expressions.length === 0 && prop.quasis.length === 1) {\n                    return prop.quasis[0].value.cooked;\n                }\n                break;\n\n            case \"Identifier\":\n                if (!node.computed) {\n                    return prop.name;\n                }\n                break;\n\n            // no default\n        }\n\n        return null;\n    },\n\n    /**\n     * Get directives from directive prologue of a Program or Function node.\n     * @param {ASTNode} node - The node to check.\n     * @returns {ASTNode[]} The directives found in the directive prologue.\n     */\n    getDirectivePrologue(node) {\n        const directives = [];\n\n        // Directive prologues only occur at the top of files or functions.\n        if (\n            node.type === \"Program\" ||\n            node.type === \"FunctionDeclaration\" ||\n            node.type === \"FunctionExpression\" ||\n\n            /*\n             * Do not check arrow functions with implicit return.\n             * `() => \"use strict\";` returns the string `\"use strict\"`.\n             */\n            (node.type === \"ArrowFunctionExpression\" && node.body.type === \"BlockStatement\")\n        ) {\n            const statements = node.type === \"Program\" ? node.body : node.body.body;\n\n            for (const statement of statements) {\n                if (\n                    statement.type === \"ExpressionStatement\" &&\n                    statement.expression.type === \"Literal\"\n                ) {\n                    directives.push(statement);\n                } else {\n                    break;\n                }\n            }\n        }\n\n        return directives;\n    },\n\n\n    /**\n     * Determines whether this node is a decimal integer literal. If a node is a decimal integer literal, a dot added\n     * after the node will be parsed as a decimal point, rather than a property-access dot.\n     * @param {ASTNode} node - The node to check.\n     * @returns {boolean} `true` if this node is a decimal integer.\n     * @example\n     *\n     * 5       // true\n     * 5.      // false\n     * 5.0     // false\n     * 05      // false\n     * 0x5     // false\n     * 0b101   // false\n     * 0o5     // false\n     * 5e0     // false\n     * '5'     // false\n     */\n    isDecimalInteger(node) {\n        return node.type === \"Literal\" && typeof node.value === \"number\" && /^(0|[1-9]\\d*)$/u.test(node.raw);\n    },\n\n    /**\n     * Gets the name and kind of the given function node.\n     *\n     * - `function foo() {}`  .................... `function 'foo'`\n     * - `(function foo() {})`  .................. `function 'foo'`\n     * - `(function() {})`  ...................... `function`\n     * - `function* foo() {}`  ................... `generator function 'foo'`\n     * - `(function* foo() {})`  ................. `generator function 'foo'`\n     * - `(function*() {})`  ..................... `generator function`\n     * - `() => {}`  ............................. `arrow function`\n     * - `async () => {}`  ....................... `async arrow function`\n     * - `({ foo: function foo() {} })`  ......... `method 'foo'`\n     * - `({ foo: function() {} })`  ............. `method 'foo'`\n     * - `({ ['foo']: function() {} })`  ......... `method 'foo'`\n     * - `({ [foo]: function() {} })`  ........... `method`\n     * - `({ foo() {} })`  ....................... `method 'foo'`\n     * - `({ foo: function* foo() {} })`  ........ `generator method 'foo'`\n     * - `({ foo: function*() {} })`  ............ `generator method 'foo'`\n     * - `({ ['foo']: function*() {} })`  ........ `generator method 'foo'`\n     * - `({ [foo]: function*() {} })`  .......... `generator method`\n     * - `({ *foo() {} })`  ...................... `generator method 'foo'`\n     * - `({ foo: async function foo() {} })`  ... `async method 'foo'`\n     * - `({ foo: async function() {} })`  ....... `async method 'foo'`\n     * - `({ ['foo']: async function() {} })`  ... `async method 'foo'`\n     * - `({ [foo]: async function() {} })`  ..... `async method`\n     * - `({ async foo() {} })`  ................. `async method 'foo'`\n     * - `({ get foo() {} })`  ................... `getter 'foo'`\n     * - `({ set foo(a) {} })`  .................. `setter 'foo'`\n     * - `class A { constructor() {} }`  ......... `constructor`\n     * - `class A { foo() {} }`  ................. `method 'foo'`\n     * - `class A { *foo() {} }`  ................ `generator method 'foo'`\n     * - `class A { async foo() {} }`  ........... `async method 'foo'`\n     * - `class A { ['foo']() {} }`  ............. `method 'foo'`\n     * - `class A { *['foo']() {} }`  ............ `generator method 'foo'`\n     * - `class A { async ['foo']() {} }`  ....... `async method 'foo'`\n     * - `class A { [foo]() {} }`  ............... `method`\n     * - `class A { *[foo]() {} }`  .............. `generator method`\n     * - `class A { async [foo]() {} }`  ......... `async method`\n     * - `class A { get foo() {} }`  ............. `getter 'foo'`\n     * - `class A { set foo(a) {} }`  ............ `setter 'foo'`\n     * - `class A { static foo() {} }`  .......... `static method 'foo'`\n     * - `class A { static *foo() {} }`  ......... `static generator method 'foo'`\n     * - `class A { static async foo() {} }`  .... `static async method 'foo'`\n     * - `class A { static get foo() {} }`  ...... `static getter 'foo'`\n     * - `class A { static set foo(a) {} }`  ..... `static setter 'foo'`\n     *\n     * @param {ASTNode} node - The function node to get.\n     * @returns {string} The name and kind of the function node.\n     */\n    getFunctionNameWithKind(node) {\n        const parent = node.parent;\n        const tokens = [];\n\n        if (parent.type === \"MethodDefinition\" && parent.static) {\n            tokens.push(\"static\");\n        }\n        if (node.async) {\n            tokens.push(\"async\");\n        }\n        if (node.generator) {\n            tokens.push(\"generator\");\n        }\n\n        if (node.type === \"ArrowFunctionExpression\") {\n            tokens.push(\"arrow\", \"function\");\n        } else if (parent.type === \"Property\" || parent.type === \"MethodDefinition\") {\n            if (parent.kind === \"constructor\") {\n                return \"constructor\";\n            }\n            if (parent.kind === \"get\") {\n                tokens.push(\"getter\");\n            } else if (parent.kind === \"set\") {\n                tokens.push(\"setter\");\n            } else {\n                tokens.push(\"method\");\n            }\n        } else {\n            tokens.push(\"function\");\n        }\n\n        if (node.id) {\n            tokens.push(`'${node.id.name}'`);\n        } else {\n            const name = module.exports.getStaticPropertyName(parent);\n\n            if (name) {\n                tokens.push(`'${name}'`);\n            }\n        }\n\n        return tokens.join(\" \");\n    },\n\n    /**\n     * Gets the location of the given function node for reporting.\n     *\n     * - `function foo() {}`\n     *    ^^^^^^^^^^^^\n     * - `(function foo() {})`\n     *     ^^^^^^^^^^^^\n     * - `(function() {})`\n     *     ^^^^^^^^\n     * - `function* foo() {}`\n     *    ^^^^^^^^^^^^^\n     * - `(function* foo() {})`\n     *     ^^^^^^^^^^^^^\n     * - `(function*() {})`\n     *     ^^^^^^^^^\n     * - `() => {}`\n     *       ^^\n     * - `async () => {}`\n     *             ^^\n     * - `({ foo: function foo() {} })`\n     *       ^^^^^^^^^^^^^^^^^\n     * - `({ foo: function() {} })`\n     *       ^^^^^^^^^^^^^\n     * - `({ ['foo']: function() {} })`\n     *       ^^^^^^^^^^^^^^^^^\n     * - `({ [foo]: function() {} })`\n     *       ^^^^^^^^^^^^^^^\n     * - `({ foo() {} })`\n     *       ^^^\n     * - `({ foo: function* foo() {} })`\n     *       ^^^^^^^^^^^^^^^^^^\n     * - `({ foo: function*() {} })`\n     *       ^^^^^^^^^^^^^^\n     * - `({ ['foo']: function*() {} })`\n     *       ^^^^^^^^^^^^^^^^^^\n     * - `({ [foo]: function*() {} })`\n     *       ^^^^^^^^^^^^^^^^\n     * - `({ *foo() {} })`\n     *       ^^^^\n     * - `({ foo: async function foo() {} })`\n     *       ^^^^^^^^^^^^^^^^^^^^^^^\n     * - `({ foo: async function() {} })`\n     *       ^^^^^^^^^^^^^^^^^^^\n     * - `({ ['foo']: async function() {} })`\n     *       ^^^^^^^^^^^^^^^^^^^^^^^\n     * - `({ [foo]: async function() {} })`\n     *       ^^^^^^^^^^^^^^^^^^^^^\n     * - `({ async foo() {} })`\n     *       ^^^^^^^^^\n     * - `({ get foo() {} })`\n     *       ^^^^^^^\n     * - `({ set foo(a) {} })`\n     *       ^^^^^^^\n     * - `class A { constructor() {} }`\n     *              ^^^^^^^^^^^\n     * - `class A { foo() {} }`\n     *              ^^^\n     * - `class A { *foo() {} }`\n     *              ^^^^\n     * - `class A { async foo() {} }`\n     *              ^^^^^^^^^\n     * - `class A { ['foo']() {} }`\n     *              ^^^^^^^\n     * - `class A { *['foo']() {} }`\n     *              ^^^^^^^^\n     * - `class A { async ['foo']() {} }`\n     *              ^^^^^^^^^^^^^\n     * - `class A { [foo]() {} }`\n     *              ^^^^^\n     * - `class A { *[foo]() {} }`\n     *              ^^^^^^\n     * - `class A { async [foo]() {} }`\n     *              ^^^^^^^^^^^\n     * - `class A { get foo() {} }`\n     *              ^^^^^^^\n     * - `class A { set foo(a) {} }`\n     *              ^^^^^^^\n     * - `class A { static foo() {} }`\n     *              ^^^^^^^^^^\n     * - `class A { static *foo() {} }`\n     *              ^^^^^^^^^^^\n     * - `class A { static async foo() {} }`\n     *              ^^^^^^^^^^^^^^^^\n     * - `class A { static get foo() {} }`\n     *              ^^^^^^^^^^^^^^\n     * - `class A { static set foo(a) {} }`\n     *              ^^^^^^^^^^^^^^\n     *\n     * @param {ASTNode} node - The function node to get.\n     * @param {SourceCode} sourceCode - The source code object to get tokens.\n     * @returns {string} The location of the function node for reporting.\n     */\n    getFunctionHeadLoc(node, sourceCode) {\n        const parent = node.parent;\n        let start = null;\n        let end = null;\n\n        if (node.type === \"ArrowFunctionExpression\") {\n            const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);\n\n            start = arrowToken.loc.start;\n            end = arrowToken.loc.end;\n        } else if (parent.type === \"Property\" || parent.type === \"MethodDefinition\") {\n            start = parent.loc.start;\n            end = getOpeningParenOfParams(node, sourceCode).loc.start;\n        } else {\n            start = node.loc.start;\n            end = getOpeningParenOfParams(node, sourceCode).loc.start;\n        }\n\n        return {\n            start: Object.assign({}, start),\n            end: Object.assign({}, end)\n        };\n    },\n\n    /**\n     * Gets the parenthesized text of a node. This is similar to sourceCode.getText(node), but it also includes any parentheses\n     * surrounding the node.\n     * @param {SourceCode} sourceCode The source code object\n     * @param {ASTNode} node An expression node\n     * @returns {string} The text representing the node, with all surrounding parentheses included\n     */\n    getParenthesisedText(sourceCode, node) {\n        let leftToken = sourceCode.getFirstToken(node);\n        let rightToken = sourceCode.getLastToken(node);\n\n        while (\n            sourceCode.getTokenBefore(leftToken) &&\n            sourceCode.getTokenBefore(leftToken).type === \"Punctuator\" &&\n            sourceCode.getTokenBefore(leftToken).value === \"(\" &&\n            sourceCode.getTokenAfter(rightToken) &&\n            sourceCode.getTokenAfter(rightToken).type === \"Punctuator\" &&\n            sourceCode.getTokenAfter(rightToken).value === \")\"\n        ) {\n            leftToken = sourceCode.getTokenBefore(leftToken);\n            rightToken = sourceCode.getTokenAfter(rightToken);\n        }\n\n        return sourceCode.getText().slice(leftToken.range[0], rightToken.range[1]);\n    },\n\n    /*\n     * Determine if a node has a possiblity to be an Error object\n     * @param  {ASTNode} node  ASTNode to check\n     * @returns {boolean} True if there is a chance it contains an Error obj\n     */\n    couldBeError(node) {\n        switch (node.type) {\n            case \"Identifier\":\n            case \"CallExpression\":\n            case \"NewExpression\":\n            case \"MemberExpression\":\n            case \"TaggedTemplateExpression\":\n            case \"YieldExpression\":\n            case \"AwaitExpression\":\n                return true; // possibly an error object.\n\n            case \"AssignmentExpression\":\n                return module.exports.couldBeError(node.right);\n\n            case \"SequenceExpression\": {\n                const exprs = node.expressions;\n\n                return exprs.length !== 0 && module.exports.couldBeError(exprs[exprs.length - 1]);\n            }\n\n            case \"LogicalExpression\":\n                return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);\n\n            case \"ConditionalExpression\":\n                return module.exports.couldBeError(node.consequent) || module.exports.couldBeError(node.alternate);\n\n            default:\n                return false;\n        }\n    },\n\n    /**\n     * Determines whether the given node is a `null` literal.\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} `true` if the node is a `null` literal\n     */\n    isNullLiteral(node) {\n\n        /*\n         * Checking `node.value === null` does not guarantee that a literal is a null literal.\n         * When parsing values that cannot be represented in the current environment (e.g. unicode\n         * regexes in Node 4), `node.value` is set to `null` because it wouldn't be possible to\n         * set `node.value` to a unicode regex. To make sure a literal is actually `null`, check\n         * `node.regex` instead. Also see: https://github.com/eslint/eslint/issues/8020\n         */\n        return node.type === \"Literal\" && node.value === null && !node.regex;\n    },\n\n    /**\n     * Determines whether two tokens can safely be placed next to each other without merging into a single token\n     * @param {Token|string} leftValue The left token. If this is a string, it will be tokenized and the last token will be used.\n     * @param {Token|string} rightValue The right token. If this is a string, it will be tokenized and the first token will be used.\n     * @returns {boolean} If the tokens cannot be safely placed next to each other, returns `false`. If the tokens can be placed\n     * next to each other, behavior is undefined (although it should return `true` in most cases).\n     */\n    canTokensBeAdjacent(leftValue, rightValue) {\n        let leftToken;\n\n        if (typeof leftValue === \"string\") {\n            const leftTokens = espree.tokenize(leftValue, { ecmaVersion: 2015 });\n\n            leftToken = leftTokens[leftTokens.length - 1];\n        } else {\n            leftToken = leftValue;\n        }\n\n        const rightToken = typeof rightValue === \"string\" ? espree.tokenize(rightValue, { ecmaVersion: 2015 })[0] : rightValue;\n\n        if (leftToken.type === \"Punctuator\" || rightToken.type === \"Punctuator\") {\n            if (leftToken.type === \"Punctuator\" && rightToken.type === \"Punctuator\") {\n                const PLUS_TOKENS = new Set([\"+\", \"++\"]);\n                const MINUS_TOKENS = new Set([\"-\", \"--\"]);\n\n                return !(\n                    PLUS_TOKENS.has(leftToken.value) && PLUS_TOKENS.has(rightToken.value) ||\n                    MINUS_TOKENS.has(leftToken.value) && MINUS_TOKENS.has(rightToken.value)\n                );\n            }\n            return true;\n        }\n\n        if (\n            leftToken.type === \"String\" || rightToken.type === \"String\" ||\n            leftToken.type === \"Template\" || rightToken.type === \"Template\"\n        ) {\n            return true;\n        }\n\n        if (leftToken.type !== \"Numeric\" && rightToken.type === \"Numeric\" && rightToken.value.startsWith(\".\")) {\n            return true;\n        }\n\n        return false;\n    }\n};\n","/**\n * @fileoverview Config file operations. This file must be usable in the browser,\n * so no Node-specific code can be here.\n * @author Nicholas C. Zakas\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst minimatch = require(\"minimatch\"),\n    path = require(\"path\");\n\nconst debug = require(\"debug\")(\"eslint:config-ops\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nconst RULE_SEVERITY_STRINGS = [\"off\", \"warn\", \"error\"],\n    RULE_SEVERITY = RULE_SEVERITY_STRINGS.reduce((map, value, index) => {\n        map[value] = index;\n        return map;\n    }, {}),\n    VALID_SEVERITIES = [0, 1, 2, \"off\", \"warn\", \"error\"];\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n\n    /**\n     * Creates an empty configuration object suitable for merging as a base.\n     * @returns {Object} A configuration object.\n     */\n    createEmptyConfig() {\n        return {\n            globals: {},\n            env: {},\n            rules: {},\n            parserOptions: {}\n        };\n    },\n\n    /**\n     * Creates an environment config based on the specified environments.\n     * @param {Object<string,boolean>} env The environment settings.\n     * @param {Environments} envContext The environment context.\n     * @returns {Object} A configuration object with the appropriate rules and globals\n     *      set.\n     */\n    createEnvironmentConfig(env, envContext) {\n\n        const envConfig = this.createEmptyConfig();\n\n        if (env) {\n\n            envConfig.env = env;\n\n            Object.keys(env).filter(name => env[name]).forEach(name => {\n                const environment = envContext.get(name);\n\n                if (environment) {\n                    debug(`Creating config for environment ${name}`);\n                    if (environment.globals) {\n                        Object.assign(envConfig.globals, environment.globals);\n                    }\n\n                    if (environment.parserOptions) {\n                        Object.assign(envConfig.parserOptions, environment.parserOptions);\n                    }\n                }\n            });\n        }\n\n        return envConfig;\n    },\n\n    /**\n     * Given a config with environment settings, applies the globals and\n     * ecmaFeatures to the configuration and returns the result.\n     * @param {Object} config The configuration information.\n     * @param {Environments} envContent env context.\n     * @returns {Object} The updated configuration information.\n     */\n    applyEnvironments(config, envContent) {\n        if (config.env && typeof config.env === \"object\") {\n            debug(\"Apply environment settings to config\");\n            return this.merge(this.createEnvironmentConfig(config.env, envContent), config);\n        }\n\n        return config;\n    },\n\n    /**\n     * Merges two config objects. This will not only add missing keys, but will also modify values to match.\n     * @param {Object} target config object\n     * @param {Object} src config object. Overrides in this config object will take priority over base.\n     * @param {boolean} [combine] Whether to combine arrays or not\n     * @param {boolean} [isRule] Whether its a rule\n     * @returns {Object} merged config object.\n     */\n    merge: function deepmerge(target, src, combine, isRule) {\n\n        /*\n         * The MIT License (MIT)\n         *\n         * Copyright (c) 2012 Nicholas Fisher\n         *\n         * Permission is hereby granted, free of charge, to any person obtaining a copy\n         * of this software and associated documentation files (the \"Software\"), to deal\n         * in the Software without restriction, including without limitation the rights\n         * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n         * copies of the Software, and to permit persons to whom the Software is\n         * furnished to do so, subject to the following conditions:\n         *\n         * The above copyright notice and this permission notice shall be included in\n         * all copies or substantial portions of the Software.\n         *\n         * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n         * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n         * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n         * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n         * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n         * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n         * THE SOFTWARE.\n         */\n\n        /*\n         * This code is taken from deepmerge repo\n         * (https://github.com/KyleAMathews/deepmerge)\n         * and modified to meet our needs.\n         */\n        const array = Array.isArray(src) || Array.isArray(target);\n        let dst = array && [] || {};\n\n        if (array) {\n            const resolvedTarget = target || [];\n\n            // src could be a string, so check for array\n            if (isRule && Array.isArray(src) && src.length > 1) {\n                dst = dst.concat(src);\n            } else {\n                dst = dst.concat(resolvedTarget);\n            }\n            const resolvedSrc = typeof src === \"object\" ? src : [src];\n\n            Object.keys(resolvedSrc).forEach((_, i) => {\n                const e = resolvedSrc[i];\n\n                if (typeof dst[i] === \"undefined\") {\n                    dst[i] = e;\n                } else if (typeof e === \"object\") {\n                    if (isRule) {\n                        dst[i] = e;\n                    } else {\n                        dst[i] = deepmerge(resolvedTarget[i], e, combine, isRule);\n                    }\n                } else {\n                    if (!combine) {\n                        dst[i] = e;\n                    } else {\n                        if (dst.indexOf(e) === -1) {\n                            dst.push(e);\n                        }\n                    }\n                }\n            });\n        } else {\n            if (target && typeof target === \"object\") {\n                Object.keys(target).forEach(key => {\n                    dst[key] = target[key];\n                });\n            }\n            Object.keys(src).forEach(key => {\n                if (key === \"overrides\") {\n                    dst[key] = (target[key] || []).concat(src[key] || []);\n                } else if (Array.isArray(src[key]) || Array.isArray(target[key])) {\n                    dst[key] = deepmerge(target[key], src[key], key === \"plugins\" || key === \"extends\", isRule);\n                } else if (typeof src[key] !== \"object\" || !src[key] || key === \"exported\" || key === \"astGlobals\") {\n                    dst[key] = src[key];\n                } else {\n                    dst[key] = deepmerge(target[key] || {}, src[key], combine, key === \"rules\");\n                }\n            });\n        }\n\n        return dst;\n    },\n\n    /**\n     * Normalizes the severity value of a rule's configuration to a number\n     * @param {(number|string|[number, ...*]|[string, ...*])} ruleConfig A rule's configuration value, generally\n     * received from the user. A valid config value is either 0, 1, 2, the string \"off\" (treated the same as 0),\n     * the string \"warn\" (treated the same as 1), the string \"error\" (treated the same as 2), or an array\n     * whose first element is one of the above values. Strings are matched case-insensitively.\n     * @returns {(0|1|2)} The numeric severity value if the config value was valid, otherwise 0.\n     */\n    getRuleSeverity(ruleConfig) {\n        const severityValue = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;\n\n        if (severityValue === 0 || severityValue === 1 || severityValue === 2) {\n            return severityValue;\n        }\n\n        if (typeof severityValue === \"string\") {\n            return RULE_SEVERITY[severityValue.toLowerCase()] || 0;\n        }\n\n        return 0;\n    },\n\n    /**\n     * Converts old-style severity settings (0, 1, 2) into new-style\n     * severity settings (off, warn, error) for all rules. Assumption is that severity\n     * values have already been validated as correct.\n     * @param {Object} config The config object to normalize.\n     * @returns {void}\n     */\n    normalizeToStrings(config) {\n\n        if (config.rules) {\n            Object.keys(config.rules).forEach(ruleId => {\n                const ruleConfig = config.rules[ruleId];\n\n                if (typeof ruleConfig === \"number\") {\n                    config.rules[ruleId] = RULE_SEVERITY_STRINGS[ruleConfig] || RULE_SEVERITY_STRINGS[0];\n                } else if (Array.isArray(ruleConfig) && typeof ruleConfig[0] === \"number\") {\n                    ruleConfig[0] = RULE_SEVERITY_STRINGS[ruleConfig[0]] || RULE_SEVERITY_STRINGS[0];\n                }\n            });\n        }\n    },\n\n    /**\n     * Determines if the severity for the given rule configuration represents an error.\n     * @param {int|string|Array} ruleConfig The configuration for an individual rule.\n     * @returns {boolean} True if the rule represents an error, false if not.\n     */\n    isErrorSeverity(ruleConfig) {\n        return module.exports.getRuleSeverity(ruleConfig) === 2;\n    },\n\n    /**\n     * Checks whether a given config has valid severity or not.\n     * @param {number|string|Array} ruleConfig - The configuration for an individual rule.\n     * @returns {boolean} `true` if the configuration has valid severity.\n     */\n    isValidSeverity(ruleConfig) {\n        let severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;\n\n        if (typeof severity === \"string\") {\n            severity = severity.toLowerCase();\n        }\n        return VALID_SEVERITIES.indexOf(severity) !== -1;\n    },\n\n    /**\n     * Checks whether every rule of a given config has valid severity or not.\n     * @param {Object} config - The configuration for rules.\n     * @returns {boolean} `true` if the configuration has valid severity.\n     */\n    isEverySeverityValid(config) {\n        return Object.keys(config).every(ruleId => this.isValidSeverity(config[ruleId]));\n    },\n\n    /**\n     * Merges all configurations in a given config vector. A vector is an array of objects, each containing a config\n     * file path and a list of subconfig indices that match the current file path. All config data is assumed to be\n     * cached.\n     * @param {Array<Object>} vector list of config files and their subconfig indices that match the current file path\n     * @param {Object} configCache the config cache\n     * @returns {Object} config object\n     */\n    getConfigFromVector(vector, configCache) {\n\n        const cachedConfig = configCache.getMergedVectorConfig(vector);\n\n        if (cachedConfig) {\n            return cachedConfig;\n        }\n\n        debug(\"Using config from partial cache\");\n\n        const subvector = Array.from(vector);\n        let nearestCacheIndex = subvector.length - 1,\n            partialCachedConfig;\n\n        while (nearestCacheIndex >= 0) {\n            partialCachedConfig = configCache.getMergedVectorConfig(subvector);\n            if (partialCachedConfig) {\n                break;\n            }\n            subvector.pop();\n            nearestCacheIndex--;\n        }\n\n        if (!partialCachedConfig) {\n            partialCachedConfig = {};\n        }\n\n        let finalConfig = partialCachedConfig;\n\n        // Start from entry immediately following nearest cached config (first uncached entry)\n        for (let i = nearestCacheIndex + 1; i < vector.length; i++) {\n            finalConfig = this.mergeVectorEntry(finalConfig, vector[i], configCache);\n            configCache.setMergedVectorConfig(vector.slice(0, i + 1), finalConfig);\n        }\n\n        return finalConfig;\n    },\n\n    /**\n     * Merges the config options from a single vector entry into the supplied config.\n     * @param {Object} config the base config to merge the vector entry's options into\n     * @param {Object} vectorEntry a single entry from a vector, consisting of a config file path and an array of\n     * matching override indices\n     * @param {Object} configCache the config cache\n     * @returns {Object} merged config object\n     */\n    mergeVectorEntry(config, vectorEntry, configCache) {\n        const vectorEntryConfig = Object.assign({}, configCache.getConfig(vectorEntry.filePath));\n        let mergedConfig = Object.assign({}, config),\n            overrides;\n\n        if (vectorEntryConfig.overrides) {\n            overrides = vectorEntryConfig.overrides.filter(\n                (override, overrideIndex) => vectorEntry.matchingOverrides.indexOf(overrideIndex) !== -1\n            );\n        } else {\n            overrides = [];\n        }\n\n        mergedConfig = this.merge(mergedConfig, vectorEntryConfig);\n\n        delete mergedConfig.overrides;\n\n        mergedConfig = overrides.reduce((lastConfig, override) => this.merge(lastConfig, override), mergedConfig);\n\n        if (mergedConfig.filePath) {\n            delete mergedConfig.filePath;\n            delete mergedConfig.baseDirectory;\n        } else if (mergedConfig.files) {\n            delete mergedConfig.files;\n        }\n\n        return mergedConfig;\n    },\n\n    /**\n     * Checks that the specified file path matches all of the supplied glob patterns.\n     * @param {string} filePath The file path to test patterns against\n     * @param {string|string[]} patterns One or more glob patterns, of which at least one should match the file path\n     * @param {string|string[]} [excludedPatterns] One or more glob patterns, of which none should match the file path\n     * @returns {boolean} True if all the supplied patterns match the file path, false otherwise\n     */\n    pathMatchesGlobs(filePath, patterns, excludedPatterns) {\n        const patternList = [].concat(patterns);\n        const excludedPatternList = [].concat(excludedPatterns || []);\n\n        patternList.concat(excludedPatternList).forEach(pattern => {\n            if (path.isAbsolute(pattern) || pattern.includes(\"..\")) {\n                throw new Error(`Invalid override pattern (expected relative path not containing '..'): ${pattern}`);\n            }\n        });\n\n        const opts = { matchBase: true };\n\n        return patternList.some(pattern => minimatch(filePath, pattern, opts)) &&\n            !excludedPatternList.some(excludedPattern => minimatch(filePath, excludedPattern, opts));\n    },\n\n    /**\n     * Normalizes a value for a global in a config\n     * @param {(boolean|string|null)} configuredValue The value given for a global in configuration or in\n     * a global directive comment\n     * @returns {(\"readable\"|\"writeable\"|\"off\")} The value normalized as a string\n     */\n    normalizeConfigGlobal(configuredValue) {\n        switch (configuredValue) {\n            case \"off\":\n                return \"off\";\n\n            case true:\n            case \"true\":\n            case \"writeable\":\n            case \"writable\":\n                return \"writeable\";\n\n            case null:\n            case false:\n            case \"false\":\n            case \"readable\":\n            case \"readonly\":\n                return \"readable\";\n\n            // Fallback to minimize compatibility impact\n            default:\n                return \"writeable\";\n        }\n    }\n};\n","/**\n * @fileoverview Validates configs.\n * @author Brandon Mills\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst path = require(\"path\"),\n    ajv = require(\"../util/ajv\"),\n    lodash = require(\"lodash\"),\n    configSchema = require(\"../../conf/config-schema.js\"),\n    util = require(\"util\");\n\nconst ruleValidators = new WeakMap();\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\nlet validateSchema;\n\n// Defitions for deprecation warnings.\nconst deprecationWarningMessages = {\n    ESLINT_LEGACY_ECMAFEATURES: \"The 'ecmaFeatures' config file property is deprecated, and has no effect.\",\n    ESLINT_LEGACY_OBJECT_REST_SPREAD: \"The 'parserOptions.ecmaFeatures.experimentalObjectRestSpread' option is deprecated. Use 'parserOptions.ecmaVersion' instead.\"\n};\nconst severityMap = {\n    error: 2,\n    warn: 1,\n    off: 0\n};\n\n/**\n * Gets a complete options schema for a rule.\n * @param {{create: Function, schema: (Array|null)}} rule A new-style rule object\n * @returns {Object} JSON Schema for the rule's options.\n */\nfunction getRuleOptionsSchema(rule) {\n    const schema = rule.schema || rule.meta && rule.meta.schema;\n\n    // Given a tuple of schemas, insert warning level at the beginning\n    if (Array.isArray(schema)) {\n        if (schema.length) {\n            return {\n                type: \"array\",\n                items: schema,\n                minItems: 0,\n                maxItems: schema.length\n            };\n        }\n        return {\n            type: \"array\",\n            minItems: 0,\n            maxItems: 0\n        };\n\n    }\n\n    // Given a full schema, leave it alone\n    return schema || null;\n}\n\n/**\n * Validates a rule's severity and returns the severity value. Throws an error if the severity is invalid.\n * @param {options} options The given options for the rule.\n * @returns {number|string} The rule's severity value\n */\nfunction validateRuleSeverity(options) {\n    const severity = Array.isArray(options) ? options[0] : options;\n    const normSeverity = typeof severity === \"string\" ? severityMap[severity.toLowerCase()] : severity;\n\n    if (normSeverity === 0 || normSeverity === 1 || normSeverity === 2) {\n        return normSeverity;\n    }\n\n    throw new Error(`\\tSeverity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '${util.inspect(severity).replace(/'/gu, \"\\\"\").replace(/\\n/gu, \"\")}').\\n`);\n\n}\n\n/**\n * Validates the non-severity options passed to a rule, based on its schema.\n * @param {{create: Function}} rule The rule to validate\n * @param {Array} localOptions The options for the rule, excluding severity\n * @returns {void}\n */\nfunction validateRuleSchema(rule, localOptions) {\n    if (!ruleValidators.has(rule)) {\n        const schema = getRuleOptionsSchema(rule);\n\n        if (schema) {\n            ruleValidators.set(rule, ajv.compile(schema));\n        }\n    }\n\n    const validateRule = ruleValidators.get(rule);\n\n    if (validateRule) {\n        validateRule(localOptions);\n        if (validateRule.errors) {\n            throw new Error(validateRule.errors.map(\n                error => `\\tValue ${JSON.stringify(error.data)} ${error.message}.\\n`\n            ).join(\"\"));\n        }\n    }\n}\n\n/**\n * Validates a rule's options against its schema.\n * @param {{create: Function}|null} rule The rule that the config is being validated for\n * @param {string} ruleId The rule's unique name.\n * @param {Array|number} options The given options for the rule.\n * @param {string|null} source The name of the configuration source to report in any errors. If null or undefined,\n * no source is prepended to the message.\n * @returns {void}\n */\nfunction validateRuleOptions(rule, ruleId, options, source = null) {\n    if (!rule) {\n        return;\n    }\n    try {\n        const severity = validateRuleSeverity(options);\n\n        if (severity !== 0) {\n            validateRuleSchema(rule, Array.isArray(options) ? options.slice(1) : []);\n        }\n    } catch (err) {\n        const enhancedMessage = `Configuration for rule \"${ruleId}\" is invalid:\\n${err.message}`;\n\n        if (typeof source === \"string\") {\n            throw new Error(`${source}:\\n\\t${enhancedMessage}`);\n        } else {\n            throw new Error(enhancedMessage);\n        }\n    }\n}\n\n/**\n * Validates an environment object\n * @param {Object} environment The environment config object to validate.\n * @param {Environments} envContext Env context\n * @param {string} source The name of the configuration source to report in any errors.\n * @returns {void}\n */\nfunction validateEnvironment(environment, envContext, source = null) {\n\n    // not having an environment is ok\n    if (!environment) {\n        return;\n    }\n\n    Object.keys(environment).forEach(env => {\n        if (!envContext.get(env)) {\n            const message = `${source}:\\n\\tEnvironment key \"${env}\" is unknown\\n`;\n\n            throw new Error(message);\n        }\n    });\n}\n\n/**\n * Validates a rules config object\n * @param {Object} rulesConfig The rules config object to validate.\n * @param {function(string): {create: Function}} ruleMapper A mapper function from strings to loaded rules\n * @param {string} source The name of the configuration source to report in any errors.\n * @returns {void}\n */\nfunction validateRules(rulesConfig, ruleMapper, source = null) {\n    if (!rulesConfig) {\n        return;\n    }\n\n    Object.keys(rulesConfig).forEach(id => {\n        validateRuleOptions(ruleMapper(id), id, rulesConfig[id], source);\n    });\n}\n\n/**\n * Formats an array of schema validation errors.\n * @param {Array} errors An array of error messages to format.\n * @returns {string} Formatted error message\n */\nfunction formatErrors(errors) {\n    return errors.map(error => {\n        if (error.keyword === \"additionalProperties\") {\n            const formattedPropertyPath = error.dataPath.length ? `${error.dataPath.slice(1)}.${error.params.additionalProperty}` : error.params.additionalProperty;\n\n            return `Unexpected top-level property \"${formattedPropertyPath}\"`;\n        }\n        if (error.keyword === \"type\") {\n            const formattedField = error.dataPath.slice(1);\n            const formattedExpectedType = Array.isArray(error.schema) ? error.schema.join(\"/\") : error.schema;\n            const formattedValue = JSON.stringify(error.data);\n\n            return `Property \"${formattedField}\" is the wrong type (expected ${formattedExpectedType} but got \\`${formattedValue}\\`)`;\n        }\n\n        const field = error.dataPath[0] === \".\" ? error.dataPath.slice(1) : error.dataPath;\n\n        return `\"${field}\" ${error.message}. Value: ${JSON.stringify(error.data)}`;\n    }).map(message => `\\t- ${message}.\\n`).join(\"\");\n}\n\n/**\n * Emits a deprecation warning containing a given filepath. A new deprecation warning is emitted\n * for each unique file path, but repeated invocations with the same file path have no effect.\n * No warnings are emitted if the `--no-deprecation` or `--no-warnings` Node runtime flags are active.\n * @param {string} source The name of the configuration source to report the warning for.\n * @param {string} errorCode The warning message to show.\n * @returns {void}\n */\nconst emitDeprecationWarning = lodash.memoize((source, errorCode) => {\n    const rel = path.relative(process.cwd(), source);\n    const message = deprecationWarningMessages[errorCode];\n\n    process.emitWarning(\n        `${message} (found in \"${rel}\")`,\n        \"DeprecationWarning\",\n        errorCode\n    );\n});\n\n/**\n * Validates the top level properties of the config object.\n * @param {Object} config The config object to validate.\n * @param {string} source The name of the configuration source to report in any errors.\n * @returns {void}\n */\nfunction validateConfigSchema(config, source = null) {\n    validateSchema = validateSchema || ajv.compile(configSchema);\n\n    if (!validateSchema(config)) {\n        throw new Error(`ESLint configuration in ${source} is invalid:\\n${formatErrors(validateSchema.errors)}`);\n    }\n\n    if (Object.hasOwnProperty.call(config, \"ecmaFeatures\")) {\n        emitDeprecationWarning(source, \"ESLINT_LEGACY_ECMAFEATURES\");\n    }\n\n    if (\n        (config.parser || \"espree\") === \"espree\" &&\n        config.parserOptions &&\n        config.parserOptions.ecmaFeatures &&\n        config.parserOptions.ecmaFeatures.experimentalObjectRestSpread\n    ) {\n        emitDeprecationWarning(source, \"ESLINT_LEGACY_OBJECT_REST_SPREAD\");\n    }\n}\n\n/**\n * Validates an entire config object.\n * @param {Object} config The config object to validate.\n * @param {function(string): {create: Function}} ruleMapper A mapper function from rule IDs to defined rules\n * @param {Environments} envContext The env context\n * @param {string} source The name of the configuration source to report in any errors.\n * @returns {void}\n */\nfunction validate(config, ruleMapper, envContext, source = null) {\n    validateConfigSchema(config, source);\n    validateRules(config.rules, ruleMapper, source);\n    validateEnvironment(config.env, envContext, source);\n\n    for (const override of config.overrides || []) {\n        validateRules(override.rules, ruleMapper, source);\n        validateEnvironment(override.env, envContext, source);\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    getRuleOptionsSchema,\n    validate,\n    validateRuleOptions\n};\n","/**\n * @fileoverview The instance of Ajv validator.\n * @author Evgeny Poberezkin\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Ajv = require(\"ajv\"),\n    metaSchema = require(\"ajv/lib/refs/json-schema-draft-04.json\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nconst ajv = new Ajv({\n    meta: false,\n    useDefaults: true,\n    validateSchema: false,\n    missingRefs: \"ignore\",\n    verbose: true,\n    schemaId: \"auto\"\n});\n\najv.addMetaSchema(metaSchema);\n// eslint-disable-next-line no-underscore-dangle\najv._opts.defaultMeta = metaSchema.id;\n\nmodule.exports = ajv;\n","/**\n * @fileoverview Defines a schema for configs.\n * @author Sylvan Mably\n */\n\n\n\nconst baseConfigProperties = {\n    env: { type: \"object\" },\n    globals: { type: \"object\" },\n    parser: { type: [\"string\", \"null\"] },\n    parserOptions: { type: \"object\" },\n    plugins: { type: \"array\" },\n    rules: { type: \"object\" },\n    settings: { type: \"object\" },\n\n    ecmaFeatures: { type: \"object\" } // deprecated; logs a warning when used\n};\n\nconst overrideProperties = Object.assign(\n    {},\n    baseConfigProperties,\n    {\n        files: {\n            oneOf: [\n                { type: \"string\" },\n                {\n                    type: \"array\",\n                    items: { type: \"string\" },\n                    minItems: 1\n                }\n            ]\n        },\n        excludedFiles: {\n            oneOf: [\n                { type: \"string\" },\n                {\n                    type: \"array\",\n                    items: { type: \"string\" }\n                }\n            ]\n        }\n    }\n);\n\nconst topLevelConfigProperties = Object.assign(\n    {},\n    baseConfigProperties,\n    {\n        extends: { type: [\"string\", \"array\"] },\n        root: { type: \"boolean\" },\n        overrides: {\n            type: \"array\",\n            items: {\n                type: \"object\",\n                properties: overrideProperties,\n                required: [\"files\"],\n                additionalProperties: false\n            }\n        }\n    }\n);\n\nconst configSchema = {\n    type: \"object\",\n    properties: topLevelConfigProperties,\n    additionalProperties: false\n};\n\nmodule.exports = configSchema;\n","/**\n * @fileoverview Environments manager\n * @author Nicholas C. Zakas\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst envs = require(\"../../conf/environments\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nclass Environments {\n\n    /**\n     * create env context\n     */\n    constructor() {\n        this._environments = new Map();\n\n        this.load();\n    }\n\n    /**\n     * Loads the default environments.\n     * @returns {void}\n     * @private\n     */\n    load() {\n        Object.keys(envs).forEach(envName => {\n            this._environments.set(envName, envs[envName]);\n        });\n    }\n\n    /**\n     * Gets the environment with the given name.\n     * @param {string} name The name of the environment to retrieve.\n     * @returns {Object?} The environment object or null if not found.\n     */\n    get(name) {\n        return this._environments.get(name) || null;\n    }\n\n    /**\n     * Gets all the environment present\n     * @returns {Object} The environment object for each env name\n     */\n    getAll() {\n        return Array.from(this._environments).reduce((coll, env) => {\n            coll[env[0]] = env[1];\n            return coll;\n        }, {});\n    }\n\n    /**\n     * Defines an environment.\n     * @param {string} name The name of the environment.\n     * @param {Object} env The environment settings.\n     * @returns {void}\n     */\n    define(name, env) {\n        this._environments.set(name, env);\n    }\n\n    /**\n     * Imports all environments from a plugin.\n     * @param {Object} plugin The plugin object.\n     * @param {string} pluginName The name of the plugin.\n     * @returns {void}\n     */\n    importPlugin(plugin, pluginName) {\n        if (plugin.environments) {\n            Object.keys(plugin.environments).forEach(envName => {\n                this.define(`${pluginName}/${envName}`, plugin.environments[envName]);\n            });\n        }\n    }\n}\n\nmodule.exports = Environments;\n","/**\n * @fileoverview Defines environment settings and globals.\n * @author Elan Shanker\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst globals = require(\"globals\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    builtin: {\n        globals: globals.es5\n    },\n    browser: {\n        globals: globals.browser\n    },\n    node: {\n        globals: globals.node,\n        parserOptions: {\n            ecmaFeatures: {\n                globalReturn: true\n            }\n        }\n    },\n    commonjs: {\n        globals: globals.commonjs,\n        parserOptions: {\n            ecmaFeatures: {\n                globalReturn: true\n            }\n        }\n    },\n    \"shared-node-browser\": {\n        globals: globals[\"shared-node-browser\"]\n    },\n    worker: {\n        globals: globals.worker\n    },\n    amd: {\n        globals: globals.amd\n    },\n    mocha: {\n        globals: globals.mocha\n    },\n    jasmine: {\n        globals: globals.jasmine\n    },\n    jest: {\n        globals: globals.jest\n    },\n    phantomjs: {\n        globals: globals.phantomjs\n    },\n    jquery: {\n        globals: globals.jquery\n    },\n    qunit: {\n        globals: globals.qunit\n    },\n    prototypejs: {\n        globals: globals.prototypejs\n    },\n    shelljs: {\n        globals: globals.shelljs\n    },\n    meteor: {\n        globals: globals.meteor\n    },\n    mongo: {\n        globals: globals.mongo\n    },\n    protractor: {\n        globals: globals.protractor\n    },\n    applescript: {\n        globals: globals.applescript\n    },\n    nashorn: {\n        globals: globals.nashorn\n    },\n    serviceworker: {\n        globals: globals.serviceworker\n    },\n    atomtest: {\n        globals: globals.atomtest\n    },\n    embertest: {\n        globals: globals.embertest\n    },\n    webextensions: {\n        globals: globals.webextensions\n    },\n    es6: {\n        globals: globals.es2015,\n        parserOptions: {\n            ecmaVersion: 6\n        }\n    },\n    greasemonkey: {\n        globals: globals.greasemonkey\n    }\n};\n","/**\n * @fileoverview A module that filters reported problems based on `eslint-disable` and `eslint-enable` comments\n * @author Teddy Katz\n */\n\n\n\nconst lodash = require(\"lodash\");\n\n/**\n * Compares the locations of two objects in a source file\n * @param {{line: number, column: number}} itemA The first object\n * @param {{line: number, column: number}} itemB The second object\n * @returns {number} A value less than 1 if itemA appears before itemB in the source file, greater than 1 if\n * itemA appears after itemB in the source file, or 0 if itemA and itemB have the same location.\n */\nfunction compareLocations(itemA, itemB) {\n    return itemA.line - itemB.line || itemA.column - itemB.column;\n}\n\n/**\n * This is the same as the exported function, except that it\n * doesn't handle disable-line and disable-next-line directives, and it always reports unused\n * disable directives.\n * @param {Object} options options for applying directives. This is the same as the options\n * for the exported function, except that `reportUnusedDisableDirectives` is not supported\n * (this function always reports unused disable directives).\n * @returns {{problems: Problem[], unusedDisableDirectives: Problem[]}} An object with a list\n * of filtered problems and unused eslint-disable directives\n */\nfunction applyDirectives(options) {\n    const problems = [];\n    let nextDirectiveIndex = 0;\n    let currentGlobalDisableDirective = null;\n    const disabledRuleMap = new Map();\n\n    // enabledRules is only used when there is a current global disable directive.\n    const enabledRules = new Set();\n    const usedDisableDirectives = new Set();\n\n    for (const problem of options.problems) {\n        while (\n            nextDirectiveIndex < options.directives.length &&\n            compareLocations(options.directives[nextDirectiveIndex], problem) <= 0\n        ) {\n            const directive = options.directives[nextDirectiveIndex++];\n\n            switch (directive.type) {\n                case \"disable\":\n                    if (directive.ruleId === null) {\n                        currentGlobalDisableDirective = directive;\n                        disabledRuleMap.clear();\n                        enabledRules.clear();\n                    } else if (currentGlobalDisableDirective) {\n                        enabledRules.delete(directive.ruleId);\n                        disabledRuleMap.set(directive.ruleId, directive);\n                    } else {\n                        disabledRuleMap.set(directive.ruleId, directive);\n                    }\n                    break;\n\n                case \"enable\":\n                    if (directive.ruleId === null) {\n                        currentGlobalDisableDirective = null;\n                        disabledRuleMap.clear();\n                    } else if (currentGlobalDisableDirective) {\n                        enabledRules.add(directive.ruleId);\n                        disabledRuleMap.delete(directive.ruleId);\n                    } else {\n                        disabledRuleMap.delete(directive.ruleId);\n                    }\n                    break;\n\n                // no default\n            }\n        }\n\n        if (disabledRuleMap.has(problem.ruleId)) {\n            usedDisableDirectives.add(disabledRuleMap.get(problem.ruleId));\n        } else if (currentGlobalDisableDirective && !enabledRules.has(problem.ruleId)) {\n            usedDisableDirectives.add(currentGlobalDisableDirective);\n        } else {\n            problems.push(problem);\n        }\n    }\n\n    const unusedDisableDirectives = options.directives\n        .filter(directive => directive.type === \"disable\" && !usedDisableDirectives.has(directive))\n        .map(directive => ({\n            ruleId: null,\n            message: directive.ruleId\n                ? `Unused eslint-disable directive (no problems were reported from '${directive.ruleId}').`\n                : \"Unused eslint-disable directive (no problems were reported).\",\n            line: directive.unprocessedDirective.line,\n            column: directive.unprocessedDirective.column,\n            severity: 2,\n            nodeType: null\n        }));\n\n    return { problems, unusedDisableDirectives };\n}\n\n/**\n * Given a list of directive comments (i.e. metadata about eslint-disable and eslint-enable comments) and a list\n * of reported problems, determines which problems should be reported.\n * @param {Object} options Information about directives and problems\n * @param {{\n *      type: (\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\"),\n *      ruleId: (string|null),\n *      line: number,\n *      column: number\n * }} options.directives Directive comments found in the file, with one-based columns.\n * Two directive comments can only have the same location if they also have the same type (e.g. a single eslint-disable\n * comment for two different rules is represented as two directives).\n * @param {{ruleId: (string|null), line: number, column: number}[]} options.problems\n * A list of problems reported by rules, sorted by increasing location in the file, with one-based columns.\n * @param {boolean} options.reportUnusedDisableDirectives If `true`, adds additional problems for unused directives\n * @returns {{ruleId: (string|null), line: number, column: number}[]}\n * A list of reported problems that were not disabled by the directive comments.\n */\nmodule.exports = options => {\n    const blockDirectives = options.directives\n        .filter(directive => directive.type === \"disable\" || directive.type === \"enable\")\n        .map(directive => Object.assign({}, directive, { unprocessedDirective: directive }))\n        .sort(compareLocations);\n\n    const lineDirectives = lodash.flatMap(options.directives, directive => {\n        switch (directive.type) {\n            case \"disable\":\n            case \"enable\":\n                return [];\n\n            case \"disable-line\":\n                return [\n                    { type: \"disable\", line: directive.line, column: 1, ruleId: directive.ruleId, unprocessedDirective: directive },\n                    { type: \"enable\", line: directive.line + 1, column: 0, ruleId: directive.ruleId, unprocessedDirective: directive }\n                ];\n\n            case \"disable-next-line\":\n                return [\n                    { type: \"disable\", line: directive.line + 1, column: 1, ruleId: directive.ruleId, unprocessedDirective: directive },\n                    { type: \"enable\", line: directive.line + 2, column: 0, ruleId: directive.ruleId, unprocessedDirective: directive }\n                ];\n\n            default:\n                throw new TypeError(`Unrecognized directive type '${directive.type}'`);\n        }\n    }).sort(compareLocations);\n\n    const blockDirectivesResult = applyDirectives({ problems: options.problems, directives: blockDirectives });\n    const lineDirectivesResult = applyDirectives({ problems: blockDirectivesResult.problems, directives: lineDirectives });\n\n    return options.reportUnusedDisableDirectives\n        ? lineDirectivesResult.problems\n            .concat(blockDirectivesResult.unusedDisableDirectives)\n            .concat(lineDirectivesResult.unusedDisableDirectives)\n            .sort(compareLocations)\n        : lineDirectivesResult.problems;\n};\n","/**\n * @fileoverview A variant of EventEmitter which does not give listeners information about each other\n * @author Teddy Katz\n */\n\n\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An event emitter\n * @typedef {Object} SafeEmitter\n * @property {function(eventName: string, listenerFunc: Function): void} on Adds a listener for a given event name\n * @property {function(eventName: string, arg1?: any, arg2?: any, arg3?: any)} emit Emits an event with a given name.\n * This calls all the listeners that were listening for that name, with `arg1`, `arg2`, and `arg3` as arguments.\n * @property {function(): string[]} eventNames Gets the list of event names that have registered listeners.\n */\n\n/**\n * Creates an object which can listen for and emit events.\n * This is similar to the EventEmitter API in Node's standard library, but it has a few differences.\n * The goal is to allow multiple modules to attach arbitrary listeners to the same emitter, without\n * letting the modules know about each other at all.\n * 1. It has no special keys like `error` and `newListener`, which would allow modules to detect when\n * another module throws an error or registers a listener.\n * 2. It calls listener functions without any `this` value. (`EventEmitter` calls listeners with a\n * `this` value of the emitter instance, which would give listeners access to other listeners.)\n * @returns {SafeEmitter} An emitter\n */\nmodule.exports = () => {\n    const listeners = Object.create(null);\n\n    return Object.freeze({\n        on(eventName, listener) {\n            if (eventName in listeners) {\n                listeners[eventName].push(listener);\n            } else {\n                listeners[eventName] = [listener];\n            }\n        },\n        emit(eventName, ...args) {\n            if (eventName in listeners) {\n                listeners[eventName].forEach(listener => listener(...args));\n            }\n        },\n        eventNames() {\n            return Object.keys(listeners);\n        }\n    });\n};\n","/**\n * @fileoverview The event generator for AST nodes.\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst esquery = require(\"esquery\");\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An object describing an AST selector\n * @typedef {Object} ASTSelector\n * @property {string} rawSelector The string that was parsed into this selector\n * @property {boolean} isExit `true` if this should be emitted when exiting the node rather than when entering\n * @property {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector\n * @property {string[]|null} listenerTypes A list of node types that could possibly cause the selector to match,\n * or `null` if all node types could cause a match\n * @property {number} attributeCount The total number of classes, pseudo-classes, and attribute queries in this selector\n * @property {number} identifierCount The total number of identifier queries in this selector\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the possible types of a selector\n * @param {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector\n * @returns {string[]|null} The node types that could possibly trigger this selector, or `null` if all node types could trigger it\n */\nfunction getPossibleTypes(parsedSelector) {\n    switch (parsedSelector.type) {\n        case \"identifier\":\n            return [parsedSelector.value];\n\n        case \"matches\": {\n            const typesForComponents = parsedSelector.selectors.map(getPossibleTypes);\n\n            if (typesForComponents.every(Boolean)) {\n                return lodash.union(...typesForComponents);\n            }\n            return null;\n        }\n\n        case \"compound\": {\n            const typesForComponents = parsedSelector.selectors.map(getPossibleTypes).filter(typesForComponent => typesForComponent);\n\n            // If all of the components could match any type, then the compound could also match any type.\n            if (!typesForComponents.length) {\n                return null;\n            }\n\n            /*\n             * If at least one of the components could only match a particular type, the compound could only match\n             * the intersection of those types.\n             */\n            return lodash.intersection(...typesForComponents);\n        }\n\n        case \"child\":\n        case \"descendant\":\n        case \"sibling\":\n        case \"adjacent\":\n            return getPossibleTypes(parsedSelector.right);\n\n        default:\n            return null;\n\n    }\n}\n\n/**\n * Counts the number of class, pseudo-class, and attribute queries in this selector\n * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior\n * @returns {number} The number of class, pseudo-class, and attribute queries in this selector\n */\nfunction countClassAttributes(parsedSelector) {\n    switch (parsedSelector.type) {\n        case \"child\":\n        case \"descendant\":\n        case \"sibling\":\n        case \"adjacent\":\n            return countClassAttributes(parsedSelector.left) + countClassAttributes(parsedSelector.right);\n\n        case \"compound\":\n        case \"not\":\n        case \"matches\":\n            return parsedSelector.selectors.reduce((sum, childSelector) => sum + countClassAttributes(childSelector), 0);\n\n        case \"attribute\":\n        case \"field\":\n        case \"nth-child\":\n        case \"nth-last-child\":\n            return 1;\n\n        default:\n            return 0;\n    }\n}\n\n/**\n * Counts the number of identifier queries in this selector\n * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior\n * @returns {number} The number of identifier queries\n */\nfunction countIdentifiers(parsedSelector) {\n    switch (parsedSelector.type) {\n        case \"child\":\n        case \"descendant\":\n        case \"sibling\":\n        case \"adjacent\":\n            return countIdentifiers(parsedSelector.left) + countIdentifiers(parsedSelector.right);\n\n        case \"compound\":\n        case \"not\":\n        case \"matches\":\n            return parsedSelector.selectors.reduce((sum, childSelector) => sum + countIdentifiers(childSelector), 0);\n\n        case \"identifier\":\n            return 1;\n\n        default:\n            return 0;\n    }\n}\n\n/**\n * Compares the specificity of two selector objects, with CSS-like rules.\n * @param {ASTSelector} selectorA An AST selector descriptor\n * @param {ASTSelector} selectorB Another AST selector descriptor\n * @returns {number}\n * a value less than 0 if selectorA is less specific than selectorB\n * a value greater than 0 if selectorA is more specific than selectorB\n * a value less than 0 if selectorA and selectorB have the same specificity, and selectorA <= selectorB alphabetically\n * a value greater than 0 if selectorA and selectorB have the same specificity, and selectorA > selectorB alphabetically\n */\nfunction compareSpecificity(selectorA, selectorB) {\n    return selectorA.attributeCount - selectorB.attributeCount ||\n        selectorA.identifierCount - selectorB.identifierCount ||\n        (selectorA.rawSelector <= selectorB.rawSelector ? -1 : 1);\n}\n\n/**\n * Parses a raw selector string, and throws a useful error if parsing fails.\n * @param {string} rawSelector A raw AST selector\n * @returns {Object} An object (from esquery) describing the matching behavior of this selector\n * @throws {Error} An error if the selector is invalid\n */\nfunction tryParseSelector(rawSelector) {\n    try {\n        return esquery.parse(rawSelector.replace(/:exit$/u, \"\"));\n    } catch (err) {\n        if (typeof err.offset === \"number\") {\n            throw new SyntaxError(`Syntax error in selector \"${rawSelector}\" at position ${err.offset}: ${err.message}`);\n        }\n        throw err;\n    }\n}\n\n/**\n * Parses a raw selector string, and returns the parsed selector along with specificity and type information.\n * @param {string} rawSelector A raw AST selector\n * @returns {ASTSelector} A selector descriptor\n */\nconst parseSelector = lodash.memoize(rawSelector => {\n    const parsedSelector = tryParseSelector(rawSelector);\n\n    return {\n        rawSelector,\n        isExit: rawSelector.endsWith(\":exit\"),\n        parsedSelector,\n        listenerTypes: getPossibleTypes(parsedSelector),\n        attributeCount: countClassAttributes(parsedSelector),\n        identifierCount: countIdentifiers(parsedSelector)\n    };\n});\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The event generator for AST nodes.\n * This implements below interface.\n *\n * ```ts\n * interface EventGenerator {\n *     emitter: SafeEmitter;\n *     enterNode(node: ASTNode): void;\n *     leaveNode(node: ASTNode): void;\n * }\n * ```\n */\nclass NodeEventGenerator {\n\n    /**\n     * @param {SafeEmitter} emitter\n     * An SafeEmitter which is the destination of events. This emitter must already\n     * have registered listeners for all of the events that it needs to listen for.\n     * (See lib/util/safe-emitter.js for more details on `SafeEmitter`.)\n     * @returns {NodeEventGenerator} new instance\n     */\n    constructor(emitter) {\n        this.emitter = emitter;\n        this.currentAncestry = [];\n        this.enterSelectorsByNodeType = new Map();\n        this.exitSelectorsByNodeType = new Map();\n        this.anyTypeEnterSelectors = [];\n        this.anyTypeExitSelectors = [];\n\n        emitter.eventNames().forEach(rawSelector => {\n            const selector = parseSelector(rawSelector);\n\n            if (selector.listenerTypes) {\n                selector.listenerTypes.forEach(nodeType => {\n                    const typeMap = selector.isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType;\n\n                    if (!typeMap.has(nodeType)) {\n                        typeMap.set(nodeType, []);\n                    }\n                    typeMap.get(nodeType).push(selector);\n                });\n            } else {\n                (selector.isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors).push(selector);\n            }\n        });\n\n        this.anyTypeEnterSelectors.sort(compareSpecificity);\n        this.anyTypeExitSelectors.sort(compareSpecificity);\n        this.enterSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\n        this.exitSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\n    }\n\n    /**\n     * Checks a selector against a node, and emits it if it matches\n     * @param {ASTNode} node The node to check\n     * @param {ASTSelector} selector An AST selector descriptor\n     * @returns {void}\n     */\n    applySelector(node, selector) {\n        if (esquery.matches(node, selector.parsedSelector, this.currentAncestry)) {\n            this.emitter.emit(selector.rawSelector, node);\n        }\n    }\n\n    /**\n     * Applies all appropriate selectors to a node, in specificity order\n     * @param {ASTNode} node The node to check\n     * @param {boolean} isExit `false` if the node is currently being entered, `true` if it's currently being exited\n     * @returns {void}\n     */\n    applySelectors(node, isExit) {\n        const selectorsByNodeType = (isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(node.type) || [];\n        const anyTypeSelectors = isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;\n\n        /*\n         * selectorsByNodeType and anyTypeSelectors were already sorted by specificity in the constructor.\n         * Iterate through each of them, applying selectors in the right order.\n         */\n        let selectorsByTypeIndex = 0;\n        let anyTypeSelectorsIndex = 0;\n\n        while (selectorsByTypeIndex < selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length) {\n            if (\n                selectorsByTypeIndex >= selectorsByNodeType.length ||\n                anyTypeSelectorsIndex < anyTypeSelectors.length &&\n                compareSpecificity(anyTypeSelectors[anyTypeSelectorsIndex], selectorsByNodeType[selectorsByTypeIndex]) < 0\n            ) {\n                this.applySelector(node, anyTypeSelectors[anyTypeSelectorsIndex++]);\n            } else {\n                this.applySelector(node, selectorsByNodeType[selectorsByTypeIndex++]);\n            }\n        }\n    }\n\n    /**\n     * Emits an event of entering AST node.\n     * @param {ASTNode} node - A node which was entered.\n     * @returns {void}\n     */\n    enterNode(node) {\n        if (node.parent) {\n            this.currentAncestry.unshift(node.parent);\n        }\n        this.applySelectors(node, false);\n    }\n\n    /**\n     * Emits an event of leaving AST node.\n     * @param {ASTNode} node - A node which was left.\n     * @returns {void}\n     */\n    leaveNode(node) {\n        this.applySelectors(node, true);\n        this.currentAncestry.shift();\n    }\n}\n\nmodule.exports = NodeEventGenerator;\n","/**\n * @fileoverview Abstraction of JavaScript source code.\n * @author Nicholas C. Zakas\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst TokenStore = require(\"../token-store\"),\n    Traverser = require(\"./traverser\"),\n    astUtils = require(\"../util/ast-utils\"),\n    lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\n * Validates that the given AST has the required information.\n * @param {ASTNode} ast The Program node of the AST to check.\n * @throws {Error} If the AST doesn't contain the correct information.\n * @returns {void}\n * @private\n */\nfunction validate(ast) {\n    if (!ast.tokens) {\n        throw new Error(\"AST is missing the tokens array.\");\n    }\n\n    if (!ast.comments) {\n        throw new Error(\"AST is missing the comments array.\");\n    }\n\n    if (!ast.loc) {\n        throw new Error(\"AST is missing location information.\");\n    }\n\n    if (!ast.range) {\n        throw new Error(\"AST is missing range information\");\n    }\n}\n\n/**\n * Check to see if its a ES6 export declaration.\n * @param {ASTNode} astNode An AST node.\n * @returns {boolean} whether the given node represents an export declaration.\n * @private\n */\nfunction looksLikeExport(astNode) {\n    return astNode.type === \"ExportDefaultDeclaration\" || astNode.type === \"ExportNamedDeclaration\" ||\n        astNode.type === \"ExportAllDeclaration\" || astNode.type === \"ExportSpecifier\";\n}\n\n/**\n * Merges two sorted lists into a larger sorted list in O(n) time.\n * @param {Token[]} tokens The list of tokens.\n * @param {Token[]} comments The list of comments.\n * @returns {Token[]} A sorted list of tokens and comments.\n * @private\n */\nfunction sortedMerge(tokens, comments) {\n    const result = [];\n    let tokenIndex = 0;\n    let commentIndex = 0;\n\n    while (tokenIndex < tokens.length || commentIndex < comments.length) {\n        if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) {\n            result.push(tokens[tokenIndex++]);\n        } else {\n            result.push(comments[commentIndex++]);\n        }\n    }\n\n    return result;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nclass SourceCode extends TokenStore {\n\n    /**\n     * Represents parsed source code.\n     * @param {string|Object} textOrConfig - The source code text or config object.\n     * @param {string} textOrConfig.text - The source code text.\n     * @param {ASTNode} textOrConfig.ast - The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n     * @param {Object|null} textOrConfig.parserServices - The parser services.\n     * @param {ScopeManager|null} textOrConfig.scopeManager - The scope of this source code.\n     * @param {Object|null} textOrConfig.visitorKeys - The visitor keys to traverse AST.\n     * @param {ASTNode} [astIfNoConfig] - The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n     * @constructor\n     */\n    constructor(textOrConfig, astIfNoConfig) {\n        let text, ast, parserServices, scopeManager, visitorKeys;\n\n        // Process overloading.\n        if (typeof textOrConfig === \"string\") {\n            text = textOrConfig;\n            ast = astIfNoConfig;\n        } else if (typeof textOrConfig === \"object\" && textOrConfig !== null) {\n            text = textOrConfig.text;\n            ast = textOrConfig.ast;\n            parserServices = textOrConfig.parserServices;\n            scopeManager = textOrConfig.scopeManager;\n            visitorKeys = textOrConfig.visitorKeys;\n        }\n\n        validate(ast);\n        super(ast.tokens, ast.comments);\n\n        /**\n         * The flag to indicate that the source code has Unicode BOM.\n         * @type boolean\n         */\n        this.hasBOM = (text.charCodeAt(0) === 0xFEFF);\n\n        /**\n         * The original text source code.\n         * BOM was stripped from this text.\n         * @type string\n         */\n        this.text = (this.hasBOM ? text.slice(1) : text);\n\n        /**\n         * The parsed AST for the source code.\n         * @type ASTNode\n         */\n        this.ast = ast;\n\n        /**\n         * The parser services of this source code.\n         * @type {Object}\n         */\n        this.parserServices = parserServices || {};\n\n        /**\n         * The scope of this source code.\n         * @type {ScopeManager|null}\n         */\n        this.scopeManager = scopeManager || null;\n\n        /**\n         * The visitor keys to traverse AST.\n         * @type {Object}\n         */\n        this.visitorKeys = visitorKeys || Traverser.DEFAULT_VISITOR_KEYS;\n\n        // Check the source text for the presence of a shebang since it is parsed as a standard line comment.\n        const shebangMatched = this.text.match(astUtils.SHEBANG_MATCHER);\n        const hasShebang = shebangMatched && ast.comments.length && ast.comments[0].value === shebangMatched[1];\n\n        if (hasShebang) {\n            ast.comments[0].type = \"Shebang\";\n        }\n\n        this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);\n\n        /**\n         * The source code split into lines according to ECMA-262 specification.\n         * This is done to avoid each rule needing to do so separately.\n         * @type string[]\n         */\n        this.lines = [];\n        this.lineStartIndices = [0];\n\n        const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();\n        let match;\n\n        /*\n         * Previously, this was implemented using a regex that\n         * matched a sequence of non-linebreak characters followed by a\n         * linebreak, then adding the lengths of the matches. However,\n         * this caused a catastrophic backtracking issue when the end\n         * of a file contained a large number of non-newline characters.\n         * To avoid this, the current implementation just matches newlines\n         * and uses match.index to get the correct line start indices.\n         */\n        while ((match = lineEndingPattern.exec(this.text))) {\n            this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));\n            this.lineStartIndices.push(match.index + match[0].length);\n        }\n        this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));\n\n        // Cache for comments found using getComments().\n        this._commentCache = new WeakMap();\n\n        // don't allow modification of this object\n        Object.freeze(this);\n        Object.freeze(this.lines);\n    }\n\n    /**\n     * Split the source code into multiple lines based on the line delimiters.\n     * @param {string} text Source code as a string.\n     * @returns {string[]} Array of source code lines.\n     * @public\n     */\n    static splitLines(text) {\n        return text.split(astUtils.createGlobalLinebreakMatcher());\n    }\n\n    /**\n     * Gets the source code for the given node.\n     * @param {ASTNode=} node The AST node to get the text for.\n     * @param {int=} beforeCount The number of characters before the node to retrieve.\n     * @param {int=} afterCount The number of characters after the node to retrieve.\n     * @returns {string} The text representing the AST node.\n     * @public\n     */\n    getText(node, beforeCount, afterCount) {\n        if (node) {\n            return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0),\n                node.range[1] + (afterCount || 0));\n        }\n        return this.text;\n    }\n\n    /**\n     * Gets the entire source text split into an array of lines.\n     * @returns {Array} The source text as an array of lines.\n     * @public\n     */\n    getLines() {\n        return this.lines;\n    }\n\n    /**\n     * Retrieves an array containing all comments in the source code.\n     * @returns {ASTNode[]} An array of comment nodes.\n     * @public\n     */\n    getAllComments() {\n        return this.ast.comments;\n    }\n\n    /**\n     * Gets all comments for the given node.\n     * @param {ASTNode} node The AST node to get the comments for.\n     * @returns {Object} An object containing a leading and trailing array\n     *      of comments indexed by their position.\n     * @public\n     */\n    getComments(node) {\n        if (this._commentCache.has(node)) {\n            return this._commentCache.get(node);\n        }\n\n        const comments = {\n            leading: [],\n            trailing: []\n        };\n\n        /*\n         * Return all comments as leading comments of the Program node when\n         * there is no executable code.\n         */\n        if (node.type === \"Program\") {\n            if (node.body.length === 0) {\n                comments.leading = node.comments;\n            }\n        } else {\n\n            /*\n             * Return comments as trailing comments of nodes that only contain\n             * comments (to mimic the comment attachment behavior present in Espree).\n             */\n            if ((node.type === \"BlockStatement\" || node.type === \"ClassBody\") && node.body.length === 0 ||\n                node.type === \"ObjectExpression\" && node.properties.length === 0 ||\n                node.type === \"ArrayExpression\" && node.elements.length === 0 ||\n                node.type === \"SwitchStatement\" && node.cases.length === 0\n            ) {\n                comments.trailing = this.getTokens(node, {\n                    includeComments: true,\n                    filter: astUtils.isCommentToken\n                });\n            }\n\n            /*\n             * Iterate over tokens before and after node and collect comment tokens.\n             * Do not include comments that exist outside of the parent node\n             * to avoid duplication.\n             */\n            let currentToken = this.getTokenBefore(node, { includeComments: true });\n\n            while (currentToken && astUtils.isCommentToken(currentToken)) {\n                if (node.parent && (currentToken.start < node.parent.start)) {\n                    break;\n                }\n                comments.leading.push(currentToken);\n                currentToken = this.getTokenBefore(currentToken, { includeComments: true });\n            }\n\n            comments.leading.reverse();\n\n            currentToken = this.getTokenAfter(node, { includeComments: true });\n\n            while (currentToken && astUtils.isCommentToken(currentToken)) {\n                if (node.parent && (currentToken.end > node.parent.end)) {\n                    break;\n                }\n                comments.trailing.push(currentToken);\n                currentToken = this.getTokenAfter(currentToken, { includeComments: true });\n            }\n        }\n\n        this._commentCache.set(node, comments);\n        return comments;\n    }\n\n    /**\n     * Retrieves the JSDoc comment for a given node.\n     * @param {ASTNode} node The AST node to get the comment for.\n     * @returns {Token|null} The Block comment token containing the JSDoc comment\n     *      for the given node or null if not found.\n     * @public\n     * @deprecated\n     */\n    getJSDocComment(node) {\n\n        /**\n         * Checks for the presence of a JSDoc comment for the given node and returns it.\n         * @param {ASTNode} astNode The AST node to get the comment for.\n         * @returns {Token|null} The Block comment token containing the JSDoc comment\n         *      for the given node or null if not found.\n         * @private\n         */\n        const findJSDocComment = astNode => {\n            const tokenBefore = this.getTokenBefore(astNode, { includeComments: true });\n\n            if (\n                tokenBefore &&\n                astUtils.isCommentToken(tokenBefore) &&\n                tokenBefore.type === \"Block\" &&\n                tokenBefore.value.charAt(0) === \"*\" &&\n                astNode.loc.start.line - tokenBefore.loc.end.line <= 1\n            ) {\n                return tokenBefore;\n            }\n\n            return null;\n        };\n        let parent = node.parent;\n\n        switch (node.type) {\n            case \"ClassDeclaration\":\n            case \"FunctionDeclaration\":\n                return findJSDocComment(looksLikeExport(parent) ? parent : node);\n\n            case \"ClassExpression\":\n                return findJSDocComment(parent.parent);\n\n            case \"ArrowFunctionExpression\":\n            case \"FunctionExpression\":\n                if (parent.type !== \"CallExpression\" && parent.type !== \"NewExpression\") {\n                    while (\n                        !this.getCommentsBefore(parent).length &&\n                        !/Function/u.test(parent.type) &&\n                        parent.type !== \"MethodDefinition\" &&\n                        parent.type !== \"Property\"\n                    ) {\n                        parent = parent.parent;\n\n                        if (!parent) {\n                            break;\n                        }\n                    }\n\n                    if (parent && parent.type !== \"FunctionDeclaration\" && parent.type !== \"Program\") {\n                        return findJSDocComment(parent);\n                    }\n                }\n\n                return findJSDocComment(node);\n\n            // falls through\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * Gets the deepest node containing a range index.\n     * @param {int} index Range index of the desired node.\n     * @returns {ASTNode} The node if found or null if not found.\n     * @public\n     */\n    getNodeByRangeIndex(index) {\n        let result = null;\n\n        Traverser.traverse(this.ast, {\n            visitorKeys: this.visitorKeys,\n            enter(node) {\n                if (node.range[0] <= index && index < node.range[1]) {\n                    result = node;\n                } else {\n                    this.skip();\n                }\n            },\n            leave(node) {\n                if (node === result) {\n                    this.break();\n                }\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Determines if two tokens have at least one whitespace character\n     * between them. This completely disregards comments in making the\n     * determination, so comments count as zero-length substrings.\n     * @param {Token} first The token to check after.\n     * @param {Token} second The token to check before.\n     * @returns {boolean} True if there is only space between tokens, false\n     *  if there is anything other than whitespace between tokens.\n     * @public\n     */\n    isSpaceBetweenTokens(first, second) {\n        const text = this.text.slice(first.range[1], second.range[0]);\n\n        return /\\s/u.test(text.replace(/\\/\\*.*?\\*\\//gu, \"\"));\n    }\n\n    /**\n     * Converts a source text index into a (line, column) pair.\n     * @param {number} index The index of a character in a file\n     * @returns {Object} A {line, column} location object with a 0-indexed column\n     * @public\n     */\n    getLocFromIndex(index) {\n        if (typeof index !== \"number\") {\n            throw new TypeError(\"Expected `index` to be a number.\");\n        }\n\n        if (index < 0 || index > this.text.length) {\n            throw new RangeError(`Index out of range (requested index ${index}, but source text has length ${this.text.length}).`);\n        }\n\n        /*\n         * For an argument of this.text.length, return the location one \"spot\" past the last character\n         * of the file. If the last character is a linebreak, the location will be column 0 of the next\n         * line; otherwise, the location will be in the next column on the same line.\n         *\n         * See getIndexFromLoc for the motivation for this special case.\n         */\n        if (index === this.text.length) {\n            return { line: this.lines.length, column: this.lines[this.lines.length - 1].length };\n        }\n\n        /*\n         * To figure out which line rangeIndex is on, determine the last index at which rangeIndex could\n         * be inserted into lineIndices to keep the list sorted.\n         */\n        const lineNumber = lodash.sortedLastIndex(this.lineStartIndices, index);\n\n        return { line: lineNumber, column: index - this.lineStartIndices[lineNumber - 1] };\n    }\n\n    /**\n     * Converts a (line, column) pair into a range index.\n     * @param {Object} loc A line/column location\n     * @param {number} loc.line The line number of the location (1-indexed)\n     * @param {number} loc.column The column number of the location (0-indexed)\n     * @returns {number} The range index of the location in the file.\n     * @public\n     */\n    getIndexFromLoc(loc) {\n        if (typeof loc !== \"object\" || typeof loc.line !== \"number\" || typeof loc.column !== \"number\") {\n            throw new TypeError(\"Expected `loc` to be an object with numeric `line` and `column` properties.\");\n        }\n\n        if (loc.line <= 0) {\n            throw new RangeError(`Line number out of range (line ${loc.line} requested). Line numbers should be 1-based.`);\n        }\n\n        if (loc.line > this.lineStartIndices.length) {\n            throw new RangeError(`Line number out of range (line ${loc.line} requested, but only ${this.lineStartIndices.length} lines present).`);\n        }\n\n        const lineStartIndex = this.lineStartIndices[loc.line - 1];\n        const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];\n        const positionIndex = lineStartIndex + loc.column;\n\n        /*\n         * By design, getIndexFromLoc({ line: lineNum, column: 0 }) should return the start index of\n         * the given line, provided that the line number is valid element of this.lines. Since the\n         * last element of this.lines is an empty string for files with trailing newlines, add a\n         * special case where getting the index for the first location after the end of the file\n         * will return the length of the file, rather than throwing an error. This allows rules to\n         * use getIndexFromLoc consistently without worrying about edge cases at the end of a file.\n         */\n        if (\n            loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex ||\n            loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex\n        ) {\n            throw new RangeError(`Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${lineEndIndex - lineStartIndex}).`);\n        }\n\n        return positionIndex;\n    }\n}\n\nmodule.exports = SourceCode;\n","/**\n * @fileoverview Object to handle access and retrieval of tokens.\n * @author Brandon Mills\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\nconst cursors = require(\"./cursors\");\nconst ForwardTokenCursor = require(\"./forward-token-cursor\");\nconst PaddedTokenCursor = require(\"./padded-token-cursor\");\nconst utils = require(\"./utils\");\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst TOKENS = Symbol(\"tokens\");\nconst COMMENTS = Symbol(\"comments\");\nconst INDEX_MAP = Symbol(\"indexMap\");\n\n/**\n * Creates the map from locations to indices in `tokens`.\n *\n * The first/last location of tokens is mapped to the index of the token.\n * The first/last location of comments is mapped to the index of the next token of each comment.\n *\n * @param {Token[]} tokens - The array of tokens.\n * @param {Comment[]} comments - The array of comments.\n * @returns {Object} The map from locations to indices in `tokens`.\n * @private\n */\nfunction createIndexMap(tokens, comments) {\n    const map = Object.create(null);\n    let tokenIndex = 0;\n    let commentIndex = 0;\n    let nextStart = 0;\n    let range = null;\n\n    while (tokenIndex < tokens.length || commentIndex < comments.length) {\n        nextStart = (commentIndex < comments.length) ? comments[commentIndex].range[0] : Number.MAX_SAFE_INTEGER;\n        while (tokenIndex < tokens.length && (range = tokens[tokenIndex].range)[0] < nextStart) {\n            map[range[0]] = tokenIndex;\n            map[range[1] - 1] = tokenIndex;\n            tokenIndex += 1;\n        }\n\n        nextStart = (tokenIndex < tokens.length) ? tokens[tokenIndex].range[0] : Number.MAX_SAFE_INTEGER;\n        while (commentIndex < comments.length && (range = comments[commentIndex].range)[0] < nextStart) {\n            map[range[0]] = tokenIndex;\n            map[range[1] - 1] = tokenIndex;\n            commentIndex += 1;\n        }\n    }\n\n    return map;\n}\n\n/**\n * Creates the cursor iterates tokens with options.\n *\n * @param {CursorFactory} factory - The cursor factory to initialize cursor.\n * @param {Token[]} tokens - The array of tokens.\n * @param {Comment[]} comments - The array of comments.\n * @param {Object} indexMap - The map from locations to indices in `tokens`.\n * @param {number} startLoc - The start location of the iteration range.\n * @param {number} endLoc - The end location of the iteration range.\n * @param {number|Function|Object} [opts=0] - The option object. If this is a number then it's `opts.skip`. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments=false] - The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] - The predicate function to choose tokens.\n * @param {number} [opts.skip=0] - The count of tokens the cursor skips.\n * @returns {Cursor} The created cursor.\n * @private\n */\nfunction createCursorWithSkip(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {\n    let includeComments = false;\n    let skip = 0;\n    let filter = null;\n\n    if (typeof opts === \"number\") {\n        skip = opts | 0;\n    } else if (typeof opts === \"function\") {\n        filter = opts;\n    } else if (opts) {\n        includeComments = !!opts.includeComments;\n        skip = opts.skip | 0;\n        filter = opts.filter || null;\n    }\n    assert(skip >= 0, \"options.skip should be zero or a positive integer.\");\n    assert(!filter || typeof filter === \"function\", \"options.filter should be a function.\");\n\n    return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, -1);\n}\n\n/**\n * Creates the cursor iterates tokens with options.\n *\n * @param {CursorFactory} factory - The cursor factory to initialize cursor.\n * @param {Token[]} tokens - The array of tokens.\n * @param {Comment[]} comments - The array of comments.\n * @param {Object} indexMap - The map from locations to indices in `tokens`.\n * @param {number} startLoc - The start location of the iteration range.\n * @param {number} endLoc - The end location of the iteration range.\n * @param {number|Function|Object} [opts=0] - The option object. If this is a number then it's `opts.count`. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments] - The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] - The predicate function to choose tokens.\n * @param {number} [opts.count=0] - The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n * @returns {Cursor} The created cursor.\n * @private\n */\nfunction createCursorWithCount(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {\n    let includeComments = false;\n    let count = 0;\n    let countExists = false;\n    let filter = null;\n\n    if (typeof opts === \"number\") {\n        count = opts | 0;\n        countExists = true;\n    } else if (typeof opts === \"function\") {\n        filter = opts;\n    } else if (opts) {\n        includeComments = !!opts.includeComments;\n        count = opts.count | 0;\n        countExists = typeof opts.count === \"number\";\n        filter = opts.filter || null;\n    }\n    assert(count >= 0, \"options.count should be zero or a positive integer.\");\n    assert(!filter || typeof filter === \"function\", \"options.filter should be a function.\");\n\n    return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, 0, countExists ? count : -1);\n}\n\n/**\n * Creates the cursor iterates tokens with options.\n * This is overload function of the below.\n *\n * @param {Token[]} tokens - The array of tokens.\n * @param {Comment[]} comments - The array of comments.\n * @param {Object} indexMap - The map from locations to indices in `tokens`.\n * @param {number} startLoc - The start location of the iteration range.\n * @param {number} endLoc - The end location of the iteration range.\n * @param {Function|Object} opts - The option object. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments] - The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] - The predicate function to choose tokens.\n * @param {number} [opts.count=0] - The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n * @returns {Cursor} The created cursor.\n * @private\n */\n/**\n * Creates the cursor iterates tokens with options.\n *\n * @param {Token[]} tokens - The array of tokens.\n * @param {Comment[]} comments - The array of comments.\n * @param {Object} indexMap - The map from locations to indices in `tokens`.\n * @param {number} startLoc - The start location of the iteration range.\n * @param {number} endLoc - The end location of the iteration range.\n * @param {number} [beforeCount=0] - The number of tokens before the node to retrieve.\n * @param {boolean} [afterCount=0] - The number of tokens after the node to retrieve.\n * @returns {Cursor} The created cursor.\n * @private\n */\nfunction createCursorWithPadding(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {\n    if (typeof beforeCount === \"undefined\" && typeof afterCount === \"undefined\") {\n        return new ForwardTokenCursor(tokens, comments, indexMap, startLoc, endLoc);\n    }\n    if (typeof beforeCount === \"number\" || typeof beforeCount === \"undefined\") {\n        return new PaddedTokenCursor(tokens, comments, indexMap, startLoc, endLoc, beforeCount | 0, afterCount | 0);\n    }\n    return createCursorWithCount(cursors.forward, tokens, comments, indexMap, startLoc, endLoc, beforeCount);\n}\n\n/**\n * Gets comment tokens that are adjacent to the current cursor position.\n * @param {Cursor} cursor - A cursor instance.\n * @returns {Array} An array of comment tokens adjacent to the current cursor position.\n * @private\n */\nfunction getAdjacentCommentTokensFromCursor(cursor) {\n    const tokens = [];\n    let currentToken = cursor.getOneToken();\n\n    while (currentToken && astUtils.isCommentToken(currentToken)) {\n        tokens.push(currentToken);\n        currentToken = cursor.getOneToken();\n    }\n\n    return tokens;\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The token store.\n *\n * This class provides methods to get tokens by locations as fast as possible.\n * The methods are a part of public API, so we should be careful if it changes this class.\n *\n * People can get tokens in O(1) by the hash map which is mapping from the location of tokens/comments to tokens.\n * Also people can get a mix of tokens and comments in O(log k), the k is the number of comments.\n * Assuming that comments to be much fewer than tokens, this does not make hash map from token's locations to comments to reduce memory cost.\n * This uses binary-searching instead for comments.\n */\nmodule.exports = class TokenStore {\n\n    /**\n     * Initializes this token store.\n     * @param {Token[]} tokens - The array of tokens.\n     * @param {Comment[]} comments - The array of comments.\n     */\n    constructor(tokens, comments) {\n        this[TOKENS] = tokens;\n        this[COMMENTS] = comments;\n        this[INDEX_MAP] = createIndexMap(tokens, comments);\n    }\n\n    //--------------------------------------------------------------------------\n    // Gets single token.\n    //--------------------------------------------------------------------------\n\n    /**\n     * Gets the token starting at the specified index.\n     * @param {number} offset - Index of the start of the token's range.\n     * @param {Object} [options=0] - The option object.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @returns {Token|null} The token starting at index, or null if no such token.\n     */\n    getTokenByRangeStart(offset, options) {\n        const includeComments = options && options.includeComments;\n        const token = cursors.forward.createBaseCursor(\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            offset,\n            -1,\n            includeComments\n        ).getOneToken();\n\n        if (token && token.range[0] === offset) {\n            return token;\n        }\n        return null;\n    }\n\n    /**\n     * Gets the first token of the given node.\n     * @param {ASTNode} node - The AST node.\n     * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.skip=0] - The count of tokens the cursor skips.\n     * @returns {Token|null} An object representing the token.\n     */\n    getFirstToken(node, options) {\n        return createCursorWithSkip(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the last token of the given node.\n     * @param {ASTNode} node - The AST node.\n     * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getLastToken(node, options) {\n        return createCursorWithSkip(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the token that precedes a given node or token.\n     * @param {ASTNode|Token|Comment} node - The AST node or token.\n     * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getTokenBefore(node, options) {\n        return createCursorWithSkip(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            -1,\n            node.range[0],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the token that follows a given node or token.\n     * @param {ASTNode|Token|Comment} node - The AST node or token.\n     * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getTokenAfter(node, options) {\n        return createCursorWithSkip(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[1],\n            -1,\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the first token between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left - Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right - Node after the desired token range.\n     * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getFirstTokenBetween(left, right, options) {\n        return createCursorWithSkip(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the last token between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getLastTokenBetween(left, right, options) {\n        return createCursorWithSkip(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the token that precedes a given node or token in the token stream.\n     * This is defined for backward compatibility. Use `includeComments` option instead.\n     * TODO: We have a plan to remove this in a future major version.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number} [skip=0] A number of tokens to skip.\n     * @returns {Token|null} An object representing the token.\n     * @deprecated\n     */\n    getTokenOrCommentBefore(node, skip) {\n        return this.getTokenBefore(node, { includeComments: true, skip });\n    }\n\n    /**\n     * Gets the token that follows a given node or token in the token stream.\n     * This is defined for backward compatibility. Use `includeComments` option instead.\n     * TODO: We have a plan to remove this in a future major version.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number} [skip=0] A number of tokens to skip.\n     * @returns {Token|null} An object representing the token.\n     * @deprecated\n     */\n    getTokenOrCommentAfter(node, skip) {\n        return this.getTokenAfter(node, { includeComments: true, skip });\n    }\n\n    //--------------------------------------------------------------------------\n    // Gets multiple tokens.\n    //--------------------------------------------------------------------------\n\n    /**\n     * Gets the first `count` tokens of the given node.\n     * @param {ASTNode} node - The AST node.\n     * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Tokens.\n     */\n    getFirstTokens(node, options) {\n        return createCursorWithCount(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            options\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets the last `count` tokens of the given node.\n     * @param {ASTNode} node - The AST node.\n     * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens.\n     */\n    getLastTokens(node, options) {\n        return createCursorWithCount(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            options\n        ).getAllTokens().reverse();\n    }\n\n    /**\n     * Gets the `count` tokens that precedes a given node or token.\n     * @param {ASTNode|Token|Comment} node - The AST node or token.\n     * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens.\n     */\n    getTokensBefore(node, options) {\n        return createCursorWithCount(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            -1,\n            node.range[0],\n            options\n        ).getAllTokens().reverse();\n    }\n\n    /**\n     * Gets the `count` tokens that follows a given node or token.\n     * @param {ASTNode|Token|Comment} node - The AST node or token.\n     * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens.\n     */\n    getTokensAfter(node, options) {\n        return createCursorWithCount(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[1],\n            -1,\n            options\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets the first `count` tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left - Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right - Node after the desired token range.\n     * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens between left and right.\n     */\n    getFirstTokensBetween(left, right, options) {\n        return createCursorWithCount(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            options\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets the last `count` tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens between left and right.\n     */\n    getLastTokensBetween(left, right, options) {\n        return createCursorWithCount(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            options\n        ).getAllTokens().reverse();\n    }\n\n    /**\n     * Gets all tokens that are related to the given node.\n     * @param {ASTNode} node - The AST node.\n     * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Array of objects representing tokens.\n     */\n    /**\n     * Gets all tokens that are related to the given node.\n     * @param {ASTNode} node - The AST node.\n     * @param {int} [beforeCount=0] - The number of tokens before the node to retrieve.\n     * @param {int} [afterCount=0] - The number of tokens after the node to retrieve.\n     * @returns {Token[]} Array of objects representing tokens.\n     */\n    getTokens(node, beforeCount, afterCount) {\n        return createCursorWithPadding(\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            beforeCount,\n            afterCount\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets all of the tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Tokens between left and right.\n     */\n    /**\n     * Gets all of the tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {int} [padding=0] Number of extra tokens on either side of center.\n     * @returns {Token[]} Tokens between left and right.\n     */\n    getTokensBetween(left, right, padding) {\n        return createCursorWithPadding(\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            padding,\n            padding\n        ).getAllTokens();\n    }\n\n    //--------------------------------------------------------------------------\n    // Others.\n    //--------------------------------------------------------------------------\n\n    /**\n     * Checks whether any comments exist or not between the given 2 nodes.\n     *\n     * @param {ASTNode} left - The node to check.\n     * @param {ASTNode} right - The node to check.\n     * @returns {boolean} `true` if one or more comments exist.\n     */\n    commentsExistBetween(left, right) {\n        const index = utils.search(this[COMMENTS], left.range[1]);\n\n        return (\n            index < this[COMMENTS].length &&\n            this[COMMENTS][index].range[1] <= right.range[0]\n        );\n    }\n\n    /**\n     * Gets all comment tokens directly before the given node or token.\n     * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.\n     * @returns {Array} An array of comments in occurrence order.\n     */\n    getCommentsBefore(nodeOrToken) {\n        const cursor = createCursorWithCount(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            -1,\n            nodeOrToken.range[0],\n            { includeComments: true }\n        );\n\n        return getAdjacentCommentTokensFromCursor(cursor).reverse();\n    }\n\n    /**\n     * Gets all comment tokens directly after the given node or token.\n     * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.\n     * @returns {Array} An array of comments in occurrence order.\n     */\n    getCommentsAfter(nodeOrToken) {\n        const cursor = createCursorWithCount(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            nodeOrToken.range[1],\n            -1,\n            { includeComments: true }\n        );\n\n        return getAdjacentCommentTokensFromCursor(cursor);\n    }\n\n    /**\n     * Gets all comment tokens inside the given node.\n     * @param {ASTNode} node The AST node to get the comments for.\n     * @returns {Array} An array of comments in occurrence order.\n     */\n    getCommentsInside(node) {\n        return this.getTokens(node, {\n            includeComments: true,\n            filter: astUtils.isCommentToken\n        });\n    }\n};\n","/**\n * @fileoverview Define 2 token factories; forward and backward.\n * @author Toru Nagashima\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst BackwardTokenCommentCursor = require(\"./backward-token-comment-cursor\");\nconst BackwardTokenCursor = require(\"./backward-token-cursor\");\nconst FilterCursor = require(\"./filter-cursor\");\nconst ForwardTokenCommentCursor = require(\"./forward-token-comment-cursor\");\nconst ForwardTokenCursor = require(\"./forward-token-cursor\");\nconst LimitCursor = require(\"./limit-cursor\");\nconst SkipCursor = require(\"./skip-cursor\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * The cursor factory.\n * @private\n */\nclass CursorFactory {\n\n    /**\n     * Initializes this cursor.\n     * @param {Function} TokenCursor - The class of the cursor which iterates tokens only.\n     * @param {Function} TokenCommentCursor - The class of the cursor which iterates the mix of tokens and comments.\n     */\n    constructor(TokenCursor, TokenCommentCursor) {\n        this.TokenCursor = TokenCursor;\n        this.TokenCommentCursor = TokenCommentCursor;\n    }\n\n    /**\n     * Creates a base cursor instance that can be decorated by createCursor.\n     *\n     * @param {Token[]} tokens - The array of tokens.\n     * @param {Comment[]} comments - The array of comments.\n     * @param {Object} indexMap - The map from locations to indices in `tokens`.\n     * @param {number} startLoc - The start location of the iteration range.\n     * @param {number} endLoc - The end location of the iteration range.\n     * @param {boolean} includeComments - The flag to iterate comments as well.\n     * @returns {Cursor} The created base cursor.\n     */\n    createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments) {\n        const Cursor = includeComments ? this.TokenCommentCursor : this.TokenCursor;\n\n        return new Cursor(tokens, comments, indexMap, startLoc, endLoc);\n    }\n\n    /**\n     * Creates a cursor that iterates tokens with normalized options.\n     *\n     * @param {Token[]} tokens - The array of tokens.\n     * @param {Comment[]} comments - The array of comments.\n     * @param {Object} indexMap - The map from locations to indices in `tokens`.\n     * @param {number} startLoc - The start location of the iteration range.\n     * @param {number} endLoc - The end location of the iteration range.\n     * @param {boolean} includeComments - The flag to iterate comments as well.\n     * @param {Function|null} filter - The predicate function to choose tokens.\n     * @param {number} skip - The count of tokens the cursor skips.\n     * @param {number} count - The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n     * @returns {Cursor} The created cursor.\n     */\n    createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, count) {\n        let cursor = this.createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments);\n\n        if (filter) {\n            cursor = new FilterCursor(cursor, filter);\n        }\n        if (skip >= 1) {\n            cursor = new SkipCursor(cursor, skip);\n        }\n        if (count >= 0) {\n            cursor = new LimitCursor(cursor, count);\n        }\n\n        return cursor;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\nexports.forward = new CursorFactory(ForwardTokenCursor, ForwardTokenCommentCursor);\nexports.backward = new CursorFactory(BackwardTokenCursor, BackwardTokenCommentCursor);\n","/**\n * @fileoverview Define the cursor which iterates tokens and comments in reverse.\n * @author Toru Nagashima\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Cursor = require(\"./cursor\");\nconst utils = require(\"./utils\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The cursor which iterates tokens and comments in reverse.\n */\nmodule.exports = class BackwardTokenCommentCursor extends Cursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Token[]} tokens - The array of tokens.\n     * @param {Comment[]} comments - The array of comments.\n     * @param {Object} indexMap - The map from locations to indices in `tokens`.\n     * @param {number} startLoc - The start location of the iteration range.\n     * @param {number} endLoc - The end location of the iteration range.\n     */\n    constructor(tokens, comments, indexMap, startLoc, endLoc) {\n        super();\n        this.tokens = tokens;\n        this.comments = comments;\n        this.tokenIndex = utils.getLastIndex(tokens, indexMap, endLoc);\n        this.commentIndex = utils.search(comments, endLoc) - 1;\n        this.border = startLoc;\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        const token = (this.tokenIndex >= 0) ? this.tokens[this.tokenIndex] : null;\n        const comment = (this.commentIndex >= 0) ? this.comments[this.commentIndex] : null;\n\n        if (token && (!comment || token.range[1] > comment.range[1])) {\n            this.current = token;\n            this.tokenIndex -= 1;\n        } else if (comment) {\n            this.current = comment;\n            this.commentIndex -= 1;\n        } else {\n            this.current = null;\n        }\n\n        return Boolean(this.current) && (this.border === -1 || this.current.range[0] >= this.border);\n    }\n};\n","/**\n * @fileoverview Define the abstract class about cursors which iterate tokens.\n * @author Toru Nagashima\n */\n\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The abstract class about cursors which iterate tokens.\n *\n * This class has 2 abstract methods.\n *\n * - `current: Token | Comment | null` ... The current token.\n * - `moveNext(): boolean` ... Moves this cursor to the next token. If the next token didn't exist, it returns `false`.\n *\n * This is similar to ES2015 Iterators.\n * However, Iterators were slow (at 2017-01), so I created this class as similar to C# IEnumerable.\n *\n * There are the following known sub classes.\n *\n * - ForwardTokenCursor .......... The cursor which iterates tokens only.\n * - BackwardTokenCursor ......... The cursor which iterates tokens only in reverse.\n * - ForwardTokenCommentCursor ... The cursor which iterates tokens and comments.\n * - BackwardTokenCommentCursor .. The cursor which iterates tokens and comments in reverse.\n * - DecorativeCursor\n *     - FilterCursor ............ The cursor which ignores the specified tokens.\n *     - SkipCursor .............. The cursor which ignores the first few tokens.\n *     - LimitCursor ............. The cursor which limits the count of tokens.\n *\n */\nmodule.exports = class Cursor {\n\n    /**\n     * Initializes this cursor.\n     */\n    constructor() {\n        this.current = null;\n    }\n\n    /**\n     * Gets the first token.\n     * This consumes this cursor.\n     * @returns {Token|Comment} The first token or null.\n     */\n    getOneToken() {\n        return this.moveNext() ? this.current : null;\n    }\n\n    /**\n     * Gets the first tokens.\n     * This consumes this cursor.\n     * @returns {(Token|Comment)[]} All tokens.\n     */\n    getAllTokens() {\n        const tokens = [];\n\n        while (this.moveNext()) {\n            tokens.push(this.current);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Moves this cursor to the next token.\n     * @returns {boolean} `true` if the next token exists.\n     * @abstract\n     */\n    /* istanbul ignore next */\n    moveNext() { // eslint-disable-line class-methods-use-this\n        throw new Error(\"Not implemented.\");\n    }\n};\n","/**\n * @fileoverview Define utilify functions for token store.\n * @author Toru Nagashima\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets `token.range[0]` from the given token.\n *\n * @param {Node|Token|Comment} token - The token to get.\n * @returns {number} The start location.\n * @private\n */\nfunction getStartLocation(token) {\n    return token.range[0];\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * Binary-searches the index of the first token which is after the given location.\n * If it was not found, this returns `tokens.length`.\n *\n * @param {(Token|Comment)[]} tokens - It searches the token in this list.\n * @param {number} location - The location to search.\n * @returns {number} The found index or `tokens.length`.\n */\nexports.search = function search(tokens, location) {\n    return lodash.sortedIndexBy(\n        tokens,\n        { range: [location] },\n        getStartLocation\n    );\n};\n\n/**\n * Gets the index of the `startLoc` in `tokens`.\n * `startLoc` can be the value of `node.range[1]`, so this checks about `startLoc - 1` as well.\n *\n * @param {(Token|Comment)[]} tokens - The tokens to find an index.\n * @param {Object} indexMap - The map from locations to indices.\n * @param {number} startLoc - The location to get an index.\n * @returns {number} The index.\n */\nexports.getFirstIndex = function getFirstIndex(tokens, indexMap, startLoc) {\n    if (startLoc in indexMap) {\n        return indexMap[startLoc];\n    }\n    if ((startLoc - 1) in indexMap) {\n        const index = indexMap[startLoc - 1];\n        const token = (index >= 0 && index < tokens.length) ? tokens[index] : null;\n\n        /*\n         * For the map of \"comment's location -> token's index\", it points the next token of a comment.\n         * In that case, +1 is unnecessary.\n         */\n        if (token && token.range[0] >= startLoc) {\n            return index;\n        }\n        return index + 1;\n    }\n    return 0;\n};\n\n/**\n * Gets the index of the `endLoc` in `tokens`.\n * The information of end locations are recorded at `endLoc - 1` in `indexMap`, so this checks about `endLoc - 1` as well.\n *\n * @param {(Token|Comment)[]} tokens - The tokens to find an index.\n * @param {Object} indexMap - The map from locations to indices.\n * @param {number} endLoc - The location to get an index.\n * @returns {number} The index.\n */\nexports.getLastIndex = function getLastIndex(tokens, indexMap, endLoc) {\n    if (endLoc in indexMap) {\n        return indexMap[endLoc] - 1;\n    }\n    if ((endLoc - 1) in indexMap) {\n        const index = indexMap[endLoc - 1];\n        const token = (index >= 0 && index < tokens.length) ? tokens[index] : null;\n\n        /*\n         * For the map of \"comment's location -> token's index\", it points the next token of a comment.\n         * In that case, -1 is necessary.\n         */\n        if (token && token.range[1] > endLoc) {\n            return index - 1;\n        }\n        return index;\n    }\n    return tokens.length - 1;\n};\n","/**\n * @fileoverview Define the cursor which iterates tokens only in reverse.\n * @author Toru Nagashima\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Cursor = require(\"./cursor\");\nconst utils = require(\"./utils\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The cursor which iterates tokens only in reverse.\n */\nmodule.exports = class BackwardTokenCursor extends Cursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Token[]} tokens - The array of tokens.\n     * @param {Comment[]} comments - The array of comments.\n     * @param {Object} indexMap - The map from locations to indices in `tokens`.\n     * @param {number} startLoc - The start location of the iteration range.\n     * @param {number} endLoc - The end location of the iteration range.\n     */\n    constructor(tokens, comments, indexMap, startLoc, endLoc) {\n        super();\n        this.tokens = tokens;\n        this.index = utils.getLastIndex(tokens, indexMap, endLoc);\n        this.indexEnd = utils.getFirstIndex(tokens, indexMap, startLoc);\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        if (this.index >= this.indexEnd) {\n            this.current = this.tokens[this.index];\n            this.index -= 1;\n            return true;\n        }\n        return false;\n    }\n\n    /*\n     *\n     * Shorthand for performance.\n     *\n     */\n\n    /** @inheritdoc */\n    getOneToken() {\n        return (this.index >= this.indexEnd) ? this.tokens[this.index] : null;\n    }\n};\n","/**\n * @fileoverview Define the cursor which ignores specified tokens.\n * @author Toru Nagashima\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst DecorativeCursor = require(\"./decorative-cursor\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The decorative cursor which ignores specified tokens.\n */\nmodule.exports = class FilterCursor extends DecorativeCursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Cursor} cursor - The cursor to be decorated.\n     * @param {Function} predicate - The predicate function to decide tokens this cursor iterates.\n     */\n    constructor(cursor, predicate) {\n        super(cursor);\n        this.predicate = predicate;\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        const predicate = this.predicate;\n\n        while (super.moveNext()) {\n            if (predicate(this.current)) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n","/**\n * @fileoverview Define the abstract class about cursors which manipulate another cursor.\n * @author Toru Nagashima\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Cursor = require(\"./cursor\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The abstract class about cursors which manipulate another cursor.\n */\nmodule.exports = class DecorativeCursor extends Cursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Cursor} cursor - The cursor to be decorated.\n     */\n    constructor(cursor) {\n        super();\n        this.cursor = cursor;\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        const retv = this.cursor.moveNext();\n\n        this.current = this.cursor.current;\n\n        return retv;\n    }\n};\n","/**\n * @fileoverview Define the cursor which iterates tokens and comments.\n * @author Toru Nagashima\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Cursor = require(\"./cursor\");\nconst utils = require(\"./utils\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The cursor which iterates tokens and comments.\n */\nmodule.exports = class ForwardTokenCommentCursor extends Cursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Token[]} tokens - The array of tokens.\n     * @param {Comment[]} comments - The array of comments.\n     * @param {Object} indexMap - The map from locations to indices in `tokens`.\n     * @param {number} startLoc - The start location of the iteration range.\n     * @param {number} endLoc - The end location of the iteration range.\n     */\n    constructor(tokens, comments, indexMap, startLoc, endLoc) {\n        super();\n        this.tokens = tokens;\n        this.comments = comments;\n        this.tokenIndex = utils.getFirstIndex(tokens, indexMap, startLoc);\n        this.commentIndex = utils.search(comments, startLoc);\n        this.border = endLoc;\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        const token = (this.tokenIndex < this.tokens.length) ? this.tokens[this.tokenIndex] : null;\n        const comment = (this.commentIndex < this.comments.length) ? this.comments[this.commentIndex] : null;\n\n        if (token && (!comment || token.range[0] < comment.range[0])) {\n            this.current = token;\n            this.tokenIndex += 1;\n        } else if (comment) {\n            this.current = comment;\n            this.commentIndex += 1;\n        } else {\n            this.current = null;\n        }\n\n        return Boolean(this.current) && (this.border === -1 || this.current.range[1] <= this.border);\n    }\n};\n","/**\n * @fileoverview Define the cursor which iterates tokens only.\n * @author Toru Nagashima\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Cursor = require(\"./cursor\");\nconst utils = require(\"./utils\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The cursor which iterates tokens only.\n */\nmodule.exports = class ForwardTokenCursor extends Cursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Token[]} tokens - The array of tokens.\n     * @param {Comment[]} comments - The array of comments.\n     * @param {Object} indexMap - The map from locations to indices in `tokens`.\n     * @param {number} startLoc - The start location of the iteration range.\n     * @param {number} endLoc - The end location of the iteration range.\n     */\n    constructor(tokens, comments, indexMap, startLoc, endLoc) {\n        super();\n        this.tokens = tokens;\n        this.index = utils.getFirstIndex(tokens, indexMap, startLoc);\n        this.indexEnd = utils.getLastIndex(tokens, indexMap, endLoc);\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        if (this.index <= this.indexEnd) {\n            this.current = this.tokens[this.index];\n            this.index += 1;\n            return true;\n        }\n        return false;\n    }\n\n    /*\n     *\n     * Shorthand for performance.\n     *\n     */\n\n    /** @inheritdoc */\n    getOneToken() {\n        return (this.index <= this.indexEnd) ? this.tokens[this.index] : null;\n    }\n\n    /** @inheritdoc */\n    getAllTokens() {\n        return this.tokens.slice(this.index, this.indexEnd + 1);\n    }\n};\n","/**\n * @fileoverview Define the cursor which limits the number of tokens.\n * @author Toru Nagashima\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst DecorativeCursor = require(\"./decorative-cursor\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The decorative cursor which limits the number of tokens.\n */\nmodule.exports = class LimitCursor extends DecorativeCursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Cursor} cursor - The cursor to be decorated.\n     * @param {number} count - The count of tokens this cursor iterates.\n     */\n    constructor(cursor, count) {\n        super(cursor);\n        this.count = count;\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        if (this.count > 0) {\n            this.count -= 1;\n            return super.moveNext();\n        }\n        return false;\n    }\n};\n","/**\n * @fileoverview Define the cursor which ignores the first few tokens.\n * @author Toru Nagashima\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst DecorativeCursor = require(\"./decorative-cursor\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The decorative cursor which ignores the first few tokens.\n */\nmodule.exports = class SkipCursor extends DecorativeCursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Cursor} cursor - The cursor to be decorated.\n     * @param {number} count - The count of tokens this cursor skips.\n     */\n    constructor(cursor, count) {\n        super(cursor);\n        this.count = count;\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        while (this.count > 0) {\n            this.count -= 1;\n            if (!super.moveNext()) {\n                return false;\n            }\n        }\n        return super.moveNext();\n    }\n};\n","/**\n * @fileoverview Define the cursor which iterates tokens only, with inflated range.\n * @author Toru Nagashima\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst ForwardTokenCursor = require(\"./forward-token-cursor\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The cursor which iterates tokens only, with inflated range.\n * This is for the backward compatibility of padding options.\n */\nmodule.exports = class PaddedTokenCursor extends ForwardTokenCursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Token[]} tokens - The array of tokens.\n     * @param {Comment[]} comments - The array of comments.\n     * @param {Object} indexMap - The map from locations to indices in `tokens`.\n     * @param {number} startLoc - The start location of the iteration range.\n     * @param {number} endLoc - The end location of the iteration range.\n     * @param {number} beforeCount - The number of tokens this cursor iterates before start.\n     * @param {number} afterCount - The number of tokens this cursor iterates after end.\n     */\n    constructor(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {\n        super(tokens, comments, indexMap, startLoc, endLoc);\n        this.index = Math.max(0, this.index - beforeCount);\n        this.indexEnd = Math.min(tokens.length - 1, this.indexEnd + afterCount);\n    }\n};\n","/**\n * @fileoverview Traverser to traverse AST trees.\n * @author Nicholas C. Zakas\n * @author Toru Nagashima\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst vk = require(\"eslint-visitor-keys\");\nconst debug = require(\"debug\")(\"eslint:traverser\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Do nothing.\n * @returns {void}\n */\nfunction noop() {\n\n    // do nothing.\n}\n\n/**\n * Check whether the given value is an ASTNode or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an ASTNode.\n */\nfunction isNode(x) {\n    return x !== null && typeof x === \"object\" && typeof x.type === \"string\";\n}\n\n/**\n * Get the visitor keys of a given node.\n * @param {Object} visitorKeys The map of visitor keys.\n * @param {ASTNode} node The node to get their visitor keys.\n * @returns {string[]} The visitor keys of the node.\n */\nfunction getVisitorKeys(visitorKeys, node) {\n    let keys = visitorKeys[node.type];\n\n    if (!keys) {\n        keys = vk.getKeys(node);\n        debug(\"Unknown node type \\\"%s\\\": Estimated visitor keys %j\", node.type, keys);\n    }\n\n    return keys;\n}\n\n/**\n * The traverser class to traverse AST trees.\n */\nclass Traverser {\n    constructor() {\n        this._current = null;\n        this._parents = [];\n        this._skipped = false;\n        this._broken = false;\n        this._visitorKeys = null;\n        this._enter = null;\n        this._leave = null;\n    }\n\n    /**\n     * @returns {ASTNode} The current node.\n     */\n    current() {\n        return this._current;\n    }\n\n    /**\n     * @returns {ASTNode[]} The ancestor nodes.\n     */\n    parents() {\n        return this._parents.slice(0);\n    }\n\n    /**\n     * Break the current traversal.\n     * @returns {void}\n     */\n    break() {\n        this._broken = true;\n    }\n\n    /**\n     * Skip child nodes for the current traversal.\n     * @returns {void}\n     */\n    skip() {\n        this._skipped = true;\n    }\n\n    /**\n     * Traverse the given AST tree.\n     * @param {ASTNode} node The root node to traverse.\n     * @param {Object} options The option object.\n     * @param {Object} [options.visitorKeys=DEFAULT_VISITOR_KEYS] The keys of each node types to traverse child nodes. Default is `./default-visitor-keys.json`.\n     * @param {Function} [options.enter=noop] The callback function which is called on entering each node.\n     * @param {Function} [options.leave=noop] The callback function which is called on leaving each node.\n     * @returns {void}\n     */\n    traverse(node, options) {\n        this._current = null;\n        this._parents = [];\n        this._skipped = false;\n        this._broken = false;\n        this._visitorKeys = options.visitorKeys || vk.KEYS;\n        this._enter = options.enter || noop;\n        this._leave = options.leave || noop;\n        this._traverse(node, null);\n    }\n\n    /**\n     * Traverse the given AST tree recursively.\n     * @param {ASTNode} node The current node.\n     * @param {ASTNode|null} parent The parent node.\n     * @returns {void}\n     * @private\n     */\n    _traverse(node, parent) {\n        if (!isNode(node)) {\n            return;\n        }\n\n        this._current = node;\n        this._skipped = false;\n        this._enter(node, parent);\n\n        if (!this._skipped && !this._broken) {\n            const keys = getVisitorKeys(this._visitorKeys, node);\n\n            if (keys.length >= 1) {\n                this._parents.push(node);\n                for (let i = 0; i < keys.length && !this._broken; ++i) {\n                    const child = node[keys[i]];\n\n                    if (Array.isArray(child)) {\n                        for (let j = 0; j < child.length && !this._broken; ++j) {\n                            this._traverse(child[j], node);\n                        }\n                    } else {\n                        this._traverse(child, node);\n                    }\n                }\n                this._parents.pop();\n            }\n        }\n\n        if (!this._broken) {\n            this._leave(node, parent);\n        }\n\n        this._current = parent;\n    }\n\n    /**\n     * Calculates the keys to use for traversal.\n     * @param {ASTNode} node The node to read keys from.\n     * @returns {string[]} An array of keys to visit on the node.\n     * @private\n     */\n    static getKeys(node) {\n        return vk.getKeys(node);\n    }\n\n    /**\n     * Traverse the given AST tree.\n     * @param {ASTNode} node The root node to traverse.\n     * @param {Object} options The option object.\n     * @param {Object} [options.visitorKeys=DEFAULT_VISITOR_KEYS] The keys of each node types to traverse child nodes. Default is `./default-visitor-keys.json`.\n     * @param {Function} [options.enter=noop] The callback function which is called on entering each node.\n     * @param {Function} [options.leave=noop] The callback function which is called on leaving each node.\n     * @returns {void}\n     */\n    static traverse(node, options) {\n        new Traverser().traverse(node, options);\n    }\n\n    /**\n     * The default visitor keys.\n     * @type {Object}\n     */\n    static get DEFAULT_VISITOR_KEYS() {\n        return vk.KEYS;\n    }\n}\n\nmodule.exports = Traverser;\n","/**\n * @fileoverview A helper that translates context.report() calls from the rule API into generic problem objects\n * @author Teddy Katz\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\nconst ruleFixer = require(\"./rule-fixer\");\nconst interpolate = require(\"./interpolate\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An error message description\n * @typedef {Object} MessageDescriptor\n * @property {ASTNode} [node] The reported node\n * @property {Location} loc The location of the problem.\n * @property {string} message The problem message.\n * @property {Object} [data] Optional data to use to fill in placeholders in the\n *      message.\n * @property {Function} [fix] The function to call that creates a fix command.\n */\n\n/**\n * Information about the report\n * @typedef {Object} ReportInfo\n * @property {string} ruleId\n * @property {(0|1|2)} severity\n * @property {(string|undefined)} message\n * @property {(string|undefined)} messageId\n * @property {number} line\n * @property {number} column\n * @property {(number|undefined)} endLine\n * @property {(number|undefined)} endColumn\n * @property {(string|null)} nodeType\n * @property {string} source\n * @property {({text: string, range: (number[]|null)}|null)} fix\n */\n\n//------------------------------------------------------------------------------\n// Module Definition\n//------------------------------------------------------------------------------\n\n\n/**\n * Translates a multi-argument context.report() call into a single object argument call\n * @param {...*} args A list of arguments passed to `context.report`\n * @returns {MessageDescriptor} A normalized object containing report information\n */\nfunction normalizeMultiArgReportCall(...args) {\n\n    // If there is one argument, it is considered to be a new-style call already.\n    if (args.length === 1) {\n\n        // Shallow clone the object to avoid surprises if reusing the descriptor\n        return Object.assign({}, args[0]);\n    }\n\n    // If the second argument is a string, the arguments are interpreted as [node, message, data, fix].\n    if (typeof args[1] === \"string\") {\n        return {\n            node: args[0],\n            message: args[1],\n            data: args[2],\n            fix: args[3]\n        };\n    }\n\n    // Otherwise, the arguments are interpreted as [node, loc, message, data, fix].\n    return {\n        node: args[0],\n        loc: args[1],\n        message: args[2],\n        data: args[3],\n        fix: args[4]\n    };\n}\n\n/**\n * Asserts that either a loc or a node was provided, and the node is valid if it was provided.\n * @param {MessageDescriptor} descriptor A descriptor to validate\n * @returns {void}\n * @throws AssertionError if neither a node nor a loc was provided, or if the node is not an object\n */\nfunction assertValidNodeInfo(descriptor) {\n    if (descriptor.node) {\n        assert(typeof descriptor.node === \"object\", \"Node must be an object\");\n    } else {\n        assert(descriptor.loc, \"Node must be provided when reporting error if location is not provided\");\n    }\n}\n\n/**\n * Normalizes a MessageDescriptor to always have a `loc` with `start` and `end` properties\n * @param {MessageDescriptor} descriptor A descriptor for the report from a rule.\n * @returns {{start: Location, end: (Location|null)}} An updated location that infers the `start` and `end` properties\n * from the `node` of the original descriptor, or infers the `start` from the `loc` of the original descriptor.\n */\nfunction normalizeReportLoc(descriptor) {\n    if (descriptor.loc) {\n        if (descriptor.loc.start) {\n            return descriptor.loc;\n        }\n        return { start: descriptor.loc, end: null };\n    }\n    return descriptor.node.loc;\n}\n\n/**\n * Compares items in a fixes array by range.\n * @param {Fix} a The first message.\n * @param {Fix} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareFixesByRange(a, b) {\n    return a.range[0] - b.range[0] || a.range[1] - b.range[1];\n}\n\n/**\n * Merges the given fixes array into one.\n * @param {Fix[]} fixes The fixes to merge.\n * @param {SourceCode} sourceCode The source code object to get the text between fixes.\n * @returns {{text: string, range: number[]}} The merged fixes\n */\nfunction mergeFixes(fixes, sourceCode) {\n    if (fixes.length === 0) {\n        return null;\n    }\n    if (fixes.length === 1) {\n        return fixes[0];\n    }\n\n    fixes.sort(compareFixesByRange);\n\n    const originalText = sourceCode.text;\n    const start = fixes[0].range[0];\n    const end = fixes[fixes.length - 1].range[1];\n    let text = \"\";\n    let lastPos = Number.MIN_SAFE_INTEGER;\n\n    for (const fix of fixes) {\n        assert(fix.range[0] >= lastPos, \"Fix objects must not be overlapped in a report.\");\n\n        if (fix.range[0] >= 0) {\n            text += originalText.slice(Math.max(0, start, lastPos), fix.range[0]);\n        }\n        text += fix.text;\n        lastPos = fix.range[1];\n    }\n    text += originalText.slice(Math.max(0, start, lastPos), end);\n\n    return { range: [start, end], text };\n}\n\n/**\n * Gets one fix object from the given descriptor.\n * If the descriptor retrieves multiple fixes, this merges those to one.\n * @param {MessageDescriptor} descriptor The report descriptor.\n * @param {SourceCode} sourceCode The source code object to get text between fixes.\n * @returns {({text: string, range: number[]}|null)} The fix for the descriptor\n */\nfunction normalizeFixes(descriptor, sourceCode) {\n    if (typeof descriptor.fix !== \"function\") {\n        return null;\n    }\n\n    // @type {null | Fix | Fix[] | IterableIterator<Fix>}\n    const fix = descriptor.fix(ruleFixer);\n\n    // Merge to one.\n    if (fix && Symbol.iterator in fix) {\n        return mergeFixes(Array.from(fix), sourceCode);\n    }\n    return fix;\n}\n\n/**\n * Creates information about the report from a descriptor\n * @param {Object} options Information about the problem\n * @param {string} options.ruleId Rule ID\n * @param {(0|1|2)} options.severity Rule severity\n * @param {(ASTNode|null)} options.node Node\n * @param {string} options.message Error message\n * @param {string} [options.messageId] The error message ID.\n * @param {{start: SourceLocation, end: (SourceLocation|null)}} options.loc Start and end location\n * @param {{text: string, range: (number[]|null)}} options.fix The fix object\n * @returns {function(...args): ReportInfo} Function that returns information about the report\n */\nfunction createProblem(options) {\n    const problem = {\n        ruleId: options.ruleId,\n        severity: options.severity,\n        message: options.message,\n        line: options.loc.start.line,\n        column: options.loc.start.column + 1,\n        nodeType: options.node && options.node.type || null\n    };\n\n    /*\n     * If this isn’t in the conditional, some of the tests fail\n     * because `messageId` is present in the problem object\n     */\n    if (options.messageId) {\n        problem.messageId = options.messageId;\n    }\n\n    if (options.loc.end) {\n        problem.endLine = options.loc.end.line;\n        problem.endColumn = options.loc.end.column + 1;\n    }\n\n    if (options.fix) {\n        problem.fix = options.fix;\n    }\n\n    return problem;\n}\n\n/**\n * Returns a function that converts the arguments of a `context.report` call from a rule into a reported\n * problem for the Node.js API.\n * @param {{ruleId: string, severity: number, sourceCode: SourceCode, messageIds: Object}} metadata Metadata for the reported problem\n * @param {SourceCode} sourceCode The `SourceCode` instance for the text being linted\n * @returns {function(...args): ReportInfo} Function that returns information about the report\n */\n\nmodule.exports = function createReportTranslator(metadata) {\n\n    /*\n     * `createReportTranslator` gets called once per enabled rule per file. It needs to be very performant.\n     * The report translator itself (i.e. the function that `createReportTranslator` returns) gets\n     * called every time a rule reports a problem, which happens much less frequently (usually, the vast\n     * majority of rules don't report any problems for a given file).\n     */\n    return (...args) => {\n        const descriptor = normalizeMultiArgReportCall(...args);\n\n        assertValidNodeInfo(descriptor);\n\n        let computedMessage;\n\n        if (descriptor.messageId) {\n            if (!metadata.messageIds) {\n                throw new TypeError(\"context.report() called with a messageId, but no messages were present in the rule metadata.\");\n            }\n            const id = descriptor.messageId;\n            const messages = metadata.messageIds;\n\n            if (descriptor.message) {\n                throw new TypeError(\"context.report() called with a message and a messageId. Please only pass one.\");\n            }\n            if (!messages || !Object.prototype.hasOwnProperty.call(messages, id)) {\n                throw new TypeError(`context.report() called with a messageId of '${id}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);\n            }\n            computedMessage = messages[id];\n        } else if (descriptor.message) {\n            computedMessage = descriptor.message;\n        } else {\n            throw new TypeError(\"Missing `message` property in report() call; add a message that describes the linting problem.\");\n        }\n\n\n        return createProblem({\n            ruleId: metadata.ruleId,\n            severity: metadata.severity,\n            node: descriptor.node,\n            message: interpolate(computedMessage, descriptor.data),\n            messageId: descriptor.messageId,\n            loc: normalizeReportLoc(descriptor),\n            fix: normalizeFixes(descriptor, metadata.sourceCode)\n        });\n    };\n};\n","/**\n * @fileoverview An object that creates fix commands for rules.\n * @author Nicholas C. Zakas\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n// none!\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Creates a fix command that inserts text at the specified index in the source text.\n * @param {int} index The 0-based index at which to insert the new text.\n * @param {string} text The text to insert.\n * @returns {Object} The fix command.\n * @private\n */\nfunction insertTextAt(index, text) {\n    return {\n        range: [index, index],\n        text\n    };\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Creates code fixing commands for rules.\n */\n\nconst ruleFixer = Object.freeze({\n\n    /**\n     * Creates a fix command that inserts text after the given node or token.\n     * The fix is not applied until applyFixes() is called.\n     * @param {ASTNode|Token} nodeOrToken The node or token to insert after.\n     * @param {string} text The text to insert.\n     * @returns {Object} The fix command.\n     */\n    insertTextAfter(nodeOrToken, text) {\n        return this.insertTextAfterRange(nodeOrToken.range, text);\n    },\n\n    /**\n     * Creates a fix command that inserts text after the specified range in the source text.\n     * The fix is not applied until applyFixes() is called.\n     * @param {int[]} range The range to replace, first item is start of range, second\n     *      is end of range.\n     * @param {string} text The text to insert.\n     * @returns {Object} The fix command.\n     */\n    insertTextAfterRange(range, text) {\n        return insertTextAt(range[1], text);\n    },\n\n    /**\n     * Creates a fix command that inserts text before the given node or token.\n     * The fix is not applied until applyFixes() is called.\n     * @param {ASTNode|Token} nodeOrToken The node or token to insert before.\n     * @param {string} text The text to insert.\n     * @returns {Object} The fix command.\n     */\n    insertTextBefore(nodeOrToken, text) {\n        return this.insertTextBeforeRange(nodeOrToken.range, text);\n    },\n\n    /**\n     * Creates a fix command that inserts text before the specified range in the source text.\n     * The fix is not applied until applyFixes() is called.\n     * @param {int[]} range The range to replace, first item is start of range, second\n     *      is end of range.\n     * @param {string} text The text to insert.\n     * @returns {Object} The fix command.\n     */\n    insertTextBeforeRange(range, text) {\n        return insertTextAt(range[0], text);\n    },\n\n    /**\n     * Creates a fix command that replaces text at the node or token.\n     * The fix is not applied until applyFixes() is called.\n     * @param {ASTNode|Token} nodeOrToken The node or token to remove.\n     * @param {string} text The text to insert.\n     * @returns {Object} The fix command.\n     */\n    replaceText(nodeOrToken, text) {\n        return this.replaceTextRange(nodeOrToken.range, text);\n    },\n\n    /**\n     * Creates a fix command that replaces text at the specified range in the source text.\n     * The fix is not applied until applyFixes() is called.\n     * @param {int[]} range The range to replace, first item is start of range, second\n     *      is end of range.\n     * @param {string} text The text to insert.\n     * @returns {Object} The fix command.\n     */\n    replaceTextRange(range, text) {\n        return {\n            range,\n            text\n        };\n    },\n\n    /**\n     * Creates a fix command that removes the node or token from the source.\n     * The fix is not applied until applyFixes() is called.\n     * @param {ASTNode|Token} nodeOrToken The node or token to remove.\n     * @returns {Object} The fix command.\n     */\n    remove(nodeOrToken) {\n        return this.removeRange(nodeOrToken.range);\n    },\n\n    /**\n     * Creates a fix command that removes the specified range of text from the source.\n     * The fix is not applied until applyFixes() is called.\n     * @param {int[]} range The range to remove, first item is start of range, second\n     *      is end of range.\n     * @returns {Object} The fix command.\n     */\n    removeRange(range) {\n        return {\n            range,\n            text: \"\"\n        };\n    }\n\n});\n\n\nmodule.exports = ruleFixer;\n","/**\n * @fileoverview Interpolate keys from an object into a string with {{ }} markers.\n * @author Jed Fox\n */\n\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = (text, data) => {\n    if (!data) {\n        return text;\n    }\n\n    // Substitution content for any {{ }} markers.\n    return text.replace(/\\{\\{([^{}]+?)\\}\\}/gu, (fullMatch, termWithWhitespace) => {\n        const term = termWithWhitespace.trim();\n\n        if (term in data) {\n            return data[term];\n        }\n\n        // Preserve old behavior: If parameter name not provided, don't replace it.\n        return fullMatch;\n    });\n};\n","/**\n * @fileoverview Defines a storage for rules.\n * @author Nicholas C. Zakas\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\nconst ruleReplacements = require(\"../conf/replacements\").rules;\nconst builtInRules = require(\"./built-in-rules-index\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Creates a stub rule that gets used when a rule with a given ID is not found.\n * @param {string} ruleId The ID of the missing rule\n * @returns {{create: function(RuleContext): Object}} A rule that reports an error at the first location\n * in the program. The report has the message `Definition for rule '${ruleId}' was not found` if the rule is unknown,\n * or `Rule '${ruleId}' was removed and replaced by: ${replacements.join(\", \")}` if the rule is known to have been\n * replaced.\n */\nconst createMissingRule = lodash.memoize(ruleId => {\n    const message = Object.prototype.hasOwnProperty.call(ruleReplacements, ruleId)\n        ? `Rule '${ruleId}' was removed and replaced by: ${ruleReplacements[ruleId].join(\", \")}`\n        : `Definition for rule '${ruleId}' was not found`;\n\n    return {\n        create: context => ({\n            Program() {\n                context.report({\n                    loc: { line: 1, column: 0 },\n                    message\n                });\n            }\n        })\n    };\n});\n\n/**\n * Normalizes a rule module to the new-style API\n * @param {(Function|{create: Function})} rule A rule object, which can either be a function\n * (\"old-style\") or an object with a `create` method (\"new-style\")\n * @returns {{create: Function}} A new-style rule.\n */\nfunction normalizeRule(rule) {\n    return typeof rule === \"function\" ? Object.assign({ create: rule }, rule) : rule;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nclass Rules {\n    constructor() {\n        this._rules = Object.create(null);\n        Object.keys(builtInRules).forEach(ruleId => {\n            this.define(ruleId, builtInRules[ruleId]);\n        });\n    }\n\n    /**\n     * Registers a rule module for rule id in storage.\n     * @param {string} ruleId Rule id (file name).\n     * @param {Function} ruleModule Rule handler.\n     * @returns {void}\n     */\n    define(ruleId, ruleModule) {\n        this._rules[ruleId] = normalizeRule(ruleModule);\n    }\n\n    /**\n     * Access rule handler by id (file name).\n     * @param {string} ruleId Rule id (file name).\n     * @returns {{create: Function, schema: JsonSchema[]}}\n     * A rule. This is normalized to always have the new-style shape with a `create` method.\n     */\n    get(ruleId) {\n        if (!Object.prototype.hasOwnProperty.call(this._rules, ruleId)) {\n            return createMissingRule(ruleId);\n        }\n        if (typeof this._rules[ruleId] === \"string\") {\n            return normalizeRule(require(this._rules[ruleId]));\n        }\n        return this._rules[ruleId];\n\n    }\n\n    /**\n     * Get an object with all currently loaded rules\n     * @returns {Map} All loaded rules\n     */\n    getAllLoadedRules() {\n        const allRules = new Map();\n\n        Object.keys(this._rules).forEach(name => {\n            const rule = this.get(name);\n\n            allRules.set(name, rule);\n        });\n        return allRules;\n    }\n}\n\nmodule.exports = Rules;\n","/**\n * @fileoverview Collects the built-in rules into a map structure so that they can be imported all at once and without\n * using the file-system directly.\n * @author Peter (Somogyvari) Metz\n */\n\n\n\n/* eslint sort-keys: [\"error\", \"asc\"] */\n\nmodule.exports = {\n    \"accessor-pairs\": require(\"./rules/accessor-pairs\"),\n    \"array-bracket-newline\": require(\"./rules/array-bracket-newline\"),\n    \"array-bracket-spacing\": require(\"./rules/array-bracket-spacing\"),\n    \"array-callback-return\": require(\"./rules/array-callback-return\"),\n    \"array-element-newline\": require(\"./rules/array-element-newline\"),\n    \"arrow-body-style\": require(\"./rules/arrow-body-style\"),\n    \"arrow-parens\": require(\"./rules/arrow-parens\"),\n    \"arrow-spacing\": require(\"./rules/arrow-spacing\"),\n    \"block-scoped-var\": require(\"./rules/block-scoped-var\"),\n    \"block-spacing\": require(\"./rules/block-spacing\"),\n    \"brace-style\": require(\"./rules/brace-style\"),\n    \"callback-return\": require(\"./rules/callback-return\"),\n    camelcase: require(\"./rules/camelcase\"),\n    \"capitalized-comments\": require(\"./rules/capitalized-comments\"),\n    \"class-methods-use-this\": require(\"./rules/class-methods-use-this\"),\n    \"comma-dangle\": require(\"./rules/comma-dangle\"),\n    \"comma-spacing\": require(\"./rules/comma-spacing\"),\n    \"comma-style\": require(\"./rules/comma-style\"),\n    complexity: require(\"./rules/complexity\"),\n    \"computed-property-spacing\": require(\"./rules/computed-property-spacing\"),\n    \"consistent-return\": require(\"./rules/consistent-return\"),\n    \"consistent-this\": require(\"./rules/consistent-this\"),\n    \"constructor-super\": require(\"./rules/constructor-super\"),\n    curly: require(\"./rules/curly\"),\n    \"default-case\": require(\"./rules/default-case\"),\n    \"dot-location\": require(\"./rules/dot-location\"),\n    \"dot-notation\": require(\"./rules/dot-notation\"),\n    \"eol-last\": require(\"./rules/eol-last\"),\n    eqeqeq: require(\"./rules/eqeqeq\"),\n    \"for-direction\": require(\"./rules/for-direction\"),\n    \"func-call-spacing\": require(\"./rules/func-call-spacing\"),\n    \"func-name-matching\": require(\"./rules/func-name-matching\"),\n    \"func-names\": require(\"./rules/func-names\"),\n    \"func-style\": require(\"./rules/func-style\"),\n    \"function-paren-newline\": require(\"./rules/function-paren-newline\"),\n    \"generator-star-spacing\": require(\"./rules/generator-star-spacing\"),\n    \"getter-return\": require(\"./rules/getter-return\"),\n    \"global-require\": require(\"./rules/global-require\"),\n    \"guard-for-in\": require(\"./rules/guard-for-in\"),\n    \"handle-callback-err\": require(\"./rules/handle-callback-err\"),\n    \"id-blacklist\": require(\"./rules/id-blacklist\"),\n    \"id-length\": require(\"./rules/id-length\"),\n    \"id-match\": require(\"./rules/id-match\"),\n    \"implicit-arrow-linebreak\": require(\"./rules/implicit-arrow-linebreak\"),\n    indent: require(\"./rules/indent\"),\n    \"indent-legacy\": require(\"./rules/indent-legacy\"),\n    \"init-declarations\": require(\"./rules/init-declarations\"),\n    \"jsx-quotes\": require(\"./rules/jsx-quotes\"),\n    \"key-spacing\": require(\"./rules/key-spacing\"),\n    \"keyword-spacing\": require(\"./rules/keyword-spacing\"),\n    \"line-comment-position\": require(\"./rules/line-comment-position\"),\n    \"linebreak-style\": require(\"./rules/linebreak-style\"),\n    \"lines-around-comment\": require(\"./rules/lines-around-comment\"),\n    \"lines-around-directive\": require(\"./rules/lines-around-directive\"),\n    \"lines-between-class-members\": require(\"./rules/lines-between-class-members\"),\n    \"max-classes-per-file\": require(\"./rules/max-classes-per-file\"),\n    \"max-depth\": require(\"./rules/max-depth\"),\n    \"max-len\": require(\"./rules/max-len\"),\n    \"max-lines\": require(\"./rules/max-lines\"),\n    \"max-lines-per-function\": require(\"./rules/max-lines-per-function\"),\n    \"max-nested-callbacks\": require(\"./rules/max-nested-callbacks\"),\n    \"max-params\": require(\"./rules/max-params\"),\n    \"max-statements\": require(\"./rules/max-statements\"),\n    \"max-statements-per-line\": require(\"./rules/max-statements-per-line\"),\n    \"multiline-comment-style\": require(\"./rules/multiline-comment-style\"),\n    \"multiline-ternary\": require(\"./rules/multiline-ternary\"),\n    \"new-cap\": require(\"./rules/new-cap\"),\n    \"new-parens\": require(\"./rules/new-parens\"),\n    \"newline-after-var\": require(\"./rules/newline-after-var\"),\n    \"newline-before-return\": require(\"./rules/newline-before-return\"),\n    \"newline-per-chained-call\": require(\"./rules/newline-per-chained-call\"),\n    \"no-alert\": require(\"./rules/no-alert\"),\n    \"no-array-constructor\": require(\"./rules/no-array-constructor\"),\n    \"no-async-promise-executor\": require(\"./rules/no-async-promise-executor\"),\n    \"no-await-in-loop\": require(\"./rules/no-await-in-loop\"),\n    \"no-bitwise\": require(\"./rules/no-bitwise\"),\n    \"no-buffer-constructor\": require(\"./rules/no-buffer-constructor\"),\n    \"no-caller\": require(\"./rules/no-caller\"),\n    \"no-case-declarations\": require(\"./rules/no-case-declarations\"),\n    \"no-catch-shadow\": require(\"./rules/no-catch-shadow\"),\n    \"no-class-assign\": require(\"./rules/no-class-assign\"),\n    \"no-compare-neg-zero\": require(\"./rules/no-compare-neg-zero\"),\n    \"no-cond-assign\": require(\"./rules/no-cond-assign\"),\n    \"no-confusing-arrow\": require(\"./rules/no-confusing-arrow\"),\n    \"no-console\": require(\"./rules/no-console\"),\n    \"no-const-assign\": require(\"./rules/no-const-assign\"),\n    \"no-constant-condition\": require(\"./rules/no-constant-condition\"),\n    \"no-continue\": require(\"./rules/no-continue\"),\n    \"no-control-regex\": require(\"./rules/no-control-regex\"),\n    \"no-debugger\": require(\"./rules/no-debugger\"),\n    \"no-delete-var\": require(\"./rules/no-delete-var\"),\n    \"no-div-regex\": require(\"./rules/no-div-regex\"),\n    \"no-dupe-args\": require(\"./rules/no-dupe-args\"),\n    \"no-dupe-class-members\": require(\"./rules/no-dupe-class-members\"),\n    \"no-dupe-keys\": require(\"./rules/no-dupe-keys\"),\n    \"no-duplicate-case\": require(\"./rules/no-duplicate-case\"),\n    \"no-duplicate-imports\": require(\"./rules/no-duplicate-imports\"),\n    \"no-else-return\": require(\"./rules/no-else-return\"),\n    \"no-empty\": require(\"./rules/no-empty\"),\n    \"no-empty-character-class\": require(\"./rules/no-empty-character-class\"),\n    \"no-empty-function\": require(\"./rules/no-empty-function\"),\n    \"no-empty-pattern\": require(\"./rules/no-empty-pattern\"),\n    \"no-eq-null\": require(\"./rules/no-eq-null\"),\n    \"no-eval\": require(\"./rules/no-eval\"),\n    \"no-ex-assign\": require(\"./rules/no-ex-assign\"),\n    \"no-extend-native\": require(\"./rules/no-extend-native\"),\n    \"no-extra-bind\": require(\"./rules/no-extra-bind\"),\n    \"no-extra-boolean-cast\": require(\"./rules/no-extra-boolean-cast\"),\n    \"no-extra-label\": require(\"./rules/no-extra-label\"),\n    \"no-extra-parens\": require(\"./rules/no-extra-parens\"),\n    \"no-extra-semi\": require(\"./rules/no-extra-semi\"),\n    \"no-fallthrough\": require(\"./rules/no-fallthrough\"),\n    \"no-floating-decimal\": require(\"./rules/no-floating-decimal\"),\n    \"no-func-assign\": require(\"./rules/no-func-assign\"),\n    \"no-global-assign\": require(\"./rules/no-global-assign\"),\n    \"no-implicit-coercion\": require(\"./rules/no-implicit-coercion\"),\n    \"no-implicit-globals\": require(\"./rules/no-implicit-globals\"),\n    \"no-implied-eval\": require(\"./rules/no-implied-eval\"),\n    \"no-inline-comments\": require(\"./rules/no-inline-comments\"),\n    \"no-inner-declarations\": require(\"./rules/no-inner-declarations\"),\n    \"no-invalid-regexp\": require(\"./rules/no-invalid-regexp\"),\n    \"no-invalid-this\": require(\"./rules/no-invalid-this\"),\n    \"no-irregular-whitespace\": require(\"./rules/no-irregular-whitespace\"),\n    \"no-iterator\": require(\"./rules/no-iterator\"),\n    \"no-label-var\": require(\"./rules/no-label-var\"),\n    \"no-labels\": require(\"./rules/no-labels\"),\n    \"no-lone-blocks\": require(\"./rules/no-lone-blocks\"),\n    \"no-lonely-if\": require(\"./rules/no-lonely-if\"),\n    \"no-loop-func\": require(\"./rules/no-loop-func\"),\n    \"no-magic-numbers\": require(\"./rules/no-magic-numbers\"),\n    \"no-misleading-character-class\": require(\"./rules/no-misleading-character-class\"),\n    \"no-mixed-operators\": require(\"./rules/no-mixed-operators\"),\n    \"no-mixed-requires\": require(\"./rules/no-mixed-requires\"),\n    \"no-mixed-spaces-and-tabs\": require(\"./rules/no-mixed-spaces-and-tabs\"),\n    \"no-multi-assign\": require(\"./rules/no-multi-assign\"),\n    \"no-multi-spaces\": require(\"./rules/no-multi-spaces\"),\n    \"no-multi-str\": require(\"./rules/no-multi-str\"),\n    \"no-multiple-empty-lines\": require(\"./rules/no-multiple-empty-lines\"),\n    \"no-native-reassign\": require(\"./rules/no-native-reassign\"),\n    \"no-negated-condition\": require(\"./rules/no-negated-condition\"),\n    \"no-negated-in-lhs\": require(\"./rules/no-negated-in-lhs\"),\n    \"no-nested-ternary\": require(\"./rules/no-nested-ternary\"),\n    \"no-new\": require(\"./rules/no-new\"),\n    \"no-new-func\": require(\"./rules/no-new-func\"),\n    \"no-new-object\": require(\"./rules/no-new-object\"),\n    \"no-new-require\": require(\"./rules/no-new-require\"),\n    \"no-new-symbol\": require(\"./rules/no-new-symbol\"),\n    \"no-new-wrappers\": require(\"./rules/no-new-wrappers\"),\n    \"no-obj-calls\": require(\"./rules/no-obj-calls\"),\n    \"no-octal\": require(\"./rules/no-octal\"),\n    \"no-octal-escape\": require(\"./rules/no-octal-escape\"),\n    \"no-param-reassign\": require(\"./rules/no-param-reassign\"),\n    \"no-path-concat\": require(\"./rules/no-path-concat\"),\n    \"no-plusplus\": require(\"./rules/no-plusplus\"),\n    \"no-process-env\": require(\"./rules/no-process-env\"),\n    \"no-process-exit\": require(\"./rules/no-process-exit\"),\n    \"no-proto\": require(\"./rules/no-proto\"),\n    \"no-prototype-builtins\": require(\"./rules/no-prototype-builtins\"),\n    \"no-redeclare\": require(\"./rules/no-redeclare\"),\n    \"no-regex-spaces\": require(\"./rules/no-regex-spaces\"),\n    \"no-restricted-globals\": require(\"./rules/no-restricted-globals\"),\n    \"no-restricted-imports\": require(\"./rules/no-restricted-imports\"),\n    \"no-restricted-modules\": require(\"./rules/no-restricted-modules\"),\n    \"no-restricted-properties\": require(\"./rules/no-restricted-properties\"),\n    \"no-restricted-syntax\": require(\"./rules/no-restricted-syntax\"),\n    \"no-return-assign\": require(\"./rules/no-return-assign\"),\n    \"no-return-await\": require(\"./rules/no-return-await\"),\n    \"no-script-url\": require(\"./rules/no-script-url\"),\n    \"no-self-assign\": require(\"./rules/no-self-assign\"),\n    \"no-self-compare\": require(\"./rules/no-self-compare\"),\n    \"no-sequences\": require(\"./rules/no-sequences\"),\n    \"no-shadow\": require(\"./rules/no-shadow\"),\n    \"no-shadow-restricted-names\": require(\"./rules/no-shadow-restricted-names\"),\n    \"no-spaced-func\": require(\"./rules/no-spaced-func\"),\n    \"no-sparse-arrays\": require(\"./rules/no-sparse-arrays\"),\n    \"no-sync\": require(\"./rules/no-sync\"),\n    \"no-tabs\": require(\"./rules/no-tabs\"),\n    \"no-template-curly-in-string\": require(\"./rules/no-template-curly-in-string\"),\n    \"no-ternary\": require(\"./rules/no-ternary\"),\n    \"no-this-before-super\": require(\"./rules/no-this-before-super\"),\n    \"no-throw-literal\": require(\"./rules/no-throw-literal\"),\n    \"no-trailing-spaces\": require(\"./rules/no-trailing-spaces\"),\n    \"no-undef\": require(\"./rules/no-undef\"),\n    \"no-undef-init\": require(\"./rules/no-undef-init\"),\n    \"no-undefined\": require(\"./rules/no-undefined\"),\n    \"no-underscore-dangle\": require(\"./rules/no-underscore-dangle\"),\n    \"no-unexpected-multiline\": require(\"./rules/no-unexpected-multiline\"),\n    \"no-unmodified-loop-condition\": require(\"./rules/no-unmodified-loop-condition\"),\n    \"no-unneeded-ternary\": require(\"./rules/no-unneeded-ternary\"),\n    \"no-unreachable\": require(\"./rules/no-unreachable\"),\n    \"no-unsafe-finally\": require(\"./rules/no-unsafe-finally\"),\n    \"no-unsafe-negation\": require(\"./rules/no-unsafe-negation\"),\n    \"no-unused-expressions\": require(\"./rules/no-unused-expressions\"),\n    \"no-unused-labels\": require(\"./rules/no-unused-labels\"),\n    \"no-unused-vars\": require(\"./rules/no-unused-vars\"),\n    \"no-use-before-define\": require(\"./rules/no-use-before-define\"),\n    \"no-useless-call\": require(\"./rules/no-useless-call\"),\n    \"no-useless-catch\": require(\"./rules/no-useless-catch\"),\n    \"no-useless-computed-key\": require(\"./rules/no-useless-computed-key\"),\n    \"no-useless-concat\": require(\"./rules/no-useless-concat\"),\n    \"no-useless-constructor\": require(\"./rules/no-useless-constructor\"),\n    \"no-useless-escape\": require(\"./rules/no-useless-escape\"),\n    \"no-useless-rename\": require(\"./rules/no-useless-rename\"),\n    \"no-useless-return\": require(\"./rules/no-useless-return\"),\n    \"no-var\": require(\"./rules/no-var\"),\n    \"no-void\": require(\"./rules/no-void\"),\n    \"no-warning-comments\": require(\"./rules/no-warning-comments\"),\n    \"no-whitespace-before-property\": require(\"./rules/no-whitespace-before-property\"),\n    \"no-with\": require(\"./rules/no-with\"),\n    \"nonblock-statement-body-position\": require(\"./rules/nonblock-statement-body-position\"),\n    \"object-curly-newline\": require(\"./rules/object-curly-newline\"),\n    \"object-curly-spacing\": require(\"./rules/object-curly-spacing\"),\n    \"object-property-newline\": require(\"./rules/object-property-newline\"),\n    \"object-shorthand\": require(\"./rules/object-shorthand\"),\n    \"one-var\": require(\"./rules/one-var\"),\n    \"one-var-declaration-per-line\": require(\"./rules/one-var-declaration-per-line\"),\n    \"operator-assignment\": require(\"./rules/operator-assignment\"),\n    \"operator-linebreak\": require(\"./rules/operator-linebreak\"),\n    \"padded-blocks\": require(\"./rules/padded-blocks\"),\n    \"padding-line-between-statements\": require(\"./rules/padding-line-between-statements\"),\n    \"prefer-arrow-callback\": require(\"./rules/prefer-arrow-callback\"),\n    \"prefer-const\": require(\"./rules/prefer-const\"),\n    \"prefer-destructuring\": require(\"./rules/prefer-destructuring\"),\n    \"prefer-named-capture-group\": require(\"./rules/prefer-named-capture-group\"),\n    \"prefer-numeric-literals\": require(\"./rules/prefer-numeric-literals\"),\n    \"prefer-object-spread\": require(\"./rules/prefer-object-spread\"),\n    \"prefer-promise-reject-errors\": require(\"./rules/prefer-promise-reject-errors\"),\n    \"prefer-reflect\": require(\"./rules/prefer-reflect\"),\n    \"prefer-rest-params\": require(\"./rules/prefer-rest-params\"),\n    \"prefer-spread\": require(\"./rules/prefer-spread\"),\n    \"prefer-template\": require(\"./rules/prefer-template\"),\n    \"quote-props\": require(\"./rules/quote-props\"),\n    quotes: require(\"./rules/quotes\"),\n    radix: require(\"./rules/radix\"),\n    \"require-atomic-updates\": require(\"./rules/require-atomic-updates\"),\n    \"require-await\": require(\"./rules/require-await\"),\n    \"require-jsdoc\": require(\"./rules/require-jsdoc\"),\n    \"require-unicode-regexp\": require(\"./rules/require-unicode-regexp\"),\n    \"require-yield\": require(\"./rules/require-yield\"),\n    \"rest-spread-spacing\": require(\"./rules/rest-spread-spacing\"),\n    semi: require(\"./rules/semi\"),\n    \"semi-spacing\": require(\"./rules/semi-spacing\"),\n    \"semi-style\": require(\"./rules/semi-style\"),\n    \"sort-imports\": require(\"./rules/sort-imports\"),\n    \"sort-keys\": require(\"./rules/sort-keys\"),\n    \"sort-vars\": require(\"./rules/sort-vars\"),\n    \"space-before-blocks\": require(\"./rules/space-before-blocks\"),\n    \"space-before-function-paren\": require(\"./rules/space-before-function-paren\"),\n    \"space-in-parens\": require(\"./rules/space-in-parens\"),\n    \"space-infix-ops\": require(\"./rules/space-infix-ops\"),\n    \"space-unary-ops\": require(\"./rules/space-unary-ops\"),\n    \"spaced-comment\": require(\"./rules/spaced-comment\"),\n    strict: require(\"./rules/strict\"),\n    \"switch-colon-spacing\": require(\"./rules/switch-colon-spacing\"),\n    \"symbol-description\": require(\"./rules/symbol-description\"),\n    \"template-curly-spacing\": require(\"./rules/template-curly-spacing\"),\n    \"template-tag-spacing\": require(\"./rules/template-tag-spacing\"),\n    \"unicode-bom\": require(\"./rules/unicode-bom\"),\n    \"use-isnan\": require(\"./rules/use-isnan\"),\n    \"valid-jsdoc\": require(\"./rules/valid-jsdoc\"),\n    \"valid-typeof\": require(\"./rules/valid-typeof\"),\n    \"vars-on-top\": require(\"./rules/vars-on-top\"),\n    \"wrap-iife\": require(\"./rules/wrap-iife\"),\n    \"wrap-regex\": require(\"./rules/wrap-regex\"),\n    \"yield-star-spacing\": require(\"./rules/yield-star-spacing\"),\n    yoda: require(\"./rules/yoda\")\n};\n","/**\n * @fileoverview Rule to flag wrapping non-iife in parens\n * @author Gyandeep Singh\n */\n\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is an `Identifier` node which was named a given name.\n * @param {ASTNode} node - A node to check.\n * @param {string} name - An expected name of the node.\n * @returns {boolean} `true` if the node is an `Identifier` node which was named as expected.\n */\nfunction isIdentifier(node, name) {\n    return node.type === \"Identifier\" && node.name === name;\n}\n\n/**\n * Checks whether or not a given node is an argument of a specified method call.\n * @param {ASTNode} node - A node to check.\n * @param {number} index - An expected index of the node in arguments.\n * @param {string} object - An expected name of the object of the method.\n * @param {string} property - An expected name of the method.\n * @returns {boolean} `true` if the node is an argument of the specified method call.\n */\nfunction isArgumentOfMethodCall(node, index, object, property) {\n    const parent = node.parent;\n\n    return (\n        parent.type === \"CallExpression\" &&\n        parent.callee.type === \"MemberExpression\" &&\n        parent.callee.computed === false &&\n        isIdentifier(parent.callee.object, object) &&\n        isIdentifier(parent.callee.property, property) &&\n        parent.arguments[index] === node\n    );\n}\n\n/**\n * Checks whether or not a given node is a property descriptor.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a property descriptor.\n */\nfunction isPropertyDescriptor(node) {\n\n    // Object.defineProperty(obj, \"foo\", {set: ...})\n    if (isArgumentOfMethodCall(node, 2, \"Object\", \"defineProperty\") ||\n        isArgumentOfMethodCall(node, 2, \"Reflect\", \"defineProperty\")\n    ) {\n        return true;\n    }\n\n    /*\n     * Object.defineProperties(obj, {foo: {set: ...}})\n     * Object.create(proto, {foo: {set: ...}})\n     */\n    const grandparent = node.parent.parent;\n\n    return grandparent.type === \"ObjectExpression\" && (\n        isArgumentOfMethodCall(grandparent, 1, \"Object\", \"create\") ||\n        isArgumentOfMethodCall(grandparent, 1, \"Object\", \"defineProperties\")\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce getter and setter pairs in objects\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/accessor-pairs\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                getWithoutSet: {\n                    type: \"boolean\",\n                    default: false\n                },\n                setWithoutGet: {\n                    type: \"boolean\",\n                    default: true\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            getter: \"Getter is not present.\",\n            setter: \"Setter is not present.\"\n        }\n    },\n    create(context) {\n        const config = context.options[0] || {};\n        const checkGetWithoutSet = config.getWithoutSet === true;\n        const checkSetWithoutGet = config.setWithoutGet !== false;\n\n        /**\n         * Checks a object expression to see if it has setter and getter both present or none.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkLonelySetGet(node) {\n            let isSetPresent = false;\n            let isGetPresent = false;\n            const isDescriptor = isPropertyDescriptor(node);\n\n            for (let i = 0, end = node.properties.length; i < end; i++) {\n                const property = node.properties[i];\n\n                let propToCheck = \"\";\n\n                if (property.kind === \"init\") {\n                    if (isDescriptor && !property.computed) {\n                        propToCheck = property.key.name;\n                    }\n                } else {\n                    propToCheck = property.kind;\n                }\n\n                switch (propToCheck) {\n                    case \"set\":\n                        isSetPresent = true;\n                        break;\n\n                    case \"get\":\n                        isGetPresent = true;\n                        break;\n\n                    default:\n\n                        // Do nothing\n                }\n\n                if (isSetPresent && isGetPresent) {\n                    break;\n                }\n            }\n\n            if (checkSetWithoutGet && isSetPresent && !isGetPresent) {\n                context.report({ node, messageId: \"getter\" });\n            } else if (checkGetWithoutSet && isGetPresent && !isSetPresent) {\n                context.report({ node, messageId: \"setter\" });\n            }\n        }\n\n        return {\n            ObjectExpression(node) {\n                if (checkSetWithoutGet || checkGetWithoutSet) {\n                    checkLonelySetGet(node);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce linebreaks after open and before close array brackets\n * @author Jan Peer Stöcklmair <https://github.com/JPeer264>\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce linebreaks after opening and before closing array brackets\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/array-bracket-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\", \"consistent\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            multiline: {\n                                type: \"boolean\"\n                            },\n                            minItems: {\n                                type: [\"integer\", \"null\"],\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unexpectedOpeningLinebreak: \"There should be no linebreak after '['.\",\n            unexpectedClosingLinebreak: \"There should be no linebreak before ']'.\",\n            missingOpeningLinebreak: \"A linebreak is required after '['.\",\n            missingClosingLinebreak: \"A linebreak is required before ']'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Normalizes a given option value.\n         *\n         * @param {string|Object|undefined} option - An option value to parse.\n         * @returns {{multiline: boolean, minItems: number}} Normalized option object.\n         */\n        function normalizeOptionValue(option) {\n            let consistent = false;\n            let multiline = false;\n            let minItems = 0;\n\n            if (option) {\n                if (option === \"consistent\") {\n                    consistent = true;\n                    minItems = Number.POSITIVE_INFINITY;\n                } else if (option === \"always\" || option.minItems === 0) {\n                    minItems = 0;\n                } else if (option === \"never\") {\n                    minItems = Number.POSITIVE_INFINITY;\n                } else {\n                    multiline = Boolean(option.multiline);\n                    minItems = option.minItems || Number.POSITIVE_INFINITY;\n                }\n            } else {\n                consistent = false;\n                multiline = true;\n                minItems = Number.POSITIVE_INFINITY;\n            }\n\n            return { consistent, multiline, minItems };\n        }\n\n        /**\n         * Normalizes a given option value.\n         *\n         * @param {string|Object|undefined} options - An option value to parse.\n         * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.\n         */\n        function normalizeOptions(options) {\n            const value = normalizeOptionValue(options);\n\n            return { ArrayExpression: value, ArrayPattern: value };\n        }\n\n        /**\n         * Reports that there shouldn't be a linebreak after the first token\n         * @param {ASTNode} node - The node to report in the event of an error.\n         * @param {Token} token - The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoBeginningLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"unexpectedOpeningLinebreak\",\n                fix(fixer) {\n                    const nextToken = sourceCode.getTokenAfter(token, { includeComments: true });\n\n                    if (astUtils.isCommentToken(nextToken)) {\n                        return null;\n                    }\n\n                    return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there shouldn't be a linebreak before the last token\n         * @param {ASTNode} node - The node to report in the event of an error.\n         * @param {Token} token - The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoEndingLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"unexpectedClosingLinebreak\",\n                fix(fixer) {\n                    const previousToken = sourceCode.getTokenBefore(token, { includeComments: true });\n\n                    if (astUtils.isCommentToken(previousToken)) {\n                        return null;\n                    }\n\n                    return fixer.removeRange([previousToken.range[1], token.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a linebreak after the first token\n         * @param {ASTNode} node - The node to report in the event of an error.\n         * @param {Token} token - The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredBeginningLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"missingOpeningLinebreak\",\n                fix(fixer) {\n                    return fixer.insertTextAfter(token, \"\\n\");\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a linebreak before the last token\n         * @param {ASTNode} node - The node to report in the event of an error.\n         * @param {Token} token - The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredEndingLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"missingClosingLinebreak\",\n                fix(fixer) {\n                    return fixer.insertTextBefore(token, \"\\n\");\n                }\n            });\n        }\n\n        /**\n         * Reports a given node if it violated this rule.\n         *\n         * @param {ASTNode} node - A node to check. This is an ArrayExpression node or an ArrayPattern node.\n         * @returns {void}\n         */\n        function check(node) {\n            const elements = node.elements;\n            const normalizedOptions = normalizeOptions(context.options[0]);\n            const options = normalizedOptions[node.type];\n            const openBracket = sourceCode.getFirstToken(node);\n            const closeBracket = sourceCode.getLastToken(node);\n            const firstIncComment = sourceCode.getTokenAfter(openBracket, { includeComments: true });\n            const lastIncComment = sourceCode.getTokenBefore(closeBracket, { includeComments: true });\n            const first = sourceCode.getTokenAfter(openBracket);\n            const last = sourceCode.getTokenBefore(closeBracket);\n\n            const needsLinebreaks = (\n                elements.length >= options.minItems ||\n                (\n                    options.multiline &&\n                    elements.length > 0 &&\n                    firstIncComment.loc.start.line !== lastIncComment.loc.end.line\n                ) ||\n                (\n                    elements.length === 0 &&\n                    firstIncComment.type === \"Block\" &&\n                    firstIncComment.loc.start.line !== lastIncComment.loc.end.line &&\n                    firstIncComment === lastIncComment\n                ) ||\n                (\n                    options.consistent &&\n                    firstIncComment.loc.start.line !== openBracket.loc.end.line\n                )\n            );\n\n            /*\n             * Use tokens or comments to check multiline or not.\n             * But use only tokens to check whether linebreaks are needed.\n             * This allows:\n             *     var arr = [ // eslint-disable-line foo\n             *         'a'\n             *     ]\n             */\n\n            if (needsLinebreaks) {\n                if (astUtils.isTokenOnSameLine(openBracket, first)) {\n                    reportRequiredBeginningLinebreak(node, openBracket);\n                }\n                if (astUtils.isTokenOnSameLine(last, closeBracket)) {\n                    reportRequiredEndingLinebreak(node, closeBracket);\n                }\n            } else {\n                if (!astUtils.isTokenOnSameLine(openBracket, first)) {\n                    reportNoBeginningLinebreak(node, openBracket);\n                }\n                if (!astUtils.isTokenOnSameLine(last, closeBracket)) {\n                    reportNoEndingLinebreak(node, closeBracket);\n                }\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            ArrayPattern: check,\n            ArrayExpression: check\n        };\n    }\n};\n","/**\n * @fileoverview Disallows or enforces spaces inside of array brackets.\n * @author Jamund Ferguson\n */\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing inside array brackets\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/array-bracket-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    singleValue: {\n                        type: \"boolean\"\n                    },\n                    objectsInArrays: {\n                        type: \"boolean\"\n                    },\n                    arraysInArrays: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedSpaceAfter: \"There should be no space after '{{tokenValue}}'.\",\n            unexpectedSpaceBefore: \"There should be no space before '{{tokenValue}}'.\",\n            missingSpaceAfter: \"A space is required after '{{tokenValue}}'.\",\n            missingSpaceBefore: \"A space is required before '{{tokenValue}}'.\"\n        }\n    },\n    create(context) {\n        const spaced = context.options[0] === \"always\",\n            sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether an option is set, relative to the spacing option.\n         * If spaced is \"always\", then check whether option is set to false.\n         * If spaced is \"never\", then check whether option is set to true.\n         * @param {Object} option - The option to exclude.\n         * @returns {boolean} Whether or not the property is excluded.\n         */\n        function isOptionSet(option) {\n            return context.options[1] ? context.options[1][option] === !spaced : false;\n        }\n\n        const options = {\n            spaced,\n            singleElementException: isOptionSet(\"singleValue\"),\n            objectsInArraysException: isOptionSet(\"objectsInArrays\"),\n            arraysInArraysException: isOptionSet(\"arraysInArrays\")\n        };\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports that there shouldn't be a space after the first token\n         * @param {ASTNode} node - The node to report in the event of an error.\n         * @param {Token} token - The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoBeginningSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                messageId: \"unexpectedSpaceAfter\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    const nextToken = sourceCode.getTokenAfter(token);\n\n                    return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there shouldn't be a space before the last token\n         * @param {ASTNode} node - The node to report in the event of an error.\n         * @param {Token} token - The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoEndingSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                messageId: \"unexpectedSpaceBefore\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    const previousToken = sourceCode.getTokenBefore(token);\n\n                    return fixer.removeRange([previousToken.range[1], token.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a space after the first token\n         * @param {ASTNode} node - The node to report in the event of an error.\n         * @param {Token} token - The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredBeginningSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                messageId: \"missingSpaceAfter\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextAfter(token, \" \");\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a space before the last token\n         * @param {ASTNode} node - The node to report in the event of an error.\n         * @param {Token} token - The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredEndingSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                messageId: \"missingSpaceBefore\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextBefore(token, \" \");\n                }\n            });\n        }\n\n        /**\n         * Determines if a node is an object type\n         * @param {ASTNode} node - The node to check.\n         * @returns {boolean} Whether or not the node is an object type.\n         */\n        function isObjectType(node) {\n            return node && (node.type === \"ObjectExpression\" || node.type === \"ObjectPattern\");\n        }\n\n        /**\n         * Determines if a node is an array type\n         * @param {ASTNode} node - The node to check.\n         * @returns {boolean} Whether or not the node is an array type.\n         */\n        function isArrayType(node) {\n            return node && (node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\");\n        }\n\n        /**\n         * Validates the spacing around array brackets\n         * @param {ASTNode} node - The node we're checking for spacing\n         * @returns {void}\n         */\n        function validateArraySpacing(node) {\n            if (options.spaced && node.elements.length === 0) {\n                return;\n            }\n\n            const first = sourceCode.getFirstToken(node),\n                second = sourceCode.getFirstToken(node, 1),\n                last = node.typeAnnotation\n                    ? sourceCode.getTokenBefore(node.typeAnnotation)\n                    : sourceCode.getLastToken(node),\n                penultimate = sourceCode.getTokenBefore(last),\n                firstElement = node.elements[0],\n                lastElement = node.elements[node.elements.length - 1];\n\n            const openingBracketMustBeSpaced =\n                options.objectsInArraysException && isObjectType(firstElement) ||\n                options.arraysInArraysException && isArrayType(firstElement) ||\n                options.singleElementException && node.elements.length === 1\n                    ? !options.spaced : options.spaced;\n\n            const closingBracketMustBeSpaced =\n                options.objectsInArraysException && isObjectType(lastElement) ||\n                options.arraysInArraysException && isArrayType(lastElement) ||\n                options.singleElementException && node.elements.length === 1\n                    ? !options.spaced : options.spaced;\n\n            if (astUtils.isTokenOnSameLine(first, second)) {\n                if (openingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(first, second)) {\n                    reportRequiredBeginningSpace(node, first);\n                }\n                if (!openingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(first, second)) {\n                    reportNoBeginningSpace(node, first);\n                }\n            }\n\n            if (first !== penultimate && astUtils.isTokenOnSameLine(penultimate, last)) {\n                if (closingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(penultimate, last)) {\n                    reportRequiredEndingSpace(node, last);\n                }\n                if (!closingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(penultimate, last)) {\n                    reportNoEndingSpace(node, last);\n                }\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ArrayPattern: validateArraySpacing,\n            ArrayExpression: validateArraySpacing\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce return statements in callbacks of array's methods\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\nconst TARGET_METHODS = /^(?:every|filter|find(?:Index)?|map|reduce(?:Right)?|some|sort)$/u;\n\n/**\n * Checks a given code path segment is reachable.\n *\n * @param {CodePathSegment} segment - A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Gets a readable location.\n *\n * - FunctionExpression -> the function name or `function` keyword.\n * - ArrowFunctionExpression -> `=>` token.\n *\n * @param {ASTNode} node - A function node to get.\n * @param {SourceCode} sourceCode - A source code to get tokens.\n * @returns {ASTNode|Token} The node or the token of a location.\n */\nfunction getLocation(node, sourceCode) {\n    if (node.type === \"ArrowFunctionExpression\") {\n        return sourceCode.getTokenBefore(node.body);\n    }\n    return node.id || node;\n}\n\n/**\n * Checks a given node is a MemberExpression node which has the specified name's\n * property.\n *\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a MemberExpression node which has\n *      the specified name's property\n */\nfunction isTargetMethod(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        TARGET_METHODS.test(astUtils.getStaticPropertyName(node) || \"\")\n    );\n}\n\n/**\n * Checks whether or not a given node is a function expression which is the\n * callback of an array method.\n *\n * @param {ASTNode} node - A node to check. This is one of\n *      FunctionExpression or ArrowFunctionExpression.\n * @returns {boolean} `true` if the node is the callback of an array method.\n */\nfunction isCallbackOfArrayMethod(node) {\n    let currentNode = node;\n\n    while (currentNode) {\n        const parent = currentNode.parent;\n\n        switch (parent.type) {\n\n            /*\n             * Looks up the destination. e.g.,\n             * foo.every(nativeFoo || function foo() { ... });\n             */\n            case \"LogicalExpression\":\n            case \"ConditionalExpression\":\n                currentNode = parent;\n                break;\n\n            /*\n             * If the upper function is IIFE, checks the destination of the return value.\n             * e.g.\n             *   foo.every((function() {\n             *     // setup...\n             *     return function callback() { ... };\n             *   })());\n             */\n            case \"ReturnStatement\": {\n                const func = astUtils.getUpperFunction(parent);\n\n                if (func === null || !astUtils.isCallee(func)) {\n                    return false;\n                }\n                currentNode = func.parent;\n                break;\n            }\n\n            /*\n             * e.g.\n             *   Array.from([], function() {});\n             *   list.every(function() {});\n             */\n            case \"CallExpression\":\n                if (astUtils.isArrayFromMethod(parent.callee)) {\n                    return (\n                        parent.arguments.length >= 2 &&\n                        parent.arguments[1] === currentNode\n                    );\n                }\n                if (isTargetMethod(parent.callee)) {\n                    return (\n                        parent.arguments.length >= 1 &&\n                        parent.arguments[0] === currentNode\n                    );\n                }\n                return false;\n\n            // Otherwise this node is not target.\n            default:\n                return false;\n        }\n    }\n\n    /* istanbul ignore next: unreachable */\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"enforce `return` statements in callbacks of array methods\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/array-callback-return\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowImplicit: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            expectedAtEnd: \"Expected to return a value at the end of {{name}}.\",\n            expectedInside: \"Expected to return a value in {{name}}.\",\n            expectedReturnValue: \"{{name}} expected a return value.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0] || { allowImplicit: false };\n\n        let funcInfo = {\n            upper: null,\n            codePath: null,\n            hasReturn: false,\n            shouldCheck: false,\n            node: null\n        };\n\n        /**\n         * Checks whether or not the last code path segment is reachable.\n         * Then reports this function if the segment is reachable.\n         *\n         * If the last code path segment is reachable, there are paths which are not\n         * returned or thrown.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {void}\n         */\n        function checkLastSegment(node) {\n            if (funcInfo.shouldCheck &&\n                funcInfo.codePath.currentSegments.some(isReachable)\n            ) {\n                context.report({\n                    node,\n                    loc: getLocation(node, context.getSourceCode()).loc.start,\n                    messageId: funcInfo.hasReturn\n                        ? \"expectedAtEnd\"\n                        : \"expectedInside\",\n                    data: {\n                        name: astUtils.getFunctionNameWithKind(funcInfo.node)\n                    }\n                });\n            }\n        }\n\n        return {\n\n            // Stacks this function's information.\n            onCodePathStart(codePath, node) {\n                funcInfo = {\n                    upper: funcInfo,\n                    codePath,\n                    hasReturn: false,\n                    shouldCheck:\n                        TARGET_NODE_TYPE.test(node.type) &&\n                        node.body.type === \"BlockStatement\" &&\n                        isCallbackOfArrayMethod(node) &&\n                        !node.async &&\n                        !node.generator,\n                    node\n                };\n            },\n\n            // Pops this function's information.\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n\n            // Checks the return statement is valid.\n            ReturnStatement(node) {\n                if (funcInfo.shouldCheck) {\n                    funcInfo.hasReturn = true;\n\n                    // if allowImplicit: false, should also check node.argument\n                    if (!options.allowImplicit && !node.argument) {\n                        context.report({\n                            node,\n                            messageId: \"expectedReturnValue\",\n                            data: {\n                                name: lodash.upperFirst(astUtils.getFunctionNameWithKind(funcInfo.node))\n                            }\n                        });\n                    }\n                }\n            },\n\n            // Reports a given function if the last path is reachable.\n            \"FunctionExpression:exit\": checkLastSegment,\n            \"ArrowFunctionExpression:exit\": checkLastSegment\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce line breaks after each array element\n * @author Jan Peer Stöcklmair <https://github.com/JPeer264>\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce line breaks after each array element\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/array-element-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\", \"consistent\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            multiline: {\n                                type: \"boolean\"\n                            },\n                            minItems: {\n                                type: [\"integer\", \"null\"],\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unexpectedLineBreak: \"There should be no linebreak here.\",\n            missingLineBreak: \"There should be a linebreak after this element.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Normalizes a given option value.\n         *\n         * @param {string|Object|undefined} providedOption - An option value to parse.\n         * @returns {{multiline: boolean, minItems: number}} Normalized option object.\n         */\n        function normalizeOptionValue(providedOption) {\n            let consistent = false;\n            let multiline = false;\n            let minItems;\n\n            const option = providedOption || \"always\";\n\n            if (!option || option === \"always\" || option.minItems === 0) {\n                minItems = 0;\n            } else if (option === \"never\") {\n                minItems = Number.POSITIVE_INFINITY;\n            } else if (option === \"consistent\") {\n                consistent = true;\n                minItems = Number.POSITIVE_INFINITY;\n            } else {\n                multiline = Boolean(option.multiline);\n                minItems = option.minItems || Number.POSITIVE_INFINITY;\n            }\n\n            return { consistent, multiline, minItems };\n        }\n\n        /**\n         * Normalizes a given option value.\n         *\n         * @param {string|Object|undefined} options - An option value to parse.\n         * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.\n         */\n        function normalizeOptions(options) {\n            const value = normalizeOptionValue(options);\n\n            return { ArrayExpression: value, ArrayPattern: value };\n        }\n\n        /**\n         * Reports that there shouldn't be a line break after the first token\n         * @param {Token} token - The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoLineBreak(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });\n\n            context.report({\n                loc: {\n                    start: tokenBefore.loc.end,\n                    end: token.loc.start\n                },\n                messageId: \"unexpectedLineBreak\",\n                fix(fixer) {\n                    if (astUtils.isCommentToken(tokenBefore)) {\n                        return null;\n                    }\n\n                    if (!astUtils.isTokenOnSameLine(tokenBefore, token)) {\n                        return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \" \");\n                    }\n\n                    /*\n                     * This will check if the comma is on the same line as the next element\n                     * Following array:\n                     * [\n                     *     1\n                     *     , 2\n                     *     , 3\n                     * ]\n                     *\n                     * will be fixed to:\n                     * [\n                     *     1, 2, 3\n                     * ]\n                     */\n                    const twoTokensBefore = sourceCode.getTokenBefore(tokenBefore, { includeComments: true });\n\n                    if (astUtils.isCommentToken(twoTokensBefore)) {\n                        return null;\n                    }\n\n                    return fixer.replaceTextRange([twoTokensBefore.range[1], tokenBefore.range[0]], \"\");\n\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a line break after the first token\n         * @param {Token} token - The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredLineBreak(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });\n\n            context.report({\n                loc: {\n                    start: tokenBefore.loc.end,\n                    end: token.loc.start\n                },\n                messageId: \"missingLineBreak\",\n                fix(fixer) {\n                    return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \"\\n\");\n                }\n            });\n        }\n\n        /**\n         * Reports a given node if it violated this rule.\n         *\n         * @param {ASTNode} node - A node to check. This is an ObjectExpression node or an ObjectPattern node.\n         * @returns {void}\n         */\n        function check(node) {\n            const elements = node.elements;\n            const normalizedOptions = normalizeOptions(context.options[0]);\n            const options = normalizedOptions[node.type];\n\n            let elementBreak = false;\n\n            /*\n             * MULTILINE: true\n             * loop through every element and check\n             * if at least one element has linebreaks inside\n             * this ensures that following is not valid (due to elements are on the same line):\n             *\n             * [\n             *      1,\n             *      2,\n             *      3\n             * ]\n             */\n            if (options.multiline) {\n                elementBreak = elements\n                    .filter(element => element !== null)\n                    .some(element => element.loc.start.line !== element.loc.end.line);\n            }\n\n            const linebreaksCount = node.elements.map((element, i) => {\n                const previousElement = elements[i - 1];\n\n                if (i === 0 || element === null || previousElement === null) {\n                    return false;\n                }\n\n                const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\n                const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\n                const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\n\n                return !astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement);\n            }).filter(isBreak => isBreak === true).length;\n\n            const needsLinebreaks = (\n                elements.length >= options.minItems ||\n                (\n                    options.multiline &&\n                    elementBreak\n                ) ||\n                (\n                    options.consistent &&\n                    linebreaksCount > 0 &&\n                    linebreaksCount < node.elements.length\n                )\n            );\n\n            elements.forEach((element, i) => {\n                const previousElement = elements[i - 1];\n\n                if (i === 0 || element === null || previousElement === null) {\n                    return;\n                }\n\n                const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\n                const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\n                const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\n\n                if (needsLinebreaks) {\n                    if (astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n                        reportRequiredLineBreak(firstTokenOfCurrentElement);\n                    }\n                } else {\n                    if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n                        reportNoLineBreak(firstTokenOfCurrentElement);\n                    }\n                }\n            });\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            ArrayPattern: check,\n            ArrayExpression: check\n        };\n    }\n};\n","/**\n * @fileoverview Rule to require braces in arrow function body.\n * @author Alberto Rodríguez\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require braces around arrow function bodies\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/arrow-body-style\"\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"never\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"as-needed\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                requireReturnForObjectLiteral: { type: \"boolean\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        fixable: \"code\",\n\n        messages: {\n            unexpectedOtherBlock: \"Unexpected block statement surrounding arrow body.\",\n            unexpectedEmptyBlock: \"Unexpected block statement surrounding arrow body; put a value of `undefined` immediately after the `=>`.\",\n            unexpectedObjectBlock: \"Unexpected block statement surrounding arrow body; parenthesize the returned value and move it immediately after the `=>`.\",\n            unexpectedSingleBlock: \"Unexpected block statement surrounding arrow body; move the returned value immediately after the `=>`.\",\n            expectedBlock: \"Expected block statement surrounding arrow body.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options;\n        const always = options[0] === \"always\";\n        const asNeeded = !options[0] || options[0] === \"as-needed\";\n        const never = options[0] === \"never\";\n        const requireReturnForObjectLiteral = options[1] && options[1].requireReturnForObjectLiteral;\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Checks whether the given node has ASI problem or not.\n         * @param {Token} token The token to check.\n         * @returns {boolean} `true` if it changes semantics if `;` or `}` followed by the token are removed.\n         */\n        function hasASIProblem(token) {\n            return token && token.type === \"Punctuator\" && /^[([/`+-]/u.test(token.value);\n        }\n\n        /**\n         * Gets the closing parenthesis which is the pair of the given opening parenthesis.\n         * @param {Token} token The opening parenthesis token to get.\n         * @returns {Token} The found closing parenthesis token.\n         */\n        function findClosingParen(token) {\n            let node = sourceCode.getNodeByRangeIndex(token.range[1]);\n\n            while (!astUtils.isParenthesised(sourceCode, node)) {\n                node = node.parent;\n            }\n            return sourceCode.getTokenAfter(node);\n        }\n\n        /**\n         * Determines whether a arrow function body needs braces\n         * @param {ASTNode} node The arrow function node.\n         * @returns {void}\n         */\n        function validate(node) {\n            const arrowBody = node.body;\n\n            if (arrowBody.type === \"BlockStatement\") {\n                const blockBody = arrowBody.body;\n\n                if (blockBody.length !== 1 && !never) {\n                    return;\n                }\n\n                if (asNeeded && requireReturnForObjectLiteral && blockBody[0].type === \"ReturnStatement\" &&\n                    blockBody[0].argument && blockBody[0].argument.type === \"ObjectExpression\") {\n                    return;\n                }\n\n                if (never || asNeeded && blockBody[0].type === \"ReturnStatement\") {\n                    let messageId;\n\n                    if (blockBody.length === 0) {\n                        messageId = \"unexpectedEmptyBlock\";\n                    } else if (blockBody.length > 1) {\n                        messageId = \"unexpectedOtherBlock\";\n                    } else if (blockBody[0].argument === null) {\n                        messageId = \"unexpectedSingleBlock\";\n                    } else if (astUtils.isOpeningBraceToken(sourceCode.getFirstToken(blockBody[0], { skip: 1 }))) {\n                        messageId = \"unexpectedObjectBlock\";\n                    } else {\n                        messageId = \"unexpectedSingleBlock\";\n                    }\n\n                    context.report({\n                        node,\n                        loc: arrowBody.loc.start,\n                        messageId,\n                        fix(fixer) {\n                            const fixes = [];\n\n                            if (blockBody.length !== 1 ||\n                                blockBody[0].type !== \"ReturnStatement\" ||\n                                !blockBody[0].argument ||\n                                hasASIProblem(sourceCode.getTokenAfter(arrowBody))\n                            ) {\n                                return fixes;\n                            }\n\n                            const openingBrace = sourceCode.getFirstToken(arrowBody);\n                            const closingBrace = sourceCode.getLastToken(arrowBody);\n                            const firstValueToken = sourceCode.getFirstToken(blockBody[0], 1);\n                            const lastValueToken = sourceCode.getLastToken(blockBody[0]);\n                            const commentsExist =\n                                sourceCode.commentsExistBetween(openingBrace, firstValueToken) ||\n                                sourceCode.commentsExistBetween(lastValueToken, closingBrace);\n\n                            /*\n                             * Remove tokens around the return value.\n                             * If comments don't exist, remove extra spaces as well.\n                             */\n                            if (commentsExist) {\n                                fixes.push(\n                                    fixer.remove(openingBrace),\n                                    fixer.remove(closingBrace),\n                                    fixer.remove(sourceCode.getTokenAfter(openingBrace)) // return keyword\n                                );\n                            } else {\n                                fixes.push(\n                                    fixer.removeRange([openingBrace.range[0], firstValueToken.range[0]]),\n                                    fixer.removeRange([lastValueToken.range[1], closingBrace.range[1]])\n                                );\n                            }\n\n                            /*\n                             * If the first token of the reutrn value is `{`,\n                             * enclose the return value by parentheses to avoid syntax error.\n                             */\n                            if (astUtils.isOpeningBraceToken(firstValueToken)) {\n                                fixes.push(\n                                    fixer.insertTextBefore(firstValueToken, \"(\"),\n                                    fixer.insertTextAfter(lastValueToken, \")\")\n                                );\n                            }\n\n                            /*\n                             * If the last token of the return statement is semicolon, remove it.\n                             * Non-block arrow body is an expression, not a statement.\n                             */\n                            if (astUtils.isSemicolonToken(lastValueToken)) {\n                                fixes.push(fixer.remove(lastValueToken));\n                            }\n\n                            return fixes;\n                        }\n                    });\n                }\n            } else {\n                if (always || (asNeeded && requireReturnForObjectLiteral && arrowBody.type === \"ObjectExpression\")) {\n                    context.report({\n                        node,\n                        loc: arrowBody.loc.start,\n                        messageId: \"expectedBlock\",\n                        fix(fixer) {\n                            const fixes = [];\n                            const arrowToken = sourceCode.getTokenBefore(arrowBody, astUtils.isArrowToken);\n                            const firstBodyToken = sourceCode.getTokenAfter(arrowToken);\n                            const lastBodyToken = sourceCode.getLastToken(node);\n                            const isParenthesisedObjectLiteral =\n                                astUtils.isOpeningParenToken(firstBodyToken) &&\n                                astUtils.isOpeningBraceToken(sourceCode.getTokenAfter(firstBodyToken));\n\n                            // Wrap the value by a block and a return statement.\n                            fixes.push(\n                                fixer.insertTextBefore(firstBodyToken, \"{return \"),\n                                fixer.insertTextAfter(lastBodyToken, \"}\")\n                            );\n\n                            // If the value is object literal, remove parentheses which were forced by syntax.\n                            if (isParenthesisedObjectLiteral) {\n                                fixes.push(\n                                    fixer.remove(firstBodyToken),\n                                    fixer.remove(findClosingParen(firstBodyToken))\n                                );\n                            }\n\n                            return fixes;\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            \"ArrowFunctionExpression:exit\": validate\n        };\n    }\n};\n","/**\n * @fileoverview Rule to require parens in arrow function arguments.\n * @author Jxck\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require parentheses around arrow function arguments\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/arrow-parens\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                enum: [\"always\", \"as-needed\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    requireForBlockBody: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedParens: \"Unexpected parentheses around single function argument.\",\n            expectedParens: \"Expected parentheses around arrow function argument.\",\n\n            unexpectedParensInline: \"Unexpected parentheses around single function argument having a body with no curly braces.\",\n            expectedParensBlock: \"Expected parentheses around arrow function argument having a body with curly braces.\"\n        }\n    },\n\n    create(context) {\n        const asNeeded = context.options[0] === \"as-needed\";\n        const requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether a arrow function argument end with `)`\n         * @param {ASTNode} node The arrow function node.\n         * @returns {void}\n         */\n        function parens(node) {\n            const isAsync = node.async;\n            const firstTokenOfParam = sourceCode.getFirstToken(node, isAsync ? 1 : 0);\n\n            /**\n             * Remove the parenthesis around a parameter\n             * @param {Fixer} fixer Fixer\n             * @returns {string} fixed parameter\n             */\n            function fixParamsWithParenthesis(fixer) {\n                const paramToken = sourceCode.getTokenAfter(firstTokenOfParam);\n\n                /*\n                 * ES8 allows Trailing commas in function parameter lists and calls\n                 * https://github.com/eslint/eslint/issues/8834\n                 */\n                const closingParenToken = sourceCode.getTokenAfter(paramToken, astUtils.isClosingParenToken);\n                const asyncToken = isAsync ? sourceCode.getTokenBefore(firstTokenOfParam) : null;\n                const shouldAddSpaceForAsync = asyncToken && (asyncToken.range[1] === firstTokenOfParam.range[0]);\n\n                return fixer.replaceTextRange([\n                    firstTokenOfParam.range[0],\n                    closingParenToken.range[1]\n                ], `${shouldAddSpaceForAsync ? \" \" : \"\"}${paramToken.value}`);\n            }\n\n            // \"as-needed\", { \"requireForBlockBody\": true }: x => x\n            if (\n                requireForBlockBody &&\n                node.params.length === 1 &&\n                node.params[0].type === \"Identifier\" &&\n                !node.params[0].typeAnnotation &&\n                node.body.type !== \"BlockStatement\" &&\n                !node.returnType\n            ) {\n                if (astUtils.isOpeningParenToken(firstTokenOfParam)) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedParensInline\",\n                        fix: fixParamsWithParenthesis\n                    });\n                }\n                return;\n            }\n\n            if (\n                requireForBlockBody &&\n                node.body.type === \"BlockStatement\"\n            ) {\n                if (!astUtils.isOpeningParenToken(firstTokenOfParam)) {\n                    context.report({\n                        node,\n                        messageId: \"expectedParensBlock\",\n                        fix(fixer) {\n                            return fixer.replaceText(firstTokenOfParam, `(${firstTokenOfParam.value})`);\n                        }\n                    });\n                }\n                return;\n            }\n\n            // \"as-needed\": x => x\n            if (asNeeded &&\n                node.params.length === 1 &&\n                node.params[0].type === \"Identifier\" &&\n                !node.params[0].typeAnnotation &&\n                !node.returnType\n            ) {\n                if (astUtils.isOpeningParenToken(firstTokenOfParam)) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedParens\",\n                        fix: fixParamsWithParenthesis\n                    });\n                }\n                return;\n            }\n\n            if (firstTokenOfParam.type === \"Identifier\") {\n                const after = sourceCode.getTokenAfter(firstTokenOfParam);\n\n                // (x) => x\n                if (after.value !== \")\") {\n                    context.report({\n                        node,\n                        messageId: \"expectedParens\",\n                        fix(fixer) {\n                            return fixer.replaceText(firstTokenOfParam, `(${firstTokenOfParam.value})`);\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: parens\n        };\n    }\n};\n","/**\n * @fileoverview Rule to define spacing before/after arrow function's arrow.\n * @author Jxck\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before and after the arrow in arrow functions\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/arrow-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    after: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            expectedBefore: \"Missing space before =>.\",\n            unexpectedBefore: \"Unexpected space before =>.\",\n\n            expectedAfter: \"Missing space after =>.\",\n            unexpectedAfter: \"Unexpected space after =>.\"\n        }\n    },\n\n    create(context) {\n\n        // merge rules with default\n        const rule = Object.assign({}, context.options[0]);\n\n        rule.before = rule.before !== false;\n        rule.after = rule.after !== false;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Get tokens of arrow(`=>`) and before/after arrow.\n         * @param {ASTNode} node The arrow function node.\n         * @returns {Object} Tokens of arrow and before/after arrow.\n         */\n        function getTokens(node) {\n            const arrow = sourceCode.getTokenBefore(node.body, astUtils.isArrowToken);\n\n            return {\n                before: sourceCode.getTokenBefore(arrow),\n                arrow,\n                after: sourceCode.getTokenAfter(arrow)\n            };\n        }\n\n        /**\n         * Count spaces before/after arrow(`=>`) token.\n         * @param {Object} tokens Tokens before/after arrow.\n         * @returns {Object} count of space before/after arrow.\n         */\n        function countSpaces(tokens) {\n            const before = tokens.arrow.range[0] - tokens.before.range[1];\n            const after = tokens.after.range[0] - tokens.arrow.range[1];\n\n            return { before, after };\n        }\n\n        /**\n         * Determines whether space(s) before after arrow(`=>`) is satisfy rule.\n         * if before/after value is `true`, there should be space(s).\n         * if before/after value is `false`, there should be no space.\n         * @param {ASTNode} node The arrow function node.\n         * @returns {void}\n         */\n        function spaces(node) {\n            const tokens = getTokens(node);\n            const countSpace = countSpaces(tokens);\n\n            if (rule.before) {\n\n                // should be space(s) before arrow\n                if (countSpace.before === 0) {\n                    context.report({\n                        node: tokens.before,\n                        messageId: \"expectedBefore\",\n                        fix(fixer) {\n                            return fixer.insertTextBefore(tokens.arrow, \" \");\n                        }\n                    });\n                }\n            } else {\n\n                // should be no space before arrow\n                if (countSpace.before > 0) {\n                    context.report({\n                        node: tokens.before,\n                        messageId: \"unexpectedBefore\",\n                        fix(fixer) {\n                            return fixer.removeRange([tokens.before.range[1], tokens.arrow.range[0]]);\n                        }\n                    });\n                }\n            }\n\n            if (rule.after) {\n\n                // should be space(s) after arrow\n                if (countSpace.after === 0) {\n                    context.report({\n                        node: tokens.after,\n                        messageId: \"expectedAfter\",\n                        fix(fixer) {\n                            return fixer.insertTextAfter(tokens.arrow, \" \");\n                        }\n                    });\n                }\n            } else {\n\n                // should be no space after arrow\n                if (countSpace.after > 0) {\n                    context.report({\n                        node: tokens.after,\n                        messageId: \"unexpectedAfter\",\n                        fix(fixer) {\n                            return fixer.removeRange([tokens.arrow.range[1], tokens.after.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: spaces\n        };\n    }\n};\n","/**\n * @fileoverview Rule to check for \"block scoped\" variables by binding context\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce the use of variables within the scope they are defined\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/block-scoped-var\"\n        },\n\n        schema: [],\n\n        messages: {\n            outOfScope: \"'{{name}}' used outside of binding context.\"\n        }\n    },\n\n    create(context) {\n        let stack = [];\n\n        /**\n         * Makes a block scope.\n         * @param {ASTNode} node - A node of a scope.\n         * @returns {void}\n         */\n        function enterScope(node) {\n            stack.push(node.range);\n        }\n\n        /**\n         * Pops the last block scope.\n         * @returns {void}\n         */\n        function exitScope() {\n            stack.pop();\n        }\n\n        /**\n         * Reports a given reference.\n         * @param {eslint-scope.Reference} reference - A reference to report.\n         * @returns {void}\n         */\n        function report(reference) {\n            const identifier = reference.identifier;\n\n            context.report({ node: identifier, messageId: \"outOfScope\", data: { name: identifier.name } });\n        }\n\n        /**\n         * Finds and reports references which are outside of valid scopes.\n         * @param {ASTNode} node - A node to get variables.\n         * @returns {void}\n         */\n        function checkForVariables(node) {\n            if (node.kind !== \"var\") {\n                return;\n            }\n\n            // Defines a predicate to check whether or not a given reference is outside of valid scope.\n            const scopeRange = stack[stack.length - 1];\n\n            /**\n             * Check if a reference is out of scope\n             * @param {ASTNode} reference node to examine\n             * @returns {boolean} True is its outside the scope\n             * @private\n             */\n            function isOutsideOfScope(reference) {\n                const idRange = reference.identifier.range;\n\n                return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];\n            }\n\n            // Gets declared variables, and checks its references.\n            const variables = context.getDeclaredVariables(node);\n\n            for (let i = 0; i < variables.length; ++i) {\n\n                // Reports.\n                variables[i]\n                    .references\n                    .filter(isOutsideOfScope)\n                    .forEach(report);\n            }\n        }\n\n        return {\n            Program(node) {\n                stack = [node.range];\n            },\n\n            // Manages scopes.\n            BlockStatement: enterScope,\n            \"BlockStatement:exit\": exitScope,\n            ForStatement: enterScope,\n            \"ForStatement:exit\": exitScope,\n            ForInStatement: enterScope,\n            \"ForInStatement:exit\": exitScope,\n            ForOfStatement: enterScope,\n            \"ForOfStatement:exit\": exitScope,\n            SwitchStatement: enterScope,\n            \"SwitchStatement:exit\": exitScope,\n            CatchClause: enterScope,\n            \"CatchClause:exit\": exitScope,\n\n            // Finds and reports references which are outside of valid scope.\n            VariableDeclaration: checkForVariables\n        };\n\n    }\n};\n","/**\n * @fileoverview A rule to disallow or enforce spaces inside of single line blocks.\n * @author Toru Nagashima\n */\n\n\n\nconst util = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow or enforce spaces inside of blocks after opening block and before closing block\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/block-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            { enum: [\"always\", \"never\"] }\n        ],\n\n        messages: {\n            missing: \"Requires a space {{location}} '{{token}}'.\",\n            extra: \"Unexpected space(s) {{location}} '{{token}}'.\"\n        }\n    },\n\n    create(context) {\n        const always = (context.options[0] !== \"never\"),\n            messageId = always ? \"missing\" : \"extra\",\n            sourceCode = context.getSourceCode();\n\n        /**\n         * Gets the open brace token from a given node.\n         * @param {ASTNode} node - A BlockStatement/SwitchStatement node to get.\n         * @returns {Token} The token of the open brace.\n         */\n        function getOpenBrace(node) {\n            if (node.type === \"SwitchStatement\") {\n                if (node.cases.length > 0) {\n                    return sourceCode.getTokenBefore(node.cases[0]);\n                }\n                return sourceCode.getLastToken(node, 1);\n            }\n            return sourceCode.getFirstToken(node);\n        }\n\n        /**\n         * Checks whether or not:\n         *   - given tokens are on same line.\n         *   - there is/isn't a space between given tokens.\n         * @param {Token} left - A token to check.\n         * @param {Token} right - The token which is next to `left`.\n         * @returns {boolean}\n         *    When the option is `\"always\"`, `true` if there are one or more spaces between given tokens.\n         *    When the option is `\"never\"`, `true` if there are not any spaces between given tokens.\n         *    If given tokens are not on same line, it's always `true`.\n         */\n        function isValid(left, right) {\n            return (\n                !util.isTokenOnSameLine(left, right) ||\n                sourceCode.isSpaceBetweenTokens(left, right) === always\n            );\n        }\n\n        /**\n         * Reports invalid spacing style inside braces.\n         * @param {ASTNode} node - A BlockStatement/SwitchStatement node to get.\n         * @returns {void}\n         */\n        function checkSpacingInsideBraces(node) {\n\n            // Gets braces and the first/last token of content.\n            const openBrace = getOpenBrace(node);\n            const closeBrace = sourceCode.getLastToken(node);\n            const firstToken = sourceCode.getTokenAfter(openBrace, { includeComments: true });\n            const lastToken = sourceCode.getTokenBefore(closeBrace, { includeComments: true });\n\n            // Skip if the node is invalid or empty.\n            if (openBrace.type !== \"Punctuator\" ||\n                openBrace.value !== \"{\" ||\n                closeBrace.type !== \"Punctuator\" ||\n                closeBrace.value !== \"}\" ||\n                firstToken === closeBrace\n            ) {\n                return;\n            }\n\n            // Skip line comments for option never\n            if (!always && firstToken.type === \"Line\") {\n                return;\n            }\n\n            // Check.\n            if (!isValid(openBrace, firstToken)) {\n                context.report({\n                    node,\n                    loc: openBrace.loc.start,\n                    messageId,\n                    data: {\n                        location: \"after\",\n                        token: openBrace.value\n                    },\n                    fix(fixer) {\n                        if (always) {\n                            return fixer.insertTextBefore(firstToken, \" \");\n                        }\n\n                        return fixer.removeRange([openBrace.range[1], firstToken.range[0]]);\n                    }\n                });\n            }\n            if (!isValid(lastToken, closeBrace)) {\n                context.report({\n                    node,\n                    loc: closeBrace.loc.start,\n                    messageId,\n                    data: {\n                        location: \"before\",\n                        token: closeBrace.value\n                    },\n                    fix(fixer) {\n                        if (always) {\n                            return fixer.insertTextAfter(lastToken, \" \");\n                        }\n\n                        return fixer.removeRange([lastToken.range[1], closeBrace.range[0]]);\n                    }\n                });\n            }\n        }\n\n        return {\n            BlockStatement: checkSpacingInsideBraces,\n            SwitchStatement: checkSpacingInsideBraces\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag block statements that do not use the one true brace style\n * @author Ian Christian Myers\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent brace style for blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/brace-style\"\n        },\n\n        schema: [\n            {\n                enum: [\"1tbs\", \"stroustrup\", \"allman\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    allowSingleLine: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"whitespace\",\n\n        messages: {\n            nextLineOpen: \"Opening curly brace does not appear on the same line as controlling statement.\",\n            sameLineOpen: \"Opening curly brace appears on the same line as controlling statement.\",\n            blockSameLine: \"Statement inside of curly braces should be on next line.\",\n            nextLineClose: \"Closing curly brace does not appear on the same line as the subsequent block.\",\n            singleLineClose: \"Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.\",\n            sameLineClose: \"Closing curly brace appears on the same line as the subsequent block.\"\n        }\n    },\n\n    create(context) {\n        const style = context.options[0] || \"1tbs\",\n            params = context.options[1] || {},\n            sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Fixes a place where a newline unexpectedly appears\n         * @param {Token} firstToken The token before the unexpected newline\n         * @param {Token} secondToken The token after the unexpected newline\n         * @returns {Function} A fixer function to remove the newlines between the tokens\n         */\n        function removeNewlineBetween(firstToken, secondToken) {\n            const textRange = [firstToken.range[1], secondToken.range[0]];\n            const textBetween = sourceCode.text.slice(textRange[0], textRange[1]);\n\n            // Don't do a fix if there is a comment between the tokens\n            if (textBetween.trim()) {\n                return null;\n            }\n            return fixer => fixer.replaceTextRange(textRange, \" \");\n        }\n\n        /**\n         * Validates a pair of curly brackets based on the user's config\n         * @param {Token} openingCurly The opening curly bracket\n         * @param {Token} closingCurly The closing curly bracket\n         * @returns {void}\n         */\n        function validateCurlyPair(openingCurly, closingCurly) {\n            const tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurly);\n            const tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurly);\n            const tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurly);\n            const singleLineException = params.allowSingleLine && astUtils.isTokenOnSameLine(openingCurly, closingCurly);\n\n            if (style !== \"allman\" && !astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly)) {\n                context.report({\n                    node: openingCurly,\n                    messageId: \"nextLineOpen\",\n                    fix: removeNewlineBetween(tokenBeforeOpeningCurly, openingCurly)\n                });\n            }\n\n            if (style === \"allman\" && astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly) && !singleLineException) {\n                context.report({\n                    node: openingCurly,\n                    messageId: \"sameLineOpen\",\n                    fix: fixer => fixer.insertTextBefore(openingCurly, \"\\n\")\n                });\n            }\n\n            if (astUtils.isTokenOnSameLine(openingCurly, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurly && !singleLineException) {\n                context.report({\n                    node: openingCurly,\n                    messageId: \"blockSameLine\",\n                    fix: fixer => fixer.insertTextAfter(openingCurly, \"\\n\")\n                });\n            }\n\n            if (tokenBeforeClosingCurly !== openingCurly && !singleLineException && astUtils.isTokenOnSameLine(tokenBeforeClosingCurly, closingCurly)) {\n                context.report({\n                    node: closingCurly,\n                    messageId: \"singleLineClose\",\n                    fix: fixer => fixer.insertTextBefore(closingCurly, \"\\n\")\n                });\n            }\n        }\n\n        /**\n         * Validates the location of a token that appears before a keyword (e.g. a newline before `else`)\n         * @param {Token} curlyToken The closing curly token. This is assumed to precede a keyword token (such as `else` or `finally`).\n         * @returns {void}\n         */\n        function validateCurlyBeforeKeyword(curlyToken) {\n            const keywordToken = sourceCode.getTokenAfter(curlyToken);\n\n            if (style === \"1tbs\" && !astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n                context.report({\n                    node: curlyToken,\n                    messageId: \"nextLineClose\",\n                    fix: removeNewlineBetween(curlyToken, keywordToken)\n                });\n            }\n\n            if (style !== \"1tbs\" && astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n                context.report({\n                    node: curlyToken,\n                    messageId: \"sameLineClose\",\n                    fix: fixer => fixer.insertTextAfter(curlyToken, \"\\n\")\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            BlockStatement(node) {\n                if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n                    validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n                }\n            },\n            ClassBody(node) {\n                validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n            },\n            SwitchStatement(node) {\n                const closingCurly = sourceCode.getLastToken(node);\n                const openingCurly = sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closingCurly);\n\n                validateCurlyPair(openingCurly, closingCurly);\n            },\n            IfStatement(node) {\n                if (node.consequent.type === \"BlockStatement\" && node.alternate) {\n\n                    // Handle the keyword after the `if` block (before `else`)\n                    validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));\n                }\n            },\n            TryStatement(node) {\n\n                // Handle the keyword after the `try` block (before `catch` or `finally`)\n                validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));\n\n                if (node.handler && node.finalizer) {\n\n                    // Handle the keyword after the `catch` block (before `finally`)\n                    validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Enforce return after a callback.\n * @author Jamund Ferguson\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `return` statements after callbacks\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/callback-return\"\n        },\n\n        schema: [{\n            type: \"array\",\n            items: { type: \"string\" }\n        }],\n\n        messages: {\n            missingReturn: \"Expected return with your callback function.\"\n        }\n    },\n\n    create(context) {\n\n        const callbacks = context.options[0] || [\"callback\", \"cb\", \"next\"],\n            sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Find the closest parent matching a list of types.\n         * @param {ASTNode} node The node whose parents we are searching\n         * @param {Array} types The node types to match\n         * @returns {ASTNode} The matched node or undefined.\n         */\n        function findClosestParentOfType(node, types) {\n            if (!node.parent) {\n                return null;\n            }\n            if (types.indexOf(node.parent.type) === -1) {\n                return findClosestParentOfType(node.parent, types);\n            }\n            return node.parent;\n        }\n\n        /**\n         * Check to see if a node contains only identifers\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} Whether or not the node contains only identifers\n         */\n        function containsOnlyIdentifiers(node) {\n            if (node.type === \"Identifier\") {\n                return true;\n            }\n\n            if (node.type === \"MemberExpression\") {\n                if (node.object.type === \"Identifier\") {\n                    return true;\n                }\n                if (node.object.type === \"MemberExpression\") {\n                    return containsOnlyIdentifiers(node.object);\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Check to see if a CallExpression is in our callback list.\n         * @param {ASTNode} node The node to check against our callback names list.\n         * @returns {boolean} Whether or not this function matches our callback name.\n         */\n        function isCallback(node) {\n            return containsOnlyIdentifiers(node.callee) && callbacks.indexOf(sourceCode.getText(node.callee)) > -1;\n        }\n\n        /**\n         * Determines whether or not the callback is part of a callback expression.\n         * @param {ASTNode} node The callback node\n         * @param {ASTNode} parentNode The expression node\n         * @returns {boolean} Whether or not this is part of a callback expression\n         */\n        function isCallbackExpression(node, parentNode) {\n\n            // ensure the parent node exists and is an expression\n            if (!parentNode || parentNode.type !== \"ExpressionStatement\") {\n                return false;\n            }\n\n            // cb()\n            if (parentNode.expression === node) {\n                return true;\n            }\n\n            // special case for cb && cb() and similar\n            if (parentNode.expression.type === \"BinaryExpression\" || parentNode.expression.type === \"LogicalExpression\") {\n                if (parentNode.expression.right === node) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            CallExpression(node) {\n\n                // if we're not a callback we can return\n                if (!isCallback(node)) {\n                    return;\n                }\n\n                // find the closest block, return or loop\n                const closestBlock = findClosestParentOfType(node, [\"BlockStatement\", \"ReturnStatement\", \"ArrowFunctionExpression\"]) || {};\n\n                // if our parent is a return we know we're ok\n                if (closestBlock.type === \"ReturnStatement\") {\n                    return;\n                }\n\n                // arrow functions don't always have blocks and implicitly return\n                if (closestBlock.type === \"ArrowFunctionExpression\") {\n                    return;\n                }\n\n                // block statements are part of functions and most if statements\n                if (closestBlock.type === \"BlockStatement\") {\n\n                    // find the last item in the block\n                    const lastItem = closestBlock.body[closestBlock.body.length - 1];\n\n                    // if the callback is the last thing in a block that might be ok\n                    if (isCallbackExpression(node, lastItem)) {\n\n                        const parentType = closestBlock.parent.type;\n\n                        // but only if the block is part of a function\n                        if (parentType === \"FunctionExpression\" ||\n                            parentType === \"FunctionDeclaration\" ||\n                            parentType === \"ArrowFunctionExpression\"\n                        ) {\n                            return;\n                        }\n\n                    }\n\n                    // ending a block with a return is also ok\n                    if (lastItem.type === \"ReturnStatement\") {\n\n                        // but only if the callback is immediately before\n                        if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {\n                            return;\n                        }\n                    }\n\n                }\n\n                // as long as you're the child of a function at this point you should be asked to return\n                if (findClosestParentOfType(node, [\"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n                    context.report({ node, messageId: \"missingReturn\" });\n                }\n\n            }\n\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag non-camelcased identifiers\n * @author Nicholas C. Zakas\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce camelcase naming convention\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/camelcase\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreDestructuring: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    properties: {\n                        enum: [\"always\", \"never\"]\n                    },\n                    allow: {\n                        type: \"array\",\n                        items: [\n                            {\n                                type: \"string\"\n                            }\n                        ],\n                        minItems: 0,\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            notCamelCase: \"Identifier '{{name}}' is not in camel case.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0] || {};\n        let properties = options.properties || \"\";\n        const ignoreDestructuring = options.ignoreDestructuring;\n        const allow = options.allow || [];\n\n        if (properties !== \"always\" && properties !== \"never\") {\n            properties = \"always\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\n        const reported = [];\n        const ALLOWED_PARENT_TYPES = new Set([\"CallExpression\", \"NewExpression\"]);\n\n        /**\n         * Checks if a string contains an underscore and isn't all upper-case\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is underscored\n         * @private\n         */\n        function isUnderscored(name) {\n\n            // if there's an underscore, it might be A_CONSTANT, which is okay\n            return name.indexOf(\"_\") > -1 && name !== name.toUpperCase();\n        }\n\n        /**\n         * Checks if a string match the ignore list\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is ignored\n         * @private\n         */\n        function isAllowed(name) {\n            return allow.findIndex(\n                entry => name === entry || name.match(new RegExp(entry)) // eslint-disable-line require-unicode-regexp\n            ) !== -1;\n        }\n\n        /**\n         * Checks if a parent of a node is an ObjectPattern.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} if the node is inside an ObjectPattern\n         * @private\n         */\n        function isInsideObjectPattern(node) {\n            let current = node;\n\n            while (current) {\n                const parent = current.parent;\n\n                if (parent && parent.type === \"Property\" && parent.computed && parent.key === current) {\n                    return false;\n                }\n\n                if (current.type === \"ObjectPattern\") {\n                    return true;\n                }\n\n                current = parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            if (reported.indexOf(node) < 0) {\n                reported.push(node);\n                context.report({ node, messageId: \"notCamelCase\", data: { name: node.name } });\n            }\n        }\n\n        return {\n\n            Identifier(node) {\n\n                /*\n                 * Leading and trailing underscores are commonly used to flag\n                 * private/protected identifiers, strip them before checking if underscored\n                 */\n                const name = node.name,\n                    nameIsUnderscored = isUnderscored(name.replace(/^_+|_+$/gu, \"\")),\n                    effectiveParent = (node.parent.type === \"MemberExpression\") ? node.parent.parent : node.parent;\n\n                // First, we ignore the node if it match the ignore list\n                if (isAllowed(name)) {\n                    return;\n                }\n\n                // MemberExpressions get special rules\n                if (node.parent.type === \"MemberExpression\") {\n\n                    // \"never\" check properties\n                    if (properties === \"never\") {\n                        return;\n                    }\n\n                    // Always report underscored object names\n                    if (node.parent.object.type === \"Identifier\" && node.parent.object.name === node.name && nameIsUnderscored) {\n                        report(node);\n\n                    // Report AssignmentExpressions only if they are the left side of the assignment\n                    } else if (effectiveParent.type === \"AssignmentExpression\" && nameIsUnderscored && (effectiveParent.right.type !== \"MemberExpression\" || effectiveParent.left.type === \"MemberExpression\" && effectiveParent.left.property.name === node.name)) {\n                        report(node);\n                    }\n\n                /*\n                 * Properties have their own rules, and\n                 * AssignmentPattern nodes can be treated like Properties:\n                 * e.g.: const { no_camelcased = false } = bar;\n                 */\n                } else if (node.parent.type === \"Property\" || node.parent.type === \"AssignmentPattern\") {\n\n                    if (node.parent.parent && node.parent.parent.type === \"ObjectPattern\") {\n                        if (node.parent.shorthand && node.parent.value.left && nameIsUnderscored) {\n                            report(node);\n                        }\n\n                        const assignmentKeyEqualsValue = node.parent.key.name === node.parent.value.name;\n\n                        if (isUnderscored(name) && node.parent.computed) {\n                            report(node);\n                        }\n\n                        // prevent checking righthand side of destructured object\n                        if (node.parent.key === node && node.parent.value !== node) {\n                            return;\n                        }\n\n                        const valueIsUnderscored = node.parent.value.name && nameIsUnderscored;\n\n                        // ignore destructuring if the option is set, unless a new identifier is created\n                        if (valueIsUnderscored && !(assignmentKeyEqualsValue && ignoreDestructuring)) {\n                            report(node);\n                        }\n                    }\n\n                    // \"never\" check properties or always ignore destructuring\n                    if (properties === \"never\" || (ignoreDestructuring && isInsideObjectPattern(node))) {\n                        return;\n                    }\n\n                    // don't check right hand side of AssignmentExpression to prevent duplicate warnings\n                    if (nameIsUnderscored && !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && !(node.parent.right === node)) {\n                        report(node);\n                    }\n\n                // Check if it's an import specifier\n                } else if ([\"ImportSpecifier\", \"ImportNamespaceSpecifier\", \"ImportDefaultSpecifier\"].indexOf(node.parent.type) >= 0) {\n\n                    // Report only if the local imported identifier is underscored\n                    if (node.parent.local && node.parent.local.name === node.name && nameIsUnderscored) {\n                        report(node);\n                    }\n\n                // Report anything that is underscored that isn't a CallExpression\n                } else if (nameIsUnderscored && !ALLOWED_PARENT_TYPES.has(effectiveParent.type)) {\n                    report(node);\n                }\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview enforce or disallow capitalization of the first letter of a comment\n * @author Kevin Partington\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst LETTER_PATTERN = require(\"../util/patterns/letters\");\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_IGNORE_PATTERN = astUtils.COMMENTS_IGNORE_PATTERN,\n    WHITESPACE = /\\s/gu,\n    MAYBE_URL = /^\\s*[^:/?#\\s]+:\\/\\/[^?#]/u; // TODO: Combine w/ max-len pattern?\n\n/*\n * Base schema body for defining the basic capitalization rule, ignorePattern,\n * and ignoreInlineComments values.\n * This can be used in a few different ways in the actual schema.\n */\nconst SCHEMA_BODY = {\n    type: \"object\",\n    properties: {\n        ignorePattern: {\n            type: \"string\"\n        },\n        ignoreInlineComments: {\n            type: \"boolean\"\n        },\n        ignoreConsecutiveComments: {\n            type: \"boolean\"\n        }\n    },\n    additionalProperties: false\n};\nconst DEFAULTS = {\n    ignorePattern: \"\",\n    ignoreInlineComments: false,\n    ignoreConsecutiveComments: false\n};\n\n/**\n * Get normalized options for either block or line comments from the given\n * user-provided options.\n * - If the user-provided options is just a string, returns a normalized\n *   set of options using default values for all other options.\n * - If the user-provided options is an object, then a normalized option\n *   set is returned. Options specified in overrides will take priority\n *   over options specified in the main options object, which will in\n *   turn take priority over the rule's defaults.\n *\n * @param {Object|string} rawOptions The user-provided options.\n * @param {string} which Either \"line\" or \"block\".\n * @returns {Object} The normalized options.\n */\nfunction getNormalizedOptions(rawOptions = {}, which) {\n    return Object.assign({}, DEFAULTS, rawOptions[which] || rawOptions);\n}\n\n/**\n * Get normalized options for block and line comments.\n *\n * @param {Object|string} rawOptions The user-provided options.\n * @returns {Object} An object with \"Line\" and \"Block\" keys and corresponding\n * normalized options objects.\n */\nfunction getAllNormalizedOptions(rawOptions) {\n    return {\n        Line: getNormalizedOptions(rawOptions, \"line\"),\n        Block: getNormalizedOptions(rawOptions, \"block\")\n    };\n}\n\n/**\n * Creates a regular expression for each ignorePattern defined in the rule\n * options.\n *\n * This is done in order to avoid invoking the RegExp constructor repeatedly.\n *\n * @param {Object} normalizedOptions The normalized rule options.\n * @returns {void}\n */\nfunction createRegExpForIgnorePatterns(normalizedOptions) {\n    Object.keys(normalizedOptions).forEach(key => {\n        const ignorePatternStr = normalizedOptions[key].ignorePattern;\n\n        if (ignorePatternStr) {\n            const regExp = RegExp(`^\\\\s*(?:${ignorePatternStr})`); // eslint-disable-line require-unicode-regexp\n\n            normalizedOptions[key].ignorePatternRegExp = regExp;\n        }\n    });\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce or disallow capitalization of the first letter of a comment\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/capitalized-comments\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            { enum: [\"always\", \"never\"] },\n            {\n                oneOf: [\n                    SCHEMA_BODY,\n                    {\n                        type: \"object\",\n                        properties: {\n                            line: SCHEMA_BODY,\n                            block: SCHEMA_BODY\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unexpectedLowercaseComment: \"Comments should not begin with a lowercase character.\",\n            unexpectedUppercaseComment: \"Comments should not begin with an uppercase character.\"\n        }\n    },\n\n    create(context) {\n\n        const capitalize = context.options[0] || \"always\",\n            normalizedOptions = getAllNormalizedOptions(context.options[1]),\n            sourceCode = context.getSourceCode();\n\n        createRegExpForIgnorePatterns(normalizedOptions);\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Checks whether a comment is an inline comment.\n         *\n         * For the purpose of this rule, a comment is inline if:\n         * 1. The comment is preceded by a token on the same line; and\n         * 2. The command is followed by a token on the same line.\n         *\n         * Note that the comment itself need not be single-line!\n         *\n         * Also, it follows from this definition that only block comments can\n         * be considered as possibly inline. This is because line comments\n         * would consume any following tokens on the same line as the comment.\n         *\n         * @param {ASTNode} comment The comment node to check.\n         * @returns {boolean} True if the comment is an inline comment, false\n         * otherwise.\n         */\n        function isInlineComment(comment) {\n            const previousToken = sourceCode.getTokenBefore(comment, { includeComments: true }),\n                nextToken = sourceCode.getTokenAfter(comment, { includeComments: true });\n\n            return Boolean(\n                previousToken &&\n                nextToken &&\n                comment.loc.start.line === previousToken.loc.end.line &&\n                comment.loc.end.line === nextToken.loc.start.line\n            );\n        }\n\n        /**\n         * Determine if a comment follows another comment.\n         *\n         * @param {ASTNode} comment The comment to check.\n         * @returns {boolean} True if the comment follows a valid comment.\n         */\n        function isConsecutiveComment(comment) {\n            const previousTokenOrComment = sourceCode.getTokenBefore(comment, { includeComments: true });\n\n            return Boolean(\n                previousTokenOrComment &&\n                [\"Block\", \"Line\"].indexOf(previousTokenOrComment.type) !== -1\n            );\n        }\n\n        /**\n         * Check a comment to determine if it is valid for this rule.\n         *\n         * @param {ASTNode} comment The comment node to process.\n         * @param {Object} options The options for checking this comment.\n         * @returns {boolean} True if the comment is valid, false otherwise.\n         */\n        function isCommentValid(comment, options) {\n\n            // 1. Check for default ignore pattern.\n            if (DEFAULT_IGNORE_PATTERN.test(comment.value)) {\n                return true;\n            }\n\n            // 2. Check for custom ignore pattern.\n            const commentWithoutAsterisks = comment.value\n                .replace(/\\*/gu, \"\");\n\n            if (options.ignorePatternRegExp && options.ignorePatternRegExp.test(commentWithoutAsterisks)) {\n                return true;\n            }\n\n            // 3. Check for inline comments.\n            if (options.ignoreInlineComments && isInlineComment(comment)) {\n                return true;\n            }\n\n            // 4. Is this a consecutive comment (and are we tolerating those)?\n            if (options.ignoreConsecutiveComments && isConsecutiveComment(comment)) {\n                return true;\n            }\n\n            // 5. Does the comment start with a possible URL?\n            if (MAYBE_URL.test(commentWithoutAsterisks)) {\n                return true;\n            }\n\n            // 6. Is the initial word character a letter?\n            const commentWordCharsOnly = commentWithoutAsterisks\n                .replace(WHITESPACE, \"\");\n\n            if (commentWordCharsOnly.length === 0) {\n                return true;\n            }\n\n            const firstWordChar = commentWordCharsOnly[0];\n\n            if (!LETTER_PATTERN.test(firstWordChar)) {\n                return true;\n            }\n\n            // 7. Check the case of the initial word character.\n            const isUppercase = firstWordChar !== firstWordChar.toLocaleLowerCase(),\n                isLowercase = firstWordChar !== firstWordChar.toLocaleUpperCase();\n\n            if (capitalize === \"always\" && isLowercase) {\n                return false;\n            }\n            if (capitalize === \"never\" && isUppercase) {\n                return false;\n            }\n\n            return true;\n        }\n\n        /**\n         * Process a comment to determine if it needs to be reported.\n         *\n         * @param {ASTNode} comment The comment node to process.\n         * @returns {void}\n         */\n        function processComment(comment) {\n            const options = normalizedOptions[comment.type],\n                commentValid = isCommentValid(comment, options);\n\n            if (!commentValid) {\n                const messageId = capitalize === \"always\"\n                    ? \"unexpectedLowercaseComment\"\n                    : \"unexpectedUppercaseComment\";\n\n                context.report({\n                    node: null, // Intentionally using loc instead\n                    loc: comment.loc,\n                    messageId,\n                    fix(fixer) {\n                        const match = comment.value.match(LETTER_PATTERN);\n\n                        return fixer.replaceTextRange(\n\n                            // Offset match.index by 2 to account for the first 2 characters that start the comment (// or /*)\n                            [comment.range[0] + match.index + 2, comment.range[0] + match.index + 3],\n                            capitalize === \"always\" ? match[0].toLocaleUpperCase() : match[0].toLocaleLowerCase()\n                        );\n                    }\n                });\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments.filter(token => token.type !== \"Shebang\").forEach(processComment);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Pattern for detecting any letter (even letters outside of ASCII).\n * NOTE: This file was generated using this script in JSCS based on the Unicode 7.0.0 standard: https://github.com/jscs-dev/node-jscs/blob/f5ed14427deb7e7aac84f3056a5aab2d9f3e563e/publish/helpers/generate-patterns.js\n * Do not edit this file by hand-- please use https://github.com/mathiasbynens/regenerate to regenerate the regular expression exported from this file.\n * @author Kevin Partington\n * @license MIT License (from JSCS). See below.\n */\n\n/*\n * The MIT License (MIT)\n *\n * Copyright 2013-2016 Dulin Marat and other contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\n\nmodule.exports = /[A-Za-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16F1-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF40\\uDF42-\\uDF49\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF]|\\uD801[\\uDC00-\\uDC9D\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF5D-\\uDF61]|\\uD805[\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF98]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D]|\\uD87E[\\uDC00-\\uDE1D]/u;\n","/**\n * @fileoverview Rule to enforce that all class methods use 'this'.\n * @author Patrick Williams\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce that class methods utilize `this`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/class-methods-use-this\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                exceptMethods: {\n                    type: \"array\",\n                    items: {\n                        type: \"string\"\n                    }\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            missingThis: \"Expected 'this' to be used by class method '{{name}}'.\"\n        }\n    },\n    create(context) {\n        const config = Object.assign({}, context.options[0]);\n        const exceptMethods = new Set(config.exceptMethods || []);\n\n        const stack = [];\n\n        /**\n         * Initializes the current context to false and pushes it onto the stack.\n         * These booleans represent whether 'this' has been used in the context.\n         * @returns {void}\n         * @private\n         */\n        function enterFunction() {\n            stack.push(false);\n        }\n\n        /**\n         * Check if the node is an instance method\n         * @param {ASTNode} node - node to check\n         * @returns {boolean} True if its an instance method\n         * @private\n         */\n        function isInstanceMethod(node) {\n            return !node.static && node.kind !== \"constructor\" && node.type === \"MethodDefinition\";\n        }\n\n        /**\n         * Check if the node is an instance method not excluded by config\n         * @param {ASTNode} node - node to check\n         * @returns {boolean} True if it is an instance method, and not excluded by config\n         * @private\n         */\n        function isIncludedInstanceMethod(node) {\n            return isInstanceMethod(node) && !exceptMethods.has(node.key.name);\n        }\n\n        /**\n         * Checks if we are leaving a function that is a method, and reports if 'this' has not been used.\n         * Static methods and the constructor are exempt.\n         * Then pops the context off the stack.\n         * @param {ASTNode} node - A function node that was entered.\n         * @returns {void}\n         * @private\n         */\n        function exitFunction(node) {\n            const methodUsesThis = stack.pop();\n\n            if (isIncludedInstanceMethod(node.parent) && !methodUsesThis) {\n                context.report({\n                    node,\n                    messageId: \"missingThis\",\n                    data: {\n                        name: node.parent.key.name\n                    }\n                });\n            }\n        }\n\n        /**\n         * Mark the current context as having used 'this'.\n         * @returns {void}\n         * @private\n         */\n        function markThisUsed() {\n            if (stack.length) {\n                stack[stack.length - 1] = true;\n            }\n        }\n\n        return {\n            FunctionDeclaration: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            FunctionExpression: enterFunction,\n            \"FunctionExpression:exit\": exitFunction,\n            ThisExpression: markThisUsed,\n            Super: markThisUsed\n        };\n    }\n};\n","/**\n * @fileoverview Rule to forbid or enforce dangling commas.\n * @author Ian Christian Myers\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_OPTIONS = Object.freeze({\n    arrays: \"never\",\n    objects: \"never\",\n    imports: \"never\",\n    exports: \"never\",\n    functions: \"ignore\"\n});\n\n/**\n * Checks whether or not a trailing comma is allowed in a given node.\n * If the `lastItem` is `RestElement` or `RestProperty`, it disallows trailing commas.\n *\n * @param {ASTNode} lastItem - The node of the last element in the given node.\n * @returns {boolean} `true` if a trailing comma is allowed.\n */\nfunction isTrailingCommaAllowed(lastItem) {\n    return !(\n        lastItem.type === \"RestElement\" ||\n        lastItem.type === \"RestProperty\" ||\n        lastItem.type === \"ExperimentalRestProperty\"\n    );\n}\n\n/**\n * Normalize option value.\n *\n * @param {string|Object|undefined} optionValue - The 1st option value to normalize.\n * @returns {Object} The normalized option value.\n */\nfunction normalizeOptions(optionValue) {\n    if (typeof optionValue === \"string\") {\n        return {\n            arrays: optionValue,\n            objects: optionValue,\n            imports: optionValue,\n            exports: optionValue,\n\n            // For backward compatibility, always ignore functions.\n            functions: \"ignore\"\n        };\n    }\n    if (typeof optionValue === \"object\" && optionValue !== null) {\n        return {\n            arrays: optionValue.arrays || DEFAULT_OPTIONS.arrays,\n            objects: optionValue.objects || DEFAULT_OPTIONS.objects,\n            imports: optionValue.imports || DEFAULT_OPTIONS.imports,\n            exports: optionValue.exports || DEFAULT_OPTIONS.exports,\n            functions: optionValue.functions || DEFAULT_OPTIONS.functions\n        };\n    }\n\n    return DEFAULT_OPTIONS;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow trailing commas\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/comma-dangle\"\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            definitions: {\n                value: {\n                    enum: [\n                        \"always-multiline\",\n                        \"always\",\n                        \"never\",\n                        \"only-multiline\"\n                    ]\n                },\n                valueWithIgnore: {\n                    enum: [\n                        \"always-multiline\",\n                        \"always\",\n                        \"ignore\",\n                        \"never\",\n                        \"only-multiline\"\n                    ]\n                }\n            },\n            type: \"array\",\n            items: [\n                {\n                    oneOf: [\n                        {\n                            $ref: \"#/definitions/value\"\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                arrays: { $ref: \"#/definitions/valueWithIgnore\" },\n                                objects: { $ref: \"#/definitions/valueWithIgnore\" },\n                                imports: { $ref: \"#/definitions/valueWithIgnore\" },\n                                exports: { $ref: \"#/definitions/valueWithIgnore\" },\n                                functions: { $ref: \"#/definitions/valueWithIgnore\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ]\n                }\n            ]\n        },\n\n        messages: {\n            unexpected: \"Unexpected trailing comma.\",\n            missing: \"Missing trailing comma.\"\n        }\n    },\n\n    create(context) {\n        const options = normalizeOptions(context.options[0]);\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Gets the last item of the given node.\n         * @param {ASTNode} node - The node to get.\n         * @returns {ASTNode|null} The last node or null.\n         */\n        function getLastItem(node) {\n            switch (node.type) {\n                case \"ObjectExpression\":\n                case \"ObjectPattern\":\n                    return lodash.last(node.properties);\n                case \"ArrayExpression\":\n                case \"ArrayPattern\":\n                    return lodash.last(node.elements);\n                case \"ImportDeclaration\":\n                case \"ExportNamedDeclaration\":\n                    return lodash.last(node.specifiers);\n                case \"FunctionDeclaration\":\n                case \"FunctionExpression\":\n                case \"ArrowFunctionExpression\":\n                    return lodash.last(node.params);\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return lodash.last(node.arguments);\n                default:\n                    return null;\n            }\n        }\n\n        /**\n         * Gets the trailing comma token of the given node.\n         * If the trailing comma does not exist, this returns the token which is\n         * the insertion point of the trailing comma token.\n         *\n         * @param {ASTNode} node - The node to get.\n         * @param {ASTNode} lastItem - The last item of the node.\n         * @returns {Token} The trailing comma token or the insertion point.\n         */\n        function getTrailingToken(node, lastItem) {\n            switch (node.type) {\n                case \"ObjectExpression\":\n                case \"ArrayExpression\":\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return sourceCode.getLastToken(node, 1);\n                default: {\n                    const nextToken = sourceCode.getTokenAfter(lastItem);\n\n                    if (astUtils.isCommaToken(nextToken)) {\n                        return nextToken;\n                    }\n                    return sourceCode.getLastToken(lastItem);\n                }\n            }\n        }\n\n        /**\n         * Checks whether or not a given node is multiline.\n         * This rule handles a given node as multiline when the closing parenthesis\n         * and the last element are not on the same line.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} `true` if the node is multiline.\n         */\n        function isMultiline(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem) {\n                return false;\n            }\n\n            const penultimateToken = getTrailingToken(node, lastItem);\n            const lastToken = sourceCode.getTokenAfter(penultimateToken);\n\n            return lastToken.loc.end.line !== penultimateToken.loc.end.line;\n        }\n\n        /**\n         * Reports a trailing comma if it exists.\n         *\n         * @param {ASTNode} node - A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forbidTrailingComma(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem || (node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\")) {\n                return;\n            }\n\n            const trailingToken = getTrailingToken(node, lastItem);\n\n            if (astUtils.isCommaToken(trailingToken)) {\n                context.report({\n                    node: lastItem,\n                    loc: trailingToken.loc.start,\n                    messageId: \"unexpected\",\n                    fix(fixer) {\n                        return fixer.remove(trailingToken);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports the last element of a given node if it does not have a trailing\n         * comma.\n         *\n         * If a given node is `ArrayPattern` which has `RestElement`, the trailing\n         * comma is disallowed, so report if it exists.\n         *\n         * @param {ASTNode} node - A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forceTrailingComma(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem || (node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\")) {\n                return;\n            }\n            if (!isTrailingCommaAllowed(lastItem)) {\n                forbidTrailingComma(node);\n                return;\n            }\n\n            const trailingToken = getTrailingToken(node, lastItem);\n\n            if (trailingToken.value !== \",\") {\n                context.report({\n                    node: lastItem,\n                    loc: trailingToken.loc.end,\n                    messageId: \"missing\",\n                    fix(fixer) {\n                        return fixer.insertTextAfter(trailingToken, \",\");\n                    }\n                });\n            }\n        }\n\n        /**\n         * If a given node is multiline, reports the last element of a given node\n         * when it does not have a trailing comma.\n         * Otherwise, reports a trailing comma if it exists.\n         *\n         * @param {ASTNode} node - A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forceTrailingCommaIfMultiline(node) {\n            if (isMultiline(node)) {\n                forceTrailingComma(node);\n            } else {\n                forbidTrailingComma(node);\n            }\n        }\n\n        /**\n         * Only if a given node is not multiline, reports the last element of a given node\n         * when it does not have a trailing comma.\n         * Otherwise, reports a trailing comma if it exists.\n         *\n         * @param {ASTNode} node - A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function allowTrailingCommaIfMultiline(node) {\n            if (!isMultiline(node)) {\n                forbidTrailingComma(node);\n            }\n        }\n\n        const predicate = {\n            always: forceTrailingComma,\n            \"always-multiline\": forceTrailingCommaIfMultiline,\n            \"only-multiline\": allowTrailingCommaIfMultiline,\n            never: forbidTrailingComma,\n            ignore: lodash.noop\n        };\n\n        return {\n            ObjectExpression: predicate[options.objects],\n            ObjectPattern: predicate[options.objects],\n\n            ArrayExpression: predicate[options.arrays],\n            ArrayPattern: predicate[options.arrays],\n\n            ImportDeclaration: predicate[options.imports],\n\n            ExportNamedDeclaration: predicate[options.exports],\n\n            FunctionDeclaration: predicate[options.functions],\n            FunctionExpression: predicate[options.functions],\n            ArrowFunctionExpression: predicate[options.functions],\n            CallExpression: predicate[options.functions],\n            NewExpression: predicate[options.functions]\n        };\n    }\n};\n","/**\n * @fileoverview Comma spacing - validates spacing before and after comma\n * @author Vignesh Anand aka vegetableman.\n */\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before and after commas\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/comma-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    after: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            missing: \"A space is required {{loc}} ','.\",\n            unexpected: \"There should be no space {{loc}} ','.\"\n        }\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n        const tokensAndComments = sourceCode.tokensAndComments;\n\n        const options = {\n            before: context.options[0] ? context.options[0].before : false,\n            after: context.options[0] ? context.options[0].after : true\n        };\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // list of comma tokens to ignore for the check of leading whitespace\n        const commaTokensToIgnore = [];\n\n        /**\n         * Reports a spacing error with an appropriate message.\n         * @param {ASTNode} node The binary expression node to report.\n         * @param {string} loc Is the error \"before\" or \"after\" the comma?\n         * @param {ASTNode} otherNode The node at the left or right of `node`\n         * @returns {void}\n         * @private\n         */\n        function report(node, loc, otherNode) {\n            context.report({\n                node,\n                fix(fixer) {\n                    if (options[loc]) {\n                        if (loc === \"before\") {\n                            return fixer.insertTextBefore(node, \" \");\n                        }\n                        return fixer.insertTextAfter(node, \" \");\n\n                    }\n                    let start, end;\n                    const newText = \"\";\n\n                    if (loc === \"before\") {\n                        start = otherNode.range[1];\n                        end = node.range[0];\n                    } else {\n                        start = node.range[1];\n                        end = otherNode.range[0];\n                    }\n\n                    return fixer.replaceTextRange([start, end], newText);\n\n                },\n                messageId: options[loc] ? \"missing\" : \"unexpected\",\n                data: {\n                    loc\n                }\n            });\n        }\n\n        /**\n         * Validates the spacing around a comma token.\n         * @param {Object} tokens - The tokens to be validated.\n         * @param {Token} tokens.comma The token representing the comma.\n         * @param {Token} [tokens.left] The last token before the comma.\n         * @param {Token} [tokens.right] The first token after the comma.\n         * @param {Token|ASTNode} reportItem The item to use when reporting an error.\n         * @returns {void}\n         * @private\n         */\n        function validateCommaItemSpacing(tokens, reportItem) {\n            if (tokens.left && astUtils.isTokenOnSameLine(tokens.left, tokens.comma) &&\n                    (options.before !== sourceCode.isSpaceBetweenTokens(tokens.left, tokens.comma))\n            ) {\n                report(reportItem, \"before\", tokens.left);\n            }\n\n            if (tokens.right && astUtils.isClosingParenToken(tokens.right)) {\n                return;\n            }\n\n            if (tokens.right && !options.after && tokens.right.type === \"Line\") {\n                return;\n            }\n\n            if (tokens.right && astUtils.isTokenOnSameLine(tokens.comma, tokens.right) &&\n                    (options.after !== sourceCode.isSpaceBetweenTokens(tokens.comma, tokens.right))\n            ) {\n                report(reportItem, \"after\", tokens.right);\n            }\n        }\n\n        /**\n         * Adds null elements of the given ArrayExpression or ArrayPattern node to the ignore list.\n         * @param {ASTNode} node An ArrayExpression or ArrayPattern node.\n         * @returns {void}\n         */\n        function addNullElementsToIgnoreList(node) {\n            let previousToken = sourceCode.getFirstToken(node);\n\n            node.elements.forEach(element => {\n                let token;\n\n                if (element === null) {\n                    token = sourceCode.getTokenAfter(previousToken);\n\n                    if (astUtils.isCommaToken(token)) {\n                        commaTokensToIgnore.push(token);\n                    }\n                } else {\n                    token = sourceCode.getTokenAfter(element);\n                }\n\n                previousToken = token;\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            \"Program:exit\"() {\n                tokensAndComments.forEach((token, i) => {\n\n                    if (!astUtils.isCommaToken(token)) {\n                        return;\n                    }\n\n                    if (token && token.type === \"JSXText\") {\n                        return;\n                    }\n\n                    const previousToken = tokensAndComments[i - 1];\n                    const nextToken = tokensAndComments[i + 1];\n\n                    validateCommaItemSpacing({\n                        comma: token,\n                        left: astUtils.isCommaToken(previousToken) || commaTokensToIgnore.indexOf(token) > -1 ? null : previousToken,\n                        right: astUtils.isCommaToken(nextToken) ? null : nextToken\n                    }, token);\n                });\n            },\n            ArrayExpression: addNullElementsToIgnoreList,\n            ArrayPattern: addNullElementsToIgnoreList\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Comma style - enforces comma styles of two types: last and first\n * @author Vignesh Anand aka vegetableman\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent comma style\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/comma-style\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                enum: [\"first\", \"last\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"boolean\"\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedLineBeforeAndAfterComma: \"Bad line breaking before and after ','.\",\n            expectedCommaFirst: \"',' should be placed first.\",\n            expectedCommaLast: \"',' should be placed last.\"\n        }\n    },\n\n    create(context) {\n        const style = context.options[0] || \"last\",\n            sourceCode = context.getSourceCode();\n        const exceptions = {\n            ArrayPattern: true,\n            ArrowFunctionExpression: true,\n            CallExpression: true,\n            FunctionDeclaration: true,\n            FunctionExpression: true,\n            ImportDeclaration: true,\n            ObjectPattern: true,\n            NewExpression: true\n        };\n\n        if (context.options.length === 2 && Object.prototype.hasOwnProperty.call(context.options[1], \"exceptions\")) {\n            const keys = Object.keys(context.options[1].exceptions);\n\n            for (let i = 0; i < keys.length; i++) {\n                exceptions[keys[i]] = context.options[1].exceptions[keys[i]];\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Modified text based on the style\n         * @param {string} styleType Style type\n         * @param {string} text Source code text\n         * @returns {string} modified text\n         * @private\n         */\n        function getReplacedText(styleType, text) {\n            switch (styleType) {\n                case \"between\":\n                    return `,${text.replace(astUtils.LINEBREAK_MATCHER, \"\")}`;\n\n                case \"first\":\n                    return `${text},`;\n\n                case \"last\":\n                    return `,${text}`;\n\n                default:\n                    return \"\";\n            }\n        }\n\n        /**\n         * Determines the fixer function for a given style.\n         * @param {string} styleType comma style\n         * @param {ASTNode} previousItemToken The token to check.\n         * @param {ASTNode} commaToken The token to check.\n         * @param {ASTNode} currentItemToken The token to check.\n         * @returns {Function} Fixer function\n         * @private\n         */\n        function getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken) {\n            const text =\n                sourceCode.text.slice(previousItemToken.range[1], commaToken.range[0]) +\n                sourceCode.text.slice(commaToken.range[1], currentItemToken.range[0]);\n            const range = [previousItemToken.range[1], currentItemToken.range[0]];\n\n            return function(fixer) {\n                return fixer.replaceTextRange(range, getReplacedText(styleType, text));\n            };\n        }\n\n        /**\n         * Validates the spacing around single items in lists.\n         * @param {Token} previousItemToken The last token from the previous item.\n         * @param {Token} commaToken The token representing the comma.\n         * @param {Token} currentItemToken The first token of the current item.\n         * @param {Token} reportItem The item to use when reporting an error.\n         * @returns {void}\n         * @private\n         */\n        function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {\n\n            // if single line\n            if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&\n                    astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {\n\n                // do nothing.\n\n            } else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&\n                    !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {\n\n                const comment = sourceCode.getCommentsAfter(commaToken)[0];\n                const styleType = comment && comment.type === \"Block\" && astUtils.isTokenOnSameLine(commaToken, comment)\n                    ? style\n                    : \"between\";\n\n                // lone comma\n                context.report({\n                    node: reportItem,\n                    loc: {\n                        line: commaToken.loc.end.line,\n                        column: commaToken.loc.start.column\n                    },\n                    messageId: \"unexpectedLineBeforeAndAfterComma\",\n                    fix: getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken)\n                });\n\n            } else if (style === \"first\" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n\n                context.report({\n                    node: reportItem,\n                    messageId: \"expectedCommaFirst\",\n                    fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n                });\n\n            } else if (style === \"last\" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n\n                context.report({\n                    node: reportItem,\n                    loc: {\n                        line: commaToken.loc.end.line,\n                        column: commaToken.loc.end.column\n                    },\n                    messageId: \"expectedCommaLast\",\n                    fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n                });\n            }\n        }\n\n        /**\n         * Checks the comma placement with regards to a declaration/property/element\n         * @param {ASTNode} node The binary expression node to check\n         * @param {string} property The property of the node containing child nodes.\n         * @private\n         * @returns {void}\n         */\n        function validateComma(node, property) {\n            const items = node[property],\n                arrayLiteral = (node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\");\n\n            if (items.length > 1 || arrayLiteral) {\n\n                // seed as opening [\n                let previousItemToken = sourceCode.getFirstToken(node);\n\n                items.forEach(item => {\n                    const commaToken = item ? sourceCode.getTokenBefore(item) : previousItemToken,\n                        currentItemToken = item ? sourceCode.getFirstToken(item) : sourceCode.getTokenAfter(commaToken),\n                        reportItem = item || currentItemToken;\n\n                    /*\n                     * This works by comparing three token locations:\n                     * - previousItemToken is the last token of the previous item\n                     * - commaToken is the location of the comma before the current item\n                     * - currentItemToken is the first token of the current item\n                     *\n                     * These values get switched around if item is undefined.\n                     * previousItemToken will refer to the last token not belonging\n                     * to the current item, which could be a comma or an opening\n                     * square bracket. currentItemToken could be a comma.\n                     *\n                     * All comparisons are done based on these tokens directly, so\n                     * they are always valid regardless of an undefined item.\n                     */\n                    if (astUtils.isCommaToken(commaToken)) {\n                        validateCommaItemSpacing(previousItemToken, commaToken,\n                            currentItemToken, reportItem);\n                    }\n\n                    if (item) {\n                        const tokenAfterItem = sourceCode.getTokenAfter(item, astUtils.isNotClosingParenToken);\n\n                        previousItemToken = tokenAfterItem\n                            ? sourceCode.getTokenBefore(tokenAfterItem)\n                            : sourceCode.ast.tokens[sourceCode.ast.tokens.length - 1];\n                    }\n                });\n\n                /*\n                 * Special case for array literals that have empty last items, such\n                 * as [ 1, 2, ]. These arrays only have two items show up in the\n                 * AST, so we need to look at the token to verify that there's no\n                 * dangling comma.\n                 */\n                if (arrayLiteral) {\n\n                    const lastToken = sourceCode.getLastToken(node),\n                        nextToLastToken = sourceCode.getTokenBefore(lastToken);\n\n                    if (astUtils.isCommaToken(nextToLastToken)) {\n                        validateCommaItemSpacing(\n                            sourceCode.getTokenBefore(nextToLastToken),\n                            nextToLastToken,\n                            lastToken,\n                            lastToken\n                        );\n                    }\n                }\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        const nodes = {};\n\n        if (!exceptions.VariableDeclaration) {\n            nodes.VariableDeclaration = function(node) {\n                validateComma(node, \"declarations\");\n            };\n        }\n        if (!exceptions.ObjectExpression) {\n            nodes.ObjectExpression = function(node) {\n                validateComma(node, \"properties\");\n            };\n        }\n        if (!exceptions.ObjectPattern) {\n            nodes.ObjectPattern = function(node) {\n                validateComma(node, \"properties\");\n            };\n        }\n        if (!exceptions.ArrayExpression) {\n            nodes.ArrayExpression = function(node) {\n                validateComma(node, \"elements\");\n            };\n        }\n        if (!exceptions.ArrayPattern) {\n            nodes.ArrayPattern = function(node) {\n                validateComma(node, \"elements\");\n            };\n        }\n        if (!exceptions.FunctionDeclaration) {\n            nodes.FunctionDeclaration = function(node) {\n                validateComma(node, \"params\");\n            };\n        }\n        if (!exceptions.FunctionExpression) {\n            nodes.FunctionExpression = function(node) {\n                validateComma(node, \"params\");\n            };\n        }\n        if (!exceptions.ArrowFunctionExpression) {\n            nodes.ArrowFunctionExpression = function(node) {\n                validateComma(node, \"params\");\n            };\n        }\n        if (!exceptions.CallExpression) {\n            nodes.CallExpression = function(node) {\n                validateComma(node, \"arguments\");\n            };\n        }\n        if (!exceptions.ImportDeclaration) {\n            nodes.ImportDeclaration = function(node) {\n                validateComma(node, \"specifiers\");\n            };\n        }\n        if (!exceptions.NewExpression) {\n            nodes.NewExpression = function(node) {\n                validateComma(node, \"arguments\");\n            };\n        }\n\n        return nodes;\n    }\n};\n","/**\n * @fileoverview Counts the cyclomatic complexity of each function of the script. See http://en.wikipedia.org/wiki/Cyclomatic_complexity.\n * Counts the number of if, conditional, for, whilte, try, switch/case,\n * @author Patrick Brosset\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce a maximum cyclomatic complexity allowed in a program\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/complexity\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            maximum: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            complex: \"{{name}} has a complexity of {{complexity}}.\"\n        }\n    },\n\n    create(context) {\n        const option = context.options[0];\n        let THRESHOLD = 20;\n\n        if (\n            typeof option === \"object\" &&\n            (Object.prototype.hasOwnProperty.call(option, \"maximum\") || Object.prototype.hasOwnProperty.call(option, \"max\"))\n        ) {\n            THRESHOLD = option.maximum || option.max;\n        } else if (typeof option === \"number\") {\n            THRESHOLD = option;\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // Using a stack to store complexity (handling nested functions)\n        const fns = [];\n\n        /**\n         * When parsing a new function, store it in our function stack\n         * @returns {void}\n         * @private\n         */\n        function startFunction() {\n            fns.push(1);\n        }\n\n        /**\n         * Evaluate the node at the end of function\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function endFunction(node) {\n            const name = lodash.upperFirst(astUtils.getFunctionNameWithKind(node));\n            const complexity = fns.pop();\n\n            if (complexity > THRESHOLD) {\n                context.report({\n                    node,\n                    messageId: \"complex\",\n                    data: { name, complexity }\n                });\n            }\n        }\n\n        /**\n         * Increase the complexity of the function in context\n         * @returns {void}\n         * @private\n         */\n        function increaseComplexity() {\n            if (fns.length) {\n                fns[fns.length - 1]++;\n            }\n        }\n\n        /**\n         * Increase the switch complexity in context\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function increaseSwitchComplexity(node) {\n\n            // Avoiding `default`\n            if (node.test) {\n                increaseComplexity();\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            FunctionDeclaration: startFunction,\n            FunctionExpression: startFunction,\n            ArrowFunctionExpression: startFunction,\n            \"FunctionDeclaration:exit\": endFunction,\n            \"FunctionExpression:exit\": endFunction,\n            \"ArrowFunctionExpression:exit\": endFunction,\n\n            CatchClause: increaseComplexity,\n            ConditionalExpression: increaseComplexity,\n            LogicalExpression: increaseComplexity,\n            ForStatement: increaseComplexity,\n            ForInStatement: increaseComplexity,\n            ForOfStatement: increaseComplexity,\n            IfStatement: increaseComplexity,\n            SwitchCase: increaseSwitchComplexity,\n            WhileStatement: increaseComplexity,\n            DoWhileStatement: increaseComplexity\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallows or enforces spaces inside computed properties.\n * @author Jamund Ferguson\n */\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing inside computed property brackets\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/computed-property-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            }\n        ],\n\n        messages: {\n            unexpectedSpaceBefore: \"There should be no space before '{{tokenValue}}'.\",\n            unexpectedSpaceAfter: \"There should be no space after '{{tokenValue}}'.\",\n\n            missingSpaceBefore: \"A space is required before '{{tokenValue}}'.\",\n            missingSpaceAfter: \"A space is required after '{{tokenValue}}'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const propertyNameMustBeSpaced = context.options[0] === \"always\"; // default is \"never\"\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports that there shouldn't be a space after the first token\n         * @param {ASTNode} node - The node to report in the event of an error.\n         * @param {Token} token - The token to use for the report.\n         * @param {Token} tokenAfter - The token after `token`.\n         * @returns {void}\n         */\n        function reportNoBeginningSpace(node, token, tokenAfter) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                messageId: \"unexpectedSpaceAfter\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.removeRange([token.range[1], tokenAfter.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there shouldn't be a space before the last token\n         * @param {ASTNode} node - The node to report in the event of an error.\n         * @param {Token} token - The token to use for the report.\n         * @param {Token} tokenBefore - The token before `token`.\n         * @returns {void}\n         */\n        function reportNoEndingSpace(node, token, tokenBefore) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                messageId: \"unexpectedSpaceBefore\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.removeRange([tokenBefore.range[1], token.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a space after the first token\n         * @param {ASTNode} node - The node to report in the event of an error.\n         * @param {Token} token - The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredBeginningSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                messageId: \"missingSpaceAfter\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextAfter(token, \" \");\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a space before the last token\n         * @param {ASTNode} node - The node to report in the event of an error.\n         * @param {Token} token - The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredEndingSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                messageId: \"missingSpaceBefore\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextBefore(token, \" \");\n                }\n            });\n        }\n\n        /**\n         * Returns a function that checks the spacing of a node on the property name\n         * that was passed in.\n         * @param {string} propertyName The property on the node to check for spacing\n         * @returns {Function} A function that will check spacing on a node\n         */\n        function checkSpacing(propertyName) {\n            return function(node) {\n                if (!node.computed) {\n                    return;\n                }\n\n                const property = node[propertyName];\n\n                const before = sourceCode.getTokenBefore(property),\n                    first = sourceCode.getFirstToken(property),\n                    last = sourceCode.getLastToken(property),\n                    after = sourceCode.getTokenAfter(property);\n\n                if (astUtils.isTokenOnSameLine(before, first)) {\n                    if (propertyNameMustBeSpaced) {\n                        if (!sourceCode.isSpaceBetweenTokens(before, first) && astUtils.isTokenOnSameLine(before, first)) {\n                            reportRequiredBeginningSpace(node, before);\n                        }\n                    } else {\n                        if (sourceCode.isSpaceBetweenTokens(before, first)) {\n                            reportNoBeginningSpace(node, before, first);\n                        }\n                    }\n                }\n\n                if (astUtils.isTokenOnSameLine(last, after)) {\n                    if (propertyNameMustBeSpaced) {\n                        if (!sourceCode.isSpaceBetweenTokens(last, after) && astUtils.isTokenOnSameLine(last, after)) {\n                            reportRequiredEndingSpace(node, after);\n                        }\n                    } else {\n                        if (sourceCode.isSpaceBetweenTokens(last, after)) {\n                            reportNoEndingSpace(node, after, last);\n                        }\n                    }\n                }\n            };\n        }\n\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Property: checkSpacing(\"key\"),\n            MemberExpression: checkSpacing(\"property\")\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag consistent return values\n * @author Nicholas C. Zakas\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is an `Identifier` node which was named a given name.\n * @param {ASTNode} node - A node to check.\n * @param {string} name - An expected name of the node.\n * @returns {boolean} `true` if the node is an `Identifier` node which was named as expected.\n */\nfunction isIdentifier(node, name) {\n    return node.type === \"Identifier\" && node.name === name;\n}\n\n/**\n * Checks whether or not a given code path segment is unreachable.\n * @param {CodePathSegment} segment - A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is unreachable.\n */\nfunction isUnreachable(segment) {\n    return !segment.reachable;\n}\n\n/**\n * Checks whether a given node is a `constructor` method in an ES6 class\n * @param {ASTNode} node A node to check\n * @returns {boolean} `true` if the node is a `constructor` method\n */\nfunction isClassConstructor(node) {\n    return node.type === \"FunctionExpression\" &&\n        node.parent &&\n        node.parent.type === \"MethodDefinition\" &&\n        node.parent.kind === \"constructor\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `return` statements to either always or never specify values\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/consistent-return\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                treatUndefinedAsUnspecified: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            missingReturn: \"Expected to return a value at the end of {{name}}.\",\n            missingReturnValue: \"{{name}} expected a return value.\",\n            unexpectedReturnValue: \"{{name}} expected no return value.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const treatUndefinedAsUnspecified = options.treatUndefinedAsUnspecified === true;\n        let funcInfo = null;\n\n        /**\n         * Checks whether of not the implicit returning is consistent if the last\n         * code path segment is reachable.\n         *\n         * @param {ASTNode} node - A program/function node to check.\n         * @returns {void}\n         */\n        function checkLastSegment(node) {\n            let loc, name;\n\n            /*\n             * Skip if it expected no return value or unreachable.\n             * When unreachable, all paths are returned or thrown.\n             */\n            if (!funcInfo.hasReturnValue ||\n                funcInfo.codePath.currentSegments.every(isUnreachable) ||\n                astUtils.isES5Constructor(node) ||\n                isClassConstructor(node)\n            ) {\n                return;\n            }\n\n            // Adjust a location and a message.\n            if (node.type === \"Program\") {\n\n                // The head of program.\n                loc = { line: 1, column: 0 };\n                name = \"program\";\n            } else if (node.type === \"ArrowFunctionExpression\") {\n\n                // `=>` token\n                loc = context.getSourceCode().getTokenBefore(node.body, astUtils.isArrowToken).loc.start;\n            } else if (\n                node.parent.type === \"MethodDefinition\" ||\n                (node.parent.type === \"Property\" && node.parent.method)\n            ) {\n\n                // Method name.\n                loc = node.parent.key.loc.start;\n            } else {\n\n                // Function name or `function` keyword.\n                loc = (node.id || node).loc.start;\n            }\n\n            if (!name) {\n                name = astUtils.getFunctionNameWithKind(node);\n            }\n\n            // Reports.\n            context.report({\n                node,\n                loc,\n                messageId: \"missingReturn\",\n                data: { name }\n            });\n        }\n\n        return {\n\n            // Initializes/Disposes state of each code path.\n            onCodePathStart(codePath, node) {\n                funcInfo = {\n                    upper: funcInfo,\n                    codePath,\n                    hasReturn: false,\n                    hasReturnValue: false,\n                    messageId: \"\",\n                    node\n                };\n            },\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n\n            // Reports a given return statement if it's inconsistent.\n            ReturnStatement(node) {\n                const argument = node.argument;\n                let hasReturnValue = Boolean(argument);\n\n                if (treatUndefinedAsUnspecified && hasReturnValue) {\n                    hasReturnValue = !isIdentifier(argument, \"undefined\") && argument.operator !== \"void\";\n                }\n\n                if (!funcInfo.hasReturn) {\n                    funcInfo.hasReturn = true;\n                    funcInfo.hasReturnValue = hasReturnValue;\n                    funcInfo.messageId = hasReturnValue ? \"missingReturnValue\" : \"unexpectedReturnValue\";\n                    funcInfo.data = {\n                        name: funcInfo.node.type === \"Program\"\n                            ? \"Program\"\n                            : lodash.upperFirst(astUtils.getFunctionNameWithKind(funcInfo.node))\n                    };\n                } else if (funcInfo.hasReturnValue !== hasReturnValue) {\n                    context.report({\n                        node,\n                        messageId: funcInfo.messageId,\n                        data: funcInfo.data\n                    });\n                }\n            },\n\n            // Reports a given program/function if the implicit returning is not consistent.\n            \"Program:exit\": checkLastSegment,\n            \"FunctionDeclaration:exit\": checkLastSegment,\n            \"FunctionExpression:exit\": checkLastSegment,\n            \"ArrowFunctionExpression:exit\": checkLastSegment\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce consistent naming of \"this\" context variables\n * @author Raphael Pigulla\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce consistent naming when capturing the current execution context\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/consistent-this\"\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                type: \"string\",\n                minLength: 1\n            },\n            uniqueItems: true\n        },\n\n        messages: {\n            aliasNotAssignedToThis: \"Designated alias '{{name}}' is not assigned to 'this'.\",\n            unexpectedAlias: \"Unexpected alias '{{name}}' for 'this'.\"\n        }\n    },\n\n    create(context) {\n        let aliases = [];\n\n        if (context.options.length === 0) {\n            aliases.push(\"that\");\n        } else {\n            aliases = context.options;\n        }\n\n        /**\n         * Reports that a variable declarator or assignment expression is assigning\n         * a non-'this' value to the specified alias.\n         * @param {ASTNode} node - The assigning node.\n         * @param {string}  name - the name of the alias that was incorrectly used.\n         * @returns {void}\n         */\n        function reportBadAssignment(node, name) {\n            context.report({ node, messageId: \"aliasNotAssignedToThis\", data: { name } });\n        }\n\n        /**\n         * Checks that an assignment to an identifier only assigns 'this' to the\n         * appropriate alias, and the alias is only assigned to 'this'.\n         * @param {ASTNode} node - The assigning node.\n         * @param {Identifier} name - The name of the variable assigned to.\n         * @param {Expression} value - The value of the assignment.\n         * @returns {void}\n         */\n        function checkAssignment(node, name, value) {\n            const isThis = value.type === \"ThisExpression\";\n\n            if (aliases.indexOf(name) !== -1) {\n                if (!isThis || node.operator && node.operator !== \"=\") {\n                    reportBadAssignment(node, name);\n                }\n            } else if (isThis) {\n                context.report({ node, messageId: \"unexpectedAlias\", data: { name } });\n            }\n        }\n\n        /**\n         * Ensures that a variable declaration of the alias in a program or function\n         * is assigned to the correct value.\n         * @param {string} alias alias the check the assignment of.\n         * @param {Object} scope scope of the current code we are checking.\n         * @private\n         * @returns {void}\n         */\n        function checkWasAssigned(alias, scope) {\n            const variable = scope.set.get(alias);\n\n            if (!variable) {\n                return;\n            }\n\n            if (variable.defs.some(def => def.node.type === \"VariableDeclarator\" &&\n                def.node.init !== null)) {\n                return;\n            }\n\n            /*\n             * The alias has been declared and not assigned: check it was\n             * assigned later in the same scope.\n             */\n            if (!variable.references.some(reference => {\n                const write = reference.writeExpr;\n\n                return (\n                    reference.from === scope &&\n                    write && write.type === \"ThisExpression\" &&\n                    write.parent.operator === \"=\"\n                );\n            })) {\n                variable.defs.map(def => def.node).forEach(node => {\n                    reportBadAssignment(node, alias);\n                });\n            }\n        }\n\n        /**\n         * Check each alias to ensure that is was assinged to the correct value.\n         * @returns {void}\n         */\n        function ensureWasAssigned() {\n            const scope = context.getScope();\n\n            aliases.forEach(alias => {\n                checkWasAssigned(alias, scope);\n            });\n        }\n\n        return {\n            \"Program:exit\": ensureWasAssigned,\n            \"FunctionExpression:exit\": ensureWasAssigned,\n            \"FunctionDeclaration:exit\": ensureWasAssigned,\n\n            VariableDeclarator(node) {\n                const id = node.id;\n                const isDestructuring =\n                    id.type === \"ArrayPattern\" || id.type === \"ObjectPattern\";\n\n                if (node.init !== null && !isDestructuring) {\n                    checkAssignment(node, id.name, node.init);\n                }\n            },\n\n            AssignmentExpression(node) {\n                if (node.left.type === \"Identifier\") {\n                    checkAssignment(node, node.left.name, node.right);\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview A rule to verify `super()` callings in constructor.\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a given code path segment is reachable or not.\n *\n * @param {CodePathSegment} segment - A code path segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Checks whether or not a given node is a constructor.\n * @param {ASTNode} node - A node to check. This node type is one of\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\n *   `ArrowFunctionExpression`.\n * @returns {boolean} `true` if the node is a constructor.\n */\nfunction isConstructorFunction(node) {\n    return (\n        node.type === \"FunctionExpression\" &&\n        node.parent.type === \"MethodDefinition\" &&\n        node.parent.kind === \"constructor\"\n    );\n}\n\n/**\n * Checks whether a given node can be a constructor or not.\n *\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node can be a constructor.\n */\nfunction isPossibleConstructor(node) {\n    if (!node) {\n        return false;\n    }\n\n    switch (node.type) {\n        case \"ClassExpression\":\n        case \"FunctionExpression\":\n        case \"ThisExpression\":\n        case \"MemberExpression\":\n        case \"CallExpression\":\n        case \"NewExpression\":\n        case \"YieldExpression\":\n        case \"TaggedTemplateExpression\":\n        case \"MetaProperty\":\n            return true;\n\n        case \"Identifier\":\n            return node.name !== \"undefined\";\n\n        case \"AssignmentExpression\":\n            return isPossibleConstructor(node.right);\n\n        case \"LogicalExpression\":\n            return (\n                isPossibleConstructor(node.left) ||\n                isPossibleConstructor(node.right)\n            );\n\n        case \"ConditionalExpression\":\n            return (\n                isPossibleConstructor(node.alternate) ||\n                isPossibleConstructor(node.consequent)\n            );\n\n        case \"SequenceExpression\": {\n            const lastExpression = node.expressions[node.expressions.length - 1];\n\n            return isPossibleConstructor(lastExpression);\n        }\n\n        default:\n            return false;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"require `super()` calls in constructors\",\n            category: \"ECMAScript 6\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/constructor-super\"\n        },\n\n        schema: [],\n\n        messages: {\n            missingSome: \"Lacked a call of 'super()' in some code paths.\",\n            missingAll: \"Expected to call 'super()'.\",\n\n            duplicate: \"Unexpected duplicate 'super()'.\",\n            badSuper: \"Unexpected 'super()' because 'super' is not a constructor.\",\n            unexpected: \"Unexpected 'super()'.\"\n        }\n    },\n\n    create(context) {\n\n        /*\n         * {{hasExtends: boolean, scope: Scope, codePath: CodePath}[]}\n         * Information for each constructor.\n         * - upper:      Information of the upper constructor.\n         * - hasExtends: A flag which shows whether own class has a valid `extends`\n         *               part.\n         * - scope:      The scope of own class.\n         * - codePath:   The code path object of the constructor.\n         */\n        let funcInfo = null;\n\n        /*\n         * {Map<string, {calledInSomePaths: boolean, calledInEveryPaths: boolean}>}\n         * Information for each code path segment.\n         * - calledInSomePaths:  A flag of be called `super()` in some code paths.\n         * - calledInEveryPaths: A flag of be called `super()` in all code paths.\n         * - validNodes:\n         */\n        let segInfoMap = Object.create(null);\n\n        /**\n         * Gets the flag which shows `super()` is called in some paths.\n         * @param {CodePathSegment} segment - A code path segment to get.\n         * @returns {boolean} The flag which shows `super()` is called in some paths\n         */\n        function isCalledInSomePath(segment) {\n            return segment.reachable && segInfoMap[segment.id].calledInSomePaths;\n        }\n\n        /**\n         * Gets the flag which shows `super()` is called in all paths.\n         * @param {CodePathSegment} segment - A code path segment to get.\n         * @returns {boolean} The flag which shows `super()` is called in all paths.\n         */\n        function isCalledInEveryPath(segment) {\n\n            /*\n             * If specific segment is the looped segment of the current segment,\n             * skip the segment.\n             * If not skipped, this never becomes true after a loop.\n             */\n            if (segment.nextSegments.length === 1 &&\n                segment.nextSegments[0].isLoopedPrevSegment(segment)\n            ) {\n                return true;\n            }\n            return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;\n        }\n\n        return {\n\n            /**\n             * Stacks a constructor information.\n             * @param {CodePath} codePath - A code path which was started.\n             * @param {ASTNode} node - The current node.\n             * @returns {void}\n             */\n            onCodePathStart(codePath, node) {\n                if (isConstructorFunction(node)) {\n\n                    // Class > ClassBody > MethodDefinition > FunctionExpression\n                    const classNode = node.parent.parent.parent;\n                    const superClass = classNode.superClass;\n\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: true,\n                        hasExtends: Boolean(superClass),\n                        superIsConstructor: isPossibleConstructor(superClass),\n                        codePath\n                    };\n                } else {\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: false,\n                        hasExtends: false,\n                        superIsConstructor: false,\n                        codePath\n                    };\n                }\n            },\n\n            /**\n             * Pops a constructor information.\n             * And reports if `super()` lacked.\n             * @param {CodePath} codePath - A code path which was ended.\n             * @param {ASTNode} node - The current node.\n             * @returns {void}\n             */\n            onCodePathEnd(codePath, node) {\n                const hasExtends = funcInfo.hasExtends;\n\n                // Pop.\n                funcInfo = funcInfo.upper;\n\n                if (!hasExtends) {\n                    return;\n                }\n\n                // Reports if `super()` lacked.\n                const segments = codePath.returnedSegments;\n                const calledInEveryPaths = segments.every(isCalledInEveryPath);\n                const calledInSomePaths = segments.some(isCalledInSomePath);\n\n                if (!calledInEveryPaths) {\n                    context.report({\n                        messageId: calledInSomePaths\n                            ? \"missingSome\"\n                            : \"missingAll\",\n                        node: node.parent\n                    });\n                }\n            },\n\n            /**\n             * Initialize information of a given code path segment.\n             * @param {CodePathSegment} segment - A code path segment to initialize.\n             * @returns {void}\n             */\n            onCodePathSegmentStart(segment) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Initialize info.\n                const info = segInfoMap[segment.id] = {\n                    calledInSomePaths: false,\n                    calledInEveryPaths: false,\n                    validNodes: []\n                };\n\n                // When there are previous segments, aggregates these.\n                const prevSegments = segment.prevSegments;\n\n                if (prevSegments.length > 0) {\n                    info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n                    info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n                }\n            },\n\n            /**\n             * Update information of the code path segment when a code path was\n             * looped.\n             * @param {CodePathSegment} fromSegment - The code path segment of the\n             *      end of a loop.\n             * @param {CodePathSegment} toSegment - A code path segment of the head\n             *      of a loop.\n             * @returns {void}\n             */\n            onCodePathSegmentLoop(fromSegment, toSegment) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Update information inside of the loop.\n                const isRealLoop = toSegment.prevSegments.length >= 2;\n\n                funcInfo.codePath.traverseSegments(\n                    { first: toSegment, last: fromSegment },\n                    segment => {\n                        const info = segInfoMap[segment.id];\n                        const prevSegments = segment.prevSegments;\n\n                        // Updates flags.\n                        info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n                        info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n\n                        // If flags become true anew, reports the valid nodes.\n                        if (info.calledInSomePaths || isRealLoop) {\n                            const nodes = info.validNodes;\n\n                            info.validNodes = [];\n\n                            for (let i = 0; i < nodes.length; ++i) {\n                                const node = nodes[i];\n\n                                context.report({\n                                    messageId: \"duplicate\",\n                                    node\n                                });\n                            }\n                        }\n                    }\n                );\n            },\n\n            /**\n             * Checks for a call of `super()`.\n             * @param {ASTNode} node - A CallExpression node to check.\n             * @returns {void}\n             */\n            \"CallExpression:exit\"(node) {\n                if (!(funcInfo && funcInfo.isConstructor)) {\n                    return;\n                }\n\n                // Skips except `super()`.\n                if (node.callee.type !== \"Super\") {\n                    return;\n                }\n\n                // Reports if needed.\n                if (funcInfo.hasExtends) {\n                    const segments = funcInfo.codePath.currentSegments;\n                    let duplicate = false;\n                    let info = null;\n\n                    for (let i = 0; i < segments.length; ++i) {\n                        const segment = segments[i];\n\n                        if (segment.reachable) {\n                            info = segInfoMap[segment.id];\n\n                            duplicate = duplicate || info.calledInSomePaths;\n                            info.calledInSomePaths = info.calledInEveryPaths = true;\n                        }\n                    }\n\n                    if (info) {\n                        if (duplicate) {\n                            context.report({\n                                messageId: \"duplicate\",\n                                node\n                            });\n                        } else if (!funcInfo.superIsConstructor) {\n                            context.report({\n                                messageId: \"badSuper\",\n                                node\n                            });\n                        } else {\n                            info.validNodes.push(node);\n                        }\n                    }\n                } else if (funcInfo.codePath.currentSegments.some(isReachable)) {\n                    context.report({\n                        messageId: \"unexpected\",\n                        node\n                    });\n                }\n            },\n\n            /**\n             * Set the mark to the returned path as `super()` was called.\n             * @param {ASTNode} node - A ReturnStatement node to check.\n             * @returns {void}\n             */\n            ReturnStatement(node) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Skips if no argument.\n                if (!node.argument) {\n                    return;\n                }\n\n                // Returning argument is a substitute of 'super()'.\n                const segments = funcInfo.codePath.currentSegments;\n\n                for (let i = 0; i < segments.length; ++i) {\n                    const segment = segments[i];\n\n                    if (segment.reachable) {\n                        const info = segInfoMap[segment.id];\n\n                        info.calledInSomePaths = info.calledInEveryPaths = true;\n                    }\n                }\n            },\n\n            /**\n             * Resets state.\n             * @returns {void}\n             */\n            \"Program:exit\"() {\n                segInfoMap = Object.create(null);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag statements without curly braces\n * @author Nicholas C. Zakas\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce consistent brace style for all control statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/curly\"\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"all\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"multi\", \"multi-line\", \"multi-or-nest\"]\n                        },\n                        {\n                            enum: [\"consistent\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        fixable: \"code\",\n\n        messages: {\n            missingCurlyAfter: \"Expected { after '{{name}}'.\",\n            missingCurlyAfterCondition: \"Expected { after '{{name}}' condition.\",\n            unexpectedCurlyAfter: \"Unnecessary { after '{{name}}'.\",\n            unexpectedCurlyAfterCondition: \"Unnecessary { after '{{name}}' condition.\"\n        }\n    },\n\n    create(context) {\n\n        const multiOnly = (context.options[0] === \"multi\");\n        const multiLine = (context.options[0] === \"multi-line\");\n        const multiOrNest = (context.options[0] === \"multi-or-nest\");\n        const consistent = (context.options[1] === \"consistent\");\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Determines if a given node is a one-liner that's on the same line as it's preceding code.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is a one-liner that's on the same line as it's preceding code.\n         * @private\n         */\n        function isCollapsedOneLiner(node) {\n            const before = sourceCode.getTokenBefore(node);\n            const last = sourceCode.getLastToken(node);\n            const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;\n\n            return before.loc.start.line === lastExcludingSemicolon.loc.end.line;\n        }\n\n        /**\n         * Determines if a given node is a one-liner.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is a one-liner.\n         * @private\n         */\n        function isOneLiner(node) {\n            const first = sourceCode.getFirstToken(node),\n                last = sourceCode.getLastToken(node);\n\n            return first.loc.start.line === last.loc.end.line;\n        }\n\n        /**\n         * Checks if the given token is an `else` token or not.\n         *\n         * @param {Token} token - The token to check.\n         * @returns {boolean} `true` if the token is an `else` token.\n         */\n        function isElseKeywordToken(token) {\n            return token.value === \"else\" && token.type === \"Keyword\";\n        }\n\n        /**\n         * Gets the `else` keyword token of a given `IfStatement` node.\n         * @param {ASTNode} node - A `IfStatement` node to get.\n         * @returns {Token} The `else` keyword token.\n         */\n        function getElseKeyword(node) {\n            return node.alternate && sourceCode.getFirstTokenBetween(node.consequent, node.alternate, isElseKeywordToken);\n        }\n\n        /**\n         * Checks a given IfStatement node requires braces of the consequent chunk.\n         * This returns `true` when below:\n         *\n         * 1. The given node has the `alternate` node.\n         * 2. There is a `IfStatement` which doesn't have `alternate` node in the\n         *    trailing statement chain of the `consequent` node.\n         *\n         * @param {ASTNode} node - A IfStatement node to check.\n         * @returns {boolean} `true` if the node requires braces of the consequent chunk.\n         */\n        function requiresBraceOfConsequent(node) {\n            if (node.alternate && node.consequent.type === \"BlockStatement\") {\n                if (node.consequent.body.length >= 2) {\n                    return true;\n                }\n\n                for (\n                    let currentNode = node.consequent.body[0];\n                    currentNode;\n                    currentNode = astUtils.getTrailingStatement(currentNode)\n                ) {\n                    if (currentNode.type === \"IfStatement\" && !currentNode.alternate) {\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a semicolon needs to be inserted after removing a set of curly brackets, in order to avoid a SyntaxError.\n         * @param {Token} closingBracket The } token\n         * @returns {boolean} `true` if a semicolon needs to be inserted after the last statement in the block.\n         */\n        function needsSemicolon(closingBracket) {\n            const tokenBefore = sourceCode.getTokenBefore(closingBracket);\n            const tokenAfter = sourceCode.getTokenAfter(closingBracket);\n            const lastBlockNode = sourceCode.getNodeByRangeIndex(tokenBefore.range[0]);\n\n            if (astUtils.isSemicolonToken(tokenBefore)) {\n\n                // If the last statement already has a semicolon, don't add another one.\n                return false;\n            }\n\n            if (!tokenAfter) {\n\n                // If there are no statements after this block, there is no need to add a semicolon.\n                return false;\n            }\n\n            if (lastBlockNode.type === \"BlockStatement\" && lastBlockNode.parent.type !== \"FunctionExpression\" && lastBlockNode.parent.type !== \"ArrowFunctionExpression\") {\n\n                /*\n                 * If the last node surrounded by curly brackets is a BlockStatement (other than a FunctionExpression or an ArrowFunctionExpression),\n                 * don't insert a semicolon. Otherwise, the semicolon would be parsed as a separate statement, which would cause\n                 * a SyntaxError if it was followed by `else`.\n                 */\n                return false;\n            }\n\n            if (tokenBefore.loc.end.line === tokenAfter.loc.start.line) {\n\n                // If the next token is on the same line, insert a semicolon.\n                return true;\n            }\n\n            if (/^[([/`+-]/u.test(tokenAfter.value)) {\n\n                // If the next token starts with a character that would disrupt ASI, insert a semicolon.\n                return true;\n            }\n\n            if (tokenBefore.type === \"Punctuator\" && (tokenBefore.value === \"++\" || tokenBefore.value === \"--\")) {\n\n                // If the last token is ++ or --, insert a semicolon to avoid disrupting ASI.\n                return true;\n            }\n\n            // Otherwise, do not insert a semicolon.\n            return false;\n        }\n\n        /**\n         * Prepares to check the body of a node to see if it's a block statement.\n         * @param {ASTNode} node The node to report if there's a problem.\n         * @param {ASTNode} body The body node to check for blocks.\n         * @param {string} name The name to report if there's a problem.\n         * @param {{ condition: boolean }} opts Options to pass to the report functions\n         * @returns {Object} a prepared check object, with \"actual\", \"expected\", \"check\" properties.\n         *   \"actual\" will be `true` or `false` whether the body is already a block statement.\n         *   \"expected\" will be `true` or `false` if the body should be a block statement or not, or\n         *   `null` if it doesn't matter, depending on the rule options. It can be modified to change\n         *   the final behavior of \"check\".\n         *   \"check\" will be a function reporting appropriate problems depending on the other\n         *   properties.\n         */\n        function prepareCheck(node, body, name, opts) {\n            const hasBlock = (body.type === \"BlockStatement\");\n            let expected = null;\n\n            if (node.type === \"IfStatement\" && node.consequent === body && requiresBraceOfConsequent(node)) {\n                expected = true;\n            } else if (multiOnly) {\n                if (hasBlock && body.body.length === 1) {\n                    expected = false;\n                }\n            } else if (multiLine) {\n                if (!isCollapsedOneLiner(body)) {\n                    expected = true;\n                }\n            } else if (multiOrNest) {\n                if (hasBlock && body.body.length === 1 && isOneLiner(body.body[0])) {\n                    const leadingComments = sourceCode.getCommentsBefore(body.body[0]);\n\n                    expected = leadingComments.length > 0;\n                } else if (!isOneLiner(body)) {\n                    expected = true;\n                }\n            } else {\n                expected = true;\n            }\n\n            return {\n                actual: hasBlock,\n                expected,\n                check() {\n                    if (this.expected !== null && this.expected !== this.actual) {\n                        if (this.expected) {\n                            context.report({\n                                node,\n                                loc: (name !== \"else\" ? node : getElseKeyword(node)).loc.start,\n                                messageId: opts && opts.condition ? \"missingCurlyAfterCondition\" : \"missingCurlyAfter\",\n                                data: {\n                                    name\n                                },\n                                fix: fixer => fixer.replaceText(body, `{${sourceCode.getText(body)}}`)\n                            });\n                        } else {\n                            context.report({\n                                node,\n                                loc: (name !== \"else\" ? node : getElseKeyword(node)).loc.start,\n                                messageId: opts && opts.condition ? \"unexpectedCurlyAfterCondition\" : \"unexpectedCurlyAfter\",\n                                data: {\n                                    name\n                                },\n                                fix(fixer) {\n\n                                    /*\n                                     * `do while` expressions sometimes need a space to be inserted after `do`.\n                                     * e.g. `do{foo()} while (bar)` should be corrected to `do foo() while (bar)`\n                                     */\n                                    const needsPrecedingSpace = node.type === \"DoWhileStatement\" &&\n                                        sourceCode.getTokenBefore(body).range[1] === body.range[0] &&\n                                        !astUtils.canTokensBeAdjacent(\"do\", sourceCode.getFirstToken(body, { skip: 1 }));\n\n                                    const openingBracket = sourceCode.getFirstToken(body);\n                                    const closingBracket = sourceCode.getLastToken(body);\n                                    const lastTokenInBlock = sourceCode.getTokenBefore(closingBracket);\n\n                                    if (needsSemicolon(closingBracket)) {\n\n                                        /*\n                                         * If removing braces would cause a SyntaxError due to multiple statements on the same line (or\n                                         * change the semantics of the code due to ASI), don't perform a fix.\n                                         */\n                                        return null;\n                                    }\n\n                                    const resultingBodyText = sourceCode.getText().slice(openingBracket.range[1], lastTokenInBlock.range[0]) +\n                                        sourceCode.getText(lastTokenInBlock) +\n                                        sourceCode.getText().slice(lastTokenInBlock.range[1], closingBracket.range[0]);\n\n                                    return fixer.replaceText(body, (needsPrecedingSpace ? \" \" : \"\") + resultingBodyText);\n                                }\n                            });\n                        }\n                    }\n                }\n            };\n        }\n\n        /**\n         * Prepares to check the bodies of a \"if\", \"else if\" and \"else\" chain.\n         * @param {ASTNode} node The first IfStatement node of the chain.\n         * @returns {Object[]} prepared checks for each body of the chain. See `prepareCheck` for more\n         *   information.\n         */\n        function prepareIfChecks(node) {\n            const preparedChecks = [];\n\n            for (let currentNode = node; currentNode; currentNode = currentNode.alternate) {\n                preparedChecks.push(prepareCheck(currentNode, currentNode.consequent, \"if\", { condition: true }));\n                if (currentNode.alternate && currentNode.alternate.type !== \"IfStatement\") {\n                    preparedChecks.push(prepareCheck(currentNode, currentNode.alternate, \"else\"));\n                    break;\n                }\n            }\n\n            if (consistent) {\n\n                /*\n                 * If any node should have or already have braces, make sure they\n                 * all have braces.\n                 * If all nodes shouldn't have braces, make sure they don't.\n                 */\n                const expected = preparedChecks.some(preparedCheck => {\n                    if (preparedCheck.expected !== null) {\n                        return preparedCheck.expected;\n                    }\n                    return preparedCheck.actual;\n                });\n\n                preparedChecks.forEach(preparedCheck => {\n                    preparedCheck.expected = expected;\n                });\n            }\n\n            return preparedChecks;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            IfStatement(node) {\n                if (node.parent.type !== \"IfStatement\") {\n                    prepareIfChecks(node).forEach(preparedCheck => {\n                        preparedCheck.check();\n                    });\n                }\n            },\n\n            WhileStatement(node) {\n                prepareCheck(node, node.body, \"while\", { condition: true }).check();\n            },\n\n            DoWhileStatement(node) {\n                prepareCheck(node, node.body, \"do\").check();\n            },\n\n            ForStatement(node) {\n                prepareCheck(node, node.body, \"for\", { condition: true }).check();\n            },\n\n            ForInStatement(node) {\n                prepareCheck(node, node.body, \"for-in\").check();\n            },\n\n            ForOfStatement(node) {\n                prepareCheck(node, node.body, \"for-of\").check();\n            }\n        };\n    }\n};\n","/**\n * @fileoverview require default case in switch statements\n * @author Aliaksei Shytkin\n */\n\n\nconst DEFAULT_COMMENT_PATTERN = /^no default$/iu;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `default` cases in `switch` statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/default-case\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                commentPattern: {\n                    type: \"string\"\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            missingDefaultCase: \"Expected a default case.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const commentPattern = options.commentPattern\n            ? new RegExp(options.commentPattern) // eslint-disable-line require-unicode-regexp\n            : DEFAULT_COMMENT_PATTERN;\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Shortcut to get last element of array\n         * @param  {*[]} collection Array\n         * @returns {*} Last element\n         */\n        function last(collection) {\n            return collection[collection.length - 1];\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            SwitchStatement(node) {\n\n                if (!node.cases.length) {\n\n                    /*\n                     * skip check of empty switch because there is no easy way\n                     * to extract comments inside it now\n                     */\n                    return;\n                }\n\n                const hasDefault = node.cases.some(v => v.test === null);\n\n                if (!hasDefault) {\n\n                    let comment;\n\n                    const lastCase = last(node.cases);\n                    const comments = sourceCode.getCommentsAfter(lastCase);\n\n                    if (comments.length) {\n                        comment = last(comments);\n                    }\n\n                    if (!comment || !commentPattern.test(comment.value.trim())) {\n                        context.report({ node, messageId: \"missingDefaultCase\" });\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Validates newlines before and after dots\n * @author Greg Cochard\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent newlines before and after dots\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/dot-location\"\n        },\n\n        schema: [\n            {\n                enum: [\"object\", \"property\"]\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            expectedDotAfterObject: \"Expected dot to be on same line as object.\",\n            expectedDotBeforeProperty: \"Expected dot to be on same line as property.\"\n        }\n    },\n\n    create(context) {\n\n        const config = context.options[0];\n\n        // default to onObject if no preference is passed\n        const onObject = config === \"object\" || !config;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports if the dot between object and property is on the correct loccation.\n         * @param {ASTNode} obj The object owning the property.\n         * @param {ASTNode} prop The property of the object.\n         * @param {ASTNode} node The corresponding node of the token.\n         * @returns {void}\n         */\n        function checkDotLocation(obj, prop, node) {\n            const dot = sourceCode.getTokenBefore(prop);\n            const textBeforeDot = sourceCode.getText().slice(obj.range[1], dot.range[0]);\n            const textAfterDot = sourceCode.getText().slice(dot.range[1], prop.range[0]);\n\n            if (dot.type === \"Punctuator\" && dot.value === \".\") {\n                if (onObject) {\n                    if (!astUtils.isTokenOnSameLine(obj, dot)) {\n                        const neededTextAfterObj = astUtils.isDecimalInteger(obj) ? \" \" : \"\";\n\n                        context.report({\n                            node,\n                            loc: dot.loc.start,\n                            messageId: \"expectedDotAfterObject\",\n                            fix: fixer => fixer.replaceTextRange([obj.range[1], prop.range[0]], `${neededTextAfterObj}.${textBeforeDot}${textAfterDot}`)\n                        });\n                    }\n                } else if (!astUtils.isTokenOnSameLine(dot, prop)) {\n                    context.report({\n                        node,\n                        loc: dot.loc.start,\n                        messageId: \"expectedDotBeforeProperty\",\n                        fix: fixer => fixer.replaceTextRange([obj.range[1], prop.range[0]], `${textBeforeDot}${textAfterDot}.`)\n                    });\n                }\n            }\n        }\n\n        /**\n         * Checks the spacing of the dot within a member expression.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkNode(node) {\n            checkDotLocation(node.object, node.property, node);\n        }\n\n        return {\n            MemberExpression: checkNode\n        };\n    }\n};\n","/**\n * @fileoverview Rule to warn about using dot notation instead of square bracket notation when possible.\n * @author Josh Perez\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/u;\nconst keywords = require(\"../util/keywords\");\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce dot notation whenever possible\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/dot-notation\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowKeywords: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    allowPattern: {\n                        type: \"string\",\n                        default: \"\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            useDot: \"[{{key}}] is better written in dot notation.\",\n            useBrackets: \".{{key}} is a syntax error.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const allowKeywords = options.allowKeywords === void 0 || options.allowKeywords;\n        const sourceCode = context.getSourceCode();\n\n        let allowPattern;\n\n        if (options.allowPattern) {\n            allowPattern = new RegExp(options.allowPattern); // eslint-disable-line require-unicode-regexp\n        }\n\n        /**\n         * Check if the property is valid dot notation\n         * @param {ASTNode} node The dot notation node\n         * @param {string} value Value which is to be checked\n         * @returns {void}\n         */\n        function checkComputedProperty(node, value) {\n            if (\n                validIdentifier.test(value) &&\n                (allowKeywords || keywords.indexOf(String(value)) === -1) &&\n                !(allowPattern && allowPattern.test(value))\n            ) {\n                const formattedValue = node.property.type === \"Literal\" ? JSON.stringify(value) : `\\`${value}\\``;\n\n                context.report({\n                    node: node.property,\n                    messageId: \"useDot\",\n                    data: {\n                        key: formattedValue\n                    },\n                    fix(fixer) {\n                        const leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);\n                        const rightBracket = sourceCode.getLastToken(node);\n\n                        if (sourceCode.getFirstTokenBetween(leftBracket, rightBracket, { includeComments: true, filter: astUtils.isCommentToken })) {\n\n                            // Don't perform any fixes if there are comments inside the brackets.\n                            return null;\n                        }\n\n                        const tokenAfterProperty = sourceCode.getTokenAfter(rightBracket);\n                        const needsSpaceAfterProperty = tokenAfterProperty &&\n                            rightBracket.range[1] === tokenAfterProperty.range[0] &&\n                            !astUtils.canTokensBeAdjacent(String(value), tokenAfterProperty);\n\n                        const textBeforeDot = astUtils.isDecimalInteger(node.object) ? \" \" : \"\";\n                        const textAfterProperty = needsSpaceAfterProperty ? \" \" : \"\";\n\n                        return fixer.replaceTextRange(\n                            [leftBracket.range[0], rightBracket.range[1]],\n                            `${textBeforeDot}.${value}${textAfterProperty}`\n                        );\n                    }\n                });\n            }\n        }\n\n        return {\n            MemberExpression(node) {\n                if (\n                    node.computed &&\n                    node.property.type === \"Literal\"\n                ) {\n                    checkComputedProperty(node, node.property.value);\n                }\n                if (\n                    node.computed &&\n                    node.property.type === \"TemplateLiteral\" &&\n                    node.property.expressions.length === 0\n                ) {\n                    checkComputedProperty(node, node.property.quasis[0].value.cooked);\n                }\n                if (\n                    !allowKeywords &&\n                    !node.computed &&\n                    keywords.indexOf(String(node.property.name)) !== -1\n                ) {\n                    context.report({\n                        node: node.property,\n                        messageId: \"useBrackets\",\n                        data: {\n                            key: node.property.name\n                        },\n                        fix(fixer) {\n                            const dot = sourceCode.getTokenBefore(node.property);\n                            const textAfterDot = sourceCode.text.slice(dot.range[1], node.property.range[0]);\n\n                            if (textAfterDot.trim()) {\n\n                                // Don't perform any fixes if there are comments between the dot and the property name.\n                                return null;\n                            }\n\n                            if (node.object.type === \"Identifier\" && node.object.name === \"let\") {\n\n                                /*\n                                 * A statement that starts with `let[` is parsed as a destructuring variable declaration, not\n                                 * a MemberExpression.\n                                 */\n                                return null;\n                            }\n\n                            return fixer.replaceTextRange(\n                                [dot.range[0], node.property.range[1]],\n                                `[${textAfterDot}\"${node.property.name}\"]`\n                            );\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A shared list of ES3 keywords.\n * @author Josh Perez\n */\n\n\nmodule.exports = [\n    \"abstract\",\n    \"boolean\",\n    \"break\",\n    \"byte\",\n    \"case\",\n    \"catch\",\n    \"char\",\n    \"class\",\n    \"const\",\n    \"continue\",\n    \"debugger\",\n    \"default\",\n    \"delete\",\n    \"do\",\n    \"double\",\n    \"else\",\n    \"enum\",\n    \"export\",\n    \"extends\",\n    \"false\",\n    \"final\",\n    \"finally\",\n    \"float\",\n    \"for\",\n    \"function\",\n    \"goto\",\n    \"if\",\n    \"implements\",\n    \"import\",\n    \"in\",\n    \"instanceof\",\n    \"int\",\n    \"interface\",\n    \"long\",\n    \"native\",\n    \"new\",\n    \"null\",\n    \"package\",\n    \"private\",\n    \"protected\",\n    \"public\",\n    \"return\",\n    \"short\",\n    \"static\",\n    \"super\",\n    \"switch\",\n    \"synchronized\",\n    \"this\",\n    \"throw\",\n    \"throws\",\n    \"transient\",\n    \"true\",\n    \"try\",\n    \"typeof\",\n    \"var\",\n    \"void\",\n    \"volatile\",\n    \"while\",\n    \"with\"\n];\n","/**\n * @fileoverview Require or disallow newline at the end of files\n * @author Nodeca Team <https://github.com/nodeca>\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow newline at the end of files\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/eol-last\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\", \"unix\", \"windows\"]\n            }\n        ],\n\n        messages: {\n            missing: \"Newline required at end of file but not found.\",\n            unexpected: \"Newline not allowed at end of file.\"\n        }\n    },\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: function checkBadEOF(node) {\n                const sourceCode = context.getSourceCode(),\n                    src = sourceCode.getText(),\n                    location = {\n                        column: lodash.last(sourceCode.lines).length,\n                        line: sourceCode.lines.length\n                    },\n                    LF = \"\\n\",\n                    CRLF = `\\r${LF}`,\n                    endsWithNewline = lodash.endsWith(src, LF);\n\n                /*\n                 * Empty source is always valid: No content in file so we don't\n                 * need to lint for a newline on the last line of content.\n                 */\n                if (!src.length) {\n                    return;\n                }\n\n                let mode = context.options[0] || \"always\",\n                    appendCRLF = false;\n\n                if (mode === \"unix\") {\n\n                    // `\"unix\"` should behave exactly as `\"always\"`\n                    mode = \"always\";\n                }\n                if (mode === \"windows\") {\n\n                    // `\"windows\"` should behave exactly as `\"always\"`, but append CRLF in the fixer for backwards compatibility\n                    mode = \"always\";\n                    appendCRLF = true;\n                }\n                if (mode === \"always\" && !endsWithNewline) {\n\n                    // File is not newline-terminated, but should be\n                    context.report({\n                        node,\n                        loc: location,\n                        messageId: \"missing\",\n                        fix(fixer) {\n                            return fixer.insertTextAfterRange([0, src.length], appendCRLF ? CRLF : LF);\n                        }\n                    });\n                } else if (mode === \"never\" && endsWithNewline) {\n\n                    // File is newline-terminated, but shouldn't be\n                    context.report({\n                        node,\n                        loc: location,\n                        messageId: \"unexpected\",\n                        fix(fixer) {\n                            const finalEOLs = /(?:\\r?\\n)+$/u,\n                                match = finalEOLs.exec(sourceCode.text),\n                                start = match.index,\n                                end = sourceCode.text.length;\n\n                            return fixer.replaceTextRange([start, end], \"\");\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag statements that use != and == instead of !== and ===\n * @author Nicholas C. Zakas\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require the use of `===` and `!==`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/eqeqeq\"\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                null: {\n                                    enum: [\"always\", \"never\", \"ignore\"]\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    additionalItems: false\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"smart\", \"allow-null\"]\n                        }\n                    ],\n                    additionalItems: false\n                }\n            ]\n        },\n\n        fixable: \"code\",\n\n        messages: {\n            unexpected: \"Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'.\"\n        }\n    },\n\n    create(context) {\n        const config = context.options[0] || \"always\";\n        const options = context.options[1] || {};\n        const sourceCode = context.getSourceCode();\n\n        const nullOption = (config === \"always\")\n            ? options.null || \"always\"\n            : \"ignore\";\n        const enforceRuleForNull = (nullOption === \"always\");\n        const enforceInverseRuleForNull = (nullOption === \"never\");\n\n        /**\n         * Checks if an expression is a typeof expression\n         * @param  {ASTNode} node The node to check\n         * @returns {boolean} if the node is a typeof expression\n         */\n        function isTypeOf(node) {\n            return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n        }\n\n        /**\n         * Checks if either operand of a binary expression is a typeof operation\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} if one of the operands is typeof\n         * @private\n         */\n        function isTypeOfBinary(node) {\n            return isTypeOf(node.left) || isTypeOf(node.right);\n        }\n\n        /**\n         * Checks if operands are literals of the same type (via typeof)\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} if operands are of same type\n         * @private\n         */\n        function areLiteralsAndSameType(node) {\n            return node.left.type === \"Literal\" && node.right.type === \"Literal\" &&\n                    typeof node.left.value === typeof node.right.value;\n        }\n\n        /**\n         * Checks if one of the operands is a literal null\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} if operands are null\n         * @private\n         */\n        function isNullCheck(node) {\n            return astUtils.isNullLiteral(node.right) || astUtils.isNullLiteral(node.left);\n        }\n\n        /**\n         * Gets the location (line and column) of the binary expression's operator\n         * @param {ASTNode} node The binary expression node to check\n         * @returns {Object} { line, column } location of operator\n         * @private\n         */\n        function getOperatorLocation(node) {\n            const opToken = sourceCode.getTokenAfter(node.left);\n\n            return { line: opToken.loc.start.line, column: opToken.loc.start.column };\n        }\n\n        /**\n         * Reports a message for this rule.\n         * @param {ASTNode} node The binary expression node that was checked\n         * @param {string} expectedOperator The operator that was expected (either '==', '!=', '===', or '!==')\n         * @returns {void}\n         * @private\n         */\n        function report(node, expectedOperator) {\n            context.report({\n                node,\n                loc: getOperatorLocation(node),\n                messageId: \"unexpected\",\n                data: { expectedOperator, actualOperator: node.operator },\n                fix(fixer) {\n\n                    // If the comparison is a `typeof` comparison or both sides are literals with the same type, then it's safe to fix.\n                    if (isTypeOfBinary(node) || areLiteralsAndSameType(node)) {\n                        const operatorToken = sourceCode.getFirstTokenBetween(\n                            node.left,\n                            node.right,\n                            token => token.value === node.operator\n                        );\n\n                        return fixer.replaceText(operatorToken, expectedOperator);\n                    }\n                    return null;\n                }\n            });\n        }\n\n        return {\n            BinaryExpression(node) {\n                const isNull = isNullCheck(node);\n\n                if (node.operator !== \"==\" && node.operator !== \"!=\") {\n                    if (enforceInverseRuleForNull && isNull) {\n                        report(node, node.operator.slice(0, -1));\n                    }\n                    return;\n                }\n\n                if (config === \"smart\" && (isTypeOfBinary(node) ||\n                        areLiteralsAndSameType(node) || isNull)) {\n                    return;\n                }\n\n                if (!enforceRuleForNull && isNull) {\n                    return;\n                }\n\n                report(node, `${node.operator}=`);\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview enforce \"for\" loop update clause moving the counter in the right direction.(for-direction)\n * @author Aladdin-ADD<hh_2013@foxmail.com>\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"enforce \\\"for\\\" loop update clause moving the counter in the right direction.\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/for-direction\"\n        },\n\n        fixable: null,\n        schema: [],\n\n        messages: {\n            incorrectDirection: \"The update clause in this loop moves the variable in the wrong direction.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * report an error.\n         * @param {ASTNode} node the node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node,\n                messageId: \"incorrectDirection\"\n            });\n        }\n\n        /**\n         * check the right side of the assignment\n         * @param {ASTNode} update UpdateExpression to check\n         * @param {int} dir expected direction that could either be turned around or invalidated\n         * @returns {int} return dir, the negated dir or zero if it's not clear for identifiers\n         */\n        function getRightDirection(update, dir) {\n            if (update.right.type === \"UnaryExpression\") {\n                if (update.right.operator === \"-\") {\n                    return -dir;\n                }\n            } else if (update.right.type === \"Identifier\") {\n                return 0;\n            }\n            return dir;\n        }\n\n        /**\n         * check UpdateExpression add/sub the counter\n         * @param {ASTNode} update UpdateExpression to check\n         * @param {string} counter variable name to check\n         * @returns {int} if add return 1, if sub return -1, if nochange, return 0\n         */\n        function getUpdateDirection(update, counter) {\n            if (update.argument.type === \"Identifier\" && update.argument.name === counter) {\n                if (update.operator === \"++\") {\n                    return 1;\n                }\n                if (update.operator === \"--\") {\n                    return -1;\n                }\n            }\n            return 0;\n        }\n\n        /**\n         * check AssignmentExpression add/sub the counter\n         * @param {ASTNode} update AssignmentExpression to check\n         * @param {string} counter variable name to check\n         * @returns {int} if add return 1, if sub return -1, if nochange, return 0\n         */\n        function getAssignmentDirection(update, counter) {\n            if (update.left.name === counter) {\n                if (update.operator === \"+=\") {\n                    return getRightDirection(update, 1);\n                }\n                if (update.operator === \"-=\") {\n                    return getRightDirection(update, -1);\n                }\n            }\n            return 0;\n        }\n        return {\n            ForStatement(node) {\n\n                if (node.test && node.test.type === \"BinaryExpression\" && node.test.left.type === \"Identifier\" && node.update) {\n                    const counter = node.test.left.name;\n                    const operator = node.test.operator;\n                    const update = node.update;\n\n                    let wrongDirection;\n\n                    if (operator === \"<\" || operator === \"<=\") {\n                        wrongDirection = -1;\n                    } else if (operator === \">\" || operator === \">=\") {\n                        wrongDirection = 1;\n                    } else {\n                        return;\n                    }\n\n                    if (update.type === \"UpdateExpression\") {\n                        if (getUpdateDirection(update, counter) === wrongDirection) {\n                            report(node);\n                        }\n                    } else if (update.type === \"AssignmentExpression\" && getAssignmentDirection(update, counter) === wrongDirection) {\n                        report(node);\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to control spacing within function calls\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow spacing between function identifiers and their invocations\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/func-call-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"never\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                allowNewlines: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        messages: {\n            unexpected: \"Unexpected newline between function name and paren.\",\n            missing: \"Missing space between function name and paren.\"\n        }\n    },\n\n    create(context) {\n\n        const never = context.options[0] !== \"always\";\n        const allowNewlines = !never && context.options[1] && context.options[1].allowNewlines;\n        const sourceCode = context.getSourceCode();\n        const text = sourceCode.getText();\n\n        /**\n         * Check if open space is present in a function name\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkSpacing(node) {\n            const lastToken = sourceCode.getLastToken(node);\n            const lastCalleeToken = sourceCode.getLastToken(node.callee);\n            const parenToken = sourceCode.getFirstTokenBetween(lastCalleeToken, lastToken, astUtils.isOpeningParenToken);\n            const prevToken = parenToken && sourceCode.getTokenBefore(parenToken);\n\n            // Parens in NewExpression are optional\n            if (!(parenToken && parenToken.range[1] < node.range[1])) {\n                return;\n            }\n\n            const textBetweenTokens = text.slice(prevToken.range[1], parenToken.range[0]).replace(/\\/\\*.*?\\*\\//gu, \"\");\n            const hasWhitespace = /\\s/u.test(textBetweenTokens);\n            const hasNewline = hasWhitespace && astUtils.LINEBREAK_MATCHER.test(textBetweenTokens);\n\n            /*\n             * never allowNewlines hasWhitespace hasNewline message\n             * F     F             F             F          Missing space between function name and paren.\n             * F     F             F             T          (Invalid `!hasWhitespace && hasNewline`)\n             * F     F             T             T          Unexpected newline between function name and paren.\n             * F     F             T             F          (OK)\n             * F     T             T             F          (OK)\n             * F     T             T             T          (OK)\n             * F     T             F             T          (Invalid `!hasWhitespace && hasNewline`)\n             * F     T             F             F          Missing space between function name and paren.\n             * T     T             F             F          (Invalid `never && allowNewlines`)\n             * T     T             F             T          (Invalid `!hasWhitespace && hasNewline`)\n             * T     T             T             T          (Invalid `never && allowNewlines`)\n             * T     T             T             F          (Invalid `never && allowNewlines`)\n             * T     F             T             F          Unexpected space between function name and paren.\n             * T     F             T             T          Unexpected space between function name and paren.\n             * T     F             F             T          (Invalid `!hasWhitespace && hasNewline`)\n             * T     F             F             F          (OK)\n             *\n             * T                   T                        Unexpected space between function name and paren.\n             * F                   F                        Missing space between function name and paren.\n             * F     F                           T          Unexpected newline between function name and paren.\n             */\n\n            if (never && hasWhitespace) {\n                context.report({\n                    node,\n                    loc: lastCalleeToken.loc.start,\n                    messageId: \"unexpected\",\n                    fix(fixer) {\n\n                        /*\n                         * Only autofix if there is no newline\n                         * https://github.com/eslint/eslint/issues/7787\n                         */\n                        if (!hasNewline) {\n                            return fixer.removeRange([prevToken.range[1], parenToken.range[0]]);\n                        }\n\n                        return null;\n                    }\n                });\n            } else if (!never && !hasWhitespace) {\n                context.report({\n                    node,\n                    loc: lastCalleeToken.loc.start,\n                    messageId: \"missing\",\n                    fix(fixer) {\n                        return fixer.insertTextBefore(parenToken, \" \");\n                    }\n                });\n            } else if (!never && !allowNewlines && hasNewline) {\n                context.report({\n                    node,\n                    loc: lastCalleeToken.loc.start,\n                    messageId: \"unexpected\",\n                    fix(fixer) {\n                        return fixer.replaceTextRange([prevToken.range[1], parenToken.range[0]], \" \");\n                    }\n                });\n            }\n        }\n\n        return {\n            CallExpression: checkSpacing,\n            NewExpression: checkSpacing\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to require function names to match the name of the variable or property to which they are assigned.\n * @author Annie Zhang, Pavel Strashkin\n */\n\n\n\n//--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\nconst esutils = require(\"esutils\");\n\n//--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines if a pattern is `module.exports` or `module[\"exports\"]`\n * @param {ASTNode} pattern The left side of the AssignmentExpression\n * @returns {boolean} True if the pattern is `module.exports` or `module[\"exports\"]`\n */\nfunction isModuleExports(pattern) {\n    if (pattern.type === \"MemberExpression\" && pattern.object.type === \"Identifier\" && pattern.object.name === \"module\") {\n\n        // module.exports\n        if (pattern.property.type === \"Identifier\" && pattern.property.name === \"exports\") {\n            return true;\n        }\n\n        // module[\"exports\"]\n        if (pattern.property.type === \"Literal\" && pattern.property.value === \"exports\") {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Determines if a string name is a valid identifier\n * @param {string} name The string to be checked\n * @param {int} ecmaVersion The ECMAScript version if specified in the parserOptions config\n * @returns {boolean} True if the string is a valid identifier\n */\nfunction isIdentifier(name, ecmaVersion) {\n    if (ecmaVersion >= 6) {\n        return esutils.keyword.isIdentifierES6(name);\n    }\n    return esutils.keyword.isIdentifierES5(name);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst alwaysOrNever = { enum: [\"always\", \"never\"] };\nconst optionsObject = {\n    type: \"object\",\n    properties: {\n        considerPropertyDescriptor: {\n            type: \"boolean\"\n        },\n        includeCommonJSModuleExports: {\n            type: \"boolean\"\n        }\n    },\n    additionalProperties: false\n};\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require function names to match the name of the variable or property to which they are assigned\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/func-name-matching\"\n        },\n\n        schema: {\n            anyOf: [{\n                type: \"array\",\n                additionalItems: false,\n                items: [alwaysOrNever, optionsObject]\n            }, {\n                type: \"array\",\n                additionalItems: false,\n                items: [optionsObject]\n            }]\n        },\n\n        messages: {\n            matchProperty: \"Function name `{{funcName}}` should match property name `{{name}}`.\",\n            matchVariable: \"Function name `{{funcName}}` should match variable name `{{name}}`.\",\n            notMatchProperty: \"Function name `{{funcName}}` should not match property name `{{name}}`.\",\n            notMatchVariable: \"Function name `{{funcName}}` should not match variable name `{{name}}`.\"\n        }\n    },\n\n    create(context) {\n        const options = (typeof context.options[0] === \"object\" ? context.options[0] : context.options[1]) || {};\n        const nameMatches = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\n        const considerPropertyDescriptor = options.considerPropertyDescriptor;\n        const includeModuleExports = options.includeCommonJSModuleExports;\n        const ecmaVersion = context.parserOptions && context.parserOptions.ecmaVersion ? context.parserOptions.ecmaVersion : 5;\n\n        /**\n         * Check whether node is a certain CallExpression.\n         * @param {string} objName object name\n         * @param {string} funcName function name\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} `true` if node matches CallExpression\n         */\n        function isPropertyCall(objName, funcName, node) {\n            if (!node) {\n                return false;\n            }\n            return node.type === \"CallExpression\" &&\n                node.callee.object.name === objName &&\n                node.callee.property.name === funcName;\n        }\n\n        /**\n         * Compares identifiers based on the nameMatches option\n         * @param {string} x the first identifier\n         * @param {string} y the second identifier\n         * @returns {boolean} whether the two identifiers should warn.\n         */\n        function shouldWarn(x, y) {\n            return (nameMatches === \"always\" && x !== y) || (nameMatches === \"never\" && x === y);\n        }\n\n        /**\n         * Reports\n         * @param {ASTNode} node The node to report\n         * @param {string} name The variable or property name\n         * @param {string} funcName The function name\n         * @param {boolean} isProp True if the reported node is a property assignment\n         * @returns {void}\n         */\n        function report(node, name, funcName, isProp) {\n            let messageId;\n\n            if (nameMatches === \"always\" && isProp) {\n                messageId = \"matchProperty\";\n            } else if (nameMatches === \"always\") {\n                messageId = \"matchVariable\";\n            } else if (isProp) {\n                messageId = \"notMatchProperty\";\n            } else {\n                messageId = \"notMatchVariable\";\n            }\n            context.report({\n                node,\n                messageId,\n                data: {\n                    name,\n                    funcName\n                }\n            });\n        }\n\n        /**\n         * Determines whether a given node is a string literal\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} `true` if the node is a string literal\n         */\n        function isStringLiteral(node) {\n            return node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclarator(node) {\n                if (!node.init || node.init.type !== \"FunctionExpression\" || node.id.type !== \"Identifier\") {\n                    return;\n                }\n                if (node.init.id && shouldWarn(node.id.name, node.init.id.name)) {\n                    report(node, node.id.name, node.init.id.name, false);\n                }\n            },\n\n            AssignmentExpression(node) {\n                if (\n                    node.right.type !== \"FunctionExpression\" ||\n                    (node.left.computed && node.left.property.type !== \"Literal\") ||\n                    (!includeModuleExports && isModuleExports(node.left)) ||\n                    (node.left.type !== \"Identifier\" && node.left.type !== \"MemberExpression\")\n                ) {\n                    return;\n                }\n\n                const isProp = node.left.type === \"MemberExpression\";\n                const name = isProp ? astUtils.getStaticPropertyName(node.left) : node.left.name;\n\n                if (node.right.id && isIdentifier(name) && shouldWarn(name, node.right.id.name)) {\n                    report(node, name, node.right.id.name, isProp);\n                }\n            },\n\n            Property(node) {\n                if (node.value.type !== \"FunctionExpression\" || !node.value.id || node.computed && !isStringLiteral(node.key)) {\n                    return;\n                }\n\n                if (node.key.type === \"Identifier\") {\n                    const functionName = node.value.id.name;\n                    let propertyName = node.key.name;\n\n                    if (considerPropertyDescriptor && propertyName === \"value\") {\n                        if (isPropertyCall(\"Object\", \"defineProperty\", node.parent.parent) || isPropertyCall(\"Reflect\", \"defineProperty\", node.parent.parent)) {\n                            const property = node.parent.parent.arguments[1];\n\n                            if (isStringLiteral(property) && shouldWarn(property.value, functionName)) {\n                                report(node, property.value, functionName, true);\n                            }\n                        } else if (isPropertyCall(\"Object\", \"defineProperties\", node.parent.parent.parent.parent)) {\n                            propertyName = node.parent.parent.key.name;\n                            if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {\n                                report(node, propertyName, functionName, true);\n                            }\n                        } else if (isPropertyCall(\"Object\", \"create\", node.parent.parent.parent.parent)) {\n                            propertyName = node.parent.parent.key.name;\n                            if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {\n                                report(node, propertyName, functionName, true);\n                            }\n                        } else if (shouldWarn(propertyName, functionName)) {\n                            report(node, propertyName, functionName, true);\n                        }\n                    } else if (shouldWarn(propertyName, functionName)) {\n                        report(node, propertyName, functionName, true);\n                    }\n                    return;\n                }\n\n                if (\n                    isStringLiteral(node.key) &&\n                    isIdentifier(node.key.value, ecmaVersion) &&\n                    shouldWarn(node.key.value, node.value.id.name)\n                ) {\n                    report(node, node.key.value, node.value.id.name, true);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to warn when a function expression does not have a name.\n * @author Kyle T. Nunery\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n/**\n * Checks whether or not a given variable is a function name.\n * @param {eslint-scope.Variable} variable - A variable to check.\n * @returns {boolean} `true` if the variable is a function name.\n */\nfunction isFunctionName(variable) {\n    return variable && variable.defs[0].type === \"FunctionName\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require or disallow named `function` expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/func-names\"\n        },\n\n        schema: {\n            definitions: {\n                value: {\n                    enum: [\n                        \"always\",\n                        \"as-needed\",\n                        \"never\"\n                    ]\n                }\n            },\n            items: [\n                {\n                    $ref: \"#/definitions/value\"\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        generators: {\n                            $ref: \"#/definitions/value\"\n                        }\n                    },\n                    additionalProperties: false\n                }\n            ]\n        },\n\n        messages: {\n            unnamed: \"Unexpected unnamed {{name}}.\",\n            named: \"Unexpected named {{name}}.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Returns the config option for the given node.\n         * @param {ASTNode} node - A node to get the config for.\n         * @returns {string} The config option.\n         */\n        function getConfigForNode(node) {\n            if (\n                node.generator &&\n                context.options.length > 1 &&\n                context.options[1].generators\n            ) {\n                return context.options[1].generators;\n            }\n\n            return context.options[0] || \"always\";\n        }\n\n        /**\n         * Determines whether the current FunctionExpression node is a get, set, or\n         * shorthand method in an object literal or a class.\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} True if the node is a get, set, or shorthand method.\n         */\n        function isObjectOrClassMethod(node) {\n            const parent = node.parent;\n\n            return (parent.type === \"MethodDefinition\" || (\n                parent.type === \"Property\" && (\n                    parent.method ||\n                    parent.kind === \"get\" ||\n                    parent.kind === \"set\"\n                )\n            ));\n        }\n\n        /**\n         * Determines whether the current FunctionExpression node has a name that would be\n         * inferred from context in a conforming ES6 environment.\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} True if the node would have a name assigned automatically.\n         */\n        function hasInferredName(node) {\n            const parent = node.parent;\n\n            return isObjectOrClassMethod(node) ||\n                (parent.type === \"VariableDeclarator\" && parent.id.type === \"Identifier\" && parent.init === node) ||\n                (parent.type === \"Property\" && parent.value === node) ||\n                (parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\" && parent.right === node) ||\n                (parent.type === \"ExportDefaultDeclaration\" && parent.declaration === node) ||\n                (parent.type === \"AssignmentPattern\" && parent.right === node);\n        }\n\n        /**\n         * Reports that an unnamed function should be named\n         * @param {ASTNode} node - The node to report in the event of an error.\n         * @returns {void}\n         */\n        function reportUnexpectedUnnamedFunction(node) {\n            context.report({\n                node,\n                messageId: \"unnamed\",\n                data: { name: astUtils.getFunctionNameWithKind(node) }\n            });\n        }\n\n        /**\n         * Reports that a named function should be unnamed\n         * @param {ASTNode} node - The node to report in the event of an error.\n         * @returns {void}\n         */\n        function reportUnexpectedNamedFunction(node) {\n            context.report({\n                node,\n                messageId: \"named\",\n                data: { name: astUtils.getFunctionNameWithKind(node) }\n            });\n        }\n\n        return {\n            \"FunctionExpression:exit\"(node) {\n\n                // Skip recursive functions.\n                const nameVar = context.getDeclaredVariables(node)[0];\n\n                if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n                    return;\n                }\n\n                const hasName = Boolean(node.id && node.id.name);\n                const config = getConfigForNode(node);\n\n                if (config === \"never\") {\n                    if (hasName) {\n                        reportUnexpectedNamedFunction(node);\n                    }\n                } else if (config === \"as-needed\") {\n                    if (!hasName && !hasInferredName(node)) {\n                        reportUnexpectedUnnamedFunction(node);\n                    }\n                } else {\n                    if (!hasName && !isObjectOrClassMethod(node)) {\n                        reportUnexpectedUnnamedFunction(node);\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce a particular function style\n * @author Nicholas C. Zakas\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce the consistent use of either `function` declarations or expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/func-style\"\n        },\n\n        schema: [\n            {\n                enum: [\"declaration\", \"expression\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    allowArrowFunctions: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            expression: \"Expected a function expression.\",\n            declaration: \"Expected a function declaration.\"\n        }\n    },\n\n    create(context) {\n\n        const style = context.options[0],\n            allowArrowFunctions = context.options[1] && context.options[1].allowArrowFunctions,\n            enforceDeclarations = (style === \"declaration\"),\n            stack = [];\n\n        const nodesToCheck = {\n            FunctionDeclaration(node) {\n                stack.push(false);\n\n                if (!enforceDeclarations && node.parent.type !== \"ExportDefaultDeclaration\") {\n                    context.report({ node, messageId: \"expression\" });\n                }\n            },\n            \"FunctionDeclaration:exit\"() {\n                stack.pop();\n            },\n\n            FunctionExpression(node) {\n                stack.push(false);\n\n                if (enforceDeclarations && node.parent.type === \"VariableDeclarator\") {\n                    context.report({ node: node.parent, messageId: \"declaration\" });\n                }\n            },\n            \"FunctionExpression:exit\"() {\n                stack.pop();\n            },\n\n            ThisExpression() {\n                if (stack.length > 0) {\n                    stack[stack.length - 1] = true;\n                }\n            }\n        };\n\n        if (!allowArrowFunctions) {\n            nodesToCheck.ArrowFunctionExpression = function() {\n                stack.push(false);\n            };\n\n            nodesToCheck[\"ArrowFunctionExpression:exit\"] = function(node) {\n                const hasThisExpr = stack.pop();\n\n                if (enforceDeclarations && !hasThisExpr && node.parent.type === \"VariableDeclarator\") {\n                    context.report({ node: node.parent, messageId: \"declaration\" });\n                }\n            };\n        }\n\n        return nodesToCheck;\n\n    }\n};\n","/**\n * @fileoverview enforce consistent line breaks inside function parentheses\n * @author Teddy Katz\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent line breaks inside function parentheses\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/function-paren-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\", \"consistent\", \"multiline\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            minItems: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            expectedBefore: \"Expected newline before ')'.\",\n            expectedAfter: \"Expected newline after '('.\",\n            unexpectedBefore: \"Unexpected newline before '('.\",\n            unexpectedAfter: \"Unexpected newline after ')'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const rawOption = context.options[0] || \"multiline\";\n        const multilineOption = rawOption === \"multiline\";\n        const consistentOption = rawOption === \"consistent\";\n        let minItems;\n\n        if (typeof rawOption === \"object\") {\n            minItems = rawOption.minItems;\n        } else if (rawOption === \"always\") {\n            minItems = 0;\n        } else if (rawOption === \"never\") {\n            minItems = Infinity;\n        } else {\n            minItems = null;\n        }\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Determines whether there should be newlines inside function parens\n         * @param {ASTNode[]} elements The arguments or parameters in the list\n         * @param {boolean} hasLeftNewline `true` if the left paren has a newline in the current code.\n         * @returns {boolean} `true` if there should be newlines inside the function parens\n         */\n        function shouldHaveNewlines(elements, hasLeftNewline) {\n            if (multilineOption) {\n                return elements.some((element, index) => index !== elements.length - 1 && element.loc.end.line !== elements[index + 1].loc.start.line);\n            }\n            if (consistentOption) {\n                return hasLeftNewline;\n            }\n            return elements.length >= minItems;\n        }\n\n        /**\n         * Validates a list of arguments or parameters\n         * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token\n         * @param {ASTNode[]} elements The arguments or parameters in the list\n         * @returns {void}\n         */\n        function validateParens(parens, elements) {\n            const leftParen = parens.leftParen;\n            const rightParen = parens.rightParen;\n            const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);\n            const tokenBeforeRightParen = sourceCode.getTokenBefore(rightParen);\n            const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);\n            const hasRightNewline = !astUtils.isTokenOnSameLine(tokenBeforeRightParen, rightParen);\n            const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);\n\n            if (hasLeftNewline && !needsNewlines) {\n                context.report({\n                    node: leftParen,\n                    messageId: \"unexpectedAfter\",\n                    fix(fixer) {\n                        return sourceCode.getText().slice(leftParen.range[1], tokenAfterLeftParen.range[0]).trim()\n\n                            // If there is a comment between the ( and the first element, don't do a fix.\n                            ? null\n                            : fixer.removeRange([leftParen.range[1], tokenAfterLeftParen.range[0]]);\n                    }\n                });\n            } else if (!hasLeftNewline && needsNewlines) {\n                context.report({\n                    node: leftParen,\n                    messageId: \"expectedAfter\",\n                    fix: fixer => fixer.insertTextAfter(leftParen, \"\\n\")\n                });\n            }\n\n            if (hasRightNewline && !needsNewlines) {\n                context.report({\n                    node: rightParen,\n                    messageId: \"unexpectedBefore\",\n                    fix(fixer) {\n                        return sourceCode.getText().slice(tokenBeforeRightParen.range[1], rightParen.range[0]).trim()\n\n                            // If there is a comment between the last element and the ), don't do a fix.\n                            ? null\n                            : fixer.removeRange([tokenBeforeRightParen.range[1], rightParen.range[0]]);\n                    }\n                });\n            } else if (!hasRightNewline && needsNewlines) {\n                context.report({\n                    node: rightParen,\n                    messageId: \"expectedBefore\",\n                    fix: fixer => fixer.insertTextBefore(rightParen, \"\\n\")\n                });\n            }\n        }\n\n        /**\n         * Gets the left paren and right paren tokens of a node.\n         * @param {ASTNode} node The node with parens\n         * @returns {Object} An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token.\n         * Can also return `null` if an expression has no parens (e.g. a NewExpression with no arguments, or an ArrowFunctionExpression\n         * with a single parameter)\n         */\n        function getParenTokens(node) {\n            switch (node.type) {\n                case \"NewExpression\":\n                    if (!node.arguments.length && !(\n                        astUtils.isOpeningParenToken(sourceCode.getLastToken(node, { skip: 1 })) &&\n                        astUtils.isClosingParenToken(sourceCode.getLastToken(node))\n                    )) {\n\n                        // If the NewExpression does not have parens (e.g. `new Foo`), return null.\n                        return null;\n                    }\n\n                    // falls through\n\n                case \"CallExpression\":\n                    return {\n                        leftParen: sourceCode.getTokenAfter(node.callee, astUtils.isOpeningParenToken),\n                        rightParen: sourceCode.getLastToken(node)\n                    };\n\n                case \"FunctionDeclaration\":\n                case \"FunctionExpression\": {\n                    const leftParen = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\n                    const rightParen = node.params.length\n                        ? sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isClosingParenToken)\n                        : sourceCode.getTokenAfter(leftParen);\n\n                    return { leftParen, rightParen };\n                }\n\n                case \"ArrowFunctionExpression\": {\n                    const firstToken = sourceCode.getFirstToken(node);\n\n                    if (!astUtils.isOpeningParenToken(firstToken)) {\n\n                        // If the ArrowFunctionExpression has a single param without parens, return null.\n                        return null;\n                    }\n\n                    return {\n                        leftParen: firstToken,\n                        rightParen: sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken)\n                    };\n                }\n\n                default:\n                    throw new TypeError(`unexpected node with type ${node.type}`);\n            }\n        }\n\n        /**\n         * Validates the parentheses for a node\n         * @param {ASTNode} node The node with parens\n         * @returns {void}\n         */\n        function validateNode(node) {\n            const parens = getParenTokens(node);\n\n            if (parens) {\n                validateParens(parens, astUtils.isFunction(node) ? node.params : node.arguments);\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            ArrowFunctionExpression: validateNode,\n            CallExpression: validateNode,\n            FunctionDeclaration: validateNode,\n            FunctionExpression: validateNode,\n            NewExpression: validateNode\n        };\n    }\n};\n","/**\n * @fileoverview Rule to check the spacing around the * in generator functions.\n * @author Jamund Ferguson\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst OVERRIDE_SCHEMA = {\n    oneOf: [\n        {\n            enum: [\"before\", \"after\", \"both\", \"neither\"]\n        },\n        {\n            type: \"object\",\n            properties: {\n                before: { type: \"boolean\" },\n                after: { type: \"boolean\" }\n            },\n            additionalProperties: false\n        }\n    ]\n};\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing around `*` operators in generator functions\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/generator-star-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"before\", \"after\", \"both\", \"neither\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            before: { type: \"boolean\" },\n                            after: { type: \"boolean\" },\n                            named: OVERRIDE_SCHEMA,\n                            anonymous: OVERRIDE_SCHEMA,\n                            method: OVERRIDE_SCHEMA\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            missingBefore: \"Missing space before *.\",\n            missingAfter: \"Missing space after *.\",\n            unexpectedBefore: \"Unexpected space before *.\",\n            unexpectedAfter: \"Unexpected space after *.\"\n        }\n    },\n\n    create(context) {\n\n        const optionDefinitions = {\n            before: { before: true, after: false },\n            after: { before: false, after: true },\n            both: { before: true, after: true },\n            neither: { before: false, after: false }\n        };\n\n        /**\n         * Returns resolved option definitions based on an option and defaults\n         *\n         * @param {any} option - The option object or string value\n         * @param {Object} defaults - The defaults to use if options are not present\n         * @returns {Object} the resolved object definition\n         */\n        function optionToDefinition(option, defaults) {\n            if (!option) {\n                return defaults;\n            }\n\n            return typeof option === \"string\"\n                ? optionDefinitions[option]\n                : Object.assign({}, defaults, option);\n        }\n\n        const modes = (function(option) {\n            const defaults = optionToDefinition(option, optionDefinitions.before);\n\n            return {\n                named: optionToDefinition(option.named, defaults),\n                anonymous: optionToDefinition(option.anonymous, defaults),\n                method: optionToDefinition(option.method, defaults)\n            };\n        }(context.options[0] || {}));\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Checks if the given token is a star token or not.\n         *\n         * @param {Token} token - The token to check.\n         * @returns {boolean} `true` if the token is a star token.\n         */\n        function isStarToken(token) {\n            return token.value === \"*\" && token.type === \"Punctuator\";\n        }\n\n        /**\n         * Gets the generator star token of the given function node.\n         *\n         * @param {ASTNode} node - The function node to get.\n         * @returns {Token} Found star token.\n         */\n        function getStarToken(node) {\n            return sourceCode.getFirstToken(\n                (node.parent.method || node.parent.type === \"MethodDefinition\") ? node.parent : node,\n                isStarToken\n            );\n        }\n\n        /**\n         * capitalize a given string.\n         * @param {string} str the given string.\n         * @returns {string} the capitalized string.\n         */\n        function capitalize(str) {\n            return str[0].toUpperCase() + str.slice(1);\n        }\n\n        /**\n         * Checks the spacing between two tokens before or after the star token.\n         *\n         * @param {string} kind Either \"named\", \"anonymous\", or \"method\"\n         * @param {string} side Either \"before\" or \"after\".\n         * @param {Token} leftToken `function` keyword token if side is \"before\", or\n         *     star token if side is \"after\".\n         * @param {Token} rightToken Star token if side is \"before\", or identifier\n         *     token if side is \"after\".\n         * @returns {void}\n         */\n        function checkSpacing(kind, side, leftToken, rightToken) {\n            if (!!(rightToken.range[0] - leftToken.range[1]) !== modes[kind][side]) {\n                const after = leftToken.value === \"*\";\n                const spaceRequired = modes[kind][side];\n                const node = after ? leftToken : rightToken;\n                const messageId = `${spaceRequired ? \"missing\" : \"unexpected\"}${capitalize(side)}`;\n\n                context.report({\n                    node,\n                    messageId,\n                    fix(fixer) {\n                        if (spaceRequired) {\n                            if (after) {\n                                return fixer.insertTextAfter(node, \" \");\n                            }\n                            return fixer.insertTextBefore(node, \" \");\n                        }\n                        return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Enforces the spacing around the star if node is a generator function.\n         *\n         * @param {ASTNode} node A function expression or declaration node.\n         * @returns {void}\n         */\n        function checkFunction(node) {\n            if (!node.generator) {\n                return;\n            }\n\n            const starToken = getStarToken(node);\n            const prevToken = sourceCode.getTokenBefore(starToken);\n            const nextToken = sourceCode.getTokenAfter(starToken);\n\n            let kind = \"named\";\n\n            if (node.parent.type === \"MethodDefinition\" || (node.parent.type === \"Property\" && node.parent.method)) {\n                kind = \"method\";\n            } else if (!node.id) {\n                kind = \"anonymous\";\n            }\n\n            // Only check before when preceded by `function`|`static` keyword\n            if (!(kind === \"method\" && starToken === sourceCode.getFirstToken(node.parent))) {\n                checkSpacing(kind, \"before\", prevToken, starToken);\n            }\n\n            checkSpacing(kind, \"after\", starToken, nextToken);\n        }\n\n        return {\n            FunctionDeclaration: checkFunction,\n            FunctionExpression: checkFunction\n        };\n\n    }\n};\n","/**\n * @fileoverview Enforces that a return statement is present in property getters.\n * @author Aladdin-ADD(hh_2013@foxmail.com)\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\n\n/**\n * Checks a given code path segment is reachable.\n *\n * @param {CodePathSegment} segment - A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Gets a readable location.\n *\n * - FunctionExpression -> the function name or `function` keyword.\n *\n * @param {ASTNode} node - A function node to get.\n * @returns {ASTNode|Token} The node or the token of a location.\n */\nfunction getId(node) {\n    return node.id || node;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"enforce `return` statements in getters\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/getter-return\"\n        },\n\n        fixable: null,\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowImplicit: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            expected: \"Expected to return a value in {{name}}.\",\n            expectedAlways: \"Expected {{name}} to always return a value.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0] || { allowImplicit: false };\n\n        let funcInfo = {\n            upper: null,\n            codePath: null,\n            hasReturn: false,\n            shouldCheck: false,\n            node: null\n        };\n\n        /**\n         * Checks whether or not the last code path segment is reachable.\n         * Then reports this function if the segment is reachable.\n         *\n         * If the last code path segment is reachable, there are paths which are not\n         * returned or thrown.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {void}\n         */\n        function checkLastSegment(node) {\n            if (funcInfo.shouldCheck &&\n                funcInfo.codePath.currentSegments.some(isReachable)\n            ) {\n                context.report({\n                    node,\n                    loc: getId(node).loc.start,\n                    messageId: funcInfo.hasReturn ? \"expectedAlways\" : \"expected\",\n                    data: {\n                        name: astUtils.getFunctionNameWithKind(funcInfo.node)\n                    }\n                });\n            }\n        }\n\n        /**\n         * Checks whether a node means a getter function.\n         * @param {ASTNode} node - a node to check.\n         * @returns {boolean} if node means a getter, return true; else return false.\n         */\n        function isGetter(node) {\n            const parent = node.parent;\n\n            if (TARGET_NODE_TYPE.test(node.type) && node.body.type === \"BlockStatement\") {\n                if (parent.kind === \"get\") {\n                    return true;\n                }\n                if (parent.type === \"Property\" && astUtils.getStaticPropertyName(parent) === \"get\" && parent.parent.type === \"ObjectExpression\") {\n\n                    // Object.defineProperty()\n                    if (parent.parent.parent.type === \"CallExpression\" &&\n                        astUtils.getStaticPropertyName(parent.parent.parent.callee) === \"defineProperty\") {\n                        return true;\n                    }\n\n                    // Object.defineProperties()\n                    if (parent.parent.parent.type === \"Property\" &&\n                        parent.parent.parent.parent.type === \"ObjectExpression\" &&\n                        parent.parent.parent.parent.parent.type === \"CallExpression\" &&\n                        astUtils.getStaticPropertyName(parent.parent.parent.parent.parent.callee) === \"defineProperties\") {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        return {\n\n            // Stacks this function's information.\n            onCodePathStart(codePath, node) {\n                funcInfo = {\n                    upper: funcInfo,\n                    codePath,\n                    hasReturn: false,\n                    shouldCheck: isGetter(node),\n                    node\n                };\n            },\n\n            // Pops this function's information.\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n\n            // Checks the return statement is valid.\n            ReturnStatement(node) {\n                if (funcInfo.shouldCheck) {\n                    funcInfo.hasReturn = true;\n\n                    // if allowImplicit: false, should also check node.argument\n                    if (!options.allowImplicit && !node.argument) {\n                        context.report({\n                            node,\n                            messageId: \"expected\",\n                            data: {\n                                name: astUtils.getFunctionNameWithKind(funcInfo.node)\n                            }\n                        });\n                    }\n                }\n            },\n\n            // Reports a given function if the last path is reachable.\n            \"FunctionExpression:exit\": checkLastSegment,\n            \"ArrowFunctionExpression:exit\": checkLastSegment\n        };\n    }\n};\n","/**\n * @fileoverview Rule for disallowing require() outside of the top-level module context\n * @author Jamund Ferguson\n */\n\n\n\nconst ACCEPTABLE_PARENTS = [\n    \"AssignmentExpression\",\n    \"VariableDeclarator\",\n    \"MemberExpression\",\n    \"ExpressionStatement\",\n    \"CallExpression\",\n    \"ConditionalExpression\",\n    \"Program\",\n    \"VariableDeclaration\"\n];\n\n/**\n * Finds the eslint-scope reference in the given scope.\n * @param {Object} scope The scope to search.\n * @param {ASTNode} node The identifier node.\n * @returns {Reference|null} Returns the found reference or null if none were found.\n */\nfunction findReference(scope, node) {\n    const references = scope.references.filter(reference => reference.identifier.range[0] === node.range[0] &&\n            reference.identifier.range[1] === node.range[1]);\n\n    /* istanbul ignore else: correctly returns null */\n    if (references.length === 1) {\n        return references[0];\n    }\n    return null;\n\n}\n\n/**\n * Checks if the given identifier node is shadowed in the given scope.\n * @param {Object} scope The current scope.\n * @param {ASTNode} node The identifier node to check.\n * @returns {boolean} Whether or not the name is shadowed.\n */\nfunction isShadowed(scope, node) {\n    const reference = findReference(scope, node);\n\n    return reference && reference.resolved && reference.resolved.defs.length > 0;\n}\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `require()` calls to be placed at top-level module scope\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/global-require\"\n        },\n\n        schema: [],\n        messages: {\n            unexpected: \"Unexpected require().\"\n        }\n    },\n\n    create(context) {\n        return {\n            CallExpression(node) {\n                const currentScope = context.getScope();\n\n                if (node.callee.name === \"require\" && !isShadowed(currentScope, node.callee)) {\n                    const isGoodRequire = context.getAncestors().every(parent => ACCEPTABLE_PARENTS.indexOf(parent.type) > -1);\n\n                    if (!isGoodRequire) {\n                        context.report({ node, messageId: \"unexpected\" });\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag for-in loops without if statements inside\n * @author Nicholas C. Zakas\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `for-in` loops to include an `if` statement\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/guard-for-in\"\n        },\n\n        schema: [],\n        messages: {\n            wrap: \"The body of a for-in should be wrapped in an if statement to filter unwanted properties from the prototype.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n\n            ForInStatement(node) {\n                const body = node.body;\n\n                // empty statement\n                if (body.type === \"EmptyStatement\") {\n                    return;\n                }\n\n                // if statement\n                if (body.type === \"IfStatement\") {\n                    return;\n                }\n\n                // empty block\n                if (body.type === \"BlockStatement\" && body.body.length === 0) {\n                    return;\n                }\n\n                // block with just if statement\n                if (body.type === \"BlockStatement\" && body.body.length === 1 && body.body[0].type === \"IfStatement\") {\n                    return;\n                }\n\n                // block that starts with if statement\n                if (body.type === \"BlockStatement\" && body.body.length >= 1 && body.body[0].type === \"IfStatement\") {\n                    const i = body.body[0];\n\n                    // ... whose consequent is a continue\n                    if (i.consequent.type === \"ContinueStatement\") {\n                        return;\n                    }\n\n                    // ... whose consequent is a block that contains only a continue\n                    if (i.consequent.type === \"BlockStatement\" && i.consequent.body.length === 1 && i.consequent.body[0].type === \"ContinueStatement\") {\n                        return;\n                    }\n                }\n\n                context.report({ node, messageId: \"wrap\" });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Ensure handling of errors when we know they exist.\n * @author Jamund Ferguson\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require error handling in callbacks\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/handle-callback-err\"\n        },\n\n        schema: [\n            {\n                type: \"string\"\n            }\n        ],\n        messages: {\n            expected: \"Expected error to be handled.\"\n        }\n    },\n\n    create(context) {\n\n        const errorArgument = context.options[0] || \"err\";\n\n        /**\n         * Checks if the given argument should be interpreted as a regexp pattern.\n         * @param {string} stringToCheck The string which should be checked.\n         * @returns {boolean} Whether or not the string should be interpreted as a pattern.\n         */\n        function isPattern(stringToCheck) {\n            const firstChar = stringToCheck[0];\n\n            return firstChar === \"^\";\n        }\n\n        /**\n         * Checks if the given name matches the configured error argument.\n         * @param {string} name The name which should be compared.\n         * @returns {boolean} Whether or not the given name matches the configured error variable name.\n         */\n        function matchesConfiguredErrorName(name) {\n            if (isPattern(errorArgument)) {\n                const regexp = new RegExp(errorArgument); // eslint-disable-line require-unicode-regexp\n\n                return regexp.test(name);\n            }\n            return name === errorArgument;\n        }\n\n        /**\n         * Get the parameters of a given function scope.\n         * @param {Object} scope The function scope.\n         * @returns {Array} All parameters of the given scope.\n         */\n        function getParameters(scope) {\n            return scope.variables.filter(variable => variable.defs[0] && variable.defs[0].type === \"Parameter\");\n        }\n\n        /**\n         * Check to see if we're handling the error object properly.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         */\n        function checkForError(node) {\n            const scope = context.getScope(),\n                parameters = getParameters(scope),\n                firstParameter = parameters[0];\n\n            if (firstParameter && matchesConfiguredErrorName(firstParameter.name)) {\n                if (firstParameter.references.length === 0) {\n                    context.report({ node, messageId: \"expected\" });\n                }\n            }\n        }\n\n        return {\n            FunctionDeclaration: checkForError,\n            FunctionExpression: checkForError,\n            ArrowFunctionExpression: checkForError\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule that warns when identifier names that are\n * blacklisted in the configuration are used.\n * @author Keith Cirkel (http://keithcirkel.co.uk)\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow specified identifiers\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/id-blacklist\"\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                type: \"string\"\n            },\n            uniqueItems: true\n        },\n        messages: {\n            blacklisted: \"Identifier '{{name}}' is blacklisted.\"\n        }\n    },\n\n    create(context) {\n\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const blacklist = context.options;\n\n\n        /**\n         * Checks if a string matches the provided pattern\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is a match\n         * @private\n         */\n        function isInvalid(name) {\n            return blacklist.indexOf(name) !== -1;\n        }\n\n        /**\n         * Verifies if we should report an error or not based on the effective\n         * parent node and the identifier name.\n         * @param {ASTNode} effectiveParent The effective parent node of the node to be reported\n         * @param {string} name The identifier name of the identifier node\n         * @returns {boolean} whether an error should be reported or not\n         */\n        function shouldReport(effectiveParent, name) {\n            return effectiveParent.type !== \"CallExpression\" &&\n                effectiveParent.type !== \"NewExpression\" &&\n                isInvalid(name);\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            context.report({\n                node,\n                messageId: \"blacklisted\",\n                data: {\n                    name: node.name\n                }\n            });\n        }\n\n        return {\n\n            Identifier(node) {\n                const name = node.name,\n                    effectiveParent = (node.parent.type === \"MemberExpression\") ? node.parent.parent : node.parent;\n\n                // MemberExpressions get special rules\n                if (node.parent.type === \"MemberExpression\") {\n\n                    // Always check object names\n                    if (node.parent.object.type === \"Identifier\" &&\n                        node.parent.object.name === node.name) {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n\n                        // Report AssignmentExpressions only if they are the left side of the assignment\n                    } else if (effectiveParent.type === \"AssignmentExpression\" &&\n                        (effectiveParent.right.type !== \"MemberExpression\" ||\n                        effectiveParent.left.type === \"MemberExpression\" &&\n                        effectiveParent.left.property.name === node.name)) {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n                    }\n\n                // Properties have their own rules\n                } else if (node.parent.type === \"Property\") {\n\n                    if (shouldReport(effectiveParent, name)) {\n                        report(node);\n                    }\n\n                // Report anything that is a match and not a CallExpression\n                } else if (shouldReport(effectiveParent, name)) {\n                    report(node);\n                }\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule that warns when identifier names are shorter or longer\n * than the values provided in configuration.\n * @author Burak Yigit Kaya aka BYK\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce minimum and maximum identifier lengths\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/id-length\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    min: {\n                        type: \"integer\",\n                        default: 2\n                    },\n                    max: {\n                        type: \"integer\"\n                    },\n                    exceptions: {\n                        type: \"array\",\n                        uniqueItems: true,\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    properties: {\n                        enum: [\"always\", \"never\"]\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            tooShort: \"Identifier name '{{name}}' is too short (< {{min}}).\",\n            tooLong: \"Identifier name '{{name}}' is too long (> {{max}}).\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const minLength = typeof options.min !== \"undefined\" ? options.min : 2;\n        const maxLength = typeof options.max !== \"undefined\" ? options.max : Infinity;\n        const properties = options.properties !== \"never\";\n        const exceptions = (options.exceptions ? options.exceptions : [])\n            .reduce((obj, item) => {\n                obj[item] = true;\n\n                return obj;\n            }, {});\n\n        const SUPPORTED_EXPRESSIONS = {\n            MemberExpression: properties && function(parent) {\n                return !parent.computed && (\n\n                    // regular property assignment\n                    (parent.parent.left === parent && parent.parent.type === \"AssignmentExpression\" ||\n\n                    // or the last identifier in an ObjectPattern destructuring\n                    parent.parent.type === \"Property\" && parent.parent.value === parent &&\n                    parent.parent.parent.type === \"ObjectPattern\" && parent.parent.parent.parent.left === parent.parent.parent)\n                );\n            },\n            AssignmentPattern(parent, node) {\n                return parent.left === node;\n            },\n            VariableDeclarator(parent, node) {\n                return parent.id === node;\n            },\n            Property: properties && function(parent, node) {\n                return parent.key === node;\n            },\n            ImportDefaultSpecifier: true,\n            RestElement: true,\n            FunctionExpression: true,\n            ArrowFunctionExpression: true,\n            ClassDeclaration: true,\n            FunctionDeclaration: true,\n            MethodDefinition: true,\n            CatchClause: true\n        };\n\n        return {\n            Identifier(node) {\n                const name = node.name;\n                const parent = node.parent;\n\n                const isShort = name.length < minLength;\n                const isLong = name.length > maxLength;\n\n                if (!(isShort || isLong) || exceptions[name]) {\n                    return; // Nothing to report\n                }\n\n                const isValidExpression = SUPPORTED_EXPRESSIONS[parent.type];\n\n                if (isValidExpression && (isValidExpression === true || isValidExpression(parent, node))) {\n                    context.report({\n                        node,\n                        messageId: isShort ? \"tooShort\" : \"tooLong\",\n                        data: { name, min: minLength, max: maxLength }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag non-matching identifiers\n * @author Matthieu Larcher\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require identifiers to match a specified regular expression\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/id-match\"\n        },\n\n        schema: [\n            {\n                type: \"string\"\n            },\n            {\n                type: \"object\",\n                properties: {\n                    properties: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    onlyDeclarations: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoreDestructuring: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                }\n            }\n        ],\n        messages: {\n            notMatch: \"Identifier '{{name}}' does not match the pattern '{{pattern}}'.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Options\n        //--------------------------------------------------------------------------\n        const pattern = context.options[0] || \"^.+$\",\n            regexp = new RegExp(pattern); // eslint-disable-line require-unicode-regexp\n\n        const options = context.options[1] || {},\n            properties = !!options.properties,\n            onlyDeclarations = !!options.onlyDeclarations,\n            ignoreDestructuring = !!options.ignoreDestructuring;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\n        const reported = new Map();\n        const ALLOWED_PARENT_TYPES = new Set([\"CallExpression\", \"NewExpression\"]);\n        const DECLARATION_TYPES = new Set([\"FunctionDeclaration\", \"VariableDeclarator\"]);\n        const IMPORT_TYPES = new Set([\"ImportSpecifier\", \"ImportNamespaceSpecifier\", \"ImportDefaultSpecifier\"]);\n\n        /**\n         * Checks if a string matches the provided pattern\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is a match\n         * @private\n         */\n        function isInvalid(name) {\n            return !regexp.test(name);\n        }\n\n        /**\n         * Checks if a parent of a node is an ObjectPattern.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} if the node is inside an ObjectPattern\n         * @private\n         */\n        function isInsideObjectPattern(node) {\n            let { parent } = node;\n\n            while (parent) {\n                if (parent.type === \"ObjectPattern\") {\n                    return true;\n                }\n\n                parent = parent.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Verifies if we should report an error or not based on the effective\n         * parent node and the identifier name.\n         * @param {ASTNode} effectiveParent The effective parent node of the node to be reported\n         * @param {string} name The identifier name of the identifier node\n         * @returns {boolean} whether an error should be reported or not\n         */\n        function shouldReport(effectiveParent, name) {\n            return (!onlyDeclarations || DECLARATION_TYPES.has(effectiveParent.type)) &&\n                !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && isInvalid(name);\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            if (!reported.has(node)) {\n                context.report({\n                    node,\n                    messageId: \"notMatch\",\n                    data: {\n                        name: node.name,\n                        pattern\n                    }\n                });\n                reported.set(node, true);\n            }\n        }\n\n        return {\n\n            Identifier(node) {\n                const name = node.name,\n                    parent = node.parent,\n                    effectiveParent = (parent.type === \"MemberExpression\") ? parent.parent : parent;\n\n                if (parent.type === \"MemberExpression\") {\n\n                    if (!properties) {\n                        return;\n                    }\n\n                    // Always check object names\n                    if (parent.object.type === \"Identifier\" &&\n                        parent.object.name === name) {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n\n                    // Report AssignmentExpressions left side's assigned variable id\n                    } else if (effectiveParent.type === \"AssignmentExpression\" &&\n                        effectiveParent.left.type === \"MemberExpression\" &&\n                        effectiveParent.left.property.name === node.name) {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n\n                    // Report AssignmentExpressions only if they are the left side of the assignment\n                    } else if (effectiveParent.type === \"AssignmentExpression\" && effectiveParent.right.type !== \"MemberExpression\") {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n                    }\n\n                /*\n                 * Properties have their own rules, and\n                 * AssignmentPattern nodes can be treated like Properties:\n                 * e.g.: const { no_camelcased = false } = bar;\n                 */\n                } else if (parent.type === \"Property\" || parent.type === \"AssignmentPattern\") {\n\n                    if (parent.parent && parent.parent.type === \"ObjectPattern\") {\n                        if (parent.shorthand && parent.value.left && isInvalid(name)) {\n\n                            report(node);\n                        }\n\n                        const assignmentKeyEqualsValue = parent.key.name === parent.value.name;\n\n                        // prevent checking righthand side of destructured object\n                        if (!assignmentKeyEqualsValue && parent.key === node) {\n                            return;\n                        }\n\n                        const valueIsInvalid = parent.value.name && isInvalid(name);\n\n                        // ignore destructuring if the option is set, unless a new identifier is created\n                        if (valueIsInvalid && !(assignmentKeyEqualsValue && ignoreDestructuring)) {\n                            report(node);\n                        }\n                    }\n\n                    // never check properties or always ignore destructuring\n                    if (!properties || (ignoreDestructuring && isInsideObjectPattern(node))) {\n                        return;\n                    }\n\n                    // don't check right hand side of AssignmentExpression to prevent duplicate warnings\n                    if (parent.right !== node && shouldReport(effectiveParent, name)) {\n                        report(node);\n                    }\n\n                // Check if it's an import specifier\n                } else if (IMPORT_TYPES.has(parent.type)) {\n\n                    // Report only if the local imported identifier is invalid\n                    if (parent.local && parent.local.name === node.name && isInvalid(name)) {\n                        report(node);\n                    }\n\n                // Report anything that is invalid that isn't a CallExpression\n                } else if (shouldReport(effectiveParent, name)) {\n                    report(node);\n                }\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview enforce the location of arrow function bodies\n * @author Sharmila Jesupaul\n */\n\n\nconst { isCommentToken, isNotOpeningParenToken } = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce the location of arrow function bodies\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/implicit-arrow-linebreak\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"beside\", \"below\"]\n            }\n        ],\n        messages: {\n            expected: \"Expected a linebreak before this expression.\",\n            unexpected: \"Expected no linebreak before this expression.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const option = context.options[0] || \"beside\";\n\n        /**\n         * Validates the location of an arrow function body\n         * @param {ASTNode} node The arrow function body\n         * @returns {void}\n         */\n        function validateExpression(node) {\n            if (node.body.type === \"BlockStatement\") {\n                return;\n            }\n\n            const arrowToken = sourceCode.getTokenBefore(node.body, isNotOpeningParenToken);\n            const firstTokenOfBody = sourceCode.getTokenAfter(arrowToken);\n\n            if (arrowToken.loc.end.line === firstTokenOfBody.loc.start.line && option === \"below\") {\n                context.report({\n                    node: firstTokenOfBody,\n                    messageId: \"expected\",\n                    fix: fixer => fixer.insertTextBefore(firstTokenOfBody, \"\\n\")\n                });\n            } else if (arrowToken.loc.end.line !== firstTokenOfBody.loc.start.line && option === \"beside\") {\n                context.report({\n                    node: firstTokenOfBody,\n                    messageId: \"unexpected\",\n                    fix(fixer) {\n                        if (sourceCode.getFirstTokenBetween(arrowToken, firstTokenOfBody, { includeComments: true, filter: isCommentToken })) {\n                            return null;\n                        }\n\n                        return fixer.replaceTextRange([arrowToken.range[1], firstTokenOfBody.range[0]], \" \");\n                    }\n                });\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n        return {\n            ArrowFunctionExpression: node => validateExpression(node)\n        };\n    }\n};\n","/**\n * @fileoverview This rule sets a specific indentation style and width for your code\n *\n * @author Teddy Katz\n * @author Vitaly Puzrin\n * @author Gyandeep Singh\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\nconst astUtils = require(\"../util/ast-utils\");\nconst createTree = require(\"functional-red-black-tree\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst KNOWN_NODES = new Set([\n    \"AssignmentExpression\",\n    \"AssignmentPattern\",\n    \"ArrayExpression\",\n    \"ArrayPattern\",\n    \"ArrowFunctionExpression\",\n    \"AwaitExpression\",\n    \"BlockStatement\",\n    \"BinaryExpression\",\n    \"BreakStatement\",\n    \"CallExpression\",\n    \"CatchClause\",\n    \"ClassBody\",\n    \"ClassDeclaration\",\n    \"ClassExpression\",\n    \"ConditionalExpression\",\n    \"ContinueStatement\",\n    \"DoWhileStatement\",\n    \"DebuggerStatement\",\n    \"EmptyStatement\",\n    \"ExperimentalRestProperty\",\n    \"ExperimentalSpreadProperty\",\n    \"ExpressionStatement\",\n    \"ForStatement\",\n    \"ForInStatement\",\n    \"ForOfStatement\",\n    \"FunctionDeclaration\",\n    \"FunctionExpression\",\n    \"Identifier\",\n    \"IfStatement\",\n    \"Literal\",\n    \"LabeledStatement\",\n    \"LogicalExpression\",\n    \"MemberExpression\",\n    \"MetaProperty\",\n    \"MethodDefinition\",\n    \"NewExpression\",\n    \"ObjectExpression\",\n    \"ObjectPattern\",\n    \"Program\",\n    \"Property\",\n    \"RestElement\",\n    \"ReturnStatement\",\n    \"SequenceExpression\",\n    \"SpreadElement\",\n    \"Super\",\n    \"SwitchCase\",\n    \"SwitchStatement\",\n    \"TaggedTemplateExpression\",\n    \"TemplateElement\",\n    \"TemplateLiteral\",\n    \"ThisExpression\",\n    \"ThrowStatement\",\n    \"TryStatement\",\n    \"UnaryExpression\",\n    \"UpdateExpression\",\n    \"VariableDeclaration\",\n    \"VariableDeclarator\",\n    \"WhileStatement\",\n    \"WithStatement\",\n    \"YieldExpression\",\n    \"JSXIdentifier\",\n    \"JSXNamespacedName\",\n    \"JSXMemberExpression\",\n    \"JSXEmptyExpression\",\n    \"JSXExpressionContainer\",\n    \"JSXElement\",\n    \"JSXClosingElement\",\n    \"JSXOpeningElement\",\n    \"JSXAttribute\",\n    \"JSXSpreadAttribute\",\n    \"JSXText\",\n    \"ExportDefaultDeclaration\",\n    \"ExportNamedDeclaration\",\n    \"ExportAllDeclaration\",\n    \"ExportSpecifier\",\n    \"ImportDeclaration\",\n    \"ImportSpecifier\",\n    \"ImportDefaultSpecifier\",\n    \"ImportNamespaceSpecifier\"\n]);\n\n/*\n * General rule strategy:\n * 1. An OffsetStorage instance stores a map of desired offsets, where each token has a specified offset from another\n *    specified token or to the first column.\n * 2. As the AST is traversed, modify the desired offsets of tokens accordingly. For example, when entering a\n *    BlockStatement, offset all of the tokens in the BlockStatement by 1 indent level from the opening curly\n *    brace of the BlockStatement.\n * 3. After traversing the AST, calculate the expected indentation levels of every token according to the\n *    OffsetStorage container.\n * 4. For each line, compare the expected indentation of the first token to the actual indentation in the file,\n *    and report the token if the two values are not equal.\n */\n\n\n/**\n * A mutable balanced binary search tree that stores (key, value) pairs. The keys are numeric, and must be unique.\n * This is intended to be a generic wrapper around a balanced binary search tree library, so that the underlying implementation\n * can easily be swapped out.\n */\nclass BinarySearchTree {\n\n    /**\n     * Creates an empty tree\n     */\n    constructor() {\n        this._rbTree = createTree();\n    }\n\n    /**\n     * Inserts an entry into the tree.\n     * @param {number} key The entry's key\n     * @param {*} value The entry's value\n     * @returns {void}\n     */\n    insert(key, value) {\n        const iterator = this._rbTree.find(key);\n\n        if (iterator.valid) {\n            this._rbTree = iterator.update(value);\n        } else {\n            this._rbTree = this._rbTree.insert(key, value);\n        }\n    }\n\n    /**\n     * Finds the entry with the largest key less than or equal to the provided key\n     * @param {number} key The provided key\n     * @returns {{key: number, value: *}|null} The found entry, or null if no such entry exists.\n     */\n    findLe(key) {\n        const iterator = this._rbTree.le(key);\n\n        return iterator && { key: iterator.key, value: iterator.value };\n    }\n\n    /**\n     * Deletes all of the keys in the interval [start, end)\n     * @param {number} start The start of the range\n     * @param {number} end The end of the range\n     * @returns {void}\n     */\n    deleteRange(start, end) {\n\n        // Exit without traversing the tree if the range has zero size.\n        if (start === end) {\n            return;\n        }\n        const iterator = this._rbTree.ge(start);\n\n        while (iterator.valid && iterator.key < end) {\n            this._rbTree = this._rbTree.remove(iterator.key);\n            iterator.next();\n        }\n    }\n}\n\n/**\n * A helper class to get token-based info related to indentation\n */\nclass TokenInfo {\n\n    /**\n     * @param {SourceCode} sourceCode A SourceCode object\n     */\n    constructor(sourceCode) {\n        this.sourceCode = sourceCode;\n        this.firstTokensByLineNumber = sourceCode.tokensAndComments.reduce((map, token) => {\n            if (!map.has(token.loc.start.line)) {\n                map.set(token.loc.start.line, token);\n            }\n            if (!map.has(token.loc.end.line) && sourceCode.text.slice(token.range[1] - token.loc.end.column, token.range[1]).trim()) {\n                map.set(token.loc.end.line, token);\n            }\n            return map;\n        }, new Map());\n    }\n\n    /**\n     * Gets the first token on a given token's line\n     * @param {Token|ASTNode} token a node or token\n     * @returns {Token} The first token on the given line\n     */\n    getFirstTokenOfLine(token) {\n        return this.firstTokensByLineNumber.get(token.loc.start.line);\n    }\n\n    /**\n     * Determines whether a token is the first token in its line\n     * @param {Token} token The token\n     * @returns {boolean} `true` if the token is the first on its line\n     */\n    isFirstTokenOfLine(token) {\n        return this.getFirstTokenOfLine(token) === token;\n    }\n\n    /**\n     * Get the actual indent of a token\n     * @param {Token} token Token to examine. This should be the first token on its line.\n     * @returns {string} The indentation characters that precede the token\n     */\n    getTokenIndent(token) {\n        return this.sourceCode.text.slice(token.range[0] - token.loc.start.column, token.range[0]);\n    }\n}\n\n/**\n * A class to store information on desired offsets of tokens from each other\n */\nclass OffsetStorage {\n\n    /**\n     * @param {TokenInfo} tokenInfo a TokenInfo instance\n     * @param {number} indentSize The desired size of each indentation level\n     * @param {string} indentType The indentation character\n     */\n    constructor(tokenInfo, indentSize, indentType) {\n        this._tokenInfo = tokenInfo;\n        this._indentSize = indentSize;\n        this._indentType = indentType;\n\n        this._tree = new BinarySearchTree();\n        this._tree.insert(0, { offset: 0, from: null, force: false });\n\n        this._lockedFirstTokens = new WeakMap();\n        this._desiredIndentCache = new WeakMap();\n        this._ignoredTokens = new WeakSet();\n    }\n\n    _getOffsetDescriptor(token) {\n        return this._tree.findLe(token.range[0]).value;\n    }\n\n    /**\n     * Sets the offset column of token B to match the offset column of token A.\n     * **WARNING**: This matches a *column*, even if baseToken is not the first token on its line. In\n     * most cases, `setDesiredOffset` should be used instead.\n     * @param {Token} baseToken The first token\n     * @param {Token} offsetToken The second token, whose offset should be matched to the first token\n     * @returns {void}\n     */\n    matchOffsetOf(baseToken, offsetToken) {\n\n        /*\n         * lockedFirstTokens is a map from a token whose indentation is controlled by the \"first\" option to\n         * the token that it depends on. For example, with the `ArrayExpression: first` option, the first\n         * token of each element in the array after the first will be mapped to the first token of the first\n         * element. The desired indentation of each of these tokens is computed based on the desired indentation\n         * of the \"first\" element, rather than through the normal offset mechanism.\n         */\n        this._lockedFirstTokens.set(offsetToken, baseToken);\n    }\n\n    /**\n     * Sets the desired offset of a token.\n     *\n     * This uses a line-based offset collapsing behavior to handle tokens on the same line.\n     * For example, consider the following two cases:\n     *\n     * (\n     *     [\n     *         bar\n     *     ]\n     * )\n     *\n     * ([\n     *     bar\n     * ])\n     *\n     * Based on the first case, it's clear that the `bar` token needs to have an offset of 1 indent level (4 spaces) from\n     * the `[` token, and the `[` token has to have an offset of 1 indent level from the `(` token. Since the `(` token is\n     * the first on its line (with an indent of 0 spaces), the `bar` token needs to be offset by 2 indent levels (8 spaces)\n     * from the start of its line.\n     *\n     * However, in the second case `bar` should only be indented by 4 spaces. This is because the offset of 1 indent level\n     * between the `(` and the `[` tokens gets \"collapsed\" because the two tokens are on the same line. As a result, the\n     * `(` token is mapped to the `[` token with an offset of 0, and the rule correctly decides that `bar` should be indented\n     * by 1 indent level from the start of the line.\n     *\n     * This is useful because rule listeners can usually just call `setDesiredOffset` for all the tokens in the node,\n     * without needing to check which lines those tokens are on.\n     *\n     * Note that since collapsing only occurs when two tokens are on the same line, there are a few cases where non-intuitive\n     * behavior can occur. For example, consider the following cases:\n     *\n     * foo(\n     * ).\n     *     bar(\n     *         baz\n     *     )\n     *\n     * foo(\n     * ).bar(\n     *     baz\n     * )\n     *\n     * Based on the first example, it would seem that `bar` should be offset by 1 indent level from `foo`, and `baz`\n     * should be offset by 1 indent level from `bar`. However, this is not correct, because it would result in `baz`\n     * being indented by 2 indent levels in the second case (since `foo`, `bar`, and `baz` are all on separate lines, no\n     * collapsing would occur).\n     *\n     * Instead, the correct way would be to offset `baz` by 1 level from `bar`, offset `bar` by 1 level from the `)`, and\n     * offset the `)` by 0 levels from `foo`. This ensures that the offset between `bar` and the `)` are correctly collapsed\n     * in the second case.\n     *\n     * @param {Token} token The token\n     * @param {Token} fromToken The token that `token` should be offset from\n     * @param {number} offset The desired indent level\n     * @returns {void}\n     */\n    setDesiredOffset(token, fromToken, offset) {\n        return this.setDesiredOffsets(token.range, fromToken, offset);\n    }\n\n    /**\n     * Sets the desired offset of all tokens in a range\n     * It's common for node listeners in this file to need to apply the same offset to a large, contiguous range of tokens.\n     * Moreover, the offset of any given token is usually updated multiple times (roughly once for each node that contains\n     * it). This means that the offset of each token is updated O(AST depth) times.\n     * It would not be performant to store and update the offsets for each token independently, because the rule would end\n     * up having a time complexity of O(number of tokens * AST depth), which is quite slow for large files.\n     *\n     * Instead, the offset tree is represented as a collection of contiguous offset ranges in a file. For example, the following\n     * list could represent the state of the offset tree at a given point:\n     *\n     * * Tokens starting in the interval [0, 15) are aligned with the beginning of the file\n     * * Tokens starting in the interval [15, 30) are offset by 1 indent level from the `bar` token\n     * * Tokens starting in the interval [30, 43) are offset by 1 indent level from the `foo` token\n     * * Tokens starting in the interval [43, 820) are offset by 2 indent levels from the `bar` token\n     * * Tokens starting in the interval [820, ∞) are offset by 1 indent level from the `baz` token\n     *\n     * The `setDesiredOffsets` methods inserts ranges like the ones above. The third line above would be inserted by using:\n     * `setDesiredOffsets([30, 43], fooToken, 1);`\n     *\n     * @param {[number, number]} range A [start, end] pair. All tokens with range[0] <= token.start < range[1] will have the offset applied.\n     * @param {Token} fromToken The token that this is offset from\n     * @param {number} offset The desired indent level\n     * @param {boolean} force `true` if this offset should not use the normal collapsing behavior. This should almost always be false.\n     * @returns {void}\n     */\n    setDesiredOffsets(range, fromToken, offset, force) {\n\n        /*\n         * Offset ranges are stored as a collection of nodes, where each node maps a numeric key to an offset\n         * descriptor. The tree for the example above would have the following nodes:\n         *\n         * * key: 0, value: { offset: 0, from: null }\n         * * key: 15, value: { offset: 1, from: barToken }\n         * * key: 30, value: { offset: 1, from: fooToken }\n         * * key: 43, value: { offset: 2, from: barToken }\n         * * key: 820, value: { offset: 1, from: bazToken }\n         *\n         * To find the offset descriptor for any given token, one needs to find the node with the largest key\n         * which is <= token.start. To make this operation fast, the nodes are stored in a balanced binary\n         * search tree indexed by key.\n         */\n\n        const descriptorToInsert = { offset, from: fromToken, force };\n\n        const descriptorAfterRange = this._tree.findLe(range[1]).value;\n\n        const fromTokenIsInRange = fromToken && fromToken.range[0] >= range[0] && fromToken.range[1] <= range[1];\n        const fromTokenDescriptor = fromTokenIsInRange && this._getOffsetDescriptor(fromToken);\n\n        // First, remove any existing nodes in the range from the tree.\n        this._tree.deleteRange(range[0] + 1, range[1]);\n\n        // Insert a new node into the tree for this range\n        this._tree.insert(range[0], descriptorToInsert);\n\n        /*\n         * To avoid circular offset dependencies, keep the `fromToken` token mapped to whatever it was mapped to previously,\n         * even if it's in the current range.\n         */\n        if (fromTokenIsInRange) {\n            this._tree.insert(fromToken.range[0], fromTokenDescriptor);\n            this._tree.insert(fromToken.range[1], descriptorToInsert);\n        }\n\n        /*\n         * To avoid modifying the offset of tokens after the range, insert another node to keep the offset of the following\n         * tokens the same as it was before.\n         */\n        this._tree.insert(range[1], descriptorAfterRange);\n    }\n\n    /**\n     * Gets the desired indent of a token\n     * @param {Token} token The token\n     * @returns {string} The desired indent of the token\n     */\n    getDesiredIndent(token) {\n        if (!this._desiredIndentCache.has(token)) {\n\n            if (this._ignoredTokens.has(token)) {\n\n                /*\n                 * If the token is ignored, use the actual indent of the token as the desired indent.\n                 * This ensures that no errors are reported for this token.\n                 */\n                this._desiredIndentCache.set(\n                    token,\n                    this._tokenInfo.getTokenIndent(token)\n                );\n            } else if (this._lockedFirstTokens.has(token)) {\n                const firstToken = this._lockedFirstTokens.get(token);\n\n                this._desiredIndentCache.set(\n                    token,\n\n                    // (indentation for the first element's line)\n                    this.getDesiredIndent(this._tokenInfo.getFirstTokenOfLine(firstToken)) +\n\n                        // (space between the start of the first element's line and the first element)\n                        this._indentType.repeat(firstToken.loc.start.column - this._tokenInfo.getFirstTokenOfLine(firstToken).loc.start.column)\n                );\n            } else {\n                const offsetInfo = this._getOffsetDescriptor(token);\n                const offset = (\n                    offsetInfo.from &&\n                    offsetInfo.from.loc.start.line === token.loc.start.line &&\n                    !/^\\s*?\\n/u.test(token.value) &&\n                    !offsetInfo.force\n                ) ? 0 : offsetInfo.offset * this._indentSize;\n\n                this._desiredIndentCache.set(\n                    token,\n                    (offsetInfo.from ? this.getDesiredIndent(offsetInfo.from) : \"\") + this._indentType.repeat(offset)\n                );\n            }\n        }\n        return this._desiredIndentCache.get(token);\n    }\n\n    /**\n     * Ignores a token, preventing it from being reported.\n     * @param {Token} token The token\n     * @returns {void}\n     */\n    ignoreToken(token) {\n        if (this._tokenInfo.isFirstTokenOfLine(token)) {\n            this._ignoredTokens.add(token);\n        }\n    }\n\n    /**\n     * Gets the first token that the given token's indentation is dependent on\n     * @param {Token} token The token\n     * @returns {Token} The token that the given token depends on, or `null` if the given token is at the top level\n     */\n    getFirstDependency(token) {\n        return this._getOffsetDescriptor(token).from;\n    }\n}\n\nconst ELEMENT_LIST_SCHEMA = {\n    oneOf: [\n        {\n            type: \"integer\",\n            minimum: 0\n        },\n        {\n            enum: [\"first\", \"off\"]\n        }\n    ]\n};\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent indentation\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/indent\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"tab\"]\n                    },\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    SwitchCase: {\n                        type: \"integer\",\n                        minimum: 0,\n                        default: 0\n                    },\n                    VariableDeclarator: {\n                        oneOf: [\n                            ELEMENT_LIST_SCHEMA,\n                            {\n                                type: \"object\",\n                                properties: {\n                                    var: ELEMENT_LIST_SCHEMA,\n                                    let: ELEMENT_LIST_SCHEMA,\n                                    const: ELEMENT_LIST_SCHEMA\n                                },\n                                additionalProperties: false\n                            }\n                        ]\n                    },\n                    outerIIFEBody: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    MemberExpression: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                enum: [\"off\"]\n                            }\n                        ]\n                    },\n                    FunctionDeclaration: {\n                        type: \"object\",\n                        properties: {\n                            parameters: ELEMENT_LIST_SCHEMA,\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    FunctionExpression: {\n                        type: \"object\",\n                        properties: {\n                            parameters: ELEMENT_LIST_SCHEMA,\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    CallExpression: {\n                        type: \"object\",\n                        properties: {\n                            arguments: ELEMENT_LIST_SCHEMA\n                        },\n                        additionalProperties: false\n                    },\n                    ArrayExpression: ELEMENT_LIST_SCHEMA,\n                    ObjectExpression: ELEMENT_LIST_SCHEMA,\n                    ImportDeclaration: ELEMENT_LIST_SCHEMA,\n                    flatTernaryExpressions: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoredNodes: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\",\n                            not: {\n                                pattern: \":exit$\"\n                            }\n                        }\n                    },\n                    ignoreComments: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            wrongIndentation: \"Expected indentation of {{expected}} but found {{actual}}.\"\n        }\n    },\n\n    create(context) {\n        const DEFAULT_VARIABLE_INDENT = 1;\n        const DEFAULT_PARAMETER_INDENT = 1;\n        const DEFAULT_FUNCTION_BODY_INDENT = 1;\n\n        let indentType = \"space\";\n        let indentSize = 4;\n        const options = {\n            SwitchCase: 0,\n            VariableDeclarator: {\n                var: DEFAULT_VARIABLE_INDENT,\n                let: DEFAULT_VARIABLE_INDENT,\n                const: DEFAULT_VARIABLE_INDENT\n            },\n            outerIIFEBody: 1,\n            FunctionDeclaration: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            FunctionExpression: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            CallExpression: {\n                arguments: DEFAULT_PARAMETER_INDENT\n            },\n            MemberExpression: 1,\n            ArrayExpression: 1,\n            ObjectExpression: 1,\n            ImportDeclaration: 1,\n            flatTernaryExpressions: false,\n            ignoredNodes: [],\n            ignoreComments: false\n        };\n\n        if (context.options.length) {\n            if (context.options[0] === \"tab\") {\n                indentSize = 1;\n                indentType = \"tab\";\n            } else {\n                indentSize = context.options[0];\n                indentType = \"space\";\n            }\n\n            if (context.options[1]) {\n                Object.assign(options, context.options[1]);\n\n                if (typeof options.VariableDeclarator === \"number\" || options.VariableDeclarator === \"first\") {\n                    options.VariableDeclarator = {\n                        var: options.VariableDeclarator,\n                        let: options.VariableDeclarator,\n                        const: options.VariableDeclarator\n                    };\n                }\n            }\n        }\n\n        const sourceCode = context.getSourceCode();\n        const tokenInfo = new TokenInfo(sourceCode);\n        const offsets = new OffsetStorage(tokenInfo, indentSize, indentType === \"space\" ? \" \" : \"\\t\");\n        const parameterParens = new WeakSet();\n\n        /**\n         * Creates an error message for a line, given the expected/actual indentation.\n         * @param {int} expectedAmount The expected amount of indentation characters for this line\n         * @param {int} actualSpaces The actual number of indentation spaces that were found on this line\n         * @param {int} actualTabs The actual number of indentation tabs that were found on this line\n         * @returns {string} An error message for this line\n         */\n        function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {\n            const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? \"\" : \"s\"}`; // e.g. \"2 tabs\"\n            const foundSpacesWord = `space${actualSpaces === 1 ? \"\" : \"s\"}`; // e.g. \"space\"\n            const foundTabsWord = `tab${actualTabs === 1 ? \"\" : \"s\"}`; // e.g. \"tabs\"\n            let foundStatement;\n\n            if (actualSpaces > 0) {\n\n                /*\n                 * Abbreviate the message if the expected indentation is also spaces.\n                 * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'\n                 */\n                foundStatement = indentType === \"space\" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;\n            } else if (actualTabs > 0) {\n                foundStatement = indentType === \"tab\" ? actualTabs : `${actualTabs} ${foundTabsWord}`;\n            } else {\n                foundStatement = \"0\";\n            }\n            return {\n                expected: expectedStatement,\n                actual: foundStatement\n            };\n        }\n\n        /**\n         * Reports a given indent violation\n         * @param {Token} token Token violating the indent rule\n         * @param {string} neededIndent Expected indentation string\n         * @returns {void}\n         */\n        function report(token, neededIndent) {\n            const actualIndent = Array.from(tokenInfo.getTokenIndent(token));\n            const numSpaces = actualIndent.filter(char => char === \" \").length;\n            const numTabs = actualIndent.filter(char => char === \"\\t\").length;\n\n            context.report({\n                node: token,\n                messageId: \"wrongIndentation\",\n                data: createErrorMessageData(neededIndent.length, numSpaces, numTabs),\n                loc: {\n                    start: { line: token.loc.start.line, column: 0 },\n                    end: { line: token.loc.start.line, column: token.loc.start.column }\n                },\n                fix(fixer) {\n                    const range = [token.range[0] - token.loc.start.column, token.range[0]];\n                    const newText = neededIndent;\n\n                    return fixer.replaceTextRange(range, newText);\n                }\n            });\n        }\n\n        /**\n         * Checks if a token's indentation is correct\n         * @param {Token} token Token to examine\n         * @param {string} desiredIndent Desired indentation of the string\n         * @returns {boolean} `true` if the token's indentation is correct\n         */\n        function validateTokenIndent(token, desiredIndent) {\n            const indentation = tokenInfo.getTokenIndent(token);\n\n            return indentation === desiredIndent ||\n\n                // To avoid conflicts with no-mixed-spaces-and-tabs, don't report mixed spaces and tabs.\n                indentation.includes(\" \") && indentation.includes(\"\\t\");\n        }\n\n        /**\n         * Check to see if the node is a file level IIFE\n         * @param {ASTNode} node The function node to check.\n         * @returns {boolean} True if the node is the outer IIFE\n         */\n        function isOuterIIFE(node) {\n\n            /*\n             * Verify that the node is an IIFE\n             */\n            if (!node.parent || node.parent.type !== \"CallExpression\" || node.parent.callee !== node) {\n                return false;\n            }\n\n            /*\n             * Navigate legal ancestors to determine whether this IIFE is outer.\n             * A \"legal ancestor\" is an expression or statement that causes the function to get executed immediately.\n             * For example, `!(function(){})()` is an outer IIFE even though it is preceded by a ! operator.\n             */\n            let statement = node.parent && node.parent.parent;\n\n            while (\n                statement.type === \"UnaryExpression\" && [\"!\", \"~\", \"+\", \"-\"].indexOf(statement.operator) > -1 ||\n                statement.type === \"AssignmentExpression\" ||\n                statement.type === \"LogicalExpression\" ||\n                statement.type === \"SequenceExpression\" ||\n                statement.type === \"VariableDeclarator\"\n            ) {\n                statement = statement.parent;\n            }\n\n            return (statement.type === \"ExpressionStatement\" || statement.type === \"VariableDeclaration\") && statement.parent.type === \"Program\";\n        }\n\n        /**\n         * Counts the number of linebreaks that follow the last non-whitespace character in a string\n         * @param {string} string The string to check\n         * @returns {number} The number of JavaScript linebreaks that follow the last non-whitespace character,\n         * or the total number of linebreaks if the string is all whitespace.\n         */\n        function countTrailingLinebreaks(string) {\n            const trailingWhitespace = string.match(/\\s*$/u)[0];\n            const linebreakMatches = trailingWhitespace.match(astUtils.createGlobalLinebreakMatcher());\n\n            return linebreakMatches === null ? 0 : linebreakMatches.length;\n        }\n\n        /**\n         * Check indentation for lists of elements (arrays, objects, function params)\n         * @param {ASTNode[]} elements List of elements that should be offset\n         * @param {Token} startToken The start token of the list that element should be aligned against, e.g. '['\n         * @param {Token} endToken The end token of the list, e.g. ']'\n         * @param {number|string} offset The amount that the elements should be offset\n         * @returns {void}\n         */\n        function addElementListIndent(elements, startToken, endToken, offset) {\n\n            /**\n             * Gets the first token of a given element, including surrounding parentheses.\n             * @param {ASTNode} element A node in the `elements` list\n             * @returns {Token} The first token of this element\n             */\n            function getFirstToken(element) {\n                let token = sourceCode.getTokenBefore(element);\n\n                while (astUtils.isOpeningParenToken(token) && token !== startToken) {\n                    token = sourceCode.getTokenBefore(token);\n                }\n                return sourceCode.getTokenAfter(token);\n            }\n\n            // Run through all the tokens in the list, and offset them by one indent level (mainly for comments, other things will end up overridden)\n            offsets.setDesiredOffsets(\n                [startToken.range[1], endToken.range[0]],\n                startToken,\n                typeof offset === \"number\" ? offset : 1\n            );\n            offsets.setDesiredOffset(endToken, startToken, 0);\n\n            // If the preference is \"first\" but there is no first element (e.g. sparse arrays w/ empty first slot), fall back to 1 level.\n            if (offset === \"first\" && elements.length && !elements[0]) {\n                return;\n            }\n            elements.forEach((element, index) => {\n                if (!element) {\n\n                    // Skip holes in arrays\n                    return;\n                }\n                if (offset === \"off\") {\n\n                    // Ignore the first token of every element if the \"off\" option is used\n                    offsets.ignoreToken(getFirstToken(element));\n                }\n\n                // Offset the following elements correctly relative to the first element\n                if (index === 0) {\n                    return;\n                }\n                if (offset === \"first\" && tokenInfo.isFirstTokenOfLine(getFirstToken(element))) {\n                    offsets.matchOffsetOf(getFirstToken(elements[0]), getFirstToken(element));\n                } else {\n                    const previousElement = elements[index - 1];\n                    const firstTokenOfPreviousElement = previousElement && getFirstToken(previousElement);\n                    const previousElementLastToken = previousElement && sourceCode.getLastToken(previousElement);\n\n                    if (\n                        previousElement &&\n                        previousElementLastToken.loc.end.line - countTrailingLinebreaks(previousElementLastToken.value) > startToken.loc.end.line\n                    ) {\n                        offsets.setDesiredOffsets(\n                            [previousElement.range[1], element.range[1]],\n                            firstTokenOfPreviousElement,\n                            0\n                        );\n                    }\n                }\n            });\n        }\n\n        /**\n         * Check and decide whether to check for indentation for blockless nodes\n         * Scenarios are for or while statements without braces around them\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function addBlocklessNodeIndent(node) {\n            if (node.type !== \"BlockStatement\") {\n                const lastParentToken = sourceCode.getTokenBefore(node, astUtils.isNotOpeningParenToken);\n\n                let firstBodyToken = sourceCode.getFirstToken(node);\n                let lastBodyToken = sourceCode.getLastToken(node);\n\n                while (\n                    astUtils.isOpeningParenToken(sourceCode.getTokenBefore(firstBodyToken)) &&\n                    astUtils.isClosingParenToken(sourceCode.getTokenAfter(lastBodyToken))\n                ) {\n                    firstBodyToken = sourceCode.getTokenBefore(firstBodyToken);\n                    lastBodyToken = sourceCode.getTokenAfter(lastBodyToken);\n                }\n\n                offsets.setDesiredOffsets([firstBodyToken.range[0], lastBodyToken.range[1]], lastParentToken, 1);\n\n                /*\n                 * For blockless nodes with semicolon-first style, don't indent the semicolon.\n                 * e.g.\n                 * if (foo) bar()\n                 * ; [1, 2, 3].map(foo)\n                 */\n                const lastToken = sourceCode.getLastToken(node);\n\n                if (node.type !== \"EmptyStatement\" && astUtils.isSemicolonToken(lastToken)) {\n                    offsets.setDesiredOffset(lastToken, lastParentToken, 0);\n                }\n            }\n        }\n\n        /**\n         * Checks the indentation for nodes that are like function calls (`CallExpression` and `NewExpression`)\n         * @param {ASTNode} node A CallExpression or NewExpression node\n         * @returns {void}\n         */\n        function addFunctionCallIndent(node) {\n            let openingParen;\n\n            if (node.arguments.length) {\n                openingParen = sourceCode.getFirstTokenBetween(node.callee, node.arguments[0], astUtils.isOpeningParenToken);\n            } else {\n                openingParen = sourceCode.getLastToken(node, 1);\n            }\n            const closingParen = sourceCode.getLastToken(node);\n\n            parameterParens.add(openingParen);\n            parameterParens.add(closingParen);\n            offsets.setDesiredOffset(openingParen, sourceCode.getTokenBefore(openingParen), 0);\n\n            addElementListIndent(node.arguments, openingParen, closingParen, options.CallExpression.arguments);\n        }\n\n        /**\n         * Checks the indentation of parenthesized values, given a list of tokens in a program\n         * @param {Token[]} tokens A list of tokens\n         * @returns {void}\n         */\n        function addParensIndent(tokens) {\n            const parenStack = [];\n            const parenPairs = [];\n\n            tokens.forEach(nextToken => {\n\n                // Accumulate a list of parenthesis pairs\n                if (astUtils.isOpeningParenToken(nextToken)) {\n                    parenStack.push(nextToken);\n                } else if (astUtils.isClosingParenToken(nextToken)) {\n                    parenPairs.unshift({ left: parenStack.pop(), right: nextToken });\n                }\n            });\n\n            parenPairs.forEach(pair => {\n                const leftParen = pair.left;\n                const rightParen = pair.right;\n\n                // We only want to handle parens around expressions, so exclude parentheses that are in function parameters and function call arguments.\n                if (!parameterParens.has(leftParen) && !parameterParens.has(rightParen)) {\n                    const parenthesizedTokens = new Set(sourceCode.getTokensBetween(leftParen, rightParen));\n\n                    parenthesizedTokens.forEach(token => {\n                        if (!parenthesizedTokens.has(offsets.getFirstDependency(token))) {\n                            offsets.setDesiredOffset(token, leftParen, 1);\n                        }\n                    });\n                }\n\n                offsets.setDesiredOffset(rightParen, leftParen, 0);\n            });\n        }\n\n        /**\n         * Ignore all tokens within an unknown node whose offset do not depend\n         * on another token's offset within the unknown node\n         * @param {ASTNode} node Unknown Node\n         * @returns {void}\n         */\n        function ignoreNode(node) {\n            const unknownNodeTokens = new Set(sourceCode.getTokens(node, { includeComments: true }));\n\n            unknownNodeTokens.forEach(token => {\n                if (!unknownNodeTokens.has(offsets.getFirstDependency(token))) {\n                    const firstTokenOfLine = tokenInfo.getFirstTokenOfLine(token);\n\n                    if (token === firstTokenOfLine) {\n                        offsets.ignoreToken(token);\n                    } else {\n                        offsets.setDesiredOffset(token, firstTokenOfLine, 0);\n                    }\n                }\n            });\n        }\n\n        /**\n         * Check whether the given token is on the first line of a statement.\n         * @param {Token} token The token to check.\n         * @param {ASTNode} leafNode The expression node that the token belongs directly.\n         * @returns {boolean} `true` if the token is on the first line of a statement.\n         */\n        function isOnFirstLineOfStatement(token, leafNode) {\n            let node = leafNode;\n\n            while (node.parent && !node.parent.type.endsWith(\"Statement\") && !node.parent.type.endsWith(\"Declaration\")) {\n                node = node.parent;\n            }\n            node = node.parent;\n\n            return !node || node.loc.start.line === token.loc.start.line;\n        }\n\n        /**\n         * Check whether there are any blank (whitespace-only) lines between\n         * two tokens on separate lines.\n         * @param {Token} firstToken The first token.\n         * @param {Token} secondToken The second token.\n         * @returns {boolean} `true` if the tokens are on separate lines and\n         *   there exists a blank line between them, `false` otherwise.\n         */\n        function hasBlankLinesBetween(firstToken, secondToken) {\n            const firstTokenLine = firstToken.loc.end.line;\n            const secondTokenLine = secondToken.loc.start.line;\n\n            if (firstTokenLine === secondTokenLine || firstTokenLine === secondTokenLine - 1) {\n                return false;\n            }\n\n            for (let line = firstTokenLine + 1; line < secondTokenLine; ++line) {\n                if (!tokenInfo.firstTokensByLineNumber.has(line)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        const ignoredNodeFirstTokens = new Set();\n\n        const baseOffsetListeners = {\n            \"ArrayExpression, ArrayPattern\"(node) {\n                const openingBracket = sourceCode.getFirstToken(node);\n                const closingBracket = sourceCode.getTokenAfter(lodash.findLast(node.elements) || openingBracket, astUtils.isClosingBracketToken);\n\n                addElementListIndent(node.elements, openingBracket, closingBracket, options.ArrayExpression);\n            },\n\n            \"ObjectExpression, ObjectPattern\"(node) {\n                const openingCurly = sourceCode.getFirstToken(node);\n                const closingCurly = sourceCode.getTokenAfter(\n                    node.properties.length ? node.properties[node.properties.length - 1] : openingCurly,\n                    astUtils.isClosingBraceToken\n                );\n\n                addElementListIndent(node.properties, openingCurly, closingCurly, options.ObjectExpression);\n            },\n\n            ArrowFunctionExpression(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n\n                if (astUtils.isOpeningParenToken(firstToken)) {\n                    const openingParen = firstToken;\n                    const closingParen = sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken);\n\n                    parameterParens.add(openingParen);\n                    parameterParens.add(closingParen);\n                    addElementListIndent(node.params, openingParen, closingParen, options.FunctionExpression.parameters);\n                }\n                addBlocklessNodeIndent(node.body);\n            },\n\n            AssignmentExpression(node) {\n                const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n\n                offsets.setDesiredOffsets([operator.range[0], node.range[1]], sourceCode.getLastToken(node.left), 1);\n                offsets.ignoreToken(operator);\n                offsets.ignoreToken(sourceCode.getTokenAfter(operator));\n            },\n\n            \"BinaryExpression, LogicalExpression\"(node) {\n                const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n\n                /*\n                 * For backwards compatibility, don't check BinaryExpression indents, e.g.\n                 * var foo = bar &&\n                 *                   baz;\n                 */\n\n                const tokenAfterOperator = sourceCode.getTokenAfter(operator);\n\n                offsets.ignoreToken(operator);\n                offsets.ignoreToken(tokenAfterOperator);\n                offsets.setDesiredOffset(tokenAfterOperator, operator, 0);\n            },\n\n            \"BlockStatement, ClassBody\"(node) {\n\n                let blockIndentLevel;\n\n                if (node.parent && isOuterIIFE(node.parent)) {\n                    blockIndentLevel = options.outerIIFEBody;\n                } else if (node.parent && (node.parent.type === \"FunctionExpression\" || node.parent.type === \"ArrowFunctionExpression\")) {\n                    blockIndentLevel = options.FunctionExpression.body;\n                } else if (node.parent && node.parent.type === \"FunctionDeclaration\") {\n                    blockIndentLevel = options.FunctionDeclaration.body;\n                } else {\n                    blockIndentLevel = 1;\n                }\n\n                /*\n                 * For blocks that aren't lone statements, ensure that the opening curly brace\n                 * is aligned with the parent.\n                 */\n                if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n                    offsets.setDesiredOffset(sourceCode.getFirstToken(node), sourceCode.getFirstToken(node.parent), 0);\n                }\n                addElementListIndent(node.body, sourceCode.getFirstToken(node), sourceCode.getLastToken(node), blockIndentLevel);\n            },\n\n            CallExpression: addFunctionCallIndent,\n\n\n            \"ClassDeclaration[superClass], ClassExpression[superClass]\"(node) {\n                const classToken = sourceCode.getFirstToken(node);\n                const extendsToken = sourceCode.getTokenBefore(node.superClass, astUtils.isNotOpeningParenToken);\n\n                offsets.setDesiredOffsets([extendsToken.range[0], node.body.range[0]], classToken, 1);\n            },\n\n            ConditionalExpression(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n\n                // `flatTernaryExpressions` option is for the following style:\n                // var a =\n                //     foo > 0 ? bar :\n                //     foo < 0 ? baz :\n                //     /*else*/ qiz ;\n                if (!options.flatTernaryExpressions ||\n                    !astUtils.isTokenOnSameLine(node.test, node.consequent) ||\n                    isOnFirstLineOfStatement(firstToken, node)\n                ) {\n                    const questionMarkToken = sourceCode.getFirstTokenBetween(node.test, node.consequent, token => token.type === \"Punctuator\" && token.value === \"?\");\n                    const colonToken = sourceCode.getFirstTokenBetween(node.consequent, node.alternate, token => token.type === \"Punctuator\" && token.value === \":\");\n\n                    const firstConsequentToken = sourceCode.getTokenAfter(questionMarkToken);\n                    const lastConsequentToken = sourceCode.getTokenBefore(colonToken);\n                    const firstAlternateToken = sourceCode.getTokenAfter(colonToken);\n\n                    offsets.setDesiredOffset(questionMarkToken, firstToken, 1);\n                    offsets.setDesiredOffset(colonToken, firstToken, 1);\n\n                    offsets.setDesiredOffset(firstConsequentToken, firstToken, 1);\n\n                    /*\n                     * The alternate and the consequent should usually have the same indentation.\n                     * If they share part of a line, align the alternate against the first token of the consequent.\n                     * This allows the alternate to be indented correctly in cases like this:\n                     * foo ? (\n                     *   bar\n                     * ) : ( // this '(' is aligned with the '(' above, so it's considered to be aligned with `foo`\n                     *   baz // as a result, `baz` is offset by 1 rather than 2\n                     * )\n                     */\n                    if (lastConsequentToken.loc.end.line === firstAlternateToken.loc.start.line) {\n                        offsets.setDesiredOffset(firstAlternateToken, firstConsequentToken, 0);\n                    } else {\n\n                        /**\n                         * If the alternate and consequent do not share part of a line, offset the alternate from the first\n                         * token of the conditional expression. For example:\n                         * foo ? bar\n                         *   : baz\n                         *\n                         * If `baz` were aligned with `bar` rather than being offset by 1 from `foo`, `baz` would end up\n                         * having no expected indentation.\n                         */\n                        offsets.setDesiredOffset(firstAlternateToken, firstToken, 1);\n                    }\n                }\n            },\n\n            \"DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement\": node => addBlocklessNodeIndent(node.body),\n\n            ExportNamedDeclaration(node) {\n                if (node.declaration === null) {\n                    const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);\n\n                    // Indent the specifiers in `export {foo, bar, baz}`\n                    addElementListIndent(node.specifiers, sourceCode.getFirstToken(node, { skip: 1 }), closingCurly, 1);\n\n                    if (node.source) {\n\n                        // Indent everything after and including the `from` token in `export {foo, bar, baz} from 'qux'`\n                        offsets.setDesiredOffsets([closingCurly.range[1], node.range[1]], sourceCode.getFirstToken(node), 1);\n                    }\n                }\n            },\n\n            ForStatement(node) {\n                const forOpeningParen = sourceCode.getFirstToken(node, 1);\n\n                if (node.init) {\n                    offsets.setDesiredOffsets(node.init.range, forOpeningParen, 1);\n                }\n                if (node.test) {\n                    offsets.setDesiredOffsets(node.test.range, forOpeningParen, 1);\n                }\n                if (node.update) {\n                    offsets.setDesiredOffsets(node.update.range, forOpeningParen, 1);\n                }\n                addBlocklessNodeIndent(node.body);\n            },\n\n            \"FunctionDeclaration, FunctionExpression\"(node) {\n                const closingParen = sourceCode.getTokenBefore(node.body);\n                const openingParen = sourceCode.getTokenBefore(node.params.length ? node.params[0] : closingParen);\n\n                parameterParens.add(openingParen);\n                parameterParens.add(closingParen);\n                addElementListIndent(node.params, openingParen, closingParen, options[node.type].parameters);\n            },\n\n            IfStatement(node) {\n                addBlocklessNodeIndent(node.consequent);\n                if (node.alternate && node.alternate.type !== \"IfStatement\") {\n                    addBlocklessNodeIndent(node.alternate);\n                }\n            },\n\n            ImportDeclaration(node) {\n                if (node.specifiers.some(specifier => specifier.type === \"ImportSpecifier\")) {\n                    const openingCurly = sourceCode.getFirstToken(node, astUtils.isOpeningBraceToken);\n                    const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);\n\n                    addElementListIndent(node.specifiers.filter(specifier => specifier.type === \"ImportSpecifier\"), openingCurly, closingCurly, options.ImportDeclaration);\n                }\n\n                const fromToken = sourceCode.getLastToken(node, token => token.type === \"Identifier\" && token.value === \"from\");\n                const sourceToken = sourceCode.getLastToken(node, token => token.type === \"String\");\n                const semiToken = sourceCode.getLastToken(node, token => token.type === \"Punctuator\" && token.value === \";\");\n\n                if (fromToken) {\n                    const end = semiToken && semiToken.range[1] === sourceToken.range[1] ? node.range[1] : sourceToken.range[1];\n\n                    offsets.setDesiredOffsets([fromToken.range[0], end], sourceCode.getFirstToken(node), 1);\n                }\n            },\n\n            \"MemberExpression, JSXMemberExpression, MetaProperty\"(node) {\n                const object = node.type === \"MetaProperty\" ? node.meta : node.object;\n                const firstNonObjectToken = sourceCode.getFirstTokenBetween(object, node.property, astUtils.isNotClosingParenToken);\n                const secondNonObjectToken = sourceCode.getTokenAfter(firstNonObjectToken);\n\n                const objectParenCount = sourceCode.getTokensBetween(object, node.property, { filter: astUtils.isClosingParenToken }).length;\n                const firstObjectToken = objectParenCount\n                    ? sourceCode.getTokenBefore(object, { skip: objectParenCount - 1 })\n                    : sourceCode.getFirstToken(object);\n                const lastObjectToken = sourceCode.getTokenBefore(firstNonObjectToken);\n                const firstPropertyToken = node.computed ? firstNonObjectToken : secondNonObjectToken;\n\n                if (node.computed) {\n\n                    // For computed MemberExpressions, match the closing bracket with the opening bracket.\n                    offsets.setDesiredOffset(sourceCode.getLastToken(node), firstNonObjectToken, 0);\n                    offsets.setDesiredOffsets(node.property.range, firstNonObjectToken, 1);\n                }\n\n                /*\n                 * If the object ends on the same line that the property starts, match against the last token\n                 * of the object, to ensure that the MemberExpression is not indented.\n                 *\n                 * Otherwise, match against the first token of the object, e.g.\n                 * foo\n                 *   .bar\n                 *   .baz // <-- offset by 1 from `foo`\n                 */\n                const offsetBase = lastObjectToken.loc.end.line === firstPropertyToken.loc.start.line\n                    ? lastObjectToken\n                    : firstObjectToken;\n\n                if (typeof options.MemberExpression === \"number\") {\n\n                    // Match the dot (for non-computed properties) or the opening bracket (for computed properties) against the object.\n                    offsets.setDesiredOffset(firstNonObjectToken, offsetBase, options.MemberExpression);\n\n                    /*\n                     * For computed MemberExpressions, match the first token of the property against the opening bracket.\n                     * Otherwise, match the first token of the property against the object.\n                     */\n                    offsets.setDesiredOffset(secondNonObjectToken, node.computed ? firstNonObjectToken : offsetBase, options.MemberExpression);\n                } else {\n\n                    // If the MemberExpression option is off, ignore the dot and the first token of the property.\n                    offsets.ignoreToken(firstNonObjectToken);\n                    offsets.ignoreToken(secondNonObjectToken);\n\n                    // To ignore the property indentation, ensure that the property tokens depend on the ignored tokens.\n                    offsets.setDesiredOffset(firstNonObjectToken, offsetBase, 0);\n                    offsets.setDesiredOffset(secondNonObjectToken, firstNonObjectToken, 0);\n                }\n            },\n\n            NewExpression(node) {\n\n                // Only indent the arguments if the NewExpression has parens (e.g. `new Foo(bar)` or `new Foo()`, but not `new Foo`\n                if (node.arguments.length > 0 ||\n                        astUtils.isClosingParenToken(sourceCode.getLastToken(node)) &&\n                        astUtils.isOpeningParenToken(sourceCode.getLastToken(node, 1))) {\n                    addFunctionCallIndent(node);\n                }\n            },\n\n            Property(node) {\n                if (!node.shorthand && !node.method && node.kind === \"init\") {\n                    const colon = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isColonToken);\n\n                    offsets.ignoreToken(sourceCode.getTokenAfter(colon));\n                }\n            },\n\n            SwitchStatement(node) {\n                const openingCurly = sourceCode.getTokenAfter(node.discriminant, astUtils.isOpeningBraceToken);\n                const closingCurly = sourceCode.getLastToken(node);\n\n                offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, options.SwitchCase);\n\n                if (node.cases.length) {\n                    sourceCode.getTokensBetween(\n                        node.cases[node.cases.length - 1],\n                        closingCurly,\n                        { includeComments: true, filter: astUtils.isCommentToken }\n                    ).forEach(token => offsets.ignoreToken(token));\n                }\n            },\n\n            SwitchCase(node) {\n                if (!(node.consequent.length === 1 && node.consequent[0].type === \"BlockStatement\")) {\n                    const caseKeyword = sourceCode.getFirstToken(node);\n                    const tokenAfterCurrentCase = sourceCode.getTokenAfter(node);\n\n                    offsets.setDesiredOffsets([caseKeyword.range[1], tokenAfterCurrentCase.range[0]], caseKeyword, 1);\n                }\n            },\n\n            TemplateLiteral(node) {\n                node.expressions.forEach((expression, index) => {\n                    const previousQuasi = node.quasis[index];\n                    const nextQuasi = node.quasis[index + 1];\n                    const tokenToAlignFrom = previousQuasi.loc.start.line === previousQuasi.loc.end.line\n                        ? sourceCode.getFirstToken(previousQuasi)\n                        : null;\n\n                    offsets.setDesiredOffsets([previousQuasi.range[1], nextQuasi.range[0]], tokenToAlignFrom, 1);\n                    offsets.setDesiredOffset(sourceCode.getFirstToken(nextQuasi), tokenToAlignFrom, 0);\n                });\n            },\n\n            VariableDeclaration(node) {\n                let variableIndent = Object.prototype.hasOwnProperty.call(options.VariableDeclarator, node.kind)\n                    ? options.VariableDeclarator[node.kind]\n                    : DEFAULT_VARIABLE_INDENT;\n\n                const firstToken = sourceCode.getFirstToken(node),\n                    lastToken = sourceCode.getLastToken(node);\n\n                if (options.VariableDeclarator[node.kind] === \"first\") {\n                    if (node.declarations.length > 1) {\n                        addElementListIndent(\n                            node.declarations,\n                            firstToken,\n                            lastToken,\n                            \"first\"\n                        );\n                        return;\n                    }\n\n                    variableIndent = DEFAULT_VARIABLE_INDENT;\n                }\n\n                if (node.declarations[node.declarations.length - 1].loc.start.line > node.loc.start.line) {\n\n                    /*\n                     * VariableDeclarator indentation is a bit different from other forms of indentation, in that the\n                     * indentation of an opening bracket sometimes won't match that of a closing bracket. For example,\n                     * the following indentations are correct:\n                     *\n                     * var foo = {\n                     *   ok: true\n                     * };\n                     *\n                     * var foo = {\n                     *     ok: true,\n                     *   },\n                     *   bar = 1;\n                     *\n                     * Account for when exiting the AST (after indentations have already been set for the nodes in\n                     * the declaration) by manually increasing the indentation level of the tokens in this declarator\n                     * on the same line as the start of the declaration, provided that there are declarators that\n                     * follow this one.\n                     */\n                    offsets.setDesiredOffsets(node.range, firstToken, variableIndent, true);\n                } else {\n                    offsets.setDesiredOffsets(node.range, firstToken, variableIndent);\n                }\n\n                if (astUtils.isSemicolonToken(lastToken)) {\n                    offsets.ignoreToken(lastToken);\n                }\n            },\n\n            VariableDeclarator(node) {\n                if (node.init) {\n                    const equalOperator = sourceCode.getTokenBefore(node.init, astUtils.isNotOpeningParenToken);\n                    const tokenAfterOperator = sourceCode.getTokenAfter(equalOperator);\n\n                    offsets.ignoreToken(equalOperator);\n                    offsets.ignoreToken(tokenAfterOperator);\n                    offsets.setDesiredOffsets([tokenAfterOperator.range[0], node.range[1]], equalOperator, 1);\n                    offsets.setDesiredOffset(equalOperator, sourceCode.getLastToken(node.id), 0);\n                }\n            },\n\n            \"JSXAttribute[value]\"(node) {\n                const equalsToken = sourceCode.getFirstTokenBetween(node.name, node.value, token => token.type === \"Punctuator\" && token.value === \"=\");\n\n                offsets.setDesiredOffsets([equalsToken.range[0], node.value.range[1]], sourceCode.getFirstToken(node.name), 1);\n            },\n\n            JSXElement(node) {\n                if (node.closingElement) {\n                    addElementListIndent(node.children, sourceCode.getFirstToken(node.openingElement), sourceCode.getFirstToken(node.closingElement), 1);\n                }\n            },\n\n            JSXOpeningElement(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n                let closingToken;\n\n                if (node.selfClosing) {\n                    closingToken = sourceCode.getLastToken(node, { skip: 1 });\n                    offsets.setDesiredOffset(sourceCode.getLastToken(node), closingToken, 0);\n                } else {\n                    closingToken = sourceCode.getLastToken(node);\n                }\n                offsets.setDesiredOffsets(node.name.range, sourceCode.getFirstToken(node));\n                addElementListIndent(node.attributes, firstToken, closingToken, 1);\n            },\n\n            JSXClosingElement(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n\n                offsets.setDesiredOffsets(node.name.range, firstToken, 1);\n            },\n\n            JSXExpressionContainer(node) {\n                const openingCurly = sourceCode.getFirstToken(node);\n                const closingCurly = sourceCode.getLastToken(node);\n\n                offsets.setDesiredOffsets(\n                    [openingCurly.range[1], closingCurly.range[0]],\n                    openingCurly,\n                    1\n                );\n            },\n\n            \"*\"(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n\n                // Ensure that the children of every node are indented at least as much as the first token.\n                if (firstToken && !ignoredNodeFirstTokens.has(firstToken)) {\n                    offsets.setDesiredOffsets(node.range, firstToken, 0);\n                }\n            }\n        };\n\n        const listenerCallQueue = [];\n\n        /*\n         * To ignore the indentation of a node:\n         * 1. Don't call the node's listener when entering it (if it has a listener)\n         * 2. Don't set any offsets against the first token of the node.\n         * 3. Call `ignoreNode` on the node sometime after exiting it and before validating offsets.\n         */\n        const offsetListeners = lodash.mapValues(\n            baseOffsetListeners,\n\n            /*\n             * Offset listener calls are deferred until traversal is finished, and are called as\n             * part of the final `Program:exit` listener. This is necessary because a node might\n             * be matched by multiple selectors.\n             *\n             * Example: Suppose there is an offset listener for `Identifier`, and the user has\n             * specified in configuration that `MemberExpression > Identifier` should be ignored.\n             * Due to selector specificity rules, the `Identifier` listener will get called first. However,\n             * if a given Identifier node is supposed to be ignored, then the `Identifier` offset listener\n             * should not have been called at all. Without doing extra selector matching, we don't know\n             * whether the Identifier matches the `MemberExpression > Identifier` selector until the\n             * `MemberExpression > Identifier` listener is called.\n             *\n             * To avoid this, the `Identifier` listener isn't called until traversal finishes and all\n             * ignored nodes are known.\n             */\n            listener =>\n                node =>\n                    listenerCallQueue.push({ listener, node })\n        );\n\n        // For each ignored node selector, set up a listener to collect it into the `ignoredNodes` set.\n        const ignoredNodes = new Set();\n\n        /**\n         * Ignores a node\n         * @param {ASTNode} node The node to ignore\n         * @returns {void}\n         */\n        function addToIgnoredNodes(node) {\n            ignoredNodes.add(node);\n            ignoredNodeFirstTokens.add(sourceCode.getFirstToken(node));\n        }\n\n        const ignoredNodeListeners = options.ignoredNodes.reduce(\n            (listeners, ignoredSelector) => Object.assign(listeners, { [ignoredSelector]: addToIgnoredNodes }),\n            {}\n        );\n\n        /*\n         * Join the listeners, and add a listener to verify that all tokens actually have the correct indentation\n         * at the end.\n         *\n         * Using Object.assign will cause some offset listeners to be overwritten if the same selector also appears\n         * in `ignoredNodeListeners`. This isn't a problem because all of the matching nodes will be ignored,\n         * so those listeners wouldn't be called anyway.\n         */\n        return Object.assign(\n            offsetListeners,\n            ignoredNodeListeners,\n            {\n                \"*:exit\"(node) {\n\n                    // If a node's type is nonstandard, we can't tell how its children should be offset, so ignore it.\n                    if (!KNOWN_NODES.has(node.type)) {\n                        addToIgnoredNodes(node);\n                    }\n                },\n                \"Program:exit\"() {\n\n                    // If ignoreComments option is enabled, ignore all comment tokens.\n                    if (options.ignoreComments) {\n                        sourceCode.getAllComments()\n                            .forEach(comment => offsets.ignoreToken(comment));\n                    }\n\n                    // Invoke the queued offset listeners for the nodes that aren't ignored.\n                    listenerCallQueue\n                        .filter(nodeInfo => !ignoredNodes.has(nodeInfo.node))\n                        .forEach(nodeInfo => nodeInfo.listener(nodeInfo.node));\n\n                    // Update the offsets for ignored nodes to prevent their child tokens from being reported.\n                    ignoredNodes.forEach(ignoreNode);\n\n                    addParensIndent(sourceCode.ast.tokens);\n\n                    /*\n                     * Create a Map from (tokenOrComment) => (precedingToken).\n                     * This is necessary because sourceCode.getTokenBefore does not handle a comment as an argument correctly.\n                     */\n                    const precedingTokens = sourceCode.ast.comments.reduce((commentMap, comment) => {\n                        const tokenOrCommentBefore = sourceCode.getTokenBefore(comment, { includeComments: true });\n\n                        return commentMap.set(comment, commentMap.has(tokenOrCommentBefore) ? commentMap.get(tokenOrCommentBefore) : tokenOrCommentBefore);\n                    }, new WeakMap());\n\n                    sourceCode.lines.forEach((line, lineIndex) => {\n                        const lineNumber = lineIndex + 1;\n\n                        if (!tokenInfo.firstTokensByLineNumber.has(lineNumber)) {\n\n                            // Don't check indentation on blank lines\n                            return;\n                        }\n\n                        const firstTokenOfLine = tokenInfo.firstTokensByLineNumber.get(lineNumber);\n\n                        if (firstTokenOfLine.loc.start.line !== lineNumber) {\n\n                            // Don't check the indentation of multi-line tokens (e.g. template literals or block comments) twice.\n                            return;\n                        }\n\n                        // If the token matches the expected expected indentation, don't report it.\n                        if (validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine))) {\n                            return;\n                        }\n\n                        if (astUtils.isCommentToken(firstTokenOfLine)) {\n                            const tokenBefore = precedingTokens.get(firstTokenOfLine);\n                            const tokenAfter = tokenBefore ? sourceCode.getTokenAfter(tokenBefore) : sourceCode.ast.tokens[0];\n\n                            const mayAlignWithBefore = tokenBefore && !hasBlankLinesBetween(tokenBefore, firstTokenOfLine);\n                            const mayAlignWithAfter = tokenAfter && !hasBlankLinesBetween(firstTokenOfLine, tokenAfter);\n\n                            // If a comment matches the expected indentation of the token immediately before or after, don't report it.\n                            if (\n                                mayAlignWithBefore && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenBefore)) ||\n                                mayAlignWithAfter && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenAfter))\n                            ) {\n                                return;\n                            }\n                        }\n\n                        // Otherwise, report the token/comment.\n                        report(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine));\n                    });\n                }\n            }\n        );\n    }\n};\n","/**\n * @fileoverview This option sets a specific tab width for your code\n *\n * This rule has been ported and modified from nodeca.\n * @author Vitaly Puzrin\n * @author Gyandeep Singh\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/* istanbul ignore next: this rule has known coverage issues, but it's deprecated and shouldn't be updated in the future anyway. */\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent indentation\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/indent-legacy\"\n        },\n\n        deprecated: true,\n\n        replacedBy: [\"indent\"],\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"tab\"]\n                    },\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    SwitchCase: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    VariableDeclarator: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                type: \"object\",\n                                properties: {\n                                    var: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    let: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    const: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    }\n                                }\n                            }\n                        ]\n                    },\n                    outerIIFEBody: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    MemberExpression: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    FunctionDeclaration: {\n                        type: \"object\",\n                        properties: {\n                            parameters: {\n                                oneOf: [\n                                    {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    {\n                                        enum: [\"first\"]\n                                    }\n                                ]\n                            },\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        }\n                    },\n                    FunctionExpression: {\n                        type: \"object\",\n                        properties: {\n                            parameters: {\n                                oneOf: [\n                                    {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    {\n                                        enum: [\"first\"]\n                                    }\n                                ]\n                            },\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        }\n                    },\n                    CallExpression: {\n                        type: \"object\",\n                        properties: {\n                            parameters: {\n                                oneOf: [\n                                    {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    {\n                                        enum: [\"first\"]\n                                    }\n                                ]\n                            }\n                        }\n                    },\n                    ArrayExpression: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                enum: [\"first\"]\n                            }\n                        ]\n                    },\n                    ObjectExpression: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                enum: [\"first\"]\n                            }\n                        ]\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            expected: \"Expected indentation of {{expected}} but found {{actual}}.\"\n        }\n    },\n\n    create(context) {\n        const DEFAULT_VARIABLE_INDENT = 1;\n        const DEFAULT_PARAMETER_INDENT = null; // For backwards compatibility, don't check parameter indentation unless specified in the config\n        const DEFAULT_FUNCTION_BODY_INDENT = 1;\n\n        let indentType = \"space\";\n        let indentSize = 4;\n        const options = {\n            SwitchCase: 0,\n            VariableDeclarator: {\n                var: DEFAULT_VARIABLE_INDENT,\n                let: DEFAULT_VARIABLE_INDENT,\n                const: DEFAULT_VARIABLE_INDENT\n            },\n            outerIIFEBody: null,\n            FunctionDeclaration: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            FunctionExpression: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            CallExpression: {\n                arguments: DEFAULT_PARAMETER_INDENT\n            },\n            ArrayExpression: 1,\n            ObjectExpression: 1\n        };\n\n        const sourceCode = context.getSourceCode();\n\n        if (context.options.length) {\n            if (context.options[0] === \"tab\") {\n                indentSize = 1;\n                indentType = \"tab\";\n            } else /* istanbul ignore else : this will be caught by options validation */ if (typeof context.options[0] === \"number\") {\n                indentSize = context.options[0];\n                indentType = \"space\";\n            }\n\n            if (context.options[1]) {\n                const opts = context.options[1];\n\n                options.SwitchCase = opts.SwitchCase || 0;\n                const variableDeclaratorRules = opts.VariableDeclarator;\n\n                if (typeof variableDeclaratorRules === \"number\") {\n                    options.VariableDeclarator = {\n                        var: variableDeclaratorRules,\n                        let: variableDeclaratorRules,\n                        const: variableDeclaratorRules\n                    };\n                } else if (typeof variableDeclaratorRules === \"object\") {\n                    Object.assign(options.VariableDeclarator, variableDeclaratorRules);\n                }\n\n                if (typeof opts.outerIIFEBody === \"number\") {\n                    options.outerIIFEBody = opts.outerIIFEBody;\n                }\n\n                if (typeof opts.MemberExpression === \"number\") {\n                    options.MemberExpression = opts.MemberExpression;\n                }\n\n                if (typeof opts.FunctionDeclaration === \"object\") {\n                    Object.assign(options.FunctionDeclaration, opts.FunctionDeclaration);\n                }\n\n                if (typeof opts.FunctionExpression === \"object\") {\n                    Object.assign(options.FunctionExpression, opts.FunctionExpression);\n                }\n\n                if (typeof opts.CallExpression === \"object\") {\n                    Object.assign(options.CallExpression, opts.CallExpression);\n                }\n\n                if (typeof opts.ArrayExpression === \"number\" || typeof opts.ArrayExpression === \"string\") {\n                    options.ArrayExpression = opts.ArrayExpression;\n                }\n\n                if (typeof opts.ObjectExpression === \"number\" || typeof opts.ObjectExpression === \"string\") {\n                    options.ObjectExpression = opts.ObjectExpression;\n                }\n            }\n        }\n\n        const caseIndentStore = {};\n\n        /**\n         * Creates an error message for a line, given the expected/actual indentation.\n         * @param {int} expectedAmount The expected amount of indentation characters for this line\n         * @param {int} actualSpaces The actual number of indentation spaces that were found on this line\n         * @param {int} actualTabs The actual number of indentation tabs that were found on this line\n         * @returns {string} An error message for this line\n         */\n        function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {\n            const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? \"\" : \"s\"}`; // e.g. \"2 tabs\"\n            const foundSpacesWord = `space${actualSpaces === 1 ? \"\" : \"s\"}`; // e.g. \"space\"\n            const foundTabsWord = `tab${actualTabs === 1 ? \"\" : \"s\"}`; // e.g. \"tabs\"\n            let foundStatement;\n\n            if (actualSpaces > 0 && actualTabs > 0) {\n                foundStatement = `${actualSpaces} ${foundSpacesWord} and ${actualTabs} ${foundTabsWord}`; // e.g. \"1 space and 2 tabs\"\n            } else if (actualSpaces > 0) {\n\n                /*\n                 * Abbreviate the message if the expected indentation is also spaces.\n                 * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'\n                 */\n                foundStatement = indentType === \"space\" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;\n            } else if (actualTabs > 0) {\n                foundStatement = indentType === \"tab\" ? actualTabs : `${actualTabs} ${foundTabsWord}`;\n            } else {\n                foundStatement = \"0\";\n            }\n            return {\n                expected: expectedStatement,\n                actual: foundStatement\n            };\n        }\n\n        /**\n         * Reports a given indent violation\n         * @param {ASTNode} node Node violating the indent rule\n         * @param {int} needed Expected indentation character count\n         * @param {int} gottenSpaces Indentation space count in the actual node/code\n         * @param {int} gottenTabs Indentation tab count in the actual node/code\n         * @param {Object=} loc Error line and column location\n         * @param {boolean} isLastNodeCheck Is the error for last node check\n         * @returns {void}\n         */\n        function report(node, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck) {\n            if (gottenSpaces && gottenTabs) {\n\n                // To avoid conflicts with `no-mixed-spaces-and-tabs`, don't report lines that have both spaces and tabs.\n                return;\n            }\n\n            const desiredIndent = (indentType === \"space\" ? \" \" : \"\\t\").repeat(needed);\n\n            const textRange = isLastNodeCheck\n                ? [node.range[1] - node.loc.end.column, node.range[1] - node.loc.end.column + gottenSpaces + gottenTabs]\n                : [node.range[0] - node.loc.start.column, node.range[0] - node.loc.start.column + gottenSpaces + gottenTabs];\n\n            context.report({\n                node,\n                loc,\n                messageId: \"expected\",\n                data: createErrorMessageData(needed, gottenSpaces, gottenTabs),\n                fix: fixer => fixer.replaceTextRange(textRange, desiredIndent)\n            });\n        }\n\n        /**\n         * Get the actual indent of node\n         * @param {ASTNode|Token} node Node to examine\n         * @param {boolean} [byLastLine=false] get indent of node's last line\n         * @returns {Object} The node's indent. Contains keys `space` and `tab`, representing the indent of each character. Also\n         * contains keys `goodChar` and `badChar`, where `goodChar` is the amount of the user's desired indentation character, and\n         * `badChar` is the amount of the other indentation character.\n         */\n        function getNodeIndent(node, byLastLine) {\n            const token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);\n            const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split(\"\");\n            const indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex(char => char !== \" \" && char !== \"\\t\"));\n            const spaces = indentChars.filter(char => char === \" \").length;\n            const tabs = indentChars.filter(char => char === \"\\t\").length;\n\n            return {\n                space: spaces,\n                tab: tabs,\n                goodChar: indentType === \"space\" ? spaces : tabs,\n                badChar: indentType === \"space\" ? tabs : spaces\n            };\n        }\n\n        /**\n         * Checks node is the first in its own start line. By default it looks by start line.\n         * @param {ASTNode} node The node to check\n         * @param {boolean} [byEndLocation=false] Lookup based on start position or end\n         * @returns {boolean} true if its the first in the its start line\n         */\n        function isNodeFirstInLine(node, byEndLocation) {\n            const firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node),\n                startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line,\n                endLine = firstToken ? firstToken.loc.end.line : -1;\n\n            return startLine !== endLine;\n        }\n\n        /**\n         * Check indent for node\n         * @param {ASTNode} node Node to check\n         * @param {int} neededIndent needed indent\n         * @returns {void}\n         */\n        function checkNodeIndent(node, neededIndent) {\n            const actualIndent = getNodeIndent(node, false);\n\n            if (\n                node.type !== \"ArrayExpression\" &&\n                node.type !== \"ObjectExpression\" &&\n                (actualIndent.goodChar !== neededIndent || actualIndent.badChar !== 0) &&\n                isNodeFirstInLine(node)\n            ) {\n                report(node, neededIndent, actualIndent.space, actualIndent.tab);\n            }\n\n            if (node.type === \"IfStatement\" && node.alternate) {\n                const elseToken = sourceCode.getTokenBefore(node.alternate);\n\n                checkNodeIndent(elseToken, neededIndent);\n\n                if (!isNodeFirstInLine(node.alternate)) {\n                    checkNodeIndent(node.alternate, neededIndent);\n                }\n            }\n\n            if (node.type === \"TryStatement\" && node.handler) {\n                const catchToken = sourceCode.getFirstToken(node.handler);\n\n                checkNodeIndent(catchToken, neededIndent);\n            }\n\n            if (node.type === \"TryStatement\" && node.finalizer) {\n                const finallyToken = sourceCode.getTokenBefore(node.finalizer);\n\n                checkNodeIndent(finallyToken, neededIndent);\n            }\n\n            if (node.type === \"DoWhileStatement\") {\n                const whileToken = sourceCode.getTokenAfter(node.body);\n\n                checkNodeIndent(whileToken, neededIndent);\n            }\n        }\n\n        /**\n         * Check indent for nodes list\n         * @param {ASTNode[]} nodes list of node objects\n         * @param {int} indent needed indent\n         * @returns {void}\n         */\n        function checkNodesIndent(nodes, indent) {\n            nodes.forEach(node => checkNodeIndent(node, indent));\n        }\n\n        /**\n         * Check last node line indent this detects, that block closed correctly\n         * @param {ASTNode} node Node to examine\n         * @param {int} lastLineIndent needed indent\n         * @returns {void}\n         */\n        function checkLastNodeLineIndent(node, lastLineIndent) {\n            const lastToken = sourceCode.getLastToken(node);\n            const endIndent = getNodeIndent(lastToken, true);\n\n            if ((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== 0) && isNodeFirstInLine(node, true)) {\n                report(\n                    node,\n                    lastLineIndent,\n                    endIndent.space,\n                    endIndent.tab,\n                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column },\n                    true\n                );\n            }\n        }\n\n        /**\n         * Check last node line indent this detects, that block closed correctly\n         * This function for more complicated return statement case, where closing parenthesis may be followed by ';'\n         * @param {ASTNode} node Node to examine\n         * @param {int} firstLineIndent first line needed indent\n         * @returns {void}\n         */\n        function checkLastReturnStatementLineIndent(node, firstLineIndent) {\n\n            /*\n             * in case if return statement ends with ');' we have traverse back to ')'\n             * otherwise we'll measure indent for ';' and replace ')'\n             */\n            const lastToken = sourceCode.getLastToken(node, astUtils.isClosingParenToken);\n            const textBeforeClosingParenthesis = sourceCode.getText(lastToken, lastToken.loc.start.column).slice(0, -1);\n\n            if (textBeforeClosingParenthesis.trim()) {\n\n                // There are tokens before the closing paren, don't report this case\n                return;\n            }\n\n            const endIndent = getNodeIndent(lastToken, true);\n\n            if (endIndent.goodChar !== firstLineIndent) {\n                report(\n                    node,\n                    firstLineIndent,\n                    endIndent.space,\n                    endIndent.tab,\n                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column },\n                    true\n                );\n            }\n        }\n\n        /**\n         * Check first node line indent is correct\n         * @param {ASTNode} node Node to examine\n         * @param {int} firstLineIndent needed indent\n         * @returns {void}\n         */\n        function checkFirstNodeLineIndent(node, firstLineIndent) {\n            const startIndent = getNodeIndent(node, false);\n\n            if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node)) {\n                report(\n                    node,\n                    firstLineIndent,\n                    startIndent.space,\n                    startIndent.tab,\n                    { line: node.loc.start.line, column: node.loc.start.column }\n                );\n            }\n        }\n\n        /**\n         * Returns a parent node of given node based on a specified type\n         * if not present then return null\n         * @param {ASTNode} node node to examine\n         * @param {string} type type that is being looked for\n         * @param {string} stopAtList end points for the evaluating code\n         * @returns {ASTNode|void} if found then node otherwise null\n         */\n        function getParentNodeByType(node, type, stopAtList) {\n            let parent = node.parent;\n            const stopAtSet = new Set(stopAtList || [\"Program\"]);\n\n            while (parent.type !== type && !stopAtSet.has(parent.type) && parent.type !== \"Program\") {\n                parent = parent.parent;\n            }\n\n            return parent.type === type ? parent : null;\n        }\n\n        /**\n         * Returns the VariableDeclarator based on the current node\n         * if not present then return null\n         * @param {ASTNode} node node to examine\n         * @returns {ASTNode|void} if found then node otherwise null\n         */\n        function getVariableDeclaratorNode(node) {\n            return getParentNodeByType(node, \"VariableDeclarator\");\n        }\n\n        /**\n         * Check to see if the node is part of the multi-line variable declaration.\n         * Also if its on the same line as the varNode\n         * @param {ASTNode} node node to check\n         * @param {ASTNode} varNode variable declaration node to check against\n         * @returns {boolean} True if all the above condition satisfy\n         */\n        function isNodeInVarOnTop(node, varNode) {\n            return varNode &&\n                varNode.parent.loc.start.line === node.loc.start.line &&\n                varNode.parent.declarations.length > 1;\n        }\n\n        /**\n         * Check to see if the argument before the callee node is multi-line and\n         * there should only be 1 argument before the callee node\n         * @param {ASTNode} node node to check\n         * @returns {boolean} True if arguments are multi-line\n         */\n        function isArgBeforeCalleeNodeMultiline(node) {\n            const parent = node.parent;\n\n            if (parent.arguments.length >= 2 && parent.arguments[1] === node) {\n                return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;\n            }\n\n            return false;\n        }\n\n        /**\n         * Check to see if the node is a file level IIFE\n         * @param {ASTNode} node The function node to check.\n         * @returns {boolean} True if the node is the outer IIFE\n         */\n        function isOuterIIFE(node) {\n            const parent = node.parent;\n            let stmt = parent.parent;\n\n            /*\n             * Verify that the node is an IIEF\n             */\n            if (\n                parent.type !== \"CallExpression\" ||\n                parent.callee !== node) {\n\n                return false;\n            }\n\n            /*\n             * Navigate legal ancestors to determine whether this IIEF is outer\n             */\n            while (\n                stmt.type === \"UnaryExpression\" && (\n                    stmt.operator === \"!\" ||\n                    stmt.operator === \"~\" ||\n                    stmt.operator === \"+\" ||\n                    stmt.operator === \"-\") ||\n                stmt.type === \"AssignmentExpression\" ||\n                stmt.type === \"LogicalExpression\" ||\n                stmt.type === \"SequenceExpression\" ||\n                stmt.type === \"VariableDeclarator\") {\n\n                stmt = stmt.parent;\n            }\n\n            return ((\n                stmt.type === \"ExpressionStatement\" ||\n                stmt.type === \"VariableDeclaration\") &&\n                stmt.parent && stmt.parent.type === \"Program\"\n            );\n        }\n\n        /**\n         * Check indent for function block content\n         * @param {ASTNode} node A BlockStatement node that is inside of a function.\n         * @returns {void}\n         */\n        function checkIndentInFunctionBlock(node) {\n\n            /*\n             * Search first caller in chain.\n             * Ex.:\n             *\n             * Models <- Identifier\n             *   .User\n             *   .find()\n             *   .exec(function() {\n             *   // function body\n             * });\n             *\n             * Looks for 'Models'\n             */\n            const calleeNode = node.parent; // FunctionExpression\n            let indent;\n\n            if (calleeNode.parent &&\n                (calleeNode.parent.type === \"Property\" ||\n                calleeNode.parent.type === \"ArrayExpression\")) {\n\n                // If function is part of array or object, comma can be put at left\n                indent = getNodeIndent(calleeNode, false).goodChar;\n            } else {\n\n                // If function is standalone, simple calculate indent\n                indent = getNodeIndent(calleeNode).goodChar;\n            }\n\n            if (calleeNode.parent.type === \"CallExpression\") {\n                const calleeParent = calleeNode.parent;\n\n                if (calleeNode.type !== \"FunctionExpression\" && calleeNode.type !== \"ArrowFunctionExpression\") {\n                    if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {\n                        indent = getNodeIndent(calleeParent).goodChar;\n                    }\n                } else {\n                    if (isArgBeforeCalleeNodeMultiline(calleeNode) &&\n                        calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line &&\n                        !isNodeFirstInLine(calleeNode)) {\n                        indent = getNodeIndent(calleeParent).goodChar;\n                    }\n                }\n            }\n\n            /*\n             * function body indent should be indent + indent size, unless this\n             * is a FunctionDeclaration, FunctionExpression, or outer IIFE and the corresponding options are enabled.\n             */\n            let functionOffset = indentSize;\n\n            if (options.outerIIFEBody !== null && isOuterIIFE(calleeNode)) {\n                functionOffset = options.outerIIFEBody * indentSize;\n            } else if (calleeNode.type === \"FunctionExpression\") {\n                functionOffset = options.FunctionExpression.body * indentSize;\n            } else if (calleeNode.type === \"FunctionDeclaration\") {\n                functionOffset = options.FunctionDeclaration.body * indentSize;\n            }\n            indent += functionOffset;\n\n            // check if the node is inside a variable\n            const parentVarNode = getVariableDeclaratorNode(node);\n\n            if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {\n                indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n            }\n\n            if (node.body.length > 0) {\n                checkNodesIndent(node.body, indent);\n            }\n\n            checkLastNodeLineIndent(node, indent - functionOffset);\n        }\n\n\n        /**\n         * Checks if the given node starts and ends on the same line\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} Whether or not the block starts and ends on the same line.\n         */\n        function isSingleLineNode(node) {\n            const lastToken = sourceCode.getLastToken(node),\n                startLine = node.loc.start.line,\n                endLine = lastToken.loc.end.line;\n\n            return startLine === endLine;\n        }\n\n        /**\n         * Check to see if the first element inside an array is an object and on the same line as the node\n         * If the node is not an array then it will return false.\n         * @param {ASTNode} node node to check\n         * @returns {boolean} success/failure\n         */\n        function isFirstArrayElementOnSameLine(node) {\n            if (node.type === \"ArrayExpression\" && node.elements[0]) {\n                return node.elements[0].loc.start.line === node.loc.start.line && node.elements[0].type === \"ObjectExpression\";\n            }\n            return false;\n\n        }\n\n        /**\n         * Check indent for array block content or object block content\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkIndentInArrayOrObjectBlock(node) {\n\n            // Skip inline\n            if (isSingleLineNode(node)) {\n                return;\n            }\n\n            let elements = (node.type === \"ArrayExpression\") ? node.elements : node.properties;\n\n            // filter out empty elements example would be [ , 2] so remove first element as espree considers it as null\n            elements = elements.filter(elem => elem !== null);\n\n            let nodeIndent;\n            let elementsIndent;\n            const parentVarNode = getVariableDeclaratorNode(node);\n\n            // TODO - come up with a better strategy in future\n            if (isNodeFirstInLine(node)) {\n                const parent = node.parent;\n\n                nodeIndent = getNodeIndent(parent).goodChar;\n                if (!parentVarNode || parentVarNode.loc.start.line !== node.loc.start.line) {\n                    if (parent.type !== \"VariableDeclarator\" || parentVarNode === parentVarNode.parent.declarations[0]) {\n                        if (parent.type === \"VariableDeclarator\" && parentVarNode.loc.start.line === parent.loc.start.line) {\n                            nodeIndent += (indentSize * options.VariableDeclarator[parentVarNode.parent.kind]);\n                        } else if (parent.type === \"ObjectExpression\" || parent.type === \"ArrayExpression\") {\n                            const parentElements = node.parent.type === \"ObjectExpression\" ? node.parent.properties : node.parent.elements;\n\n                            if (parentElements[0] &&\n                                    parentElements[0].loc.start.line === parent.loc.start.line &&\n                                    parentElements[0].loc.end.line !== parent.loc.start.line) {\n\n                                /*\n                                 * If the first element of the array spans multiple lines, don't increase the expected indentation of the rest.\n                                 * e.g. [{\n                                 *        foo: 1\n                                 *      },\n                                 *      {\n                                 *        bar: 1\n                                 *      }]\n                                 * the second object is not indented.\n                                 */\n                            } else if (typeof options[parent.type] === \"number\") {\n                                nodeIndent += options[parent.type] * indentSize;\n                            } else {\n                                nodeIndent = parentElements[0].loc.start.column;\n                            }\n                        } else if (parent.type === \"CallExpression\" || parent.type === \"NewExpression\") {\n                            if (typeof options.CallExpression.arguments === \"number\") {\n                                nodeIndent += options.CallExpression.arguments * indentSize;\n                            } else if (options.CallExpression.arguments === \"first\") {\n                                if (parent.arguments.indexOf(node) !== -1) {\n                                    nodeIndent = parent.arguments[0].loc.start.column;\n                                }\n                            } else {\n                                nodeIndent += indentSize;\n                            }\n                        } else if (parent.type === \"LogicalExpression\" || parent.type === \"ArrowFunctionExpression\") {\n                            nodeIndent += indentSize;\n                        }\n                    }\n                } else if (!parentVarNode && !isFirstArrayElementOnSameLine(parent) && parent.type !== \"MemberExpression\" && parent.type !== \"ExpressionStatement\" && parent.type !== \"AssignmentExpression\" && parent.type !== \"Property\") {\n                    nodeIndent += indentSize;\n                }\n\n                checkFirstNodeLineIndent(node, nodeIndent);\n            } else {\n                nodeIndent = getNodeIndent(node).goodChar;\n            }\n\n            if (options[node.type] === \"first\") {\n                elementsIndent = elements.length ? elements[0].loc.start.column : 0; // If there are no elements, elementsIndent doesn't matter.\n            } else {\n                elementsIndent = nodeIndent + indentSize * options[node.type];\n            }\n\n            /*\n             * Check if the node is a multiple variable declaration; if so, then\n             * make sure indentation takes that into account.\n             */\n            if (isNodeInVarOnTop(node, parentVarNode)) {\n                elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n            }\n\n            checkNodesIndent(elements, elementsIndent);\n\n            if (elements.length > 0) {\n\n                // Skip last block line check if last item in same line\n                if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {\n                    return;\n                }\n            }\n\n            checkLastNodeLineIndent(node, nodeIndent +\n                (isNodeInVarOnTop(node, parentVarNode) ? options.VariableDeclarator[parentVarNode.parent.kind] * indentSize : 0));\n        }\n\n        /**\n         * Check if the node or node body is a BlockStatement or not\n         * @param {ASTNode} node node to test\n         * @returns {boolean} True if it or its body is a block statement\n         */\n        function isNodeBodyBlock(node) {\n            return node.type === \"BlockStatement\" || node.type === \"ClassBody\" || (node.body && node.body.type === \"BlockStatement\") ||\n                (node.consequent && node.consequent.type === \"BlockStatement\");\n        }\n\n        /**\n         * Check indentation for blocks\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function blockIndentationCheck(node) {\n\n            // Skip inline blocks\n            if (isSingleLineNode(node)) {\n                return;\n            }\n\n            if (node.parent && (\n                node.parent.type === \"FunctionExpression\" ||\n                node.parent.type === \"FunctionDeclaration\" ||\n                node.parent.type === \"ArrowFunctionExpression\")\n            ) {\n                checkIndentInFunctionBlock(node);\n                return;\n            }\n\n            let indent;\n            let nodesToCheck = [];\n\n            /*\n             * For this statements we should check indent from statement beginning,\n             * not from the beginning of the block.\n             */\n            const statementsWithProperties = [\n                \"IfStatement\", \"WhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\", \"DoWhileStatement\", \"ClassDeclaration\", \"TryStatement\"\n            ];\n\n            if (node.parent && statementsWithProperties.indexOf(node.parent.type) !== -1 && isNodeBodyBlock(node)) {\n                indent = getNodeIndent(node.parent).goodChar;\n            } else if (node.parent && node.parent.type === \"CatchClause\") {\n                indent = getNodeIndent(node.parent.parent).goodChar;\n            } else {\n                indent = getNodeIndent(node).goodChar;\n            }\n\n            if (node.type === \"IfStatement\" && node.consequent.type !== \"BlockStatement\") {\n                nodesToCheck = [node.consequent];\n            } else if (Array.isArray(node.body)) {\n                nodesToCheck = node.body;\n            } else {\n                nodesToCheck = [node.body];\n            }\n\n            if (nodesToCheck.length > 0) {\n                checkNodesIndent(nodesToCheck, indent + indentSize);\n            }\n\n            if (node.type === \"BlockStatement\") {\n                checkLastNodeLineIndent(node, indent);\n            }\n        }\n\n        /**\n         * Filter out the elements which are on the same line of each other or the node.\n         * basically have only 1 elements from each line except the variable declaration line.\n         * @param {ASTNode} node Variable declaration node\n         * @returns {ASTNode[]} Filtered elements\n         */\n        function filterOutSameLineVars(node) {\n            return node.declarations.reduce((finalCollection, elem) => {\n                const lastElem = finalCollection[finalCollection.length - 1];\n\n                if ((elem.loc.start.line !== node.loc.start.line && !lastElem) ||\n                    (lastElem && lastElem.loc.start.line !== elem.loc.start.line)) {\n                    finalCollection.push(elem);\n                }\n\n                return finalCollection;\n            }, []);\n        }\n\n        /**\n         * Check indentation for variable declarations\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkIndentInVariableDeclarations(node) {\n            const elements = filterOutSameLineVars(node);\n            const nodeIndent = getNodeIndent(node).goodChar;\n            const lastElement = elements[elements.length - 1];\n\n            const elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];\n\n            checkNodesIndent(elements, elementsIndent);\n\n            // Only check the last line if there is any token after the last item\n            if (sourceCode.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {\n                return;\n            }\n\n            const tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);\n\n            if (tokenBeforeLastElement.value === \",\") {\n\n                // Special case for comma-first syntax where the semicolon is indented\n                checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement).goodChar);\n            } else {\n                checkLastNodeLineIndent(node, elementsIndent - indentSize);\n            }\n        }\n\n        /**\n         * Check and decide whether to check for indentation for blockless nodes\n         * Scenarios are for or while statements without braces around them\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function blockLessNodes(node) {\n            if (node.body.type !== \"BlockStatement\") {\n                blockIndentationCheck(node);\n            }\n        }\n\n        /**\n         * Returns the expected indentation for the case statement\n         * @param {ASTNode} node node to examine\n         * @param {int} [providedSwitchIndent] indent for switch statement\n         * @returns {int} indent size\n         */\n        function expectedCaseIndent(node, providedSwitchIndent) {\n            const switchNode = (node.type === \"SwitchStatement\") ? node : node.parent;\n            const switchIndent = typeof providedSwitchIndent === \"undefined\"\n                ? getNodeIndent(switchNode).goodChar\n                : providedSwitchIndent;\n            let caseIndent;\n\n            if (caseIndentStore[switchNode.loc.start.line]) {\n                return caseIndentStore[switchNode.loc.start.line];\n            }\n\n            if (switchNode.cases.length > 0 && options.SwitchCase === 0) {\n                caseIndent = switchIndent;\n            } else {\n                caseIndent = switchIndent + (indentSize * options.SwitchCase);\n            }\n\n            caseIndentStore[switchNode.loc.start.line] = caseIndent;\n            return caseIndent;\n\n        }\n\n        /**\n         * Checks wether a return statement is wrapped in ()\n         * @param {ASTNode} node node to examine\n         * @returns {boolean} the result\n         */\n        function isWrappedInParenthesis(node) {\n            const regex = /^return\\s*?\\(\\s*?\\);*?/u;\n\n            const statementWithoutArgument = sourceCode.getText(node).replace(\n                sourceCode.getText(node.argument), \"\"\n            );\n\n            return regex.test(statementWithoutArgument);\n        }\n\n        return {\n            Program(node) {\n                if (node.body.length > 0) {\n\n                    // Root nodes should have no indent\n                    checkNodesIndent(node.body, getNodeIndent(node).goodChar);\n                }\n            },\n\n            ClassBody: blockIndentationCheck,\n\n            BlockStatement: blockIndentationCheck,\n\n            WhileStatement: blockLessNodes,\n\n            ForStatement: blockLessNodes,\n\n            ForInStatement: blockLessNodes,\n\n            ForOfStatement: blockLessNodes,\n\n            DoWhileStatement: blockLessNodes,\n\n            IfStatement(node) {\n                if (node.consequent.type !== \"BlockStatement\" && node.consequent.loc.start.line > node.loc.start.line) {\n                    blockIndentationCheck(node);\n                }\n            },\n\n            VariableDeclaration(node) {\n                if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {\n                    checkIndentInVariableDeclarations(node);\n                }\n            },\n\n            ObjectExpression(node) {\n                checkIndentInArrayOrObjectBlock(node);\n            },\n\n            ArrayExpression(node) {\n                checkIndentInArrayOrObjectBlock(node);\n            },\n\n            MemberExpression(node) {\n\n                if (typeof options.MemberExpression === \"undefined\") {\n                    return;\n                }\n\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n\n                /*\n                 * The typical layout of variable declarations and assignments\n                 * alter the expectation of correct indentation. Skip them.\n                 * TODO: Add appropriate configuration options for variable\n                 * declarations and assignments.\n                 */\n                if (getParentNodeByType(node, \"VariableDeclarator\", [\"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n                    return;\n                }\n\n                if (getParentNodeByType(node, \"AssignmentExpression\", [\"FunctionExpression\"])) {\n                    return;\n                }\n\n                const propertyIndent = getNodeIndent(node).goodChar + indentSize * options.MemberExpression;\n\n                const checkNodes = [node.property];\n\n                const dot = sourceCode.getTokenBefore(node.property);\n\n                if (dot.type === \"Punctuator\" && dot.value === \".\") {\n                    checkNodes.push(dot);\n                }\n\n                checkNodesIndent(checkNodes, propertyIndent);\n            },\n\n            SwitchStatement(node) {\n\n                // Switch is not a 'BlockStatement'\n                const switchIndent = getNodeIndent(node).goodChar;\n                const caseIndent = expectedCaseIndent(node, switchIndent);\n\n                checkNodesIndent(node.cases, caseIndent);\n\n\n                checkLastNodeLineIndent(node, switchIndent);\n            },\n\n            SwitchCase(node) {\n\n                // Skip inline cases\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                const caseIndent = expectedCaseIndent(node);\n\n                checkNodesIndent(node.consequent, caseIndent + indentSize);\n            },\n\n            FunctionDeclaration(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                if (options.FunctionDeclaration.parameters === \"first\" && node.params.length) {\n                    checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n                } else if (options.FunctionDeclaration.parameters !== null) {\n                    checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionDeclaration.parameters);\n                }\n            },\n\n            FunctionExpression(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                if (options.FunctionExpression.parameters === \"first\" && node.params.length) {\n                    checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n                } else if (options.FunctionExpression.parameters !== null) {\n                    checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionExpression.parameters);\n                }\n            },\n\n            ReturnStatement(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n\n                const firstLineIndent = getNodeIndent(node).goodChar;\n\n                // in case if return statement is wrapped in parenthesis\n                if (isWrappedInParenthesis(node)) {\n                    checkLastReturnStatementLineIndent(node, firstLineIndent);\n                } else {\n                    checkNodeIndent(node, firstLineIndent);\n                }\n            },\n\n            CallExpression(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                if (options.CallExpression.arguments === \"first\" && node.arguments.length) {\n                    checkNodesIndent(node.arguments.slice(1), node.arguments[0].loc.start.column);\n                } else if (options.CallExpression.arguments !== null) {\n                    checkNodesIndent(node.arguments, getNodeIndent(node).goodChar + indentSize * options.CallExpression.arguments);\n                }\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview A rule to control the style of variable initializations.\n * @author Colin Ihrig\n */\n\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a for loop.\n * @param {ASTNode} block - A node to check.\n * @returns {boolean} `true` when the node is a for loop.\n */\nfunction isForLoop(block) {\n    return block.type === \"ForInStatement\" ||\n    block.type === \"ForOfStatement\" ||\n    block.type === \"ForStatement\";\n}\n\n/**\n * Checks whether or not a given declarator node has its initializer.\n * @param {ASTNode} node - A declarator node to check.\n * @returns {boolean} `true` when the node has its initializer.\n */\nfunction isInitialized(node) {\n    const declaration = node.parent;\n    const block = declaration.parent;\n\n    if (isForLoop(block)) {\n        if (block.type === \"ForStatement\") {\n            return block.init === declaration;\n        }\n        return block.left === declaration;\n    }\n    return Boolean(node.init);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require or disallow initialization in variable declarations\",\n            category: \"Variables\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/init-declarations\"\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"never\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                ignoreForLoopInit: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n        messages: {\n            initialized: \"Variable '{{idName}}' should be initialized on declaration.\",\n            notInitialized: \"Variable '{{idName}}' should not be initialized on declaration.\"\n        }\n    },\n\n    create(context) {\n\n        const MODE_ALWAYS = \"always\",\n            MODE_NEVER = \"never\";\n\n        const mode = context.options[0] || MODE_ALWAYS;\n        const params = context.options[1] || {};\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            \"VariableDeclaration:exit\"(node) {\n\n                const kind = node.kind,\n                    declarations = node.declarations;\n\n                for (let i = 0; i < declarations.length; ++i) {\n                    const declaration = declarations[i],\n                        id = declaration.id,\n                        initialized = isInitialized(declaration),\n                        isIgnoredForLoop = params.ignoreForLoopInit && isForLoop(node.parent);\n                    let messageId = \"\";\n\n                    if (mode === MODE_ALWAYS && !initialized) {\n                        messageId = \"initialized\";\n                    } else if (mode === MODE_NEVER && kind !== \"const\" && initialized && !isIgnoredForLoop) {\n                        messageId = \"notInitialized\";\n                    }\n\n                    if (id.type === \"Identifier\" && messageId) {\n                        context.report({\n                            node: declaration,\n                            messageId,\n                            data: {\n                                idName: id.name\n                            }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A rule to ensure consistent quotes used in jsx syntax.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst QUOTE_SETTINGS = {\n    \"prefer-double\": {\n        quote: \"\\\"\",\n        description: \"singlequote\",\n        convert(str) {\n            return str.replace(/'/gu, \"\\\"\");\n        }\n    },\n    \"prefer-single\": {\n        quote: \"'\",\n        description: \"doublequote\",\n        convert(str) {\n            return str.replace(/\"/gu, \"'\");\n        }\n    }\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce the consistent use of either double or single quotes in JSX attributes\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/jsx-quotes\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"prefer-single\", \"prefer-double\"]\n            }\n        ],\n        messages: {\n            unexpected: \"Unexpected usage of {{description}}.\"\n        }\n    },\n\n    create(context) {\n        const quoteOption = context.options[0] || \"prefer-double\",\n            setting = QUOTE_SETTINGS[quoteOption];\n\n        /**\n         * Checks if the given string literal node uses the expected quotes\n         * @param {ASTNode} node - A string literal node.\n         * @returns {boolean} Whether or not the string literal used the expected quotes.\n         * @public\n         */\n        function usesExpectedQuotes(node) {\n            return node.value.indexOf(setting.quote) !== -1 || astUtils.isSurroundedBy(node.raw, setting.quote);\n        }\n\n        return {\n            JSXAttribute(node) {\n                const attributeValue = node.value;\n\n                if (attributeValue && astUtils.isStringLiteral(attributeValue) && !usesExpectedQuotes(attributeValue)) {\n                    context.report({\n                        node: attributeValue,\n                        messageId: \"unexpected\",\n                        data: {\n                            description: setting.description\n                        },\n                        fix(fixer) {\n                            return fixer.replaceText(attributeValue, setting.convert(attributeValue.raw));\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to specify spacing of object literal keys and values\n * @author Brandon Mills\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a string contains a line terminator as defined in\n * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3\n * @param {string} str String to test.\n * @returns {boolean} True if str contains a line terminator.\n */\nfunction containsLineTerminator(str) {\n    return astUtils.LINEBREAK_MATCHER.test(str);\n}\n\n/**\n * Gets the last element of an array.\n * @param {Array} arr An array.\n * @returns {any} Last element of arr.\n */\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\n/**\n * Checks whether a node is contained on a single line.\n * @param {ASTNode} node AST Node being evaluated.\n * @returns {boolean} True if the node is a single line.\n */\nfunction isSingleLine(node) {\n    return (node.loc.end.line === node.loc.start.line);\n}\n\n/**\n * Initializes a single option property from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\nfunction initOptionProperty(toOptions, fromOptions) {\n    toOptions.mode = fromOptions.mode || \"strict\";\n\n    // Set value of beforeColon\n    if (typeof fromOptions.beforeColon !== \"undefined\") {\n        toOptions.beforeColon = +fromOptions.beforeColon;\n    } else {\n        toOptions.beforeColon = 0;\n    }\n\n    // Set value of afterColon\n    if (typeof fromOptions.afterColon !== \"undefined\") {\n        toOptions.afterColon = +fromOptions.afterColon;\n    } else {\n        toOptions.afterColon = 1;\n    }\n\n    // Set align if exists\n    if (typeof fromOptions.align !== \"undefined\") {\n        if (typeof fromOptions.align === \"object\") {\n            toOptions.align = fromOptions.align;\n        } else { // \"string\"\n            toOptions.align = {\n                on: fromOptions.align,\n                mode: toOptions.mode,\n                beforeColon: toOptions.beforeColon,\n                afterColon: toOptions.afterColon\n            };\n        }\n    }\n\n    return toOptions;\n}\n\n/**\n * Initializes all the option values (singleLine, multiLine and align) from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\nfunction initOptions(toOptions, fromOptions) {\n    if (typeof fromOptions.align === \"object\") {\n\n        // Initialize the alignment configuration\n        toOptions.align = initOptionProperty({}, fromOptions.align);\n        toOptions.align.on = fromOptions.align.on || \"colon\";\n        toOptions.align.mode = fromOptions.align.mode || \"strict\";\n\n        toOptions.multiLine = initOptionProperty({}, (fromOptions.multiLine || fromOptions));\n        toOptions.singleLine = initOptionProperty({}, (fromOptions.singleLine || fromOptions));\n\n    } else { // string or undefined\n        toOptions.multiLine = initOptionProperty({}, (fromOptions.multiLine || fromOptions));\n        toOptions.singleLine = initOptionProperty({}, (fromOptions.singleLine || fromOptions));\n\n        // If alignment options are defined in multiLine, pull them out into the general align configuration\n        if (toOptions.multiLine.align) {\n            toOptions.align = {\n                on: toOptions.multiLine.align.on,\n                mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,\n                beforeColon: toOptions.multiLine.align.beforeColon,\n                afterColon: toOptions.multiLine.align.afterColon\n            };\n        }\n    }\n\n    return toOptions;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing between keys and values in object literal properties\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/key-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [{\n            anyOf: [\n                {\n                    type: \"object\",\n                    properties: {\n                        align: {\n                            anyOf: [\n                                {\n                                    enum: [\"colon\", \"value\"]\n                                },\n                                {\n                                    type: \"object\",\n                                    properties: {\n                                        mode: {\n                                            enum: [\"strict\", \"minimum\"]\n                                        },\n                                        on: {\n                                            enum: [\"colon\", \"value\"]\n                                        },\n                                        beforeColon: {\n                                            type: \"boolean\"\n                                        },\n                                        afterColon: {\n                                            type: \"boolean\"\n                                        }\n                                    },\n                                    additionalProperties: false\n                                }\n                            ]\n                        },\n                        mode: {\n                            enum: [\"strict\", \"minimum\"]\n                        },\n                        beforeColon: {\n                            type: \"boolean\"\n                        },\n                        afterColon: {\n                            type: \"boolean\"\n                        }\n                    },\n                    additionalProperties: false\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        singleLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        multiLine: {\n                            type: \"object\",\n                            properties: {\n                                align: {\n                                    anyOf: [\n                                        {\n                                            enum: [\"colon\", \"value\"]\n                                        },\n                                        {\n                                            type: \"object\",\n                                            properties: {\n                                                mode: {\n                                                    enum: [\"strict\", \"minimum\"]\n                                                },\n                                                on: {\n                                                    enum: [\"colon\", \"value\"]\n                                                },\n                                                beforeColon: {\n                                                    type: \"boolean\"\n                                                },\n                                                afterColon: {\n                                                    type: \"boolean\"\n                                                }\n                                            },\n                                            additionalProperties: false\n                                        }\n                                    ]\n                                },\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    },\n                    additionalProperties: false\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        singleLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        multiLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        align: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                on: {\n                                    enum: [\"colon\", \"value\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    },\n                    additionalProperties: false\n                }\n            ]\n        }],\n        messages: {\n            extraKey: \"Extra space after {{computed}}key '{{key}}'.\",\n            extraValue: \"Extra space before value for {{computed}}key '{{key}}'.\",\n            missingKey: \"Missing space after {{computed}}key '{{key}}'.\",\n            missingValue: \"Missing space before value for {{computed}}key '{{key}}'.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * OPTIONS\n         * \"key-spacing\": [2, {\n         *     beforeColon: false,\n         *     afterColon: true,\n         *     align: \"colon\" // Optional, or \"value\"\n         * }\n         */\n        const options = context.options[0] || {},\n            ruleOptions = initOptions({}, options),\n            multiLineOptions = ruleOptions.multiLine,\n            singleLineOptions = ruleOptions.singleLine,\n            alignmentOptions = ruleOptions.align || null;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Checks whether a property is a member of the property group it follows.\n         * @param {ASTNode} lastMember The last Property known to be in the group.\n         * @param {ASTNode} candidate The next Property that might be in the group.\n         * @returns {boolean} True if the candidate property is part of the group.\n         */\n        function continuesPropertyGroup(lastMember, candidate) {\n            const groupEndLine = lastMember.loc.start.line,\n                candidateStartLine = candidate.loc.start.line;\n\n            if (candidateStartLine - groupEndLine <= 1) {\n                return true;\n            }\n\n            /*\n             * Check that the first comment is adjacent to the end of the group, the\n             * last comment is adjacent to the candidate property, and that successive\n             * comments are adjacent to each other.\n             */\n            const leadingComments = sourceCode.getCommentsBefore(candidate);\n\n            if (\n                leadingComments.length &&\n                leadingComments[0].loc.start.line - groupEndLine <= 1 &&\n                candidateStartLine - last(leadingComments).loc.end.line <= 1\n            ) {\n                for (let i = 1; i < leadingComments.length; i++) {\n                    if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if the given property is key-value property.\n         * @param {ASTNode} property Property node to check.\n         * @returns {boolean} Whether the property is a key-value property.\n         */\n        function isKeyValueProperty(property) {\n            return !(\n                (property.method ||\n                property.shorthand ||\n                property.kind !== \"init\" || property.type !== \"Property\") // Could be \"ExperimentalSpreadProperty\" or \"SpreadElement\"\n            );\n        }\n\n        /**\n         * Starting from the given a node (a property.key node here) looks forward\n         * until it finds the last token before a colon punctuator and returns it.\n         * @param {ASTNode} node The node to start looking from.\n         * @returns {ASTNode} The last token before a colon punctuator.\n         */\n        function getLastTokenBeforeColon(node) {\n            const colonToken = sourceCode.getTokenAfter(node, astUtils.isColonToken);\n\n            return sourceCode.getTokenBefore(colonToken);\n        }\n\n        /**\n         * Starting from the given a node (a property.key node here) looks forward\n         * until it finds the colon punctuator and returns it.\n         * @param {ASTNode} node The node to start looking from.\n         * @returns {ASTNode} The colon punctuator.\n         */\n        function getNextColon(node) {\n            return sourceCode.getTokenAfter(node, astUtils.isColonToken);\n        }\n\n        /**\n         * Gets an object literal property's key as the identifier name or string value.\n         * @param {ASTNode} property Property node whose key to retrieve.\n         * @returns {string} The property's key.\n         */\n        function getKey(property) {\n            const key = property.key;\n\n            if (property.computed) {\n                return sourceCode.getText().slice(key.range[0], key.range[1]);\n            }\n\n            return property.key.name || property.key.value;\n        }\n\n        /**\n         * Reports an appropriately-formatted error if spacing is incorrect on one\n         * side of the colon.\n         * @param {ASTNode} property Key-value pair in an object literal.\n         * @param {string} side Side being verified - either \"key\" or \"value\".\n         * @param {string} whitespace Actual whitespace string.\n         * @param {int} expected Expected whitespace length.\n         * @param {string} mode Value of the mode as \"strict\" or \"minimum\"\n         * @returns {void}\n         */\n        function report(property, side, whitespace, expected, mode) {\n            const diff = whitespace.length - expected,\n                nextColon = getNextColon(property.key),\n                tokenBeforeColon = sourceCode.getTokenBefore(nextColon, { includeComments: true }),\n                tokenAfterColon = sourceCode.getTokenAfter(nextColon, { includeComments: true }),\n                isKeySide = side === \"key\",\n                locStart = isKeySide ? tokenBeforeColon.loc.start : tokenAfterColon.loc.start,\n                isExtra = diff > 0,\n                diffAbs = Math.abs(diff),\n                spaces = Array(diffAbs + 1).join(\" \");\n\n            if ((\n                diff && mode === \"strict\" ||\n                diff < 0 && mode === \"minimum\" ||\n                diff > 0 && !expected && mode === \"minimum\") &&\n                !(expected && containsLineTerminator(whitespace))\n            ) {\n                let fix;\n\n                if (isExtra) {\n                    let range;\n\n                    // Remove whitespace\n                    if (isKeySide) {\n                        range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];\n                    } else {\n                        range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];\n                    }\n                    fix = function(fixer) {\n                        return fixer.removeRange(range);\n                    };\n                } else {\n\n                    // Add whitespace\n                    if (isKeySide) {\n                        fix = function(fixer) {\n                            return fixer.insertTextAfter(tokenBeforeColon, spaces);\n                        };\n                    } else {\n                        fix = function(fixer) {\n                            return fixer.insertTextBefore(tokenAfterColon, spaces);\n                        };\n                    }\n                }\n\n                let messageId = \"\";\n\n                if (isExtra) {\n                    messageId = side === \"key\" ? \"extraKey\" : \"extraValue\";\n                } else {\n                    messageId = side === \"key\" ? \"missingKey\" : \"missingValue\";\n                }\n\n                context.report({\n                    node: property[side],\n                    loc: locStart,\n                    messageId,\n                    data: {\n                        computed: property.computed ? \"computed \" : \"\",\n                        key: getKey(property)\n                    },\n                    fix\n                });\n            }\n        }\n\n        /**\n         * Gets the number of characters in a key, including quotes around string\n         * keys and braces around computed property keys.\n         * @param {ASTNode} property Property of on object literal.\n         * @returns {int} Width of the key.\n         */\n        function getKeyWidth(property) {\n            const startToken = sourceCode.getFirstToken(property);\n            const endToken = getLastTokenBeforeColon(property.key);\n\n            return endToken.range[1] - startToken.range[0];\n        }\n\n        /**\n         * Gets the whitespace around the colon in an object literal property.\n         * @param {ASTNode} property Property node from an object literal.\n         * @returns {Object} Whitespace before and after the property's colon.\n         */\n        function getPropertyWhitespace(property) {\n            const whitespace = /(\\s*):(\\s*)/u.exec(sourceCode.getText().slice(\n                property.key.range[1], property.value.range[0]\n            ));\n\n            if (whitespace) {\n                return {\n                    beforeColon: whitespace[1],\n                    afterColon: whitespace[2]\n                };\n            }\n            return null;\n        }\n\n        /**\n         * Creates groups of properties.\n         * @param  {ASTNode} node ObjectExpression node being evaluated.\n         * @returns {Array.<ASTNode[]>} Groups of property AST node lists.\n         */\n        function createGroups(node) {\n            if (node.properties.length === 1) {\n                return [node.properties];\n            }\n\n            return node.properties.reduce((groups, property) => {\n                const currentGroup = last(groups),\n                    prev = last(currentGroup);\n\n                if (!prev || continuesPropertyGroup(prev, property)) {\n                    currentGroup.push(property);\n                } else {\n                    groups.push([property]);\n                }\n\n                return groups;\n            }, [\n                []\n            ]);\n        }\n\n        /**\n         * Verifies correct vertical alignment of a group of properties.\n         * @param {ASTNode[]} properties List of Property AST nodes.\n         * @returns {void}\n         */\n        function verifyGroupAlignment(properties) {\n            const length = properties.length,\n                widths = properties.map(getKeyWidth), // Width of keys, including quotes\n                align = alignmentOptions.on; // \"value\" or \"colon\"\n            let targetWidth = Math.max(...widths),\n                beforeColon, afterColon, mode;\n\n            if (alignmentOptions && length > 1) { // When aligning values within a group, use the alignment configuration.\n                beforeColon = alignmentOptions.beforeColon;\n                afterColon = alignmentOptions.afterColon;\n                mode = alignmentOptions.mode;\n            } else {\n                beforeColon = multiLineOptions.beforeColon;\n                afterColon = multiLineOptions.afterColon;\n                mode = alignmentOptions.mode;\n            }\n\n            // Conditionally include one space before or after colon\n            targetWidth += (align === \"colon\" ? beforeColon : afterColon);\n\n            for (let i = 0; i < length; i++) {\n                const property = properties[i];\n                const whitespace = getPropertyWhitespace(property);\n\n                if (whitespace) { // Object literal getters/setters lack a colon\n                    const width = widths[i];\n\n                    if (align === \"value\") {\n                        report(property, \"key\", whitespace.beforeColon, beforeColon, mode);\n                        report(property, \"value\", whitespace.afterColon, targetWidth - width, mode);\n                    } else { // align = \"colon\"\n                        report(property, \"key\", whitespace.beforeColon, targetWidth - width, mode);\n                        report(property, \"value\", whitespace.afterColon, afterColon, mode);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Verifies vertical alignment, taking into account groups of properties.\n         * @param  {ASTNode} node ObjectExpression node being evaluated.\n         * @returns {void}\n         */\n        function verifyAlignment(node) {\n            createGroups(node).forEach(group => {\n                verifyGroupAlignment(group.filter(isKeyValueProperty));\n            });\n        }\n\n        /**\n         * Verifies spacing of property conforms to specified options.\n         * @param  {ASTNode} node Property node being evaluated.\n         * @param {Object} lineOptions Configured singleLine or multiLine options\n         * @returns {void}\n         */\n        function verifySpacing(node, lineOptions) {\n            const actual = getPropertyWhitespace(node);\n\n            if (actual) { // Object literal getters/setters lack colons\n                report(node, \"key\", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);\n                report(node, \"value\", actual.afterColon, lineOptions.afterColon, lineOptions.mode);\n            }\n        }\n\n        /**\n         * Verifies spacing of each property in a list.\n         * @param  {ASTNode[]} properties List of Property AST nodes.\n         * @returns {void}\n         */\n        function verifyListSpacing(properties) {\n            const length = properties.length;\n\n            for (let i = 0; i < length; i++) {\n                verifySpacing(properties[i], singleLineOptions);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        if (alignmentOptions) { // Verify vertical alignment\n\n            return {\n                ObjectExpression(node) {\n                    if (isSingleLine(node)) {\n                        verifyListSpacing(node.properties.filter(isKeyValueProperty));\n                    } else {\n                        verifyAlignment(node);\n                    }\n                }\n            };\n\n        }\n\n        // Obey beforeColon and afterColon in each property as configured\n        return {\n            Property(node) {\n                verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);\n            }\n        };\n\n\n    }\n};\n","/**\n * @fileoverview Rule to enforce spacing before and after keywords.\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\"),\n    keywords = require(\"../util/keywords\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst PREV_TOKEN = /^[)\\]}>]$/u;\nconst NEXT_TOKEN = /^(?:[([{<~!]|\\+\\+?|--?)$/u;\nconst PREV_TOKEN_M = /^[)\\]}>*]$/u;\nconst NEXT_TOKEN_M = /^[{*]$/u;\nconst TEMPLATE_OPEN_PAREN = /\\$\\{$/u;\nconst TEMPLATE_CLOSE_PAREN = /^\\}/u;\nconst CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template)$/u;\nconst KEYS = keywords.concat([\"as\", \"async\", \"await\", \"from\", \"get\", \"let\", \"of\", \"set\", \"yield\"]);\n\n// check duplications.\n(function() {\n    KEYS.sort();\n    for (let i = 1; i < KEYS.length; ++i) {\n        if (KEYS[i] === KEYS[i - 1]) {\n            throw new Error(`Duplication was found in the keyword list: ${KEYS[i]}`);\n        }\n    }\n}());\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given token is a \"Template\" token ends with \"${\".\n *\n * @param {Token} token - A token to check.\n * @returns {boolean} `true` if the token is a \"Template\" token ends with \"${\".\n */\nfunction isOpenParenOfTemplate(token) {\n    return token.type === \"Template\" && TEMPLATE_OPEN_PAREN.test(token.value);\n}\n\n/**\n * Checks whether or not a given token is a \"Template\" token starts with \"}\".\n *\n * @param {Token} token - A token to check.\n * @returns {boolean} `true` if the token is a \"Template\" token starts with \"}\".\n */\nfunction isCloseParenOfTemplate(token) {\n    return token.type === \"Template\" && TEMPLATE_CLOSE_PAREN.test(token.value);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before and after keywords\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/keyword-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: { type: \"boolean\", default: true },\n                    after: { type: \"boolean\", default: true },\n                    overrides: {\n                        type: \"object\",\n                        properties: KEYS.reduce((retv, key) => {\n                            retv[key] = {\n                                type: \"object\",\n                                properties: {\n                                    before: { type: \"boolean\", default: true },\n                                    after: { type: \"boolean\", default: true }\n                                },\n                                additionalProperties: false\n                            };\n                            return retv;\n                        }, {}),\n                        additionalProperties: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            expectedBefore: \"Expected space(s) before \\\"{{value}}\\\".\",\n            expectedAfter: \"Expected space(s) after \\\"{{value}}\\\".\",\n            unexpectedBefore: \"Unexpected space(s) before \\\"{{value}}\\\".\",\n            unexpectedAfter: \"Unexpected space(s) after \\\"{{value}}\\\".\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports a given token if there are not space(s) before the token.\n         *\n         * @param {Token} token - A token to report.\n         * @param {RegExp} pattern - A pattern of the previous token to check.\n         * @returns {void}\n         */\n        function expectSpaceBefore(token, pattern) {\n            const prevToken = sourceCode.getTokenBefore(token);\n\n            if (prevToken &&\n                (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &&\n                !isOpenParenOfTemplate(prevToken) &&\n                astUtils.isTokenOnSameLine(prevToken, token) &&\n                !sourceCode.isSpaceBetweenTokens(prevToken, token)\n            ) {\n                context.report({\n                    loc: token.loc.start,\n                    messageId: \"expectedBefore\",\n                    data: token,\n                    fix(fixer) {\n                        return fixer.insertTextBefore(token, \" \");\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports a given token if there are space(s) before the token.\n         *\n         * @param {Token} token - A token to report.\n         * @param {RegExp} pattern - A pattern of the previous token to check.\n         * @returns {void}\n         */\n        function unexpectSpaceBefore(token, pattern) {\n            const prevToken = sourceCode.getTokenBefore(token);\n\n            if (prevToken &&\n                (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &&\n                !isOpenParenOfTemplate(prevToken) &&\n                astUtils.isTokenOnSameLine(prevToken, token) &&\n                sourceCode.isSpaceBetweenTokens(prevToken, token)\n            ) {\n                context.report({\n                    loc: token.loc.start,\n                    messageId: \"unexpectedBefore\",\n                    data: token,\n                    fix(fixer) {\n                        return fixer.removeRange([prevToken.range[1], token.range[0]]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports a given token if there are not space(s) after the token.\n         *\n         * @param {Token} token - A token to report.\n         * @param {RegExp} pattern - A pattern of the next token to check.\n         * @returns {void}\n         */\n        function expectSpaceAfter(token, pattern) {\n            const nextToken = sourceCode.getTokenAfter(token);\n\n            if (nextToken &&\n                (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&\n                !isCloseParenOfTemplate(nextToken) &&\n                astUtils.isTokenOnSameLine(token, nextToken) &&\n                !sourceCode.isSpaceBetweenTokens(token, nextToken)\n            ) {\n                context.report({\n                    loc: token.loc.start,\n                    messageId: \"expectedAfter\",\n                    data: token,\n                    fix(fixer) {\n                        return fixer.insertTextAfter(token, \" \");\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports a given token if there are space(s) after the token.\n         *\n         * @param {Token} token - A token to report.\n         * @param {RegExp} pattern - A pattern of the next token to check.\n         * @returns {void}\n         */\n        function unexpectSpaceAfter(token, pattern) {\n            const nextToken = sourceCode.getTokenAfter(token);\n\n            if (nextToken &&\n                (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&\n                !isCloseParenOfTemplate(nextToken) &&\n                astUtils.isTokenOnSameLine(token, nextToken) &&\n                sourceCode.isSpaceBetweenTokens(token, nextToken)\n            ) {\n                context.report({\n                    loc: token.loc.start,\n                    messageId: \"unexpectedAfter\",\n                    data: token,\n                    fix(fixer) {\n                        return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Parses the option object and determines check methods for each keyword.\n         *\n         * @param {Object|undefined} options - The option object to parse.\n         * @returns {Object} - Normalized option object.\n         *      Keys are keywords (there are for every keyword).\n         *      Values are instances of `{\"before\": function, \"after\": function}`.\n         */\n        function parseOptions(options = {}) {\n            const before = options.before !== false;\n            const after = options.after !== false;\n            const defaultValue = {\n                before: before ? expectSpaceBefore : unexpectSpaceBefore,\n                after: after ? expectSpaceAfter : unexpectSpaceAfter\n            };\n            const overrides = (options && options.overrides) || {};\n            const retv = Object.create(null);\n\n            for (let i = 0; i < KEYS.length; ++i) {\n                const key = KEYS[i];\n                const override = overrides[key];\n\n                if (override) {\n                    const thisBefore = (\"before\" in override) ? override.before : before;\n                    const thisAfter = (\"after\" in override) ? override.after : after;\n\n                    retv[key] = {\n                        before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,\n                        after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter\n                    };\n                } else {\n                    retv[key] = defaultValue;\n                }\n            }\n\n            return retv;\n        }\n\n        const checkMethodMap = parseOptions(context.options[0]);\n\n        /**\n         * Reports a given token if usage of spacing followed by the token is\n         * invalid.\n         *\n         * @param {Token} token - A token to report.\n         * @param {RegExp|undefined} pattern - Optional. A pattern of the previous\n         *      token to check.\n         * @returns {void}\n         */\n        function checkSpacingBefore(token, pattern) {\n            checkMethodMap[token.value].before(token, pattern || PREV_TOKEN);\n        }\n\n        /**\n         * Reports a given token if usage of spacing preceded by the token is\n         * invalid.\n         *\n         * @param {Token} token - A token to report.\n         * @param {RegExp|undefined} pattern - Optional. A pattern of the next\n         *      token to check.\n         * @returns {void}\n         */\n        function checkSpacingAfter(token, pattern) {\n            checkMethodMap[token.value].after(token, pattern || NEXT_TOKEN);\n        }\n\n        /**\n         * Reports a given token if usage of spacing around the token is invalid.\n         *\n         * @param {Token} token - A token to report.\n         * @returns {void}\n         */\n        function checkSpacingAround(token) {\n            checkSpacingBefore(token);\n            checkSpacingAfter(token);\n        }\n\n        /**\n         * Reports the first token of a given node if the first token is a keyword\n         * and usage of spacing around the token is invalid.\n         *\n         * @param {ASTNode|null} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingAroundFirstToken(node) {\n            const firstToken = node && sourceCode.getFirstToken(node);\n\n            if (firstToken && firstToken.type === \"Keyword\") {\n                checkSpacingAround(firstToken);\n            }\n        }\n\n        /**\n         * Reports the first token of a given node if the first token is a keyword\n         * and usage of spacing followed by the token is invalid.\n         *\n         * This is used for unary operators (e.g. `typeof`), `function`, and `super`.\n         * Other rules are handling usage of spacing preceded by those keywords.\n         *\n         * @param {ASTNode|null} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingBeforeFirstToken(node) {\n            const firstToken = node && sourceCode.getFirstToken(node);\n\n            if (firstToken && firstToken.type === \"Keyword\") {\n                checkSpacingBefore(firstToken);\n            }\n        }\n\n        /**\n         * Reports the previous token of a given node if the token is a keyword and\n         * usage of spacing around the token is invalid.\n         *\n         * @param {ASTNode|null} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingAroundTokenBefore(node) {\n            if (node) {\n                const token = sourceCode.getTokenBefore(node, astUtils.isKeywordToken);\n\n                checkSpacingAround(token);\n            }\n        }\n\n        /**\n         * Reports `async` or `function` keywords of a given node if usage of\n         * spacing around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForFunction(node) {\n            const firstToken = node && sourceCode.getFirstToken(node);\n\n            if (firstToken &&\n                ((firstToken.type === \"Keyword\" && firstToken.value === \"function\") ||\n                firstToken.value === \"async\")\n            ) {\n                checkSpacingBefore(firstToken);\n            }\n        }\n\n        /**\n         * Reports `class` and `extends` keywords of a given node if usage of\n         * spacing around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForClass(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.superClass);\n        }\n\n        /**\n         * Reports `if` and `else` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForIfStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.alternate);\n        }\n\n        /**\n         * Reports `try`, `catch`, and `finally` keywords of a given node if usage\n         * of spacing around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForTryStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundFirstToken(node.handler);\n            checkSpacingAroundTokenBefore(node.finalizer);\n        }\n\n        /**\n         * Reports `do` and `while` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForDoWhileStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.test);\n        }\n\n        /**\n         * Reports `for` and `in` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForForInStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.right);\n        }\n\n        /**\n         * Reports `for` and `of` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForForOfStatement(node) {\n            if (node.await) {\n                checkSpacingBefore(sourceCode.getFirstToken(node, 0));\n                checkSpacingAfter(sourceCode.getFirstToken(node, 1));\n            } else {\n                checkSpacingAroundFirstToken(node);\n            }\n            checkSpacingAround(sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken));\n        }\n\n        /**\n         * Reports `import`, `export`, `as`, and `from` keywords of a given node if\n         * usage of spacing around those keywords is invalid.\n         *\n         * This rule handles the `*` token in module declarations.\n         *\n         *     import*as A from \"./a\"; /*error Expected space(s) after \"import\".\n         *                               error Expected space(s) before \"as\".\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForModuleDeclaration(node) {\n            const firstToken = sourceCode.getFirstToken(node);\n\n            checkSpacingBefore(firstToken, PREV_TOKEN_M);\n            checkSpacingAfter(firstToken, NEXT_TOKEN_M);\n\n            if (node.type === \"ExportDefaultDeclaration\") {\n                checkSpacingAround(sourceCode.getTokenAfter(firstToken));\n            }\n\n            if (node.source) {\n                const fromToken = sourceCode.getTokenBefore(node.source);\n\n                checkSpacingBefore(fromToken, PREV_TOKEN_M);\n                checkSpacingAfter(fromToken, NEXT_TOKEN_M);\n            }\n        }\n\n        /**\n         * Reports `as` keyword of a given node if usage of spacing around this\n         * keyword is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForImportNamespaceSpecifier(node) {\n            const asToken = sourceCode.getFirstToken(node, 1);\n\n            checkSpacingBefore(asToken, PREV_TOKEN_M);\n        }\n\n        /**\n         * Reports `static`, `get`, and `set` keywords of a given node if usage of\n         * spacing around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForProperty(node) {\n            if (node.static) {\n                checkSpacingAroundFirstToken(node);\n            }\n            if (node.kind === \"get\" ||\n                node.kind === \"set\" ||\n                (\n                    (node.method || node.type === \"MethodDefinition\") &&\n                    node.value.async\n                )\n            ) {\n                const token = sourceCode.getTokenBefore(\n                    node.key,\n                    tok => {\n                        switch (tok.value) {\n                            case \"get\":\n                            case \"set\":\n                            case \"async\":\n                                return true;\n                            default:\n                                return false;\n                        }\n                    }\n                );\n\n                if (!token) {\n                    throw new Error(\"Failed to find token get, set, or async beside method name\");\n                }\n\n\n                checkSpacingAround(token);\n            }\n        }\n\n        /**\n         * Reports `await` keyword of a given node if usage of spacing before\n         * this keyword is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForAwaitExpression(node) {\n            checkSpacingBefore(sourceCode.getFirstToken(node));\n        }\n\n        return {\n\n            // Statements\n            DebuggerStatement: checkSpacingAroundFirstToken,\n            WithStatement: checkSpacingAroundFirstToken,\n\n            // Statements - Control flow\n            BreakStatement: checkSpacingAroundFirstToken,\n            ContinueStatement: checkSpacingAroundFirstToken,\n            ReturnStatement: checkSpacingAroundFirstToken,\n            ThrowStatement: checkSpacingAroundFirstToken,\n            TryStatement: checkSpacingForTryStatement,\n\n            // Statements - Choice\n            IfStatement: checkSpacingForIfStatement,\n            SwitchStatement: checkSpacingAroundFirstToken,\n            SwitchCase: checkSpacingAroundFirstToken,\n\n            // Statements - Loops\n            DoWhileStatement: checkSpacingForDoWhileStatement,\n            ForInStatement: checkSpacingForForInStatement,\n            ForOfStatement: checkSpacingForForOfStatement,\n            ForStatement: checkSpacingAroundFirstToken,\n            WhileStatement: checkSpacingAroundFirstToken,\n\n            // Statements - Declarations\n            ClassDeclaration: checkSpacingForClass,\n            ExportNamedDeclaration: checkSpacingForModuleDeclaration,\n            ExportDefaultDeclaration: checkSpacingForModuleDeclaration,\n            ExportAllDeclaration: checkSpacingForModuleDeclaration,\n            FunctionDeclaration: checkSpacingForFunction,\n            ImportDeclaration: checkSpacingForModuleDeclaration,\n            VariableDeclaration: checkSpacingAroundFirstToken,\n\n            // Expressions\n            ArrowFunctionExpression: checkSpacingForFunction,\n            AwaitExpression: checkSpacingForAwaitExpression,\n            ClassExpression: checkSpacingForClass,\n            FunctionExpression: checkSpacingForFunction,\n            NewExpression: checkSpacingBeforeFirstToken,\n            Super: checkSpacingBeforeFirstToken,\n            ThisExpression: checkSpacingBeforeFirstToken,\n            UnaryExpression: checkSpacingBeforeFirstToken,\n            YieldExpression: checkSpacingBeforeFirstToken,\n\n            // Others\n            ImportNamespaceSpecifier: checkSpacingForImportNamespaceSpecifier,\n            MethodDefinition: checkSpacingForProperty,\n            Property: checkSpacingForProperty\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce the position of line comments\n * @author Alberto Rodríguez\n */\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce position of line comments\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/line-comment-position\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"above\", \"beside\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            position: {\n                                enum: [\"above\", \"beside\"],\n                                default: \"above\"\n                            },\n                            ignorePattern: {\n                                type: \"string\"\n                            },\n                            applyDefaultPatterns: {\n                                type: \"boolean\"\n                            },\n                            applyDefaultIgnorePatterns: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n        messages: {\n            above: \"Expected comment to be above code.\",\n            beside: \"Expected comment to be beside code.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0];\n\n        let above,\n            ignorePattern,\n            applyDefaultIgnorePatterns = true;\n\n        if (!options || typeof options === \"string\") {\n            above = !options || options === \"above\";\n\n        } else {\n            above = !options.position || options.position === \"above\";\n            ignorePattern = options.ignorePattern;\n\n            if (Object.prototype.hasOwnProperty.call(options, \"applyDefaultIgnorePatterns\")) {\n                applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns;\n            } else {\n                applyDefaultIgnorePatterns = options.applyDefaultPatterns !== false;\n            }\n        }\n\n        const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;\n        const fallThroughRegExp = /^\\s*falls?\\s?through/u;\n        const customIgnoreRegExp = new RegExp(ignorePattern); // eslint-disable-line require-unicode-regexp\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments.filter(token => token.type === \"Line\").forEach(node => {\n                    if (applyDefaultIgnorePatterns && (defaultIgnoreRegExp.test(node.value) || fallThroughRegExp.test(node.value))) {\n                        return;\n                    }\n\n                    if (ignorePattern && customIgnoreRegExp.test(node.value)) {\n                        return;\n                    }\n\n                    const previous = sourceCode.getTokenBefore(node, { includeComments: true });\n                    const isOnSameLine = previous && previous.loc.end.line === node.loc.start.line;\n\n                    if (above) {\n                        if (isOnSameLine) {\n                            context.report({\n                                node,\n                                messageId: \"above\"\n                            });\n                        }\n                    } else {\n                        if (!isOnSameLine) {\n                            context.report({\n                                node,\n                                messageId: \"beside\"\n                            });\n                        }\n                    }\n                });\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce a single linebreak style.\n * @author Erik Mueller\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent linebreak style\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/linebreak-style\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"unix\", \"windows\"]\n            }\n        ],\n        messages: {\n            expectedLF: \"Expected linebreaks to be 'LF' but found 'CRLF'.\",\n            expectedCRLF: \"Expected linebreaks to be 'CRLF' but found 'LF'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Builds a fix function that replaces text at the specified range in the source text.\n         * @param {int[]} range The range to replace\n         * @param {string} text The text to insert.\n         * @returns {Function} Fixer function\n         * @private\n         */\n        function createFix(range, text) {\n            return function(fixer) {\n                return fixer.replaceTextRange(range, text);\n            };\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: function checkForlinebreakStyle(node) {\n                const linebreakStyle = context.options[0] || \"unix\",\n                    expectedLF = linebreakStyle === \"unix\",\n                    expectedLFChars = expectedLF ? \"\\n\" : \"\\r\\n\",\n                    source = sourceCode.getText(),\n                    pattern = astUtils.createGlobalLinebreakMatcher();\n                let match;\n\n                let i = 0;\n\n                while ((match = pattern.exec(source)) !== null) {\n                    i++;\n                    if (match[0] === expectedLFChars) {\n                        continue;\n                    }\n\n                    const index = match.index;\n                    const range = [index, index + match[0].length];\n\n                    context.report({\n                        node,\n                        loc: {\n                            line: i,\n                            column: sourceCode.lines[i - 1].length\n                        },\n                        messageId: expectedLF ? \"expectedLF\" : \"expectedCRLF\",\n                        fix: createFix(range, expectedLFChars)\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Enforces empty lines around comments.\n * @author Jamund Ferguson\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\"),\n    astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Return an array with with any line numbers that are empty.\n * @param {Array} lines An array of each line of the file.\n * @returns {Array} An array of line numbers.\n */\nfunction getEmptyLineNums(lines) {\n    const emptyLines = lines.map((line, i) => ({\n        code: line.trim(),\n        num: i + 1\n    })).filter(line => !line.code).map(line => line.num);\n\n    return emptyLines;\n}\n\n/**\n * Return an array with with any line numbers that contain comments.\n * @param {Array} comments An array of comment tokens.\n * @returns {Array} An array of line numbers.\n */\nfunction getCommentLineNums(comments) {\n    const lines = [];\n\n    comments.forEach(token => {\n        const start = token.loc.start.line;\n        const end = token.loc.end.line;\n\n        lines.push(start, end);\n    });\n    return lines;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require empty lines around comments\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/lines-around-comment\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    beforeBlockComment: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    afterBlockComment: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    beforeLineComment: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    afterLineComment: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowBlockStart: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowBlockEnd: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowClassStart: {\n                        type: \"boolean\"\n                    },\n                    allowClassEnd: {\n                        type: \"boolean\"\n                    },\n                    allowObjectStart: {\n                        type: \"boolean\"\n                    },\n                    allowObjectEnd: {\n                        type: \"boolean\"\n                    },\n                    allowArrayStart: {\n                        type: \"boolean\"\n                    },\n                    allowArrayEnd: {\n                        type: \"boolean\"\n                    },\n                    ignorePattern: {\n                        type: \"string\"\n                    },\n                    applyDefaultIgnorePatterns: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            after: \"Expected line after comment.\",\n            before: \"Expected line before comment.\"\n        }\n    },\n\n    create(context) {\n\n        const options = Object.assign({}, context.options[0]);\n        const ignorePattern = options.ignorePattern;\n        const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;\n        const customIgnoreRegExp = new RegExp(ignorePattern); // eslint-disable-line require-unicode-regexp\n        const applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;\n\n        options.beforeBlockComment = typeof options.beforeBlockComment !== \"undefined\" ? options.beforeBlockComment : true;\n\n        const sourceCode = context.getSourceCode();\n\n        const lines = sourceCode.lines,\n            numLines = lines.length + 1,\n            comments = sourceCode.getAllComments(),\n            commentLines = getCommentLineNums(comments),\n            emptyLines = getEmptyLineNums(lines),\n            commentAndEmptyLines = commentLines.concat(emptyLines);\n\n        /**\n         * Returns whether or not comments are on lines starting with or ending with code\n         * @param {token} token The comment token to check.\n         * @returns {boolean} True if the comment is not alone.\n         */\n        function codeAroundComment(token) {\n            let currentToken = token;\n\n            do {\n                currentToken = sourceCode.getTokenBefore(currentToken, { includeComments: true });\n            } while (currentToken && astUtils.isCommentToken(currentToken));\n\n            if (currentToken && astUtils.isTokenOnSameLine(currentToken, token)) {\n                return true;\n            }\n\n            currentToken = token;\n            do {\n                currentToken = sourceCode.getTokenAfter(currentToken, { includeComments: true });\n            } while (currentToken && astUtils.isCommentToken(currentToken));\n\n            if (currentToken && astUtils.isTokenOnSameLine(token, currentToken)) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Returns whether or not comments are inside a node type or not.\n         * @param {ASTNode} parent The Comment parent node.\n         * @param {string} nodeType The parent type to check against.\n         * @returns {boolean} True if the comment is inside nodeType.\n         */\n        function isParentNodeType(parent, nodeType) {\n            return parent.type === nodeType ||\n                (parent.body && parent.body.type === nodeType) ||\n                (parent.consequent && parent.consequent.type === nodeType);\n        }\n\n        /**\n         * Returns the parent node that contains the given token.\n         * @param {token} token The token to check.\n         * @returns {ASTNode} The parent node that contains the given token.\n         */\n        function getParentNodeOfToken(token) {\n            return sourceCode.getNodeByRangeIndex(token.range[0]);\n        }\n\n        /**\n         * Returns whether or not comments are at the parent start or not.\n         * @param {token} token The Comment token.\n         * @param {string} nodeType The parent type to check against.\n         * @returns {boolean} True if the comment is at parent start.\n         */\n        function isCommentAtParentStart(token, nodeType) {\n            const parent = getParentNodeOfToken(token);\n\n            return parent && isParentNodeType(parent, nodeType) &&\n                    token.loc.start.line - parent.loc.start.line === 1;\n        }\n\n        /**\n         * Returns whether or not comments are at the parent end or not.\n         * @param {token} token The Comment token.\n         * @param {string} nodeType The parent type to check against.\n         * @returns {boolean} True if the comment is at parent end.\n         */\n        function isCommentAtParentEnd(token, nodeType) {\n            const parent = getParentNodeOfToken(token);\n\n            return parent && isParentNodeType(parent, nodeType) &&\n                    parent.loc.end.line - token.loc.end.line === 1;\n        }\n\n        /**\n         * Returns whether or not comments are at the block start or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at block start.\n         */\n        function isCommentAtBlockStart(token) {\n            return isCommentAtParentStart(token, \"ClassBody\") || isCommentAtParentStart(token, \"BlockStatement\") || isCommentAtParentStart(token, \"SwitchCase\");\n        }\n\n        /**\n         * Returns whether or not comments are at the block end or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at block end.\n         */\n        function isCommentAtBlockEnd(token) {\n            return isCommentAtParentEnd(token, \"ClassBody\") || isCommentAtParentEnd(token, \"BlockStatement\") || isCommentAtParentEnd(token, \"SwitchCase\") || isCommentAtParentEnd(token, \"SwitchStatement\");\n        }\n\n        /**\n         * Returns whether or not comments are at the class start or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at class start.\n         */\n        function isCommentAtClassStart(token) {\n            return isCommentAtParentStart(token, \"ClassBody\");\n        }\n\n        /**\n         * Returns whether or not comments are at the class end or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at class end.\n         */\n        function isCommentAtClassEnd(token) {\n            return isCommentAtParentEnd(token, \"ClassBody\");\n        }\n\n        /**\n         * Returns whether or not comments are at the object start or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at object start.\n         */\n        function isCommentAtObjectStart(token) {\n            return isCommentAtParentStart(token, \"ObjectExpression\") || isCommentAtParentStart(token, \"ObjectPattern\");\n        }\n\n        /**\n         * Returns whether or not comments are at the object end or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at object end.\n         */\n        function isCommentAtObjectEnd(token) {\n            return isCommentAtParentEnd(token, \"ObjectExpression\") || isCommentAtParentEnd(token, \"ObjectPattern\");\n        }\n\n        /**\n         * Returns whether or not comments are at the array start or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at array start.\n         */\n        function isCommentAtArrayStart(token) {\n            return isCommentAtParentStart(token, \"ArrayExpression\") || isCommentAtParentStart(token, \"ArrayPattern\");\n        }\n\n        /**\n         * Returns whether or not comments are at the array end or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at array end.\n         */\n        function isCommentAtArrayEnd(token) {\n            return isCommentAtParentEnd(token, \"ArrayExpression\") || isCommentAtParentEnd(token, \"ArrayPattern\");\n        }\n\n        /**\n         * Checks if a comment token has lines around it (ignores inline comments)\n         * @param {token} token The Comment token.\n         * @param {Object} opts Options to determine the newline.\n         * @param {boolean} opts.after Should have a newline after this line.\n         * @param {boolean} opts.before Should have a newline before this line.\n         * @returns {void}\n         */\n        function checkForEmptyLine(token, opts) {\n            if (applyDefaultIgnorePatterns && defaultIgnoreRegExp.test(token.value)) {\n                return;\n            }\n\n            if (ignorePattern && customIgnoreRegExp.test(token.value)) {\n                return;\n            }\n\n            let after = opts.after,\n                before = opts.before;\n\n            const prevLineNum = token.loc.start.line - 1,\n                nextLineNum = token.loc.end.line + 1,\n                commentIsNotAlone = codeAroundComment(token);\n\n            const blockStartAllowed = options.allowBlockStart &&\n                    isCommentAtBlockStart(token) &&\n                    !(options.allowClassStart === false &&\n                    isCommentAtClassStart(token)),\n                blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(token) && !(options.allowClassEnd === false && isCommentAtClassEnd(token)),\n                classStartAllowed = options.allowClassStart && isCommentAtClassStart(token),\n                classEndAllowed = options.allowClassEnd && isCommentAtClassEnd(token),\n                objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(token),\n                objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(token),\n                arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(token),\n                arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(token);\n\n            const exceptionStartAllowed = blockStartAllowed || classStartAllowed || objectStartAllowed || arrayStartAllowed;\n            const exceptionEndAllowed = blockEndAllowed || classEndAllowed || objectEndAllowed || arrayEndAllowed;\n\n            // ignore top of the file and bottom of the file\n            if (prevLineNum < 1) {\n                before = false;\n            }\n            if (nextLineNum >= numLines) {\n                after = false;\n            }\n\n            // we ignore all inline comments\n            if (commentIsNotAlone) {\n                return;\n            }\n\n            const previousTokenOrComment = sourceCode.getTokenBefore(token, { includeComments: true });\n            const nextTokenOrComment = sourceCode.getTokenAfter(token, { includeComments: true });\n\n            // check for newline before\n            if (!exceptionStartAllowed && before && !lodash.includes(commentAndEmptyLines, prevLineNum) &&\n                    !(astUtils.isCommentToken(previousTokenOrComment) && astUtils.isTokenOnSameLine(previousTokenOrComment, token))) {\n                const lineStart = token.range[0] - token.loc.start.column;\n                const range = [lineStart, lineStart];\n\n                context.report({\n                    node: token,\n                    messageId: \"before\",\n                    fix(fixer) {\n                        return fixer.insertTextBeforeRange(range, \"\\n\");\n                    }\n                });\n            }\n\n            // check for newline after\n            if (!exceptionEndAllowed && after && !lodash.includes(commentAndEmptyLines, nextLineNum) &&\n                    !(astUtils.isCommentToken(nextTokenOrComment) && astUtils.isTokenOnSameLine(token, nextTokenOrComment))) {\n                context.report({\n                    node: token,\n                    messageId: \"after\",\n                    fix(fixer) {\n                        return fixer.insertTextAfter(token, \"\\n\");\n                    }\n                });\n            }\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program() {\n                comments.forEach(token => {\n                    if (token.type === \"Line\") {\n                        if (options.beforeLineComment || options.afterLineComment) {\n                            checkForEmptyLine(token, {\n                                after: options.afterLineComment,\n                                before: options.beforeLineComment\n                            });\n                        }\n                    } else if (token.type === \"Block\") {\n                        if (options.beforeBlockComment || options.afterBlockComment) {\n                            checkForEmptyLine(token, {\n                                after: options.afterBlockComment,\n                                before: options.beforeBlockComment\n                            });\n                        }\n                    }\n                });\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Require or disallow newlines around directives.\n * @author Kai Cataldo\n * @deprecated\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow newlines around directives\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/lines-around-directive\"\n        },\n\n        schema: [{\n            oneOf: [\n                {\n                    enum: [\"always\", \"never\"]\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        before: {\n                            enum: [\"always\", \"never\"]\n                        },\n                        after: {\n                            enum: [\"always\", \"never\"]\n                        }\n                    },\n                    additionalProperties: false,\n                    minProperties: 2\n                }\n            ]\n        }],\n\n        fixable: \"whitespace\",\n        messages: {\n            expected: \"Expected newline {{location}} \\\"{{value}}\\\" directive.\",\n            unexpected: \"Unexpected newline {{location}} \\\"{{value}}\\\" directive.\"\n        },\n        deprecated: true,\n        replacedBy: [\"padding-line-between-statements\"]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const config = context.options[0] || \"always\";\n        const expectLineBefore = typeof config === \"string\" ? config : config.before;\n        const expectLineAfter = typeof config === \"string\" ? config : config.after;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Check if node is preceded by a blank newline.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} Whether or not the passed in node is preceded by a blank newline.\n         */\n        function hasNewlineBefore(node) {\n            const tokenBefore = sourceCode.getTokenBefore(node, { includeComments: true });\n            const tokenLineBefore = tokenBefore ? tokenBefore.loc.end.line : 0;\n\n            return node.loc.start.line - tokenLineBefore >= 2;\n        }\n\n        /**\n         * Gets the last token of a node that is on the same line as the rest of the node.\n         * This will usually be the last token of the node, but it will be the second-to-last token if the node has a trailing\n         * semicolon on a different line.\n         * @param {ASTNode} node A directive node\n         * @returns {Token} The last token of the node on the line\n         */\n        function getLastTokenOnLine(node) {\n            const lastToken = sourceCode.getLastToken(node);\n            const secondToLastToken = sourceCode.getTokenBefore(lastToken);\n\n            return astUtils.isSemicolonToken(lastToken) && lastToken.loc.start.line > secondToLastToken.loc.end.line\n                ? secondToLastToken\n                : lastToken;\n        }\n\n        /**\n         * Check if node is followed by a blank newline.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} Whether or not the passed in node is followed by a blank newline.\n         */\n        function hasNewlineAfter(node) {\n            const lastToken = getLastTokenOnLine(node);\n            const tokenAfter = sourceCode.getTokenAfter(lastToken, { includeComments: true });\n\n            return tokenAfter.loc.start.line - lastToken.loc.end.line >= 2;\n        }\n\n        /**\n         * Report errors for newlines around directives.\n         * @param {ASTNode} node Node to check.\n         * @param {string} location Whether the error was found before or after the directive.\n         * @param {boolean} expected Whether or not a newline was expected or unexpected.\n         * @returns {void}\n         */\n        function reportError(node, location, expected) {\n            context.report({\n                node,\n                messageId: expected ? \"expected\" : \"unexpected\",\n                data: {\n                    value: node.expression.value,\n                    location\n                },\n                fix(fixer) {\n                    const lastToken = getLastTokenOnLine(node);\n\n                    if (expected) {\n                        return location === \"before\" ? fixer.insertTextBefore(node, \"\\n\") : fixer.insertTextAfter(lastToken, \"\\n\");\n                    }\n                    return fixer.removeRange(location === \"before\" ? [node.range[0] - 1, node.range[0]] : [lastToken.range[1], lastToken.range[1] + 1]);\n                }\n            });\n        }\n\n        /**\n         * Check lines around directives in node\n         * @param {ASTNode} node - node to check\n         * @returns {void}\n         */\n        function checkDirectives(node) {\n            const directives = astUtils.getDirectivePrologue(node);\n\n            if (!directives.length) {\n                return;\n            }\n\n            const firstDirective = directives[0];\n            const leadingComments = sourceCode.getCommentsBefore(firstDirective);\n\n            /*\n             * Only check before the first directive if it is preceded by a comment or if it is at the top of\n             * the file and expectLineBefore is set to \"never\". This is to not force a newline at the top of\n             * the file if there are no comments as well as for compatibility with padded-blocks.\n             */\n            if (leadingComments.length) {\n                if (expectLineBefore === \"always\" && !hasNewlineBefore(firstDirective)) {\n                    reportError(firstDirective, \"before\", true);\n                }\n\n                if (expectLineBefore === \"never\" && hasNewlineBefore(firstDirective)) {\n                    reportError(firstDirective, \"before\", false);\n                }\n            } else if (\n                node.type === \"Program\" &&\n                expectLineBefore === \"never\" &&\n                !leadingComments.length &&\n                hasNewlineBefore(firstDirective)\n            ) {\n                reportError(firstDirective, \"before\", false);\n            }\n\n            const lastDirective = directives[directives.length - 1];\n            const statements = node.type === \"Program\" ? node.body : node.body.body;\n\n            /*\n             * Do not check after the last directive if the body only\n             * contains a directive prologue and isn't followed by a comment to ensure\n             * this rule behaves well with padded-blocks.\n             */\n            if (lastDirective === statements[statements.length - 1] && !lastDirective.trailingComments) {\n                return;\n            }\n\n            if (expectLineAfter === \"always\" && !hasNewlineAfter(lastDirective)) {\n                reportError(lastDirective, \"after\", true);\n            }\n\n            if (expectLineAfter === \"never\" && hasNewlineAfter(lastDirective)) {\n                reportError(lastDirective, \"after\", false);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: checkDirectives,\n            FunctionDeclaration: checkDirectives,\n            FunctionExpression: checkDirectives,\n            ArrowFunctionExpression: checkDirectives\n        };\n    }\n};\n","/**\n * @fileoverview Rule to check empty newline between class members\n * @author 薛定谔的猫<hh_2013@foxmail.com>\n */\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow an empty line between class members\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/lines-between-class-members\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptAfterSingleLine: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            never: \"Unexpected blank line between class members.\",\n            always: \"Expected blank line between class members.\"\n        }\n    },\n\n    create(context) {\n\n        const options = [];\n\n        options[0] = context.options[0] || \"always\";\n        options[1] = context.options[1] || { exceptAfterSingleLine: false };\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Checks if there is padding between two tokens\n         * @param {Token} first The first token\n         * @param {Token} second The second token\n         * @returns {boolean} True if there is at least a line between the tokens\n         */\n        function isPaddingBetweenTokens(first, second) {\n            const comments = sourceCode.getCommentsBefore(second);\n            const len = comments.length;\n\n            // If there is no comments\n            if (len === 0) {\n                const linesBetweenFstAndSnd = second.loc.start.line - first.loc.end.line - 1;\n\n                return linesBetweenFstAndSnd >= 1;\n            }\n\n\n            // If there are comments\n            let sumOfCommentLines = 0; // the numbers of lines of comments\n            let prevCommentLineNum = -1; // line number of the end of the previous comment\n\n            for (let i = 0; i < len; i++) {\n                const commentLinesOfThisComment = comments[i].loc.end.line - comments[i].loc.start.line + 1;\n\n                sumOfCommentLines += commentLinesOfThisComment;\n\n                /*\n                 * If this comment and the previous comment are in the same line,\n                 * the count of comment lines is duplicated. So decrement sumOfCommentLines.\n                 */\n                if (prevCommentLineNum === comments[i].loc.start.line) {\n                    sumOfCommentLines -= 1;\n                }\n\n                prevCommentLineNum = comments[i].loc.end.line;\n            }\n\n            /*\n             * If the first block and the first comment are in the same line,\n             * the count of comment lines is duplicated. So decrement sumOfCommentLines.\n             */\n            if (first.loc.end.line === comments[0].loc.start.line) {\n                sumOfCommentLines -= 1;\n            }\n\n            /*\n             * If the last comment and the second block are in the same line,\n             * the count of comment lines is duplicated. So decrement sumOfCommentLines.\n             */\n            if (comments[len - 1].loc.end.line === second.loc.start.line) {\n                sumOfCommentLines -= 1;\n            }\n\n            const linesBetweenFstAndSnd = second.loc.start.line - first.loc.end.line - 1;\n\n            return linesBetweenFstAndSnd - sumOfCommentLines >= 1;\n        }\n\n        return {\n            ClassBody(node) {\n                const body = node.body;\n\n                for (let i = 0; i < body.length - 1; i++) {\n                    const curFirst = sourceCode.getFirstToken(body[i]);\n                    const curLast = sourceCode.getLastToken(body[i]);\n                    const nextFirst = sourceCode.getFirstToken(body[i + 1]);\n                    const isPadded = isPaddingBetweenTokens(curLast, nextFirst);\n                    const isMulti = !astUtils.isTokenOnSameLine(curFirst, curLast);\n                    const skip = !isMulti && options[1].exceptAfterSingleLine;\n\n\n                    if ((options[0] === \"always\" && !skip && !isPadded) ||\n                        (options[0] === \"never\" && isPadded)) {\n                        context.report({\n                            node: body[i + 1],\n                            messageId: isPadded ? \"never\" : \"always\",\n                            fix(fixer) {\n                                return isPadded\n                                    ? fixer.replaceTextRange([curLast.range[1], nextFirst.range[0]], \"\\n\")\n                                    : fixer.insertTextAfter(curLast, \"\\n\");\n                            }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Enforce a maximum number of classes per file\n * @author James Garbutt <https://github.com/43081j>\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce a maximum number of classes per file\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/max-classes-per-file\"\n        },\n\n        schema: [\n            {\n                type: \"integer\",\n                minimum: 1\n            }\n        ],\n\n        messages: {\n            maximumExceeded: \"Number of classes per file must not exceed {{ max }}.\"\n        }\n    },\n    create(context) {\n\n        const maxClasses = context.options[0] || 1;\n\n        let classCount = 0;\n\n        return {\n            Program() {\n                classCount = 0;\n            },\n            \"Program:exit\"(node) {\n                if (classCount > maxClasses) {\n                    context.report({\n                        node,\n                        messageId: \"maximumExceeded\",\n                        data: {\n                            max: maxClasses\n                        }\n                    });\n                }\n            },\n            \"ClassDeclaration, ClassExpression\"() {\n                classCount++;\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A rule to set the maximum depth block can be nested in a function.\n * @author Ian Christian Myers\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce a maximum depth that blocks can be nested\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/max-depth\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            maximum: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n        messages: {\n            tooDeeply: \"Blocks are nested too deeply ({{depth}}).\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const functionStack = [],\n            option = context.options[0];\n        let maxDepth = 4;\n\n        if (\n            typeof option === \"object\" &&\n            (Object.prototype.hasOwnProperty.call(option, \"maximum\") || Object.prototype.hasOwnProperty.call(option, \"max\"))\n        ) {\n            maxDepth = option.maximum || option.max;\n        }\n        if (typeof option === \"number\") {\n            maxDepth = option;\n        }\n\n        /**\n         * When parsing a new function, store it in our function stack\n         * @returns {void}\n         * @private\n         */\n        function startFunction() {\n            functionStack.push(0);\n        }\n\n        /**\n         * When parsing is done then pop out the reference\n         * @returns {void}\n         * @private\n         */\n        function endFunction() {\n            functionStack.pop();\n        }\n\n        /**\n         * Save the block and Evaluate the node\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function pushBlock(node) {\n            const len = ++functionStack[functionStack.length - 1];\n\n            if (len > maxDepth) {\n                context.report({ node, messageId: \"tooDeeply\", data: { depth: len } });\n            }\n        }\n\n        /**\n         * Pop the saved block\n         * @returns {void}\n         * @private\n         */\n        function popBlock() {\n            functionStack[functionStack.length - 1]--;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: startFunction,\n            FunctionDeclaration: startFunction,\n            FunctionExpression: startFunction,\n            ArrowFunctionExpression: startFunction,\n\n            IfStatement(node) {\n                if (node.parent.type !== \"IfStatement\") {\n                    pushBlock(node);\n                }\n            },\n            SwitchStatement: pushBlock,\n            TryStatement: pushBlock,\n            DoWhileStatement: pushBlock,\n            WhileStatement: pushBlock,\n            WithStatement: pushBlock,\n            ForStatement: pushBlock,\n            ForInStatement: pushBlock,\n            ForOfStatement: pushBlock,\n\n            \"IfStatement:exit\": popBlock,\n            \"SwitchStatement:exit\": popBlock,\n            \"TryStatement:exit\": popBlock,\n            \"DoWhileStatement:exit\": popBlock,\n            \"WhileStatement:exit\": popBlock,\n            \"WithStatement:exit\": popBlock,\n            \"ForStatement:exit\": popBlock,\n            \"ForInStatement:exit\": popBlock,\n            \"ForOfStatement:exit\": popBlock,\n\n            \"FunctionDeclaration:exit\": endFunction,\n            \"FunctionExpression:exit\": endFunction,\n            \"ArrowFunctionExpression:exit\": endFunction,\n            \"Program:exit\": endFunction\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to check for max length on a line.\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst OPTIONS_SCHEMA = {\n    type: \"object\",\n    properties: {\n        code: {\n            type: \"integer\",\n            minimum: 0,\n            default: 80\n        },\n        comments: {\n            type: \"integer\",\n            minimum: 0\n        },\n        tabWidth: {\n            type: \"integer\",\n            minimum: 0,\n            default: 4\n        },\n        ignorePattern: {\n            type: \"string\"\n        },\n        ignoreComments: {\n            type: \"boolean\",\n            default: false\n        },\n        ignoreStrings: {\n            type: \"boolean\",\n            default: false\n        },\n        ignoreUrls: {\n            type: \"boolean\",\n            default: false\n        },\n        ignoreTemplateLiterals: {\n            type: \"boolean\",\n            default: false\n        },\n        ignoreRegExpLiterals: {\n            type: \"boolean\",\n            default: false\n        },\n        ignoreTrailingComments: {\n            type: \"boolean\",\n            default: false\n        }\n    },\n    additionalProperties: false\n};\n\nconst OPTIONS_OR_INTEGER_SCHEMA = {\n    anyOf: [\n        OPTIONS_SCHEMA,\n        {\n            type: \"integer\",\n            minimum: 0\n        }\n    ]\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce a maximum line length\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/max-len\"\n        },\n\n        schema: [\n            OPTIONS_OR_INTEGER_SCHEMA,\n            OPTIONS_OR_INTEGER_SCHEMA,\n            OPTIONS_SCHEMA\n        ],\n        messages: {\n            max: \"Line {{lineNumber}} exceeds the maximum line length of {{maxLength}}.\",\n            maxComment: \"Line {{lineNumber}} exceeds the maximum comment line length of {{maxCommentLength}}.\"\n        }\n    },\n\n    create(context) {\n\n        /*\n         * Inspired by http://tools.ietf.org/html/rfc3986#appendix-B, however:\n         * - They're matching an entire string that we know is a URI\n         * - We're matching part of a string where we think there *might* be a URL\n         * - We're only concerned about URLs, as picking out any URI would cause\n         *   too many false positives\n         * - We don't care about matching the entire URL, any small segment is fine\n         */\n        const URL_REGEXP = /[^:/?#]:\\/\\/[^?#]/u;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Computes the length of a line that may contain tabs. The width of each\n         * tab will be the number of spaces to the next tab stop.\n         * @param {string} line The line.\n         * @param {int} tabWidth The width of each tab stop in spaces.\n         * @returns {int} The computed line length.\n         * @private\n         */\n        function computeLineLength(line, tabWidth) {\n            let extraCharacterCount = 0;\n\n            line.replace(/\\t/gu, (match, offset) => {\n                const totalOffset = offset + extraCharacterCount,\n                    previousTabStopOffset = tabWidth ? totalOffset % tabWidth : 0,\n                    spaceCount = tabWidth - previousTabStopOffset;\n\n                extraCharacterCount += spaceCount - 1; // -1 for the replaced tab\n            });\n            return Array.from(line).length + extraCharacterCount;\n        }\n\n        // The options object must be the last option specified…\n        const options = Object.assign({}, context.options[context.options.length - 1]);\n\n        // …but max code length…\n        if (typeof context.options[0] === \"number\") {\n            options.code = context.options[0];\n        }\n\n        // …and tabWidth can be optionally specified directly as integers.\n        if (typeof context.options[1] === \"number\") {\n            options.tabWidth = context.options[1];\n        }\n\n        const maxLength = options.code || 80,\n            tabWidth = options.tabWidth || 4,\n            ignoreComments = options.ignoreComments || false,\n            ignoreStrings = options.ignoreStrings || false,\n            ignoreTemplateLiterals = options.ignoreTemplateLiterals || false,\n            ignoreRegExpLiterals = options.ignoreRegExpLiterals || false,\n            ignoreTrailingComments = options.ignoreTrailingComments || options.ignoreComments || false,\n            ignoreUrls = options.ignoreUrls || false,\n            maxCommentLength = options.comments;\n        let ignorePattern = options.ignorePattern || null;\n\n        if (ignorePattern) {\n            ignorePattern = new RegExp(ignorePattern); // eslint-disable-line require-unicode-regexp\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Tells if a given comment is trailing: it starts on the current line and\n         * extends to or past the end of the current line.\n         * @param {string} line The source line we want to check for a trailing comment on\n         * @param {number} lineNumber The one-indexed line number for line\n         * @param {ASTNode} comment The comment to inspect\n         * @returns {boolean} If the comment is trailing on the given line\n         */\n        function isTrailingComment(line, lineNumber, comment) {\n            return comment &&\n                (comment.loc.start.line === lineNumber && lineNumber <= comment.loc.end.line) &&\n                (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);\n        }\n\n        /**\n         * Tells if a comment encompasses the entire line.\n         * @param {string} line The source line with a trailing comment\n         * @param {number} lineNumber The one-indexed line number this is on\n         * @param {ASTNode} comment The comment to remove\n         * @returns {boolean} If the comment covers the entire line\n         */\n        function isFullLineComment(line, lineNumber, comment) {\n            const start = comment.loc.start,\n                end = comment.loc.end,\n                isFirstTokenOnLine = !line.slice(0, comment.loc.start.column).trim();\n\n            return comment &&\n                (start.line < lineNumber || (start.line === lineNumber && isFirstTokenOnLine)) &&\n                (end.line > lineNumber || (end.line === lineNumber && end.column === line.length));\n        }\n\n        /**\n         * Gets the line after the comment and any remaining trailing whitespace is\n         * stripped.\n         * @param {string} line The source line with a trailing comment\n         * @param {ASTNode} comment The comment to remove\n         * @returns {string} Line without comment and trailing whitepace\n         */\n        function stripTrailingComment(line, comment) {\n\n            // loc.column is zero-indexed\n            return line.slice(0, comment.loc.start.column).replace(/\\s+$/u, \"\");\n        }\n\n        /**\n         * Ensure that an array exists at [key] on `object`, and add `value` to it.\n         *\n         * @param {Object} object the object to mutate\n         * @param {string} key the object's key\n         * @param {*} value the value to add\n         * @returns {void}\n         * @private\n         */\n        function ensureArrayAndPush(object, key, value) {\n            if (!Array.isArray(object[key])) {\n                object[key] = [];\n            }\n            object[key].push(value);\n        }\n\n        /**\n         * Retrieves an array containing all strings (\" or ') in the source code.\n         *\n         * @returns {ASTNode[]} An array of string nodes.\n         */\n        function getAllStrings() {\n            return sourceCode.ast.tokens.filter(token => (token.type === \"String\" ||\n                (token.type === \"JSXText\" && sourceCode.getNodeByRangeIndex(token.range[0] - 1).type === \"JSXAttribute\")));\n        }\n\n        /**\n         * Retrieves an array containing all template literals in the source code.\n         *\n         * @returns {ASTNode[]} An array of template literal nodes.\n         */\n        function getAllTemplateLiterals() {\n            return sourceCode.ast.tokens.filter(token => token.type === \"Template\");\n        }\n\n\n        /**\n         * Retrieves an array containing all RegExp literals in the source code.\n         *\n         * @returns {ASTNode[]} An array of RegExp literal nodes.\n         */\n        function getAllRegExpLiterals() {\n            return sourceCode.ast.tokens.filter(token => token.type === \"RegularExpression\");\n        }\n\n\n        /**\n         * A reducer to group an AST node by line number, both start and end.\n         *\n         * @param {Object} acc the accumulator\n         * @param {ASTNode} node the AST node in question\n         * @returns {Object} the modified accumulator\n         * @private\n         */\n        function groupByLineNumber(acc, node) {\n            for (let i = node.loc.start.line; i <= node.loc.end.line; ++i) {\n                ensureArrayAndPush(acc, i, node);\n            }\n            return acc;\n        }\n\n        /**\n         * Check the program for max length\n         * @param {ASTNode} node Node to examine\n         * @returns {void}\n         * @private\n         */\n        function checkProgramForMaxLength(node) {\n\n            // split (honors line-ending)\n            const lines = sourceCode.lines,\n\n                // list of comments to ignore\n                comments = ignoreComments || maxCommentLength || ignoreTrailingComments ? sourceCode.getAllComments() : [];\n\n            // we iterate over comments in parallel with the lines\n            let commentsIndex = 0;\n\n            const strings = getAllStrings();\n            const stringsByLine = strings.reduce(groupByLineNumber, {});\n\n            const templateLiterals = getAllTemplateLiterals();\n            const templateLiteralsByLine = templateLiterals.reduce(groupByLineNumber, {});\n\n            const regExpLiterals = getAllRegExpLiterals();\n            const regExpLiteralsByLine = regExpLiterals.reduce(groupByLineNumber, {});\n\n            lines.forEach((line, i) => {\n\n                // i is zero-indexed, line numbers are one-indexed\n                const lineNumber = i + 1;\n\n                /*\n                 * if we're checking comment length; we need to know whether this\n                 * line is a comment\n                 */\n                let lineIsComment = false;\n                let textToMeasure;\n\n                /*\n                 * We can short-circuit the comment checks if we're already out of\n                 * comments to check.\n                 */\n                if (commentsIndex < comments.length) {\n                    let comment = null;\n\n                    // iterate over comments until we find one past the current line\n                    do {\n                        comment = comments[++commentsIndex];\n                    } while (comment && comment.loc.start.line <= lineNumber);\n\n                    // and step back by one\n                    comment = comments[--commentsIndex];\n\n                    if (isFullLineComment(line, lineNumber, comment)) {\n                        lineIsComment = true;\n                        textToMeasure = line;\n                    } else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment)) {\n                        textToMeasure = stripTrailingComment(line, comment);\n                    } else {\n                        textToMeasure = line;\n                    }\n                } else {\n                    textToMeasure = line;\n                }\n                if (ignorePattern && ignorePattern.test(textToMeasure) ||\n                    ignoreUrls && URL_REGEXP.test(textToMeasure) ||\n                    ignoreStrings && stringsByLine[lineNumber] ||\n                    ignoreTemplateLiterals && templateLiteralsByLine[lineNumber] ||\n                    ignoreRegExpLiterals && regExpLiteralsByLine[lineNumber]\n                ) {\n\n                    // ignore this line\n                    return;\n                }\n\n                const lineLength = computeLineLength(textToMeasure, tabWidth);\n                const commentLengthApplies = lineIsComment && maxCommentLength;\n\n                if (lineIsComment && ignoreComments) {\n                    return;\n                }\n\n                if (commentLengthApplies) {\n                    if (lineLength > maxCommentLength) {\n                        context.report({\n                            node,\n                            loc: { line: lineNumber, column: 0 },\n                            messageId: \"maxComment\",\n                            data: {\n                                lineNumber: i + 1,\n                                maxCommentLength\n                            }\n                        });\n                    }\n                } else if (lineLength > maxLength) {\n                    context.report({\n                        node,\n                        loc: { line: lineNumber, column: 0 },\n                        messageId: \"max\",\n                        data: {\n                            lineNumber: i + 1,\n                            maxLength\n                        }\n                    });\n                }\n            });\n        }\n\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: checkProgramForMaxLength\n        };\n\n    }\n};\n","/**\n * @fileoverview enforce a maximum file length\n * @author Alberto Rodríguez\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce a maximum number of lines per file\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/max-lines\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            skipComments: {\n                                type: \"boolean\"\n                            },\n                            skipBlankLines: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n        messages: {\n            exceed: \"File must be at most {{max}} lines long. It's {{actual}} lines long.\"\n        }\n    },\n\n    create(context) {\n        const option = context.options[0];\n        let max = 300;\n\n        if (typeof option === \"object\" && Object.prototype.hasOwnProperty.call(option, \"max\")) {\n            max = option.max;\n        } else if (typeof option === \"number\") {\n            max = option;\n        }\n\n        const skipComments = option && option.skipComments;\n        const skipBlankLines = option && option.skipBlankLines;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Returns whether or not a token is a comment node type\n         * @param {Token} token The token to check\n         * @returns {boolean} True if the token is a comment node\n         */\n        function isCommentNodeType(token) {\n            return token && (token.type === \"Block\" || token.type === \"Line\");\n        }\n\n        /**\n         * Returns the line numbers of a comment that don't have any code on the same line\n         * @param {Node} comment The comment node to check\n         * @returns {number[]} The line numbers\n         */\n        function getLinesWithoutCode(comment) {\n            let start = comment.loc.start.line;\n            let end = comment.loc.end.line;\n\n            let token;\n\n            token = comment;\n            do {\n                token = sourceCode.getTokenBefore(token, { includeComments: true });\n            } while (isCommentNodeType(token));\n\n            if (token && astUtils.isTokenOnSameLine(token, comment)) {\n                start += 1;\n            }\n\n            token = comment;\n            do {\n                token = sourceCode.getTokenAfter(token, { includeComments: true });\n            } while (isCommentNodeType(token));\n\n            if (token && astUtils.isTokenOnSameLine(comment, token)) {\n                end -= 1;\n            }\n\n            if (start <= end) {\n                return lodash.range(start, end + 1);\n            }\n            return [];\n        }\n\n        return {\n            \"Program:exit\"() {\n                let lines = sourceCode.lines.map((text, i) => ({ lineNumber: i + 1, text }));\n\n                if (skipBlankLines) {\n                    lines = lines.filter(l => l.text.trim() !== \"\");\n                }\n\n                if (skipComments) {\n                    const comments = sourceCode.getAllComments();\n\n                    const commentLines = lodash.flatten(comments.map(comment => getLinesWithoutCode(comment)));\n\n                    lines = lines.filter(l => !lodash.includes(commentLines, l.lineNumber));\n                }\n\n                if (lines.length > max) {\n                    context.report({\n                        loc: { line: 1, column: 0 },\n                        messageId: \"exceed\",\n                        data: {\n                            max,\n                            actual: lines.length\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A rule to set the maximum number of line of code in a function.\n * @author Pete Ward <peteward44@gmail.com>\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst OPTIONS_SCHEMA = {\n    type: \"object\",\n    properties: {\n        max: {\n            type: \"integer\",\n            minimum: 0,\n            default: 50\n        },\n        skipComments: {\n            type: \"boolean\",\n            default: false\n        },\n        skipBlankLines: {\n            type: \"boolean\",\n            default: false\n        },\n        IIFEs: {\n            type: \"boolean\",\n            default: false\n        }\n    },\n    additionalProperties: false\n};\n\nconst OPTIONS_OR_INTEGER_SCHEMA = {\n    oneOf: [\n        OPTIONS_SCHEMA,\n        {\n            type: \"integer\",\n            minimum: 1\n        }\n    ]\n};\n\n/**\n * Given a list of comment nodes, return a map with numeric keys (source code line numbers) and comment token values.\n * @param {Array} comments An array of comment nodes.\n * @returns {Map.<string,Node>} A map with numeric keys (source code line numbers) and comment token values.\n */\nfunction getCommentLineNumbers(comments) {\n    const map = new Map();\n\n    if (!comments) {\n        return map;\n    }\n    comments.forEach(comment => {\n        for (let i = comment.loc.start.line; i <= comment.loc.end.line; i++) {\n            map.set(i, comment);\n        }\n    });\n    return map;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce a maximum number of line of code in a function\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/max-lines-per-function\"\n        },\n\n        schema: [\n            OPTIONS_OR_INTEGER_SCHEMA\n        ],\n        messages: {\n            exceed: \"{{name}} has too many lines ({{lineCount}}). Maximum allowed is {{maxLines}}.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const lines = sourceCode.lines;\n\n        const option = context.options[0];\n        let maxLines = 50;\n        let skipComments = false;\n        let skipBlankLines = false;\n        let IIFEs = false;\n\n        if (typeof option === \"object\") {\n            maxLines = option.max;\n            skipComments = option.skipComments;\n            skipBlankLines = option.skipBlankLines;\n            IIFEs = option.IIFEs;\n        } else if (typeof option === \"number\") {\n            maxLines = option;\n        }\n\n        const commentLineNumbers = getCommentLineNumbers(sourceCode.getAllComments());\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Tells if a comment encompasses the entire line.\n         * @param {string} line The source line with a trailing comment\n         * @param {number} lineNumber The one-indexed line number this is on\n         * @param {ASTNode} comment The comment to remove\n         * @returns {boolean} If the comment covers the entire line\n         */\n        function isFullLineComment(line, lineNumber, comment) {\n            const start = comment.loc.start,\n                end = comment.loc.end,\n                isFirstTokenOnLine = start.line === lineNumber && !line.slice(0, start.column).trim(),\n                isLastTokenOnLine = end.line === lineNumber && !line.slice(end.column).trim();\n\n            return comment &&\n                (start.line < lineNumber || isFirstTokenOnLine) &&\n                (end.line > lineNumber || isLastTokenOnLine);\n        }\n\n        /**\n         * Identifies is a node is a FunctionExpression which is part of an IIFE\n         * @param {ASTNode} node Node to test\n         * @returns {boolean} True if it's an IIFE\n         */\n        function isIIFE(node) {\n            return node.type === \"FunctionExpression\" && node.parent && node.parent.type === \"CallExpression\" && node.parent.callee === node;\n        }\n\n        /**\n         * Identifies is a node is a FunctionExpression which is embedded within a MethodDefinition or Property\n         * @param {ASTNode} node Node to test\n         * @returns {boolean} True if it's a FunctionExpression embedded within a MethodDefinition or Property\n         */\n        function isEmbedded(node) {\n            if (!node.parent) {\n                return false;\n            }\n            if (node !== node.parent.value) {\n                return false;\n            }\n            if (node.parent.type === \"MethodDefinition\") {\n                return true;\n            }\n            if (node.parent.type === \"Property\") {\n                return node.parent.method === true || node.parent.kind === \"get\" || node.parent.kind === \"set\";\n            }\n            return false;\n        }\n\n        /**\n         * Count the lines in the function\n         * @param {ASTNode} funcNode Function AST node\n         * @returns {void}\n         * @private\n         */\n        function processFunction(funcNode) {\n            const node = isEmbedded(funcNode) ? funcNode.parent : funcNode;\n\n            if (!IIFEs && isIIFE(node)) {\n                return;\n            }\n            let lineCount = 0;\n\n            for (let i = node.loc.start.line - 1; i < node.loc.end.line; ++i) {\n                const line = lines[i];\n\n                if (skipComments) {\n                    if (commentLineNumbers.has(i + 1) && isFullLineComment(line, i + 1, commentLineNumbers.get(i + 1))) {\n                        continue;\n                    }\n                }\n\n                if (skipBlankLines) {\n                    if (line.match(/^\\s*$/u)) {\n                        continue;\n                    }\n                }\n\n                lineCount++;\n            }\n\n            if (lineCount > maxLines) {\n                const name = astUtils.getFunctionNameWithKind(funcNode);\n\n                context.report({\n                    node,\n                    messageId: \"exceed\",\n                    data: { name, lineCount, maxLines }\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            FunctionDeclaration: processFunction,\n            FunctionExpression: processFunction,\n            ArrowFunctionExpression: processFunction\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce a maximum number of nested callbacks.\n * @author Ian Christian Myers\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce a maximum depth that callbacks can be nested\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/max-nested-callbacks\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            maximum: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n        messages: {\n            exceed: \"Too many nested callbacks ({{num}}). Maximum allowed is {{max}}.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Constants\n        //--------------------------------------------------------------------------\n        const option = context.options[0];\n        let THRESHOLD = 10;\n\n        if (\n            typeof option === \"object\" &&\n            (Object.prototype.hasOwnProperty.call(option, \"maximum\") || Object.prototype.hasOwnProperty.call(option, \"max\"))\n        ) {\n            THRESHOLD = option.maximum || option.max;\n        } else if (typeof option === \"number\") {\n            THRESHOLD = option;\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const callbackStack = [];\n\n        /**\n         * Checks a given function node for too many callbacks.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkFunction(node) {\n            const parent = node.parent;\n\n            if (parent.type === \"CallExpression\") {\n                callbackStack.push(node);\n            }\n\n            if (callbackStack.length > THRESHOLD) {\n                const opts = { num: callbackStack.length, max: THRESHOLD };\n\n                context.report({ node, messageId: \"exceed\", data: opts });\n            }\n        }\n\n        /**\n         * Pops the call stack.\n         * @returns {void}\n         * @private\n         */\n        function popStack() {\n            callbackStack.pop();\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            ArrowFunctionExpression: checkFunction,\n            \"ArrowFunctionExpression:exit\": popStack,\n\n            FunctionExpression: checkFunction,\n            \"FunctionExpression:exit\": popStack\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag when a function has too many parameters\n * @author Ilya Volodin\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce a maximum number of parameters in function definitions\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/max-params\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            maximum: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n        messages: {\n            exceed: \"{{name}} has too many parameters ({{count}}). Maximum allowed is {{max}}.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const option = context.options[0];\n        let numParams = 3;\n\n        if (\n            typeof option === \"object\" &&\n            (Object.prototype.hasOwnProperty.call(option, \"maximum\") || Object.prototype.hasOwnProperty.call(option, \"max\"))\n        ) {\n            numParams = option.maximum || option.max;\n        }\n        if (typeof option === \"number\") {\n            numParams = option;\n        }\n\n        /**\n         * Checks a function to see if it has too many parameters.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkFunction(node) {\n            if (node.params.length > numParams) {\n                context.report({\n                    loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                    node,\n                    messageId: \"exceed\",\n                    data: {\n                        name: lodash.upperFirst(astUtils.getFunctionNameWithKind(node)),\n                        count: node.params.length,\n                        max: numParams\n                    }\n                });\n            }\n        }\n\n        return {\n            FunctionDeclaration: checkFunction,\n            ArrowFunctionExpression: checkFunction,\n            FunctionExpression: checkFunction\n        };\n\n    }\n};\n","/**\n * @fileoverview A rule to set the maximum number of statements in a function.\n * @author Ian Christian Myers\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce a maximum number of statements allowed in function blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/max-statements\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            maximum: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    ignoreTopLevelFunctions: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            exceed: \"{{name}} has too many statements ({{count}}). Maximum allowed is {{max}}.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const functionStack = [],\n            option = context.options[0],\n            ignoreTopLevelFunctions = context.options[1] && context.options[1].ignoreTopLevelFunctions || false,\n            topLevelFunctions = [];\n        let maxStatements = 10;\n\n        if (\n            typeof option === \"object\" &&\n            (Object.prototype.hasOwnProperty.call(option, \"maximum\") || Object.prototype.hasOwnProperty.call(option, \"max\"))\n        ) {\n            maxStatements = option.maximum || option.max;\n        } else if (typeof option === \"number\") {\n            maxStatements = option;\n        }\n\n        /**\n         * Reports a node if it has too many statements\n         * @param {ASTNode} node node to evaluate\n         * @param {int} count Number of statements in node\n         * @param {int} max Maximum number of statements allowed\n         * @returns {void}\n         * @private\n         */\n        function reportIfTooManyStatements(node, count, max) {\n            if (count > max) {\n                const name = lodash.upperFirst(astUtils.getFunctionNameWithKind(node));\n\n                context.report({\n                    node,\n                    messageId: \"exceed\",\n                    data: { name, count, max }\n                });\n            }\n        }\n\n        /**\n         * When parsing a new function, store it in our function stack\n         * @returns {void}\n         * @private\n         */\n        function startFunction() {\n            functionStack.push(0);\n        }\n\n        /**\n         * Evaluate the node at the end of function\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function endFunction(node) {\n            const count = functionStack.pop();\n\n            if (ignoreTopLevelFunctions && functionStack.length === 0) {\n                topLevelFunctions.push({ node, count });\n            } else {\n                reportIfTooManyStatements(node, count, maxStatements);\n            }\n        }\n\n        /**\n         * Increment the count of the functions\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function countStatements(node) {\n            functionStack[functionStack.length - 1] += node.body.length;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            FunctionDeclaration: startFunction,\n            FunctionExpression: startFunction,\n            ArrowFunctionExpression: startFunction,\n\n            BlockStatement: countStatements,\n\n            \"FunctionDeclaration:exit\": endFunction,\n            \"FunctionExpression:exit\": endFunction,\n            \"ArrowFunctionExpression:exit\": endFunction,\n\n            \"Program:exit\"() {\n                if (topLevelFunctions.length === 1) {\n                    return;\n                }\n\n                topLevelFunctions.forEach(element => {\n                    const count = element.count;\n                    const node = element.node;\n\n                    reportIfTooManyStatements(node, count, maxStatements);\n                });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Specify the maximum number of statements allowed per line.\n * @author Kenneth Williams\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce a maximum number of statements allowed per line\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/max-statements-per-line\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    max: {\n                        type: \"integer\",\n                        minimum: 1,\n                        default: 1\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            exceed: \"This line has {{numberOfStatementsOnThisLine}} {{statements}}. Maximum allowed is {{maxStatementsPerLine}}.\"\n        }\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode(),\n            options = context.options[0] || {},\n            maxStatementsPerLine = typeof options.max !== \"undefined\" ? options.max : 1;\n\n        let lastStatementLine = 0,\n            numberOfStatementsOnThisLine = 0,\n            firstExtraStatement;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const SINGLE_CHILD_ALLOWED = /^(?:(?:DoWhile|For|ForIn|ForOf|If|Labeled|While)Statement|Export(?:Default|Named)Declaration)$/u;\n\n        /**\n         * Reports with the first extra statement, and clears it.\n         *\n         * @returns {void}\n         */\n        function reportFirstExtraStatementAndClear() {\n            if (firstExtraStatement) {\n                context.report({\n                    node: firstExtraStatement,\n                    messageId: \"exceed\",\n                    data: {\n                        numberOfStatementsOnThisLine,\n                        maxStatementsPerLine,\n                        statements: numberOfStatementsOnThisLine === 1 ? \"statement\" : \"statements\"\n                    }\n                });\n            }\n            firstExtraStatement = null;\n        }\n\n        /**\n         * Gets the actual last token of a given node.\n         *\n         * @param {ASTNode} node - A node to get. This is a node except EmptyStatement.\n         * @returns {Token} The actual last token.\n         */\n        function getActualLastToken(node) {\n            return sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);\n        }\n\n        /**\n         * Addresses a given node.\n         * It updates the state of this rule, then reports the node if the node violated this rule.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {void}\n         */\n        function enterStatement(node) {\n            const line = node.loc.start.line;\n\n            /*\n             * Skip to allow non-block statements if this is direct child of control statements.\n             * `if (a) foo();` is counted as 1.\n             * But `if (a) foo(); else foo();` should be counted as 2.\n             */\n            if (SINGLE_CHILD_ALLOWED.test(node.parent.type) &&\n                node.parent.alternate !== node\n            ) {\n                return;\n            }\n\n            // Update state.\n            if (line === lastStatementLine) {\n                numberOfStatementsOnThisLine += 1;\n            } else {\n                reportFirstExtraStatementAndClear();\n                numberOfStatementsOnThisLine = 1;\n                lastStatementLine = line;\n            }\n\n            // Reports if the node violated this rule.\n            if (numberOfStatementsOnThisLine === maxStatementsPerLine + 1) {\n                firstExtraStatement = firstExtraStatement || node;\n            }\n        }\n\n        /**\n         * Updates the state of this rule with the end line of leaving node to check with the next statement.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {void}\n         */\n        function leaveStatement(node) {\n            const line = getActualLastToken(node).loc.end.line;\n\n            // Update state.\n            if (line !== lastStatementLine) {\n                reportFirstExtraStatementAndClear();\n                numberOfStatementsOnThisLine = 1;\n                lastStatementLine = line;\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            BreakStatement: enterStatement,\n            ClassDeclaration: enterStatement,\n            ContinueStatement: enterStatement,\n            DebuggerStatement: enterStatement,\n            DoWhileStatement: enterStatement,\n            ExpressionStatement: enterStatement,\n            ForInStatement: enterStatement,\n            ForOfStatement: enterStatement,\n            ForStatement: enterStatement,\n            FunctionDeclaration: enterStatement,\n            IfStatement: enterStatement,\n            ImportDeclaration: enterStatement,\n            LabeledStatement: enterStatement,\n            ReturnStatement: enterStatement,\n            SwitchStatement: enterStatement,\n            ThrowStatement: enterStatement,\n            TryStatement: enterStatement,\n            VariableDeclaration: enterStatement,\n            WhileStatement: enterStatement,\n            WithStatement: enterStatement,\n            ExportNamedDeclaration: enterStatement,\n            ExportDefaultDeclaration: enterStatement,\n            ExportAllDeclaration: enterStatement,\n\n            \"BreakStatement:exit\": leaveStatement,\n            \"ClassDeclaration:exit\": leaveStatement,\n            \"ContinueStatement:exit\": leaveStatement,\n            \"DebuggerStatement:exit\": leaveStatement,\n            \"DoWhileStatement:exit\": leaveStatement,\n            \"ExpressionStatement:exit\": leaveStatement,\n            \"ForInStatement:exit\": leaveStatement,\n            \"ForOfStatement:exit\": leaveStatement,\n            \"ForStatement:exit\": leaveStatement,\n            \"FunctionDeclaration:exit\": leaveStatement,\n            \"IfStatement:exit\": leaveStatement,\n            \"ImportDeclaration:exit\": leaveStatement,\n            \"LabeledStatement:exit\": leaveStatement,\n            \"ReturnStatement:exit\": leaveStatement,\n            \"SwitchStatement:exit\": leaveStatement,\n            \"ThrowStatement:exit\": leaveStatement,\n            \"TryStatement:exit\": leaveStatement,\n            \"VariableDeclaration:exit\": leaveStatement,\n            \"WhileStatement:exit\": leaveStatement,\n            \"WithStatement:exit\": leaveStatement,\n            \"ExportNamedDeclaration:exit\": leaveStatement,\n            \"ExportDefaultDeclaration:exit\": leaveStatement,\n            \"ExportAllDeclaration:exit\": leaveStatement,\n            \"Program:exit\": reportFirstExtraStatementAndClear\n        };\n    }\n};\n","/**\n * @fileoverview enforce a particular style for multiline comments\n * @author Teddy Katz\n */\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce a particular style for multiline comments\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/multiline-comment-style\"\n        },\n\n        fixable: \"whitespace\",\n        schema: [{ enum: [\"starred-block\", \"separate-lines\", \"bare-block\"] }],\n        messages: {\n            expectedBlock: \"Expected a block comment instead of consecutive line comments.\",\n            startNewline: \"Expected a linebreak after '/*'.\",\n            endNewline: \"Expected a linebreak before '*/'.\",\n            missingStar: \"Expected a '*' at the start of this line.\",\n            alignment: \"Expected this line to be aligned with the start of the comment.\",\n            expectedLines: \"Expected multiple line comments instead of a block comment.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const option = context.options[0] || \"starred-block\";\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Gets a list of comment lines in a group\n         * @param {Token[]} commentGroup A group of comments, containing either multiple line comments or a single block comment\n         * @returns {string[]} A list of comment lines\n         */\n        function getCommentLines(commentGroup) {\n            if (commentGroup[0].type === \"Line\") {\n                return commentGroup.map(comment => comment.value);\n            }\n            return commentGroup[0].value\n                .split(astUtils.LINEBREAK_MATCHER)\n                .map(line => line.replace(/^\\s*\\*?/u, \"\"));\n        }\n\n        /**\n         * Converts a comment into starred-block form\n         * @param {Token} firstComment The first comment of the group being converted\n         * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n         * @returns {string} A representation of the comment value in starred-block form, excluding start and end markers\n         */\n        function convertToStarredBlock(firstComment, commentLinesList) {\n            const initialOffset = sourceCode.text.slice(firstComment.range[0] - firstComment.loc.start.column, firstComment.range[0]);\n            const starredLines = commentLinesList.map(line => `${initialOffset} *${line}`);\n\n            return `\\n${starredLines.join(\"\\n\")}\\n${initialOffset} `;\n        }\n\n        /**\n         * Converts a comment into separate-line form\n         * @param {Token} firstComment The first comment of the group being converted\n         * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n         * @returns {string} A representation of the comment value in separate-line form\n         */\n        function convertToSeparateLines(firstComment, commentLinesList) {\n            const initialOffset = sourceCode.text.slice(firstComment.range[0] - firstComment.loc.start.column, firstComment.range[0]);\n            const separateLines = commentLinesList.map(line => `// ${line.trim()}`);\n\n            return separateLines.join(`\\n${initialOffset}`);\n        }\n\n        /**\n         * Converts a comment into bare-block form\n         * @param {Token} firstComment The first comment of the group being converted\n         * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n         * @returns {string} A representation of the comment value in bare-block form\n         */\n        function convertToBlock(firstComment, commentLinesList) {\n            const initialOffset = sourceCode.text.slice(firstComment.range[0] - firstComment.loc.start.column, firstComment.range[0]);\n            const blockLines = commentLinesList.map(line => line.trim());\n\n            return `/* ${blockLines.join(`\\n${initialOffset}   `)} */`;\n        }\n\n        /**\n         * Check a comment is JSDoc form\n         * @param {Token[]} commentGroup A group of comments, containing either multiple line comments or a single block comment\n         * @returns {boolean} if commentGroup is JSDoc form, return true\n         */\n        function isJSDoc(commentGroup) {\n            const lines = commentGroup[0].value.split(astUtils.LINEBREAK_MATCHER);\n\n            return commentGroup[0].type === \"Block\" &&\n                /^\\*\\s*$/u.test(lines[0]) &&\n                lines.slice(1, -1).every(line => /^\\s* /u.test(line)) &&\n                /^\\s*$/u.test(lines[lines.length - 1]);\n        }\n\n        /**\n         * Each method checks a group of comments to see if it's valid according to the given option.\n         * @param {Token[]} commentGroup A list of comments that appear together. This will either contain a single\n         * block comment or multiple line comments.\n         * @returns {void}\n         */\n        const commentGroupCheckers = {\n            \"starred-block\"(commentGroup) {\n                const commentLines = getCommentLines(commentGroup);\n\n                if (commentLines.some(value => value.includes(\"*/\"))) {\n                    return;\n                }\n\n                if (commentGroup.length > 1) {\n                    context.report({\n                        loc: {\n                            start: commentGroup[0].loc.start,\n                            end: commentGroup[commentGroup.length - 1].loc.end\n                        },\n                        messageId: \"expectedBlock\",\n                        fix(fixer) {\n                            const range = [commentGroup[0].range[0], commentGroup[commentGroup.length - 1].range[1]];\n                            const starredBlock = `/*${convertToStarredBlock(commentGroup[0], commentLines)}*/`;\n\n                            return commentLines.some(value => value.startsWith(\"/\"))\n                                ? null\n                                : fixer.replaceTextRange(range, starredBlock);\n                        }\n                    });\n                } else {\n                    const block = commentGroup[0];\n                    const lines = block.value.split(astUtils.LINEBREAK_MATCHER);\n                    const expectedLinePrefix = `${sourceCode.text.slice(block.range[0] - block.loc.start.column, block.range[0])} *`;\n\n                    if (!/^\\*?\\s*$/u.test(lines[0])) {\n                        const start = block.value.startsWith(\"*\") ? block.range[0] + 1 : block.range[0];\n\n                        context.report({\n                            loc: {\n                                start: block.loc.start,\n                                end: { line: block.loc.start.line, column: block.loc.start.column + 2 }\n                            },\n                            messageId: \"startNewline\",\n                            fix: fixer => fixer.insertTextAfterRange([start, start + 2], `\\n${expectedLinePrefix}`)\n                        });\n                    }\n\n                    if (!/^\\s*$/u.test(lines[lines.length - 1])) {\n                        context.report({\n                            loc: {\n                                start: { line: block.loc.end.line, column: block.loc.end.column - 2 },\n                                end: block.loc.end\n                            },\n                            messageId: \"endNewline\",\n                            fix: fixer => fixer.replaceTextRange([block.range[1] - 2, block.range[1]], `\\n${expectedLinePrefix}/`)\n                        });\n                    }\n\n                    for (let lineNumber = block.loc.start.line + 1; lineNumber <= block.loc.end.line; lineNumber++) {\n                        const lineText = sourceCode.lines[lineNumber - 1];\n\n                        if (!lineText.startsWith(expectedLinePrefix)) {\n                            context.report({\n                                loc: {\n                                    start: { line: lineNumber, column: 0 },\n                                    end: { line: lineNumber, column: sourceCode.lines[lineNumber - 1].length }\n                                },\n                                messageId: /^\\s*\\*/u.test(lineText)\n                                    ? \"alignment\"\n                                    : \"missingStar\",\n                                fix(fixer) {\n                                    const lineStartIndex = sourceCode.getIndexFromLoc({ line: lineNumber, column: 0 });\n                                    const linePrefixLength = lineText.match(/^\\s*\\*? ?/u)[0].length;\n                                    const commentStartIndex = lineStartIndex + linePrefixLength;\n\n                                    const replacementText = lineNumber === block.loc.end.line || lineText.length === linePrefixLength\n                                        ? expectedLinePrefix\n                                        : `${expectedLinePrefix} `;\n\n                                    return fixer.replaceTextRange([lineStartIndex, commentStartIndex], replacementText);\n                                }\n                            });\n                        }\n                    }\n                }\n            },\n            \"separate-lines\"(commentGroup) {\n                if (!isJSDoc(commentGroup) && commentGroup[0].type === \"Block\") {\n                    const commentLines = getCommentLines(commentGroup);\n                    const block = commentGroup[0];\n                    const tokenAfter = sourceCode.getTokenAfter(block, { includeComments: true });\n\n                    if (tokenAfter && block.loc.end.line === tokenAfter.loc.start.line) {\n                        return;\n                    }\n\n                    context.report({\n                        loc: {\n                            start: block.loc.start,\n                            end: { line: block.loc.start.line, column: block.loc.start.column + 2 }\n                        },\n                        messageId: \"expectedLines\",\n                        fix(fixer) {\n                            return fixer.replaceText(block, convertToSeparateLines(block, commentLines.filter(line => line)));\n                        }\n                    });\n                }\n            },\n            \"bare-block\"(commentGroup) {\n                if (!isJSDoc(commentGroup)) {\n                    const commentLines = getCommentLines(commentGroup);\n\n                    // disallows consecutive line comments in favor of using a block comment.\n                    if (commentGroup[0].type === \"Line\" && commentLines.length > 1 &&\n                        !commentLines.some(value => value.includes(\"*/\"))) {\n                        context.report({\n                            loc: {\n                                start: commentGroup[0].loc.start,\n                                end: commentGroup[commentGroup.length - 1].loc.end\n                            },\n                            messageId: \"expectedBlock\",\n                            fix(fixer) {\n                                const range = [commentGroup[0].range[0], commentGroup[commentGroup.length - 1].range[1]];\n                                const block = convertToBlock(commentGroup[0], commentLines.filter(line => line));\n\n                                return fixer.replaceTextRange(range, block);\n                            }\n                        });\n                    }\n\n                    // prohibits block comments from having a * at the beginning of each line.\n                    if (commentGroup[0].type === \"Block\") {\n                        const block = commentGroup[0];\n                        const lines = block.value.split(astUtils.LINEBREAK_MATCHER).filter(line => line.trim());\n\n                        if (lines.length > 0 && lines.every(line => /^\\s*\\*/u.test(line))) {\n                            context.report({\n                                loc: {\n                                    start: block.loc.start,\n                                    end: { line: block.loc.start.line, column: block.loc.start.column + 2 }\n                                },\n                                messageId: \"expectedBlock\",\n                                fix(fixer) {\n                                    return fixer.replaceText(block, convertToBlock(block, commentLines.filter(line => line)));\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n        };\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            Program() {\n                return sourceCode.getAllComments()\n                    .filter(comment => comment.type !== \"Shebang\")\n                    .filter(comment => !astUtils.COMMENTS_IGNORE_PATTERN.test(comment.value))\n                    .filter(comment => {\n                        const tokenBefore = sourceCode.getTokenBefore(comment, { includeComments: true });\n\n                        return !tokenBefore || tokenBefore.loc.end.line < comment.loc.start.line;\n                    })\n                    .reduce((commentGroups, comment, index, commentList) => {\n                        const tokenBefore = sourceCode.getTokenBefore(comment, { includeComments: true });\n\n                        if (\n                            comment.type === \"Line\" &&\n                            index && commentList[index - 1].type === \"Line\" &&\n                            tokenBefore && tokenBefore.loc.end.line === comment.loc.start.line - 1 &&\n                            tokenBefore === commentList[index - 1]\n                        ) {\n                            commentGroups[commentGroups.length - 1].push(comment);\n                        } else {\n                            commentGroups.push([comment]);\n                        }\n\n                        return commentGroups;\n                    }, [])\n                    .filter(commentGroup => !(commentGroup.length === 1 && commentGroup[0].loc.start.line === commentGroup[0].loc.end.line))\n                    .forEach(commentGroupCheckers[option]);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Enforce newlines between operands of ternary expressions\n * @author Kai Cataldo\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce newlines between operands of ternary expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/multiline-ternary\"\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"always-multiline\", \"never\"]\n            }\n        ],\n        messages: {\n            expectedTestCons: \"Expected newline between test and consequent of ternary expression.\",\n            expectedConsAlt: \"Expected newline between consequent and alternate of ternary expression.\",\n            unexpectedTestCons: \"Unexpected newline between test and consequent of ternary expression.\",\n            unexpectedConsAlt: \"Unexpected newline between consequent and alternate of ternary expression.\"\n        }\n    },\n\n    create(context) {\n        const option = context.options[0];\n        const multiline = option !== \"never\";\n        const allowSingleLine = option === \"always-multiline\";\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Tests whether node is preceded by supplied tokens\n         * @param {ASTNode} node - node to check\n         * @param {ASTNode} parentNode - parent of node to report\n         * @param {boolean} expected - whether newline was expected or not\n         * @returns {void}\n         * @private\n         */\n        function reportError(node, parentNode, expected) {\n            context.report({\n                node,\n                messageId: `${expected ? \"expected\" : \"unexpected\"}${node === parentNode.test ? \"TestCons\" : \"ConsAlt\"}`\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ConditionalExpression(node) {\n                const areTestAndConsequentOnSameLine = astUtils.isTokenOnSameLine(node.test, node.consequent);\n                const areConsequentAndAlternateOnSameLine = astUtils.isTokenOnSameLine(node.consequent, node.alternate);\n\n                if (!multiline) {\n                    if (!areTestAndConsequentOnSameLine) {\n                        reportError(node.test, node, false);\n                    }\n\n                    if (!areConsequentAndAlternateOnSameLine) {\n                        reportError(node.consequent, node, false);\n                    }\n                } else {\n                    if (allowSingleLine && node.loc.start.line === node.loc.end.line) {\n                        return;\n                    }\n\n                    if (areTestAndConsequentOnSameLine) {\n                        reportError(node.test, node, true);\n                    }\n\n                    if (areConsequentAndAlternateOnSameLine) {\n                        reportError(node.consequent, node, true);\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag use of constructors without capital letters\n * @author Nicholas C. Zakas\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst CAPS_ALLOWED = [\n    \"Array\",\n    \"Boolean\",\n    \"Date\",\n    \"Error\",\n    \"Function\",\n    \"Number\",\n    \"Object\",\n    \"RegExp\",\n    \"String\",\n    \"Symbol\"\n];\n\n/**\n * Ensure that if the key is provided, it must be an array.\n * @param {Object} obj Object to check with `key`.\n * @param {string} key Object key to check on `obj`.\n * @param {*} fallback If obj[key] is not present, this will be returned.\n * @returns {string[]} Returns obj[key] if it's an Array, otherwise `fallback`\n */\nfunction checkArray(obj, key, fallback) {\n\n    /* istanbul ignore if */\n    if (Object.prototype.hasOwnProperty.call(obj, key) && !Array.isArray(obj[key])) {\n        throw new TypeError(`${key}, if provided, must be an Array`);\n    }\n    return obj[key] || fallback;\n}\n\n/**\n * A reducer function to invert an array to an Object mapping the string form of the key, to `true`.\n * @param {Object} map Accumulator object for the reduce.\n * @param {string} key Object key to set to `true`.\n * @returns {Object} Returns the updated Object for further reduction.\n */\nfunction invert(map, key) {\n    map[key] = true;\n    return map;\n}\n\n/**\n * Creates an object with the cap is new exceptions as its keys and true as their values.\n * @param {Object} config Rule configuration\n * @returns {Object} Object with cap is new exceptions.\n */\nfunction calculateCapIsNewExceptions(config) {\n    let capIsNewExceptions = checkArray(config, \"capIsNewExceptions\", CAPS_ALLOWED);\n\n    if (capIsNewExceptions !== CAPS_ALLOWED) {\n        capIsNewExceptions = capIsNewExceptions.concat(CAPS_ALLOWED);\n    }\n\n    return capIsNewExceptions.reduce(invert, {});\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require constructor names to begin with a capital letter\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/new-cap\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    newIsCap: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    capIsNew: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    newIsCapExceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    newIsCapExceptionPattern: {\n                        type: \"string\"\n                    },\n                    capIsNewExceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    capIsNewExceptionPattern: {\n                        type: \"string\"\n                    },\n                    properties: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            upper: \"A function with a name starting with an uppercase letter should only be used as a constructor.\",\n            lower: \"A constructor name should not start with a lowercase letter.\"\n        }\n    },\n\n    create(context) {\n\n        const config = Object.assign({}, context.options[0]);\n\n        config.newIsCap = config.newIsCap !== false;\n        config.capIsNew = config.capIsNew !== false;\n        const skipProperties = config.properties === false;\n\n        const newIsCapExceptions = checkArray(config, \"newIsCapExceptions\", []).reduce(invert, {});\n        const newIsCapExceptionPattern = config.newIsCapExceptionPattern ? new RegExp(config.newIsCapExceptionPattern) : null; // eslint-disable-line require-unicode-regexp\n\n        const capIsNewExceptions = calculateCapIsNewExceptions(config);\n        const capIsNewExceptionPattern = config.capIsNewExceptionPattern ? new RegExp(config.capIsNewExceptionPattern) : null; // eslint-disable-line require-unicode-regexp\n\n        const listeners = {};\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Get exact callee name from expression\n         * @param {ASTNode} node CallExpression or NewExpression node\n         * @returns {string} name\n         */\n        function extractNameFromExpression(node) {\n\n            let name = \"\";\n\n            if (node.callee.type === \"MemberExpression\") {\n                const property = node.callee.property;\n\n                if (property.type === \"Literal\" && (typeof property.value === \"string\")) {\n                    name = property.value;\n                } else if (property.type === \"Identifier\" && !node.callee.computed) {\n                    name = property.name;\n                }\n            } else {\n                name = node.callee.name;\n            }\n            return name;\n        }\n\n        /**\n         * Returns the capitalization state of the string -\n         * Whether the first character is uppercase, lowercase, or non-alphabetic\n         * @param {string} str String\n         * @returns {string} capitalization state: \"non-alpha\", \"lower\", or \"upper\"\n         */\n        function getCap(str) {\n            const firstChar = str.charAt(0);\n\n            const firstCharLower = firstChar.toLowerCase();\n            const firstCharUpper = firstChar.toUpperCase();\n\n            if (firstCharLower === firstCharUpper) {\n\n                // char has no uppercase variant, so it's non-alphabetic\n                return \"non-alpha\";\n            }\n            if (firstChar === firstCharLower) {\n                return \"lower\";\n            }\n            return \"upper\";\n\n        }\n\n        /**\n         * Check if capitalization is allowed for a CallExpression\n         * @param {Object} allowedMap Object mapping calleeName to a Boolean\n         * @param {ASTNode} node CallExpression node\n         * @param {string} calleeName Capitalized callee name from a CallExpression\n         * @param {Object} pattern RegExp object from options pattern\n         * @returns {boolean} Returns true if the callee may be capitalized\n         */\n        function isCapAllowed(allowedMap, node, calleeName, pattern) {\n            const sourceText = sourceCode.getText(node.callee);\n\n            if (allowedMap[calleeName] || allowedMap[sourceText]) {\n                return true;\n            }\n\n            if (pattern && pattern.test(sourceText)) {\n                return true;\n            }\n\n            if (calleeName === \"UTC\" && node.callee.type === \"MemberExpression\") {\n\n                // allow if callee is Date.UTC\n                return node.callee.object.type === \"Identifier\" &&\n                    node.callee.object.name === \"Date\";\n            }\n\n            return skipProperties && node.callee.type === \"MemberExpression\";\n        }\n\n        /**\n         * Reports the given messageId for the given node. The location will be the start of the property or the callee.\n         * @param {ASTNode} node CallExpression or NewExpression node.\n         * @param {string} messageId The messageId to report.\n         * @returns {void}\n         */\n        function report(node, messageId) {\n            let callee = node.callee;\n\n            if (callee.type === \"MemberExpression\") {\n                callee = callee.property;\n            }\n\n            context.report({ node, loc: callee.loc.start, messageId });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        if (config.newIsCap) {\n            listeners.NewExpression = function(node) {\n\n                const constructorName = extractNameFromExpression(node);\n\n                if (constructorName) {\n                    const capitalization = getCap(constructorName);\n                    const isAllowed = capitalization !== \"lower\" || isCapAllowed(newIsCapExceptions, node, constructorName, newIsCapExceptionPattern);\n\n                    if (!isAllowed) {\n                        report(node, \"lower\");\n                    }\n                }\n            };\n        }\n\n        if (config.capIsNew) {\n            listeners.CallExpression = function(node) {\n\n                const calleeName = extractNameFromExpression(node);\n\n                if (calleeName) {\n                    const capitalization = getCap(calleeName);\n                    const isAllowed = capitalization !== \"upper\" || isCapAllowed(capIsNewExceptions, node, calleeName, capIsNewExceptionPattern);\n\n                    if (!isAllowed) {\n                        report(node, \"upper\");\n                    }\n                }\n            };\n        }\n\n        return listeners;\n    }\n};\n","/**\n * @fileoverview Rule to flag when using constructor without parentheses\n * @author Ilya Volodin\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require parentheses when invoking a constructor with no arguments\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/new-parens\"\n        },\n\n        fixable: \"code\",\n        schema: [],\n        messages: {\n            missing: \"Missing '()' invoking a constructor.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            NewExpression(node) {\n                if (node.arguments.length !== 0) {\n                    return; // shortcut: if there are arguments, there have to be parens\n                }\n\n                const lastToken = sourceCode.getLastToken(node);\n                const hasLastParen = lastToken && astUtils.isClosingParenToken(lastToken);\n                const hasParens = hasLastParen && astUtils.isOpeningParenToken(sourceCode.getTokenBefore(lastToken));\n\n                if (!hasParens) {\n                    context.report({\n                        node,\n                        messageId: \"missing\",\n                        fix: fixer => fixer.insertTextAfter(node, \"()\")\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to check empty newline after \"var\" statement\n * @author Gopal Venkatesan\n * @deprecated\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow an empty line after variable declarations\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/newline-after-var\"\n        },\n        schema: [\n            {\n                enum: [\"never\", \"always\"]\n            }\n        ],\n        fixable: \"whitespace\",\n        messages: {\n            expected: \"Expected blank line after variable declarations.\",\n            unexpected: \"Unexpected blank line after variable declarations.\"\n        },\n\n        deprecated: true,\n\n        replacedBy: [\"padding-line-between-statements\"]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        // Default `mode` to \"always\".\n        const mode = context.options[0] === \"never\" ? \"never\" : \"always\";\n\n        // Cache starting and ending line numbers of comments for faster lookup\n        const commentEndLine = sourceCode.getAllComments().reduce((result, token) => {\n            result[token.loc.start.line] = token.loc.end.line;\n            return result;\n        }, {});\n\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Gets a token from the given node to compare line to the next statement.\n         *\n         * In general, the token is the last token of the node. However, the token is the second last token if the following conditions satisfy.\n         *\n         * - The last token is semicolon.\n         * - The semicolon is on a different line from the previous token of the semicolon.\n         *\n         * This behavior would address semicolon-less style code. e.g.:\n         *\n         *     var foo = 1\n         *\n         *     ;(a || b).doSomething()\n         *\n         * @param {ASTNode} node - The node to get.\n         * @returns {Token} The token to compare line to the next statement.\n         */\n        function getLastToken(node) {\n            const lastToken = sourceCode.getLastToken(node);\n\n            if (lastToken.type === \"Punctuator\" && lastToken.value === \";\") {\n                const prevToken = sourceCode.getTokenBefore(lastToken);\n\n                if (prevToken.loc.end.line !== lastToken.loc.start.line) {\n                    return prevToken;\n                }\n            }\n\n            return lastToken;\n        }\n\n        /**\n         * Determine if provided keyword is a variable declaration\n         * @private\n         * @param {string} keyword - keyword to test\n         * @returns {boolean} True if `keyword` is a type of var\n         */\n        function isVar(keyword) {\n            return keyword === \"var\" || keyword === \"let\" || keyword === \"const\";\n        }\n\n        /**\n         * Determine if provided keyword is a variant of for specifiers\n         * @private\n         * @param {string} keyword - keyword to test\n         * @returns {boolean} True if `keyword` is a variant of for specifier\n         */\n        function isForTypeSpecifier(keyword) {\n            return keyword === \"ForStatement\" || keyword === \"ForInStatement\" || keyword === \"ForOfStatement\";\n        }\n\n        /**\n         * Determine if provided keyword is an export specifiers\n         * @private\n         * @param {string} nodeType - nodeType to test\n         * @returns {boolean} True if `nodeType` is an export specifier\n         */\n        function isExportSpecifier(nodeType) {\n            return nodeType === \"ExportNamedDeclaration\" || nodeType === \"ExportSpecifier\" ||\n                nodeType === \"ExportDefaultDeclaration\" || nodeType === \"ExportAllDeclaration\";\n        }\n\n        /**\n         * Determine if provided node is the last of their parent block.\n         * @private\n         * @param {ASTNode} node - node to test\n         * @returns {boolean} True if `node` is last of their parent block.\n         */\n        function isLastNode(node) {\n            const token = sourceCode.getTokenAfter(node);\n\n            return !token || (token.type === \"Punctuator\" && token.value === \"}\");\n        }\n\n        /**\n         * Gets the last line of a group of consecutive comments\n         * @param {number} commentStartLine The starting line of the group\n         * @returns {number} The number of the last comment line of the group\n         */\n        function getLastCommentLineOfBlock(commentStartLine) {\n            const currentCommentEnd = commentEndLine[commentStartLine];\n\n            return commentEndLine[currentCommentEnd + 1] ? getLastCommentLineOfBlock(currentCommentEnd + 1) : currentCommentEnd;\n        }\n\n        /**\n         * Determine if a token starts more than one line after a comment ends\n         * @param  {token}   token            The token being checked\n         * @param {integer}  commentStartLine The line number on which the comment starts\n         * @returns {boolean}                 True if `token` does not start immediately after a comment\n         */\n        function hasBlankLineAfterComment(token, commentStartLine) {\n            return token.loc.start.line > getLastCommentLineOfBlock(commentStartLine) + 1;\n        }\n\n        /**\n         * Checks that a blank line exists after a variable declaration when mode is\n         * set to \"always\", or checks that there is no blank line when mode is set\n         * to \"never\"\n         * @private\n         * @param {ASTNode} node - `VariableDeclaration` node to test\n         * @returns {void}\n         */\n        function checkForBlankLine(node) {\n\n            /*\n             * lastToken is the last token on the node's line. It will usually also be the last token of the node, but it will\n             * sometimes be second-last if there is a semicolon on a different line.\n             */\n            const lastToken = getLastToken(node),\n\n                /*\n                 * If lastToken is the last token of the node, nextToken should be the token after the node. Otherwise, nextToken\n                 * is the last token of the node.\n                 */\n                nextToken = lastToken === sourceCode.getLastToken(node) ? sourceCode.getTokenAfter(node) : sourceCode.getLastToken(node),\n                nextLineNum = lastToken.loc.end.line + 1;\n\n            // Ignore if there is no following statement\n            if (!nextToken) {\n                return;\n            }\n\n            // Ignore if parent of node is a for variant\n            if (isForTypeSpecifier(node.parent.type)) {\n                return;\n            }\n\n            // Ignore if parent of node is an export specifier\n            if (isExportSpecifier(node.parent.type)) {\n                return;\n            }\n\n            /*\n             * Some coding styles use multiple `var` statements, so do nothing if\n             * the next token is a `var` statement.\n             */\n            if (nextToken.type === \"Keyword\" && isVar(nextToken.value)) {\n                return;\n            }\n\n            // Ignore if it is last statement in a block\n            if (isLastNode(node)) {\n                return;\n            }\n\n            // Next statement is not a `var`...\n            const noNextLineToken = nextToken.loc.start.line > nextLineNum;\n            const hasNextLineComment = (typeof commentEndLine[nextLineNum] !== \"undefined\");\n\n            if (mode === \"never\" && noNextLineToken && !hasNextLineComment) {\n                context.report({\n                    node,\n                    messageId: \"unexpected\",\n                    data: { identifier: node.name },\n                    fix(fixer) {\n                        const linesBetween = sourceCode.getText().slice(lastToken.range[1], nextToken.range[0]).split(astUtils.LINEBREAK_MATCHER);\n\n                        return fixer.replaceTextRange([lastToken.range[1], nextToken.range[0]], `${linesBetween.slice(0, -1).join(\"\")}\\n${linesBetween[linesBetween.length - 1]}`);\n                    }\n                });\n            }\n\n            // Token on the next line, or comment without blank line\n            if (\n                mode === \"always\" && (\n                    !noNextLineToken ||\n                    hasNextLineComment && !hasBlankLineAfterComment(nextToken, nextLineNum)\n                )\n            ) {\n                context.report({\n                    node,\n                    messageId: \"expected\",\n                    data: { identifier: node.name },\n                    fix(fixer) {\n                        if ((noNextLineToken ? getLastCommentLineOfBlock(nextLineNum) : lastToken.loc.end.line) === nextToken.loc.start.line) {\n                            return fixer.insertTextBefore(nextToken, \"\\n\\n\");\n                        }\n\n                        return fixer.insertTextBeforeRange([nextToken.range[0] - nextToken.loc.start.column, nextToken.range[1]], \"\\n\");\n                    }\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclaration: checkForBlankLine\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to require newlines before `return` statement\n * @author Kai Cataldo\n * @deprecated\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require an empty line before `return` statements\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/newline-before-return\"\n        },\n\n        fixable: \"whitespace\",\n        schema: [],\n        messages: {\n            expected: \"Expected newline before return statement.\"\n        },\n\n        deprecated: true,\n        replacedBy: [\"padding-line-between-statements\"]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Tests whether node is preceded by supplied tokens\n         * @param {ASTNode} node - node to check\n         * @param {Array} testTokens - array of tokens to test against\n         * @returns {boolean} Whether or not the node is preceded by one of the supplied tokens\n         * @private\n         */\n        function isPrecededByTokens(node, testTokens) {\n            const tokenBefore = sourceCode.getTokenBefore(node);\n\n            return testTokens.some(token => tokenBefore.value === token);\n        }\n\n        /**\n         * Checks whether node is the first node after statement or in block\n         * @param {ASTNode} node - node to check\n         * @returns {boolean} Whether or not the node is the first node after statement or in block\n         * @private\n         */\n        function isFirstNode(node) {\n            const parentType = node.parent.type;\n\n            if (node.parent.body) {\n                return Array.isArray(node.parent.body)\n                    ? node.parent.body[0] === node\n                    : node.parent.body === node;\n            }\n\n            if (parentType === \"IfStatement\") {\n                return isPrecededByTokens(node, [\"else\", \")\"]);\n            }\n            if (parentType === \"DoWhileStatement\") {\n                return isPrecededByTokens(node, [\"do\"]);\n            }\n            if (parentType === \"SwitchCase\") {\n                return isPrecededByTokens(node, [\":\"]);\n            }\n            return isPrecededByTokens(node, [\")\"]);\n\n        }\n\n        /**\n         * Returns the number of lines of comments that precede the node\n         * @param {ASTNode} node - node to check for overlapping comments\n         * @param {number} lineNumTokenBefore - line number of previous token, to check for overlapping comments\n         * @returns {number} Number of lines of comments that precede the node\n         * @private\n         */\n        function calcCommentLines(node, lineNumTokenBefore) {\n            const comments = sourceCode.getCommentsBefore(node);\n            let numLinesComments = 0;\n\n            if (!comments.length) {\n                return numLinesComments;\n            }\n\n            comments.forEach(comment => {\n                numLinesComments++;\n\n                if (comment.type === \"Block\") {\n                    numLinesComments += comment.loc.end.line - comment.loc.start.line;\n                }\n\n                // avoid counting lines with inline comments twice\n                if (comment.loc.start.line === lineNumTokenBefore) {\n                    numLinesComments--;\n                }\n\n                if (comment.loc.end.line === node.loc.start.line) {\n                    numLinesComments--;\n                }\n            });\n\n            return numLinesComments;\n        }\n\n        /**\n         * Returns the line number of the token before the node that is passed in as an argument\n         * @param {ASTNode} node - The node to use as the start of the calculation\n         * @returns {number} Line number of the token before `node`\n         * @private\n         */\n        function getLineNumberOfTokenBefore(node) {\n            const tokenBefore = sourceCode.getTokenBefore(node);\n            let lineNumTokenBefore;\n\n            /**\n             * Global return (at the beginning of a script) is a special case.\n             * If there is no token before `return`, then we expect no line\n             * break before the return. Comments are allowed to occupy lines\n             * before the global return, just no blank lines.\n             * Setting lineNumTokenBefore to zero in that case results in the\n             * desired behavior.\n             */\n            if (tokenBefore) {\n                lineNumTokenBefore = tokenBefore.loc.end.line;\n            } else {\n                lineNumTokenBefore = 0; // global return at beginning of script\n            }\n\n            return lineNumTokenBefore;\n        }\n\n        /**\n         * Checks whether node is preceded by a newline\n         * @param {ASTNode} node - node to check\n         * @returns {boolean} Whether or not the node is preceded by a newline\n         * @private\n         */\n        function hasNewlineBefore(node) {\n            const lineNumNode = node.loc.start.line;\n            const lineNumTokenBefore = getLineNumberOfTokenBefore(node);\n            const commentLines = calcCommentLines(node, lineNumTokenBefore);\n\n            return (lineNumNode - lineNumTokenBefore - commentLines) > 1;\n        }\n\n        /**\n         * Checks whether it is safe to apply a fix to a given return statement.\n         *\n         * The fix is not considered safe if the given return statement has leading comments,\n         * as we cannot safely determine if the newline should be added before or after the comments.\n         * For more information, see: https://github.com/eslint/eslint/issues/5958#issuecomment-222767211\n         *\n         * @param {ASTNode} node - The return statement node to check.\n         * @returns {boolean} `true` if it can fix the node.\n         * @private\n         */\n        function canFix(node) {\n            const leadingComments = sourceCode.getCommentsBefore(node);\n            const lastLeadingComment = leadingComments[leadingComments.length - 1];\n            const tokenBefore = sourceCode.getTokenBefore(node);\n\n            if (leadingComments.length === 0) {\n                return true;\n            }\n\n            /*\n             * if the last leading comment ends in the same line as the previous token and\n             * does not share a line with the `return` node, we can consider it safe to fix.\n             * Example:\n             * function a() {\n             *     var b; //comment\n             *     return;\n             * }\n             */\n            if (lastLeadingComment.loc.end.line === tokenBefore.loc.end.line &&\n                lastLeadingComment.loc.end.line !== node.loc.start.line) {\n                return true;\n            }\n\n            return false;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ReturnStatement(node) {\n                if (!isFirstNode(node) && !hasNewlineBefore(node)) {\n                    context.report({\n                        node,\n                        messageId: \"expected\",\n                        fix(fixer) {\n                            if (canFix(node)) {\n                                const tokenBefore = sourceCode.getTokenBefore(node);\n                                const newlines = node.loc.start.line === tokenBefore.loc.end.line ? \"\\n\\n\" : \"\\n\";\n\n                                return fixer.insertTextBefore(node, newlines);\n                            }\n                            return null;\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to ensure newline per method call when chaining calls\n * @author Rajendra Patil\n * @author Burak Yigit Kaya\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require a newline after each call in a method chain\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/newline-per-chained-call\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                ignoreChainWithDepth: {\n                    type: \"integer\",\n                    minimum: 1,\n                    maximum: 10,\n                    default: 2\n                }\n            },\n            additionalProperties: false\n        }],\n        messages: {\n            expected: \"Expected line break before `{{callee}}`.\"\n        }\n    },\n\n    create(context) {\n\n        const options = context.options[0] || {},\n            ignoreChainWithDepth = options.ignoreChainWithDepth || 2;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Get the prefix of a given MemberExpression node.\n         * If the MemberExpression node is a computed value it returns a\n         * left bracket. If not it returns a period.\n         *\n         * @param  {ASTNode} node - A MemberExpression node to get\n         * @returns {string} The prefix of the node.\n         */\n        function getPrefix(node) {\n            return node.computed ? \"[\" : \".\";\n        }\n\n        /**\n         * Gets the property text of a given MemberExpression node.\n         * If the text is multiline, this returns only the first line.\n         *\n         * @param {ASTNode} node - A MemberExpression node to get.\n         * @returns {string} The property text of the node.\n         */\n        function getPropertyText(node) {\n            const prefix = getPrefix(node);\n            const lines = sourceCode.getText(node.property).split(astUtils.LINEBREAK_MATCHER);\n            const suffix = node.computed && lines.length === 1 ? \"]\" : \"\";\n\n            return prefix + lines[0] + suffix;\n        }\n\n        return {\n            \"CallExpression:exit\"(node) {\n                if (!node.callee || node.callee.type !== \"MemberExpression\") {\n                    return;\n                }\n\n                const callee = node.callee;\n                let parent = callee.object;\n                let depth = 1;\n\n                while (parent && parent.callee) {\n                    depth += 1;\n                    parent = parent.callee.object;\n                }\n\n                if (depth > ignoreChainWithDepth && astUtils.isTokenOnSameLine(callee.object, callee.property)) {\n                    context.report({\n                        node: callee.property,\n                        loc: callee.property.loc.start,\n                        messageId: \"expected\",\n                        data: {\n                            callee: getPropertyText(callee)\n                        },\n                        fix(fixer) {\n                            const firstTokenAfterObject = sourceCode.getTokenAfter(callee.object, astUtils.isNotClosingParenToken);\n\n                            return fixer.insertTextBefore(firstTokenAfterObject, \"\\n\");\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag use of alert, confirm, prompt\n * @author Nicholas C. Zakas\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst getPropertyName = require(\"../util/ast-utils\").getStaticPropertyName;\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks if the given name is a prohibited identifier.\n * @param {string} name The name to check\n * @returns {boolean} Whether or not the name is prohibited.\n */\nfunction isProhibitedIdentifier(name) {\n    return /^(alert|confirm|prompt)$/u.test(name);\n}\n\n/**\n * Finds the eslint-scope reference in the given scope.\n * @param {Object} scope The scope to search.\n * @param {ASTNode} node The identifier node.\n * @returns {Reference|null} Returns the found reference or null if none were found.\n */\nfunction findReference(scope, node) {\n    const references = scope.references.filter(reference => reference.identifier.range[0] === node.range[0] &&\n            reference.identifier.range[1] === node.range[1]);\n\n    if (references.length === 1) {\n        return references[0];\n    }\n    return null;\n}\n\n/**\n * Checks if the given identifier node is shadowed in the given scope.\n * @param {Object} scope The current scope.\n * @param {string} node The identifier node to check\n * @returns {boolean} Whether or not the name is shadowed.\n */\nfunction isShadowed(scope, node) {\n    const reference = findReference(scope, node);\n\n    return reference && reference.resolved && reference.resolved.defs.length > 0;\n}\n\n/**\n * Checks if the given identifier node is a ThisExpression in the global scope or the global window property.\n * @param {Object} scope The current scope.\n * @param {string} node The identifier node to check\n * @returns {boolean} Whether or not the node is a reference to the global object.\n */\nfunction isGlobalThisReferenceOrGlobalWindow(scope, node) {\n    if (scope.type === \"global\" && node.type === \"ThisExpression\") {\n        return true;\n    }\n    if (node.name === \"window\") {\n        return !isShadowed(scope, node);\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `alert`, `confirm`, and `prompt`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-alert\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Unexpected {{name}}.\"\n        }\n    },\n\n    create(context) {\n        return {\n            CallExpression(node) {\n                const callee = node.callee,\n                    currentScope = context.getScope();\n\n                // without window.\n                if (callee.type === \"Identifier\") {\n                    const name = callee.name;\n\n                    if (!isShadowed(currentScope, callee) && isProhibitedIdentifier(callee.name)) {\n                        context.report({\n                            node,\n                            messageId: \"unexpected\",\n                            data: { name }\n                        });\n                    }\n\n                } else if (callee.type === \"MemberExpression\" && isGlobalThisReferenceOrGlobalWindow(currentScope, callee.object)) {\n                    const name = getPropertyName(callee);\n\n                    if (isProhibitedIdentifier(name)) {\n                        context.report({\n                            node,\n                            messageId: \"unexpected\",\n                            data: { name }\n                        });\n                    }\n                }\n\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallow construction of dense arrays using the Array constructor\n * @author Matt DuVall <http://www.mattduvall.com/>\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `Array` constructors\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-array-constructor\"\n        },\n\n        schema: [],\n\n        messages: {\n            preferLiteral: \"The array literal notation [] is preferable.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Disallow construction of dense arrays using the Array constructor\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function check(node) {\n            if (\n                node.arguments.length !== 1 &&\n                node.callee.type === \"Identifier\" &&\n                node.callee.name === \"Array\"\n            ) {\n                context.report({ node, messageId: \"preferLiteral\" });\n            }\n        }\n\n        return {\n            CallExpression: check,\n            NewExpression: check\n        };\n\n    }\n};\n","/**\n * @fileoverview disallow using an async function as a Promise executor\n * @author Teddy Katz\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow using an async function as a Promise executor\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-async-promise-executor\"\n        },\n\n        fixable: null,\n        schema: [],\n        messages: {\n            async: \"Promise executor functions should not be async.\"\n        }\n    },\n\n    create(context) {\n        return {\n            \"NewExpression[callee.name='Promise'][arguments.0.async=true]\"(node) {\n                context.report({\n                    node: context.getSourceCode().getFirstToken(node.arguments[0], token => token.value === \"async\"),\n                    messageId: \"async\"\n                });\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow uses of await inside of loops.\n * @author Nat Mote (nmote)\n */\n\n\n/**\n * Check whether it should stop traversing ancestors at the given node.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if it should stop traversing.\n */\nfunction isBoundary(node) {\n    const t = node.type;\n\n    return (\n        t === \"FunctionDeclaration\" ||\n        t === \"FunctionExpression\" ||\n        t === \"ArrowFunctionExpression\" ||\n\n        /*\n         * Don't report the await expressions on for-await-of loop since it's\n         * asynchronous iteration intentionally.\n         */\n        (t === \"ForOfStatement\" && node.await === true)\n    );\n}\n\n/**\n * Check whether the given node is in loop.\n * @param {ASTNode} node A node to check.\n * @param {ASTNode} parent A parent node to check.\n * @returns {boolean} `true` if the node is in loop.\n */\nfunction isLooped(node, parent) {\n    switch (parent.type) {\n        case \"ForStatement\":\n            return (\n                node === parent.test ||\n                node === parent.update ||\n                node === parent.body\n            );\n\n        case \"ForOfStatement\":\n        case \"ForInStatement\":\n            return node === parent.body;\n\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n            return node === parent.test || node === parent.body;\n\n        default:\n            return false;\n    }\n}\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow `await` inside of loops\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-await-in-loop\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpectedAwait: \"Unexpected `await` inside a loop.\"\n        }\n    },\n    create(context) {\n\n        /**\n         * Validate an await expression.\n         * @param {ASTNode} awaitNode An AwaitExpression or ForOfStatement node to validate.\n         * @returns {void}\n         */\n        function validate(awaitNode) {\n            if (awaitNode.type === \"ForOfStatement\" && !awaitNode.await) {\n                return;\n            }\n\n            let node = awaitNode;\n            let parent = node.parent;\n\n            while (parent && !isBoundary(parent)) {\n                if (isLooped(node, parent)) {\n                    context.report({\n                        node: awaitNode,\n                        messageId: \"unexpectedAwait\"\n                    });\n                    return;\n                }\n                node = parent;\n                parent = parent.parent;\n            }\n        }\n\n        return {\n            AwaitExpression: validate,\n            ForOfStatement: validate\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag bitwise identifiers\n * @author Nicholas C. Zakas\n */\n\n\n\n/*\n *\n * Set of bitwise operators.\n *\n */\nconst BITWISE_OPERATORS = [\n    \"^\", \"|\", \"&\", \"<<\", \">>\", \">>>\",\n    \"^=\", \"|=\", \"&=\", \"<<=\", \">>=\", \">>>=\",\n    \"~\"\n];\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow bitwise operators\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-bitwise\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            enum: BITWISE_OPERATORS\n                        },\n                        uniqueItems: true\n                    },\n                    int32Hint: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"Unexpected use of '{{operator}}'.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const allowed = options.allow || [];\n        const int32Hint = options.int32Hint === true;\n\n        /**\n         * Reports an unexpected use of a bitwise operator.\n         * @param   {ASTNode} node Node which contains the bitwise operator.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({ node, messageId: \"unexpected\", data: { operator: node.operator } });\n        }\n\n        /**\n         * Checks if the given node has a bitwise operator.\n         * @param   {ASTNode} node The node to check.\n         * @returns {boolean} Whether or not the node has a bitwise operator.\n         */\n        function hasBitwiseOperator(node) {\n            return BITWISE_OPERATORS.indexOf(node.operator) !== -1;\n        }\n\n        /**\n         * Checks if exceptions were provided, e.g. `{ allow: ['~', '|'] }`.\n         * @param   {ASTNode} node The node to check.\n         * @returns {boolean} Whether or not the node has a bitwise operator.\n         */\n        function allowedOperator(node) {\n            return allowed.indexOf(node.operator) !== -1;\n        }\n\n        /**\n         * Checks if the given bitwise operator is used for integer typecasting, i.e. \"|0\"\n         * @param   {ASTNode} node The node to check.\n         * @returns {boolean} whether the node is used in integer typecasting.\n         */\n        function isInt32Hint(node) {\n            return int32Hint && node.operator === \"|\" && node.right &&\n              node.right.type === \"Literal\" && node.right.value === 0;\n        }\n\n        /**\n         * Report if the given node contains a bitwise operator.\n         * @param   {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkNodeForBitwiseOperator(node) {\n            if (hasBitwiseOperator(node) && !allowedOperator(node) && !isInt32Hint(node)) {\n                report(node);\n            }\n        }\n\n        return {\n            AssignmentExpression: checkNodeForBitwiseOperator,\n            BinaryExpression: checkNodeForBitwiseOperator,\n            UnaryExpression: checkNodeForBitwiseOperator\n        };\n\n    }\n};\n","/**\n * @fileoverview disallow use of the Buffer() constructor\n * @author Teddy Katz\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow use of the `Buffer()` constructor\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-buffer-constructor\"\n        },\n\n        schema: [],\n\n        messages: {\n            deprecated: \"{{expr}} is deprecated. Use Buffer.from(), Buffer.alloc(), or Buffer.allocUnsafe() instead.\"\n        }\n    },\n\n    create(context) {\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            \"CallExpression[callee.name='Buffer'], NewExpression[callee.name='Buffer']\"(node) {\n                context.report({\n                    node,\n                    messageId: \"deprecated\",\n                    data: { expr: node.type === \"CallExpression\" ? \"Buffer()\" : \"new Buffer()\" }\n                });\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag use of arguments.callee and arguments.caller.\n * @author Nicholas C. Zakas\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `arguments.caller` or `arguments.callee`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-caller\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Avoid arguments.{{prop}}.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n\n            MemberExpression(node) {\n                const objectName = node.object.name,\n                    propertyName = node.property.name;\n\n                if (objectName === \"arguments\" && !node.computed && propertyName && propertyName.match(/^calle[er]$/u)) {\n                    context.report({ node, messageId: \"unexpected\", data: { prop: propertyName } });\n                }\n\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use of an lexical declarations inside a case clause\n * @author Erik Arvidsson\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow lexical declarations in case clauses\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-case-declarations\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Unexpected lexical declaration in case block.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Checks whether or not a node is a lexical declaration.\n         * @param {ASTNode} node A direct child statement of a switch case.\n         * @returns {boolean} Whether or not the node is a lexical declaration.\n         */\n        function isLexicalDeclaration(node) {\n            switch (node.type) {\n                case \"FunctionDeclaration\":\n                case \"ClassDeclaration\":\n                    return true;\n                case \"VariableDeclaration\":\n                    return node.kind !== \"var\";\n                default:\n                    return false;\n            }\n        }\n\n        return {\n            SwitchCase(node) {\n                for (let i = 0; i < node.consequent.length; i++) {\n                    const statement = node.consequent[i];\n\n                    if (isLexicalDeclaration(statement)) {\n                        context.report({\n                            node: statement,\n                            messageId: \"unexpected\"\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag variable leak in CatchClauses in IE 8 and earlier\n * @author Ian Christian Myers\n * @deprecated in ESLint v5.1.0\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `catch` clause parameters from shadowing variables in the outer scope\",\n            category: \"Variables\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-catch-shadow\"\n        },\n\n        replacedBy: [\"no-shadow\"],\n\n        deprecated: true,\n        schema: [],\n\n        messages: {\n            mutable: \"Value of '{{name}}' may be overwritten in IE 8 and earlier.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Check if the parameters are been shadowed\n         * @param {Object} scope current scope\n         * @param {string} name parameter name\n         * @returns {boolean} True is its been shadowed\n         */\n        function paramIsShadowing(scope, name) {\n            return astUtils.getVariableByName(scope, name) !== null;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            \"CatchClause[param!=null]\"(node) {\n                let scope = context.getScope();\n\n                /*\n                 * When ecmaVersion >= 6, CatchClause creates its own scope\n                 * so start from one upper scope to exclude the current node\n                 */\n                if (scope.block === node) {\n                    scope = scope.upper;\n                }\n\n                if (paramIsShadowing(scope, node.param.name)) {\n                    context.report({ node, messageId: \"mutable\", data: { name: node.param.name } });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview A rule to disallow modifying variables of class declarations\n * @author Toru Nagashima\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow reassigning class members\",\n            category: \"ECMAScript 6\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-class-assign\"\n        },\n\n        schema: [],\n\n        messages: {\n            class: \"'{{name}}' is a class.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable - A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            astUtils.getModifyingReferences(variable.references).forEach(reference => {\n                context.report({ node: reference.identifier, messageId: \"class\", data: { name: reference.identifier.name } });\n\n            });\n        }\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {ASTNode} node - A ClassDeclaration/ClassExpression node to check.\n         * @returns {void}\n         */\n        function checkForClass(node) {\n            context.getDeclaredVariables(node).forEach(checkVariable);\n        }\n\n        return {\n            ClassDeclaration: checkForClass,\n            ClassExpression: checkForClass\n        };\n\n    }\n};\n","/**\n * @fileoverview The rule should warn against code that tries to compare against -0.\n * @author Aladdin-ADD <hh_2013@foxmail.com>\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow comparing against -0\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-compare-neg-zero\"\n        },\n\n        fixable: null,\n        schema: [],\n\n        messages: {\n            unexpected: \"Do not use the '{{operator}}' operator to compare against -0.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Checks a given node is -0\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} `true` if the node is -0.\n         */\n        function isNegZero(node) {\n            return node.type === \"UnaryExpression\" && node.operator === \"-\" && node.argument.type === \"Literal\" && node.argument.value === 0;\n        }\n        const OPERATORS_TO_CHECK = new Set([\">\", \">=\", \"<\", \"<=\", \"==\", \"===\", \"!=\", \"!==\"]);\n\n        return {\n            BinaryExpression(node) {\n                if (OPERATORS_TO_CHECK.has(node.operator)) {\n                    if (isNegZero(node.left) || isNegZero(node.right)) {\n                        context.report({\n                            node,\n                            messageId: \"unexpected\",\n                            data: { operator: node.operator }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag assignment in a conditional statement's test expression\n * @author Stephen Murray <spmurrayzzz>\n */\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\nconst NODE_DESCRIPTIONS = {\n    DoWhileStatement: \"a 'do...while' statement\",\n    ForStatement: \"a 'for' statement\",\n    IfStatement: \"an 'if' statement\",\n    WhileStatement: \"a 'while' statement\"\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow assignment operators in conditional expressions\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-cond-assign\"\n        },\n\n        schema: [\n            {\n                enum: [\"except-parens\", \"always\"]\n            }\n        ],\n\n        messages: {\n            unexpected: \"Unexpected assignment within {{type}}.\",\n\n            // must match JSHint's error message\n            missing: \"Expected a conditional expression and instead saw an assignment.\"\n        }\n    },\n\n    create(context) {\n\n        const prohibitAssign = (context.options[0] || \"except-parens\");\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check whether an AST node is the test expression for a conditional statement.\n         * @param {!Object} node The node to test.\n         * @returns {boolean} `true` if the node is the text expression for a conditional statement; otherwise, `false`.\n         */\n        function isConditionalTestExpression(node) {\n            return node.parent &&\n                node.parent.test &&\n                node === node.parent.test;\n        }\n\n        /**\n         * Given an AST node, perform a bottom-up search for the first ancestor that represents a conditional statement.\n         * @param {!Object} node The node to use at the start of the search.\n         * @returns {?Object} The closest ancestor node that represents a conditional statement.\n         */\n        function findConditionalAncestor(node) {\n            let currentAncestor = node;\n\n            do {\n                if (isConditionalTestExpression(currentAncestor)) {\n                    return currentAncestor.parent;\n                }\n            } while ((currentAncestor = currentAncestor.parent) && !astUtils.isFunction(currentAncestor));\n\n            return null;\n        }\n\n        /**\n         * Check whether the code represented by an AST node is enclosed in two sets of parentheses.\n         * @param {!Object} node The node to test.\n         * @returns {boolean} `true` if the code is enclosed in two sets of parentheses; otherwise, `false`.\n         */\n        function isParenthesisedTwice(node) {\n            const previousToken = sourceCode.getTokenBefore(node, 1),\n                nextToken = sourceCode.getTokenAfter(node, 1);\n\n            return astUtils.isParenthesised(sourceCode, node) &&\n                astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] &&\n                astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\n        }\n\n        /**\n         * Check a conditional statement's test expression for top-level assignments that are not enclosed in parentheses.\n         * @param {!Object} node The node for the conditional statement.\n         * @returns {void}\n         */\n        function testForAssign(node) {\n            if (node.test &&\n                (node.test.type === \"AssignmentExpression\") &&\n                (node.type === \"ForStatement\"\n                    ? !astUtils.isParenthesised(sourceCode, node.test)\n                    : !isParenthesisedTwice(node.test)\n                )\n            ) {\n\n                context.report({\n                    node,\n                    loc: node.test.loc.start,\n                    messageId: \"missing\"\n                });\n            }\n        }\n\n        /**\n         * Check whether an assignment expression is descended from a conditional statement's test expression.\n         * @param {!Object} node The node for the assignment expression.\n         * @returns {void}\n         */\n        function testForConditionalAncestor(node) {\n            const ancestor = findConditionalAncestor(node);\n\n            if (ancestor) {\n                context.report({\n                    node: ancestor,\n                    messageId: \"unexpected\",\n                    data: {\n                        type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type\n                    }\n                });\n            }\n        }\n\n        if (prohibitAssign === \"always\") {\n            return {\n                AssignmentExpression: testForConditionalAncestor\n            };\n        }\n\n        return {\n            DoWhileStatement: testForAssign,\n            ForStatement: testForAssign,\n            IfStatement: testForAssign,\n            WhileStatement: testForAssign,\n            ConditionalExpression: testForAssign\n        };\n\n    }\n};\n","/**\n * @fileoverview A rule to warn against using arrow functions when they could be\n * confused with comparisions\n * @author Jxck <https://github.com/Jxck>\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils.js\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a node is a conditional expression.\n * @param {ASTNode} node - node to test\n * @returns {boolean} `true` if the node is a conditional expression.\n */\nfunction isConditional(node) {\n    return node && node.type === \"ConditionalExpression\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow arrow functions where they could be confused with comparisons\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-confusing-arrow\"\n        },\n\n        fixable: \"code\",\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowParens: { type: \"boolean\", default: false }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            confusing: \"Arrow function used ambiguously with a conditional expression.\"\n        }\n    },\n\n    create(context) {\n        const config = context.options[0] || {};\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports if an arrow function contains an ambiguous conditional.\n         * @param {ASTNode} node - A node to check and report.\n         * @returns {void}\n         */\n        function checkArrowFunc(node) {\n            const body = node.body;\n\n            if (isConditional(body) && !(config.allowParens && astUtils.isParenthesised(sourceCode, body))) {\n                context.report({\n                    node,\n                    messageId: \"confusing\",\n                    fix(fixer) {\n\n                        // if `allowParens` is not set to true dont bother wrapping in parens\n                        return config.allowParens && fixer.replaceText(node.body, `(${sourceCode.getText(node.body)})`);\n                    }\n                });\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: checkArrowFunc\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag use of console object\n * @author Nicholas C. Zakas\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `console`\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-console\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        },\n                        minItems: 1,\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"Unexpected console statement.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const allowed = options.allow || [];\n\n        /**\n         * Checks whether the given reference is 'console' or not.\n         *\n         * @param {eslint-scope.Reference} reference - The reference to check.\n         * @returns {boolean} `true` if the reference is 'console'.\n         */\n        function isConsole(reference) {\n            const id = reference.identifier;\n\n            return id && id.name === \"console\";\n        }\n\n        /**\n         * Checks whether the property name of the given MemberExpression node\n         * is allowed by options or not.\n         *\n         * @param {ASTNode} node - The MemberExpression node to check.\n         * @returns {boolean} `true` if the property name of the node is allowed.\n         */\n        function isAllowed(node) {\n            const propertyName = astUtils.getStaticPropertyName(node);\n\n            return propertyName && allowed.indexOf(propertyName) !== -1;\n        }\n\n        /**\n         * Checks whether the given reference is a member access which is not\n         * allowed by options or not.\n         *\n         * @param {eslint-scope.Reference} reference - The reference to check.\n         * @returns {boolean} `true` if the reference is a member access which\n         *      is not allowed by options.\n         */\n        function isMemberAccessExceptAllowed(reference) {\n            const node = reference.identifier;\n            const parent = node.parent;\n\n            return (\n                parent.type === \"MemberExpression\" &&\n                parent.object === node &&\n                !isAllowed(parent)\n            );\n        }\n\n        /**\n         * Reports the given reference as a violation.\n         *\n         * @param {eslint-scope.Reference} reference - The reference to report.\n         * @returns {void}\n         */\n        function report(reference) {\n            const node = reference.identifier.parent;\n\n            context.report({\n                node,\n                loc: node.loc,\n                messageId: \"unexpected\"\n            });\n        }\n\n        return {\n            \"Program:exit\"() {\n                const scope = context.getScope();\n                const consoleVar = astUtils.getVariableByName(scope, \"console\");\n                const shadowed = consoleVar && consoleVar.defs.length > 0;\n\n                /*\n                 * 'scope.through' includes all references to undefined\n                 * variables. If the variable 'console' is not defined, it uses\n                 * 'scope.through'.\n                 */\n                const references = consoleVar\n                    ? consoleVar.references\n                    : scope.through.filter(isConsole);\n\n                if (!shadowed) {\n                    references\n                        .filter(isMemberAccessExceptAllowed)\n                        .forEach(report);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A rule to disallow modifying variables that are declared using `const`\n * @author Toru Nagashima\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow reassigning `const` variables\",\n            category: \"ECMAScript 6\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-const-assign\"\n        },\n\n        schema: [],\n\n        messages: {\n            const: \"'{{name}}' is constant.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable - A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            astUtils.getModifyingReferences(variable.references).forEach(reference => {\n                context.report({ node: reference.identifier, messageId: \"const\", data: { name: reference.identifier.name } });\n            });\n        }\n\n        return {\n            VariableDeclaration(node) {\n                if (node.kind === \"const\") {\n                    context.getDeclaredVariables(node).forEach(checkVariable);\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use constant conditions\n * @author Christian Schulz <http://rndm.de>\n */\n\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst EQUALITY_OPERATORS = [\"===\", \"!==\", \"==\", \"!=\"];\nconst RELATIONAL_OPERATORS = [\">\", \"<\", \">=\", \"<=\", \"in\", \"instanceof\"];\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow constant expressions in conditions\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-constant-condition\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    checkLoops: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"Unexpected constant condition.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {},\n            checkLoops = options.checkLoops !== false,\n            loopSetStack = [];\n\n        let loopsInCurrentScope = new Set();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n\n        /**\n         * Checks if a branch node of LogicalExpression short circuits the whole condition\n         * @param {ASTNode} node The branch of main condition which needs to be checked\n         * @param {string} operator The operator of the main LogicalExpression.\n         * @returns {boolean} true when condition short circuits whole condition\n         */\n        function isLogicalIdentity(node, operator) {\n            switch (node.type) {\n                case \"Literal\":\n                    return (operator === \"||\" && node.value === true) ||\n                           (operator === \"&&\" && node.value === false);\n\n                case \"UnaryExpression\":\n                    return (operator === \"&&\" && node.operator === \"void\");\n\n                case \"LogicalExpression\":\n                    return isLogicalIdentity(node.left, node.operator) ||\n                             isLogicalIdentity(node.right, node.operator);\n\n                // no default\n            }\n            return false;\n        }\n\n        /**\n         * Checks if a node has a constant truthiness value.\n         * @param {ASTNode} node The AST node to check.\n         * @param {boolean} inBooleanPosition `false` if checking branch of a condition.\n         *  `true` in all other cases\n         * @returns {Bool} true when node's truthiness is constant\n         * @private\n         */\n        function isConstant(node, inBooleanPosition) {\n            switch (node.type) {\n                case \"Literal\":\n                case \"ArrowFunctionExpression\":\n                case \"FunctionExpression\":\n                case \"ObjectExpression\":\n                case \"ArrayExpression\":\n                    return true;\n\n                case \"UnaryExpression\":\n                    if (node.operator === \"void\") {\n                        return true;\n                    }\n\n                    return (node.operator === \"typeof\" && inBooleanPosition) ||\n                        isConstant(node.argument, true);\n\n                case \"BinaryExpression\":\n                    return isConstant(node.left, false) &&\n                            isConstant(node.right, false) &&\n                            node.operator !== \"in\";\n\n                case \"LogicalExpression\": {\n                    const isLeftConstant = isConstant(node.left, inBooleanPosition);\n                    const isRightConstant = isConstant(node.right, inBooleanPosition);\n                    const isLeftShortCircuit = (isLeftConstant && isLogicalIdentity(node.left, node.operator));\n                    const isRightShortCircuit = (isRightConstant && isLogicalIdentity(node.right, node.operator));\n\n                    return (isLeftConstant && isRightConstant) ||\n                        (\n\n                            // in the case of an \"OR\", we need to know if the right constant value is truthy\n                            node.operator === \"||\" &&\n                            isRightConstant &&\n                            node.right.value &&\n                            (\n                                !node.parent ||\n                                node.parent.type !== \"BinaryExpression\" ||\n                                !(EQUALITY_OPERATORS.includes(node.parent.operator) || RELATIONAL_OPERATORS.includes(node.parent.operator))\n                            )\n                        ) ||\n                        isLeftShortCircuit ||\n                        isRightShortCircuit;\n                }\n\n                case \"AssignmentExpression\":\n                    return (node.operator === \"=\") && isConstant(node.right, inBooleanPosition);\n\n                case \"SequenceExpression\":\n                    return isConstant(node.expressions[node.expressions.length - 1], inBooleanPosition);\n\n                // no default\n            }\n            return false;\n        }\n\n        /**\n         * Tracks when the given node contains a constant condition.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function trackConstantConditionLoop(node) {\n            if (node.test && isConstant(node.test, true)) {\n                loopsInCurrentScope.add(node);\n            }\n        }\n\n        /**\n         * Reports when the set contains the given constant condition node\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkConstantConditionLoopInSet(node) {\n            if (loopsInCurrentScope.has(node)) {\n                loopsInCurrentScope.delete(node);\n                context.report({ node: node.test, messageId: \"unexpected\" });\n            }\n        }\n\n        /**\n         * Reports when the given node contains a constant condition.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function reportIfConstant(node) {\n            if (node.test && isConstant(node.test, true)) {\n                context.report({ node: node.test, messageId: \"unexpected\" });\n            }\n        }\n\n        /**\n         * Stores current set of constant loops in loopSetStack temporarily\n         * and uses a new set to track constant loops\n         * @returns {void}\n         * @private\n         */\n        function enterFunction() {\n            loopSetStack.push(loopsInCurrentScope);\n            loopsInCurrentScope = new Set();\n        }\n\n        /**\n         * Reports when the set still contains stored constant conditions\n         * @returns {void}\n         * @private\n         */\n        function exitFunction() {\n            loopsInCurrentScope = loopSetStack.pop();\n        }\n\n        /**\n         * Checks node when checkLoops option is enabled\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkLoop(node) {\n            if (checkLoops) {\n                trackConstantConditionLoop(node);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ConditionalExpression: reportIfConstant,\n            IfStatement: reportIfConstant,\n            WhileStatement: checkLoop,\n            \"WhileStatement:exit\": checkConstantConditionLoopInSet,\n            DoWhileStatement: checkLoop,\n            \"DoWhileStatement:exit\": checkConstantConditionLoopInSet,\n            ForStatement: checkLoop,\n            \"ForStatement > .test\": node => checkLoop(node.parent),\n            \"ForStatement:exit\": checkConstantConditionLoopInSet,\n            FunctionDeclaration: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            FunctionExpression: enterFunction,\n            \"FunctionExpression:exit\": exitFunction,\n            YieldExpression: () => loopsInCurrentScope.clear()\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use of continue statement\n * @author Borislav Zhivkov\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `continue` statements\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-continue\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Unexpected use of continue statement.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n            ContinueStatement(node) {\n                context.report({ node, messageId: \"unexpected\" });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to forbid control charactes from regular expressions.\n * @author Nicholas C. Zakas\n */\n\n\n\nconst RegExpValidator = require(\"regexpp\").RegExpValidator;\nconst collector = new (class {\n    constructor() {\n        this.ecmaVersion = 2018;\n        this._source = \"\";\n        this._controlChars = [];\n        this._validator = new RegExpValidator(this);\n    }\n\n    onPatternEnter() {\n        this._controlChars = [];\n    }\n\n    onCharacter(start, end, cp) {\n        if (cp >= 0x00 &&\n            cp <= 0x1F &&\n            (\n                this._source.codePointAt(start) === cp ||\n                this._source.slice(start, end).startsWith(\"\\\\x\") ||\n                this._source.slice(start, end).startsWith(\"\\\\u\")\n            )\n        ) {\n            this._controlChars.push(`\\\\x${`0${cp.toString(16)}`.slice(-2)}`);\n        }\n    }\n\n    collectControlChars(regexpStr) {\n        try {\n            this._source = regexpStr;\n            this._validator.validatePattern(regexpStr); // Call onCharacter hook\n        } catch (err) {\n\n            // Ignore syntax errors in RegExp.\n        }\n        return this._controlChars;\n    }\n})();\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow control characters in regular expressions\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-control-regex\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Unexpected control character(s) in regular expression: {{controlChars}}.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Get the regex expression\n         * @param {ASTNode} node node to evaluate\n         * @returns {RegExp|null} Regex if found else null\n         * @private\n         */\n        function getRegExpPattern(node) {\n            if (node.regex) {\n                return node.regex.pattern;\n            }\n            if (typeof node.value === \"string\" &&\n                (node.parent.type === \"NewExpression\" || node.parent.type === \"CallExpression\") &&\n                node.parent.callee.type === \"Identifier\" &&\n                node.parent.callee.name === \"RegExp\" &&\n                node.parent.arguments[0] === node\n            ) {\n                return node.value;\n            }\n\n            return null;\n        }\n\n        return {\n            Literal(node) {\n                const pattern = getRegExpPattern(node);\n\n                if (pattern) {\n                    const controlCharacters = collector.collectControlChars(pattern);\n\n                    if (controlCharacters.length > 0) {\n                        context.report({\n                            node,\n                            messageId: \"unexpected\",\n                            data: {\n                                controlChars: controlCharacters.join(\", \")\n                            }\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use of a debugger statement\n * @author Nicholas C. Zakas\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow the use of `debugger`\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-debugger\"\n        },\n\n        fixable: null,\n        schema: [],\n\n        messages: {\n            unexpected: \"Unexpected 'debugger' statement.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n            DebuggerStatement(node) {\n                context.report({\n                    node,\n                    messageId: \"unexpected\"\n                });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag when deleting variables\n * @author Ilya Volodin\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow deleting variables\",\n            category: \"Variables\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-delete-var\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Variables should not be deleted.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n\n            UnaryExpression(node) {\n                if (node.operator === \"delete\" && node.argument.type === \"Identifier\") {\n                    context.report({ node, messageId: \"unexpected\" });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to check for ambiguous div operator in regexes\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow division operators explicitly at the beginning of regular expressions\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-div-regex\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"A regular expression literal can be confused with '/='.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n\n            Literal(node) {\n                const token = sourceCode.getFirstToken(node);\n\n                if (token.type === \"RegularExpression\" && token.value[1] === \"=\") {\n                    context.report({ node, messageId: \"unexpected\" });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag duplicate arguments\n * @author Jamund Ferguson\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow duplicate arguments in `function` definitions\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-dupe-args\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Duplicate param '{{name}}'.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Checks whether or not a given definition is a parameter's.\n         * @param {eslint-scope.DefEntry} def - A definition to check.\n         * @returns {boolean} `true` if the definition is a parameter's.\n         */\n        function isParameter(def) {\n            return def.type === \"Parameter\";\n        }\n\n        /**\n         * Determines if a given node has duplicate parameters.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkParams(node) {\n            const variables = context.getDeclaredVariables(node);\n\n            for (let i = 0; i < variables.length; ++i) {\n                const variable = variables[i];\n\n                // Checks and reports duplications.\n                const defs = variable.defs.filter(isParameter);\n\n                if (defs.length >= 2) {\n                    context.report({\n                        node,\n                        messageId: \"unexpected\",\n                        data: { name: variable.name }\n                    });\n                }\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            FunctionDeclaration: checkParams,\n            FunctionExpression: checkParams\n        };\n\n    }\n};\n","/**\n * @fileoverview A rule to disallow duplicate name in class members.\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow duplicate class members\",\n            category: \"ECMAScript 6\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-dupe-class-members\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Duplicate name '{{name}}'.\"\n        }\n    },\n\n    create(context) {\n        let stack = [];\n\n        /**\n         * Gets state of a given member name.\n         * @param {string} name - A name of a member.\n         * @param {boolean} isStatic - A flag which specifies that is a static member.\n         * @returns {Object} A state of a given member name.\n         *   - retv.init {boolean} A flag which shows the name is declared as normal member.\n         *   - retv.get {boolean} A flag which shows the name is declared as getter.\n         *   - retv.set {boolean} A flag which shows the name is declared as setter.\n         */\n        function getState(name, isStatic) {\n            const stateMap = stack[stack.length - 1];\n            const key = `$${name}`; // to avoid \"__proto__\".\n\n            if (!stateMap[key]) {\n                stateMap[key] = {\n                    nonStatic: { init: false, get: false, set: false },\n                    static: { init: false, get: false, set: false }\n                };\n            }\n\n            return stateMap[key][isStatic ? \"static\" : \"nonStatic\"];\n        }\n\n        /**\n         * Gets the name text of a given node.\n         *\n         * @param {ASTNode} node - A node to get the name.\n         * @returns {string} The name text of the node.\n         */\n        function getName(node) {\n            switch (node.type) {\n                case \"Identifier\": return node.name;\n                case \"Literal\": return String(node.value);\n\n                /* istanbul ignore next: syntax error */\n                default: return \"\";\n            }\n        }\n\n        return {\n\n            // Initializes the stack of state of member declarations.\n            Program() {\n                stack = [];\n            },\n\n            // Initializes state of member declarations for the class.\n            ClassBody() {\n                stack.push(Object.create(null));\n            },\n\n            // Disposes the state for the class.\n            \"ClassBody:exit\"() {\n                stack.pop();\n            },\n\n            // Reports the node if its name has been declared already.\n            MethodDefinition(node) {\n                if (node.computed) {\n                    return;\n                }\n\n                const name = getName(node.key);\n                const state = getState(name, node.static);\n                let isDuplicate = false;\n\n                if (node.kind === \"get\") {\n                    isDuplicate = (state.init || state.get);\n                    state.get = true;\n                } else if (node.kind === \"set\") {\n                    isDuplicate = (state.init || state.set);\n                    state.set = true;\n                } else {\n                    isDuplicate = (state.init || state.get || state.set);\n                    state.init = true;\n                }\n\n                if (isDuplicate) {\n                    context.report({ node, messageId: \"unexpected\", data: { name } });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag use of duplicate keys in an object.\n * @author Ian Christian Myers\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst GET_KIND = /^(?:init|get)$/u;\nconst SET_KIND = /^(?:init|set)$/u;\n\n/**\n * The class which stores properties' information of an object.\n */\nclass ObjectInfo {\n\n    /**\n     * @param {ObjectInfo|null} upper - The information of the outer object.\n     * @param {ASTNode} node - The ObjectExpression node of this information.\n     */\n    constructor(upper, node) {\n        this.upper = upper;\n        this.node = node;\n        this.properties = new Map();\n    }\n\n    /**\n     * Gets the information of the given Property node.\n     * @param {ASTNode} node - The Property node to get.\n     * @returns {{get: boolean, set: boolean}} The information of the property.\n     */\n    getPropertyInfo(node) {\n        const name = astUtils.getStaticPropertyName(node);\n\n        if (!this.properties.has(name)) {\n            this.properties.set(name, { get: false, set: false });\n        }\n        return this.properties.get(name);\n    }\n\n    /**\n     * Checks whether the given property has been defined already or not.\n     * @param {ASTNode} node - The Property node to check.\n     * @returns {boolean} `true` if the property has been defined.\n     */\n    isPropertyDefined(node) {\n        const entry = this.getPropertyInfo(node);\n\n        return (\n            (GET_KIND.test(node.kind) && entry.get) ||\n            (SET_KIND.test(node.kind) && entry.set)\n        );\n    }\n\n    /**\n     * Defines the given property.\n     * @param {ASTNode} node - The Property node to define.\n     * @returns {void}\n     */\n    defineProperty(node) {\n        const entry = this.getPropertyInfo(node);\n\n        if (GET_KIND.test(node.kind)) {\n            entry.get = true;\n        }\n        if (SET_KIND.test(node.kind)) {\n            entry.set = true;\n        }\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow duplicate keys in object literals\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-dupe-keys\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Duplicate key '{{name}}'.\"\n        }\n    },\n\n    create(context) {\n        let info = null;\n\n        return {\n            ObjectExpression(node) {\n                info = new ObjectInfo(info, node);\n            },\n            \"ObjectExpression:exit\"() {\n                info = info.upper;\n            },\n\n            Property(node) {\n                const name = astUtils.getStaticPropertyName(node);\n\n                // Skip destructuring.\n                if (node.parent.type !== \"ObjectExpression\") {\n                    return;\n                }\n\n                // Skip if the name is not static.\n                if (!name) {\n                    return;\n                }\n\n                // Reports if the name is defined already.\n                if (info.isPropertyDefined(node)) {\n                    context.report({\n                        node: info.node,\n                        loc: node.key.loc,\n                        messageId: \"unexpected\",\n                        data: { name }\n                    });\n                }\n\n                // Update info.\n                info.defineProperty(node);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow a duplicate case label.\n * @author Dieter Oberkofler\n * @author Burak Yigit Kaya\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow duplicate case labels\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-duplicate-case\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Duplicate case label.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            SwitchStatement(node) {\n                const mapping = {};\n\n                node.cases.forEach(switchCase => {\n                    const key = sourceCode.getText(switchCase.test);\n\n                    if (mapping[key]) {\n                        context.report({ node: switchCase, messageId: \"unexpected\" });\n                    } else {\n                        mapping[key] = switchCase;\n                    }\n                });\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Restrict usage of duplicate imports.\n * @author Simen Bekkhus\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Returns the name of the module imported or re-exported.\n *\n * @param {ASTNode} node - A node to get.\n * @returns {string} the name of the module, or empty string if no name.\n */\nfunction getValue(node) {\n    if (node && node.source && node.source.value) {\n        return node.source.value.trim();\n    }\n\n    return \"\";\n}\n\n/**\n * Checks if the name of the import or export exists in the given array, and reports if so.\n *\n * @param {RuleContext} context - The ESLint rule context object.\n * @param {ASTNode} node - A node to get.\n * @param {string} value - The name of the imported or exported module.\n * @param {string[]} array - The array containing other imports or exports in the file.\n * @param {string} messageId - A messageId to be reported after the name of the module\n *\n * @returns {void} No return value\n */\nfunction checkAndReport(context, node, value, array, messageId) {\n    if (array.indexOf(value) !== -1) {\n        context.report({\n            node,\n            messageId,\n            data: {\n                module: value\n            }\n        });\n    }\n}\n\n/**\n * @callback nodeCallback\n * @param {ASTNode} node - A node to handle.\n */\n\n/**\n * Returns a function handling the imports of a given file\n *\n * @param {RuleContext} context - The ESLint rule context object.\n * @param {boolean} includeExports - Whether or not to check for exports in addition to imports.\n * @param {string[]} importsInFile - The array containing other imports in the file.\n * @param {string[]} exportsInFile - The array containing other exports in the file.\n *\n * @returns {nodeCallback} A function passed to ESLint to handle the statement.\n */\nfunction handleImports(context, includeExports, importsInFile, exportsInFile) {\n    return function(node) {\n        const value = getValue(node);\n\n        if (value) {\n            checkAndReport(context, node, value, importsInFile, \"import\");\n\n            if (includeExports) {\n                checkAndReport(context, node, value, exportsInFile, \"importAs\");\n            }\n\n            importsInFile.push(value);\n        }\n    };\n}\n\n/**\n * Returns a function handling the exports of a given file\n *\n * @param {RuleContext} context - The ESLint rule context object.\n * @param {string[]} importsInFile - The array containing other imports in the file.\n * @param {string[]} exportsInFile - The array containing other exports in the file.\n *\n * @returns {nodeCallback} A function passed to ESLint to handle the statement.\n */\nfunction handleExports(context, importsInFile, exportsInFile) {\n    return function(node) {\n        const value = getValue(node);\n\n        if (value) {\n            checkAndReport(context, node, value, exportsInFile, \"export\");\n            checkAndReport(context, node, value, importsInFile, \"exportAs\");\n\n            exportsInFile.push(value);\n        }\n    };\n}\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow duplicate module imports\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-duplicate-imports\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                includeExports: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n        messages: {\n            import: \"'{{module}}' import is duplicated.\",\n            importAs: \"'{{module}}' import is duplicated as export.\",\n            export: \"'{{module}}' export is duplicated.\",\n            exportAs: \"'{{module}}' export is duplicated as import.\"\n        }\n    },\n\n    create(context) {\n        const includeExports = (context.options[0] || {}).includeExports,\n            importsInFile = [],\n            exportsInFile = [];\n\n        const handlers = {\n            ImportDeclaration: handleImports(context, includeExports, importsInFile, exportsInFile)\n        };\n\n        if (includeExports) {\n            handlers.ExportNamedDeclaration = handleExports(context, importsInFile, exportsInFile);\n            handlers.ExportAllDeclaration = handleExports(context, importsInFile, exportsInFile);\n        }\n\n        return handlers;\n    }\n};\n","/**\n * @fileoverview Rule to flag `else` after a `return` in `if`\n * @author Ian Christian Myers\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\nconst FixTracker = require(\"../util/fix-tracker\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `else` blocks after `return` statements in `if` statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-else-return\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowElseIf: {\n                    type: \"boolean\",\n                    default: true\n                }\n            },\n            additionalProperties: false\n        }],\n\n        fixable: \"code\",\n\n        messages: {\n            unexpected: \"Unnecessary 'else' after 'return'.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Display the context report if rule is violated\n         *\n         * @param {Node} node The 'else' node\n         * @returns {void}\n         */\n        function displayReport(node) {\n            context.report({\n                node,\n                messageId: \"unexpected\",\n                fix: fixer => {\n                    const sourceCode = context.getSourceCode();\n                    const startToken = sourceCode.getFirstToken(node);\n                    const elseToken = sourceCode.getTokenBefore(startToken);\n                    const source = sourceCode.getText(node);\n                    const lastIfToken = sourceCode.getTokenBefore(elseToken);\n                    let fixedSource, firstTokenOfElseBlock;\n\n                    if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n                        firstTokenOfElseBlock = sourceCode.getTokenAfter(startToken);\n                    } else {\n                        firstTokenOfElseBlock = startToken;\n                    }\n\n                    /*\n                     * If the if block does not have curly braces and does not end in a semicolon\n                     * and the else block starts with (, [, /, +, ` or -, then it is not\n                     * safe to remove the else keyword, because ASI will not add a semicolon\n                     * after the if block\n                     */\n                    const ifBlockMaybeUnsafe = node.parent.consequent.type !== \"BlockStatement\" && lastIfToken.value !== \";\";\n                    const elseBlockUnsafe = /^[([/+`-]/u.test(firstTokenOfElseBlock.value);\n\n                    if (ifBlockMaybeUnsafe && elseBlockUnsafe) {\n                        return null;\n                    }\n\n                    const endToken = sourceCode.getLastToken(node);\n                    const lastTokenOfElseBlock = sourceCode.getTokenBefore(endToken);\n\n                    if (lastTokenOfElseBlock.value !== \";\") {\n                        const nextToken = sourceCode.getTokenAfter(endToken);\n\n                        const nextTokenUnsafe = nextToken && /^[([/+`-]/u.test(nextToken.value);\n                        const nextTokenOnSameLine = nextToken && nextToken.loc.start.line === lastTokenOfElseBlock.loc.start.line;\n\n                        /*\n                         * If the else block contents does not end in a semicolon,\n                         * and the else block starts with (, [, /, +, ` or -, then it is not\n                         * safe to remove the else block, because ASI will not add a semicolon\n                         * after the remaining else block contents\n                         */\n                        if (nextTokenUnsafe || (nextTokenOnSameLine && nextToken.value !== \"}\")) {\n                            return null;\n                        }\n                    }\n\n                    if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n                        fixedSource = source.slice(1, -1);\n                    } else {\n                        fixedSource = source;\n                    }\n\n                    /*\n                     * Extend the replacement range to include the entire\n                     * function to avoid conflicting with no-useless-return.\n                     * https://github.com/eslint/eslint/issues/8026\n                     */\n                    return new FixTracker(fixer, sourceCode)\n                        .retainEnclosingFunction(node)\n                        .replaceTextRange([elseToken.range[0], node.range[1]], fixedSource);\n                }\n            });\n        }\n\n        /**\n         * Check to see if the node is a ReturnStatement\n         *\n         * @param {Node} node The node being evaluated\n         * @returns {boolean} True if node is a return\n         */\n        function checkForReturn(node) {\n            return node.type === \"ReturnStatement\";\n        }\n\n        /**\n         * Naive return checking, does not iterate through the whole\n         * BlockStatement because we make the assumption that the ReturnStatement\n         * will be the last node in the body of the BlockStatement.\n         *\n         * @param {Node} node The consequent/alternate node\n         * @returns {boolean} True if it has a return\n         */\n        function naiveHasReturn(node) {\n            if (node.type === \"BlockStatement\") {\n                const body = node.body,\n                    lastChildNode = body[body.length - 1];\n\n                return lastChildNode && checkForReturn(lastChildNode);\n            }\n            return checkForReturn(node);\n        }\n\n        /**\n         * Check to see if the node is valid for evaluation,\n         * meaning it has an else.\n         *\n         * @param {Node} node The node being evaluated\n         * @returns {boolean} True if the node is valid\n         */\n        function hasElse(node) {\n            return node.alternate && node.consequent;\n        }\n\n        /**\n         * If the consequent is an IfStatement, check to see if it has an else\n         * and both its consequent and alternate path return, meaning this is\n         * a nested case of rule violation.  If-Else not considered currently.\n         *\n         * @param {Node} node The consequent node\n         * @returns {boolean} True if this is a nested rule violation\n         */\n        function checkForIf(node) {\n            return node.type === \"IfStatement\" && hasElse(node) &&\n                naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);\n        }\n\n        /**\n         * Check the consequent/body node to make sure it is not\n         * a ReturnStatement or an IfStatement that returns on both\n         * code paths.\n         *\n         * @param {Node} node The consequent or body node\n         * @returns {boolean} `true` if it is a Return/If node that always returns.\n         */\n        function checkForReturnOrIf(node) {\n            return checkForReturn(node) || checkForIf(node);\n        }\n\n\n        /**\n         * Check whether a node returns in every codepath.\n         * @param {Node} node The node to be checked\n         * @returns {boolean} `true` if it returns on every codepath.\n         */\n        function alwaysReturns(node) {\n            if (node.type === \"BlockStatement\") {\n\n                // If we have a BlockStatement, check each consequent body node.\n                return node.body.some(checkForReturnOrIf);\n            }\n\n            /*\n             * If not a block statement, make sure the consequent isn't a\n             * ReturnStatement or an IfStatement with returns on both paths.\n             */\n            return checkForReturnOrIf(node);\n        }\n\n\n        /**\n         * Check the if statement, but don't catch else-if blocks.\n         * @returns {void}\n         * @param {Node} node The node for the if statement to check\n         * @private\n         */\n        function checkIfWithoutElse(node) {\n            const parent = node.parent;\n\n            /*\n             * Fixing this would require splitting one statement into two, so no error should\n             * be reported if this node is in a position where only one statement is allowed.\n             */\n            if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\n                return;\n            }\n\n            const consequents = [];\n            let alternate;\n\n            for (let currentNode = node; currentNode.type === \"IfStatement\"; currentNode = currentNode.alternate) {\n                if (!currentNode.alternate) {\n                    return;\n                }\n                consequents.push(currentNode.consequent);\n                alternate = currentNode.alternate;\n            }\n\n            if (consequents.every(alwaysReturns)) {\n                displayReport(alternate);\n            }\n        }\n\n        /**\n         * Check the if statement\n         * @returns {void}\n         * @param {Node} node The node for the if statement to check\n         * @private\n         */\n        function checkIfWithElse(node) {\n            const parent = node.parent;\n\n\n            /*\n             * Fixing this would require splitting one statement into two, so no error should\n             * be reported if this node is in a position where only one statement is allowed.\n             */\n            if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\n                return;\n            }\n\n            const alternate = node.alternate;\n\n            if (alternate && alwaysReturns(node.consequent)) {\n                displayReport(alternate);\n            }\n        }\n\n        const allowElseIf = !(context.options[0] && context.options[0].allowElseIf === false);\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            \"IfStatement:exit\": allowElseIf ? checkIfWithoutElse : checkIfWithElse\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Helper class to aid in constructing fix commands.\n * @author Alan Pierce\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A helper class to combine fix options into a fix command. Currently, it\n * exposes some \"retain\" methods that extend the range of the text being\n * replaced so that other fixes won't touch that region in the same pass.\n */\nclass FixTracker {\n\n    /**\n     * Create a new FixTracker.\n     *\n     * @param {ruleFixer} fixer A ruleFixer instance.\n     * @param {SourceCode} sourceCode A SourceCode object for the current code.\n     */\n    constructor(fixer, sourceCode) {\n        this.fixer = fixer;\n        this.sourceCode = sourceCode;\n        this.retainedRange = null;\n    }\n\n    /**\n     * Mark the given range as \"retained\", meaning that other fixes may not\n     * may not modify this region in the same pass.\n     *\n     * @param {int[]} range The range to retain.\n     * @returns {FixTracker} The same RuleFixer, for chained calls.\n     */\n    retainRange(range) {\n        this.retainedRange = range;\n        return this;\n    }\n\n    /**\n     * Given a node, find the function containing it (or the entire program) and\n     * mark it as retained, meaning that other fixes may not modify it in this\n     * pass. This is useful for avoiding conflicts in fixes that modify control\n     * flow.\n     *\n     * @param {ASTNode} node The node to use as a starting point.\n     * @returns {FixTracker} The same RuleFixer, for chained calls.\n     */\n    retainEnclosingFunction(node) {\n        const functionNode = astUtils.getUpperFunction(node);\n\n        return this.retainRange(functionNode ? functionNode.range : this.sourceCode.ast.range);\n    }\n\n    /**\n     * Given a node or token, find the token before and afterward, and mark that\n     * range as retained, meaning that other fixes may not modify it in this\n     * pass. This is useful for avoiding conflicts in fixes that make a small\n     * change to the code where the AST should not be changed.\n     *\n     * @param {ASTNode|Token} nodeOrToken The node or token to use as a starting\n     *      point. The token to the left and right are use in the range.\n     * @returns {FixTracker} The same RuleFixer, for chained calls.\n     */\n    retainSurroundingTokens(nodeOrToken) {\n        const tokenBefore = this.sourceCode.getTokenBefore(nodeOrToken) || nodeOrToken;\n        const tokenAfter = this.sourceCode.getTokenAfter(nodeOrToken) || nodeOrToken;\n\n        return this.retainRange([tokenBefore.range[0], tokenAfter.range[1]]);\n    }\n\n    /**\n     * Create a fix command that replaces the given range with the given text,\n     * accounting for any retained ranges.\n     *\n     * @param {int[]} range The range to remove in the fix.\n     * @param {string} text The text to insert in place of the range.\n     * @returns {Object} The fix command.\n     */\n    replaceTextRange(range, text) {\n        let actualRange;\n\n        if (this.retainedRange) {\n            actualRange = [\n                Math.min(this.retainedRange[0], range[0]),\n                Math.max(this.retainedRange[1], range[1])\n            ];\n        } else {\n            actualRange = range;\n        }\n\n        return this.fixer.replaceTextRange(\n            actualRange,\n            this.sourceCode.text.slice(actualRange[0], range[0]) +\n                text +\n                this.sourceCode.text.slice(range[1], actualRange[1])\n        );\n    }\n\n    /**\n     * Create a fix command that removes the given node or token, accounting for\n     * any retained ranges.\n     *\n     * @param {ASTNode|Token} nodeOrToken The node or token to remove.\n     * @returns {Object} The fix command.\n     */\n    remove(nodeOrToken) {\n        return this.replaceTextRange(nodeOrToken.range, \"\");\n    }\n}\n\nmodule.exports = FixTracker;\n","/**\n * @fileoverview Rule to flag use of an empty block statement\n * @author Nicholas C. Zakas\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow empty block statements\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-empty\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowEmptyCatch: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"Empty {{type}} statement.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {},\n            allowEmptyCatch = options.allowEmptyCatch || false;\n\n        const sourceCode = context.getSourceCode();\n\n        return {\n            BlockStatement(node) {\n\n                // if the body is not empty, we can just return immediately\n                if (node.body.length !== 0) {\n                    return;\n                }\n\n                // a function is generally allowed to be empty\n                if (astUtils.isFunction(node.parent)) {\n                    return;\n                }\n\n                if (allowEmptyCatch && node.parent.type === \"CatchClause\") {\n                    return;\n                }\n\n                // any other block is only allowed to be empty, if it contains a comment\n                if (sourceCode.getCommentsInside(node).length > 0) {\n                    return;\n                }\n\n                context.report({ node, messageId: \"unexpected\", data: { type: \"block\" } });\n            },\n\n            SwitchStatement(node) {\n\n                if (typeof node.cases === \"undefined\" || node.cases.length === 0) {\n                    context.report({ node, messageId: \"unexpected\", data: { type: \"switch\" } });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag the use of empty character classes in regular expressions\n * @author Ian Christian Myers\n */\n\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/*\n * plain-English description of the following regexp:\n * 0. `^` fix the match at the beginning of the string\n * 1. `\\/`: the `/` that begins the regexp\n * 2. `([^\\\\[]|\\\\.|\\[([^\\\\\\]]|\\\\.)+\\])*`: regexp contents; 0 or more of the following\n * 2.0. `[^\\\\[]`: any character that's not a `\\` or a `[` (anything but escape sequences and character classes)\n * 2.1. `\\\\.`: an escape sequence\n * 2.2. `\\[([^\\\\\\]]|\\\\.)+\\]`: a character class that isn't empty\n * 3. `\\/` the `/` that ends the regexp\n * 4. `[gimuy]*`: optional regexp flags\n * 5. `$`: fix the match at the end of the string\n */\nconst regex = /^\\/([^\\\\[]|\\\\.|\\[([^\\\\\\]]|\\\\.)+\\])*\\/[gimuys]*$/u;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow empty character classes in regular expressions\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-empty-character-class\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Empty class.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n\n            Literal(node) {\n                const token = sourceCode.getFirstToken(node);\n\n                if (token.type === \"RegularExpression\" && !regex.test(token.value)) {\n                    context.report({ node, messageId: \"unexpected\" });\n                }\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to disallow empty functions.\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst ALLOW_OPTIONS = Object.freeze([\n    \"functions\",\n    \"arrowFunctions\",\n    \"generatorFunctions\",\n    \"methods\",\n    \"generatorMethods\",\n    \"getters\",\n    \"setters\",\n    \"constructors\"\n]);\n\n/**\n * Gets the kind of a given function node.\n *\n * @param {ASTNode} node - A function node to get. This is one of\n *      an ArrowFunctionExpression, a FunctionDeclaration, or a\n *      FunctionExpression.\n * @returns {string} The kind of the function. This is one of \"functions\",\n *      \"arrowFunctions\", \"generatorFunctions\", \"asyncFunctions\", \"methods\",\n *      \"generatorMethods\", \"asyncMethods\", \"getters\", \"setters\", and\n *      \"constructors\".\n */\nfunction getKind(node) {\n    const parent = node.parent;\n    let kind = \"\";\n\n    if (node.type === \"ArrowFunctionExpression\") {\n        return \"arrowFunctions\";\n    }\n\n    // Detects main kind.\n    if (parent.type === \"Property\") {\n        if (parent.kind === \"get\") {\n            return \"getters\";\n        }\n        if (parent.kind === \"set\") {\n            return \"setters\";\n        }\n        kind = parent.method ? \"methods\" : \"functions\";\n\n    } else if (parent.type === \"MethodDefinition\") {\n        if (parent.kind === \"get\") {\n            return \"getters\";\n        }\n        if (parent.kind === \"set\") {\n            return \"setters\";\n        }\n        if (parent.kind === \"constructor\") {\n            return \"constructors\";\n        }\n        kind = \"methods\";\n\n    } else {\n        kind = \"functions\";\n    }\n\n    // Detects prefix.\n    let prefix = \"\";\n\n    if (node.generator) {\n        prefix = \"generator\";\n    } else if (node.async) {\n        prefix = \"async\";\n    } else {\n        return kind;\n    }\n    return prefix + kind[0].toUpperCase() + kind.slice(1);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow empty functions\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-empty-function\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allow: {\n                        type: \"array\",\n                        items: { enum: ALLOW_OPTIONS },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"Unexpected empty {{name}}.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const allowed = options.allow || [];\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports a given function node if the node matches the following patterns.\n         *\n         * - Not allowed by options.\n         * - The body is empty.\n         * - The body doesn't have any comments.\n         *\n         * @param {ASTNode} node - A function node to report. This is one of\n         *      an ArrowFunctionExpression, a FunctionDeclaration, or a\n         *      FunctionExpression.\n         * @returns {void}\n         */\n        function reportIfEmpty(node) {\n            const kind = getKind(node);\n            const name = astUtils.getFunctionNameWithKind(node);\n            const innerComments = sourceCode.getTokens(node.body, {\n                includeComments: true,\n                filter: astUtils.isCommentToken\n            });\n\n            if (allowed.indexOf(kind) === -1 &&\n                node.body.type === \"BlockStatement\" &&\n                node.body.body.length === 0 &&\n                innerComments.length === 0\n            ) {\n                context.report({\n                    node,\n                    loc: node.body.loc.start,\n                    messageId: \"unexpected\",\n                    data: { name }\n                });\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: reportIfEmpty,\n            FunctionDeclaration: reportIfEmpty,\n            FunctionExpression: reportIfEmpty\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow an empty pattern\n * @author Alberto Rodríguez\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow empty destructuring patterns\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-empty-pattern\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Unexpected empty {{type}} pattern.\"\n        }\n    },\n\n    create(context) {\n        return {\n            ObjectPattern(node) {\n                if (node.properties.length === 0) {\n                    context.report({ node, messageId: \"unexpected\", data: { type: \"object\" } });\n                }\n            },\n            ArrayPattern(node) {\n                if (node.elements.length === 0) {\n                    context.report({ node, messageId: \"unexpected\", data: { type: \"array\" } });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag comparisons to null without a type-checking\n * operator.\n * @author Ian Christian Myers\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `null` comparisons without type-checking operators\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-eq-null\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Use '===' to compare with null.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n\n            BinaryExpression(node) {\n                const badOperator = node.operator === \"==\" || node.operator === \"!=\";\n\n                if (node.right.type === \"Literal\" && node.right.raw === \"null\" && badOperator ||\n                        node.left.type === \"Literal\" && node.left.raw === \"null\" && badOperator) {\n                    context.report({ node, messageId: \"unexpected\" });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use of eval() statement\n * @author Nicholas C. Zakas\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst candidatesOfGlobalObject = Object.freeze([\n    \"global\",\n    \"window\"\n]);\n\n/**\n * Checks a given node is a Identifier node of the specified name.\n *\n * @param {ASTNode} node - A node to check.\n * @param {string} name - A name to check.\n * @returns {boolean} `true` if the node is a Identifier node of the name.\n */\nfunction isIdentifier(node, name) {\n    return node.type === \"Identifier\" && node.name === name;\n}\n\n/**\n * Checks a given node is a Literal node of the specified string value.\n *\n * @param {ASTNode} node - A node to check.\n * @param {string} name - A name to check.\n * @returns {boolean} `true` if the node is a Literal node of the name.\n */\nfunction isConstant(node, name) {\n    switch (node.type) {\n        case \"Literal\":\n            return node.value === name;\n\n        case \"TemplateLiteral\":\n            return (\n                node.expressions.length === 0 &&\n                node.quasis[0].value.cooked === name\n            );\n\n        default:\n            return false;\n    }\n}\n\n/**\n * Checks a given node is a MemberExpression node which has the specified name's\n * property.\n *\n * @param {ASTNode} node - A node to check.\n * @param {string} name - A name to check.\n * @returns {boolean} `true` if the node is a MemberExpression node which has\n *      the specified name's property\n */\nfunction isMember(node, name) {\n    return (\n        node.type === \"MemberExpression\" &&\n        (node.computed ? isConstant : isIdentifier)(node.property, name)\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `eval()`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-eval\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowIndirect: { type: \"boolean\", default: false }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"eval can be harmful.\"\n        }\n    },\n\n    create(context) {\n        const allowIndirect = Boolean(\n            context.options[0] &&\n            context.options[0].allowIndirect\n        );\n        const sourceCode = context.getSourceCode();\n        let funcInfo = null;\n\n        /**\n         * Pushs a variable scope (Program or Function) information to the stack.\n         *\n         * This is used in order to check whether or not `this` binding is a\n         * reference to the global object.\n         *\n         * @param {ASTNode} node - A node of the scope. This is one of Program,\n         *      FunctionDeclaration, FunctionExpression, and ArrowFunctionExpression.\n         * @returns {void}\n         */\n        function enterVarScope(node) {\n            const strict = context.getScope().isStrict;\n\n            funcInfo = {\n                upper: funcInfo,\n                node,\n                strict,\n                defaultThis: false,\n                initialized: strict\n            };\n        }\n\n        /**\n         * Pops a variable scope from the stack.\n         *\n         * @returns {void}\n         */\n        function exitVarScope() {\n            funcInfo = funcInfo.upper;\n        }\n\n        /**\n         * Reports a given node.\n         *\n         * `node` is `Identifier` or `MemberExpression`.\n         * The parent of `node` might be `CallExpression`.\n         *\n         * The location of the report is always `eval` `Identifier` (or possibly\n         * `Literal`). The type of the report is `CallExpression` if the parent is\n         * `CallExpression`. Otherwise, it's the given node type.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            const parent = node.parent;\n            const locationNode = node.type === \"MemberExpression\"\n                ? node.property\n                : node;\n\n            const reportNode = parent.type === \"CallExpression\" && parent.callee === node\n                ? parent\n                : node;\n\n            context.report({\n                node: reportNode,\n                loc: locationNode.loc.start,\n                messageId: \"unexpected\"\n            });\n        }\n\n        /**\n         * Reports accesses of `eval` via the global object.\n         *\n         * @param {eslint-scope.Scope} globalScope - The global scope.\n         * @returns {void}\n         */\n        function reportAccessingEvalViaGlobalObject(globalScope) {\n            for (let i = 0; i < candidatesOfGlobalObject.length; ++i) {\n                const name = candidatesOfGlobalObject[i];\n                const variable = astUtils.getVariableByName(globalScope, name);\n\n                if (!variable) {\n                    continue;\n                }\n\n                const references = variable.references;\n\n                for (let j = 0; j < references.length; ++j) {\n                    const identifier = references[j].identifier;\n                    let node = identifier.parent;\n\n                    // To detect code like `window.window.eval`.\n                    while (isMember(node, name)) {\n                        node = node.parent;\n                    }\n\n                    // Reports.\n                    if (isMember(node, \"eval\")) {\n                        report(node);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Reports all accesses of `eval` (excludes direct calls to eval).\n         *\n         * @param {eslint-scope.Scope} globalScope - The global scope.\n         * @returns {void}\n         */\n        function reportAccessingEval(globalScope) {\n            const variable = astUtils.getVariableByName(globalScope, \"eval\");\n\n            if (!variable) {\n                return;\n            }\n\n            const references = variable.references;\n\n            for (let i = 0; i < references.length; ++i) {\n                const reference = references[i];\n                const id = reference.identifier;\n\n                if (id.name === \"eval\" && !astUtils.isCallee(id)) {\n\n                    // Is accessing to eval (excludes direct calls to eval)\n                    report(id);\n                }\n            }\n        }\n\n        if (allowIndirect) {\n\n            // Checks only direct calls to eval. It's simple!\n            return {\n                \"CallExpression:exit\"(node) {\n                    const callee = node.callee;\n\n                    if (isIdentifier(callee, \"eval\")) {\n                        report(callee);\n                    }\n                }\n            };\n        }\n\n        return {\n            \"CallExpression:exit\"(node) {\n                const callee = node.callee;\n\n                if (isIdentifier(callee, \"eval\")) {\n                    report(callee);\n                }\n            },\n\n            Program(node) {\n                const scope = context.getScope(),\n                    features = context.parserOptions.ecmaFeatures || {},\n                    strict =\n                        scope.isStrict ||\n                        node.sourceType === \"module\" ||\n                        (features.globalReturn && scope.childScopes[0].isStrict);\n\n                funcInfo = {\n                    upper: null,\n                    node,\n                    strict,\n                    defaultThis: true,\n                    initialized: true\n                };\n            },\n\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n\n                exitVarScope();\n                reportAccessingEval(globalScope);\n                reportAccessingEvalViaGlobalObject(globalScope);\n            },\n\n            FunctionDeclaration: enterVarScope,\n            \"FunctionDeclaration:exit\": exitVarScope,\n            FunctionExpression: enterVarScope,\n            \"FunctionExpression:exit\": exitVarScope,\n            ArrowFunctionExpression: enterVarScope,\n            \"ArrowFunctionExpression:exit\": exitVarScope,\n\n            ThisExpression(node) {\n                if (!isMember(node.parent, \"eval\")) {\n                    return;\n                }\n\n                /*\n                 * `this.eval` is found.\n                 * Checks whether or not the value of `this` is the global object.\n                 */\n                if (!funcInfo.initialized) {\n                    funcInfo.initialized = true;\n                    funcInfo.defaultThis = astUtils.isDefaultThisBinding(\n                        funcInfo.node,\n                        sourceCode\n                    );\n                }\n\n                if (!funcInfo.strict && funcInfo.defaultThis) {\n\n                    // `this.eval` is possible built-in `eval`.\n                    report(node.parent);\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag assignment of the exception parameter\n * @author Stephen Murray <spmurrayzzz>\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow reassigning exceptions in `catch` clauses\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-ex-assign\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Do not assign to the exception parameter.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable - A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            astUtils.getModifyingReferences(variable.references).forEach(reference => {\n                context.report({ node: reference.identifier, messageId: \"unexpected\" });\n            });\n        }\n\n        return {\n            CatchClause(node) {\n                context.getDeclaredVariables(node).forEach(checkVariable);\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag adding properties to native object's prototypes.\n * @author David Nelson\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\nconst globals = require(\"globals\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst propertyDefinitionMethods = new Set([\"defineProperty\", \"defineProperties\"]);\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow extending native types\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-extend-native\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"{{builtin}} prototype is read only, properties should not be added.\"\n        }\n    },\n\n    create(context) {\n\n        const config = context.options[0] || {};\n        const exceptions = new Set(config.exceptions || []);\n        const modifiedBuiltins = new Set(\n            Object.keys(globals.builtin)\n                .filter(builtin => builtin[0].toUpperCase() === builtin[0])\n                .filter(builtin => !exceptions.has(builtin))\n        );\n\n        /**\n         * Reports a lint error for the given node.\n         * @param {ASTNode} node The node to report.\n         * @param {string} builtin The name of the native builtin being extended.\n         * @returns {void}\n         */\n        function reportNode(node, builtin) {\n            context.report({\n                node,\n                messageId: \"unexpected\",\n                data: {\n                    builtin\n                }\n            });\n        }\n\n        /**\n         * Check to see if the `prototype` property of the given object\n         * identifier node is being accessed.\n         * @param {ASTNode} identifierNode The Identifier representing the object\n         * to check.\n         * @returns {boolean} True if the identifier is the object of a\n         * MemberExpression and its `prototype` property is being accessed,\n         * false otherwise.\n         */\n        function isPrototypePropertyAccessed(identifierNode) {\n            return Boolean(\n                identifierNode &&\n                identifierNode.parent &&\n                identifierNode.parent.type === \"MemberExpression\" &&\n                identifierNode.parent.object === identifierNode &&\n                astUtils.getStaticPropertyName(identifierNode.parent) === \"prototype\"\n            );\n        }\n\n        /**\n         * Checks that an identifier is an object of a prototype whose member\n         * is being assigned in an AssignmentExpression.\n         * Example: Object.prototype.foo = \"bar\"\n         * @param {ASTNode} identifierNode The identifier to check.\n         * @returns {boolean} True if the identifier's prototype is modified.\n         */\n        function isInPrototypePropertyAssignment(identifierNode) {\n            return Boolean(\n                isPrototypePropertyAccessed(identifierNode) &&\n                identifierNode.parent.parent.type === \"MemberExpression\" &&\n                identifierNode.parent.parent.parent.type === \"AssignmentExpression\" &&\n                identifierNode.parent.parent.parent.left === identifierNode.parent.parent\n            );\n        }\n\n        /**\n         * Checks that an identifier is an object of a prototype whose member\n         * is being extended via the Object.defineProperty() or\n         * Object.defineProperties() methods.\n         * Example: Object.defineProperty(Array.prototype, \"foo\", ...)\n         * Example: Object.defineProperties(Array.prototype, ...)\n         * @param {ASTNode} identifierNode The identifier to check.\n         * @returns {boolean} True if the identifier's prototype is modified.\n         */\n        function isInDefinePropertyCall(identifierNode) {\n            return Boolean(\n                isPrototypePropertyAccessed(identifierNode) &&\n                identifierNode.parent.parent.type === \"CallExpression\" &&\n                identifierNode.parent.parent.arguments[0] === identifierNode.parent &&\n                identifierNode.parent.parent.callee.type === \"MemberExpression\" &&\n                identifierNode.parent.parent.callee.object.type === \"Identifier\" &&\n                identifierNode.parent.parent.callee.object.name === \"Object\" &&\n                identifierNode.parent.parent.callee.property.type === \"Identifier\" &&\n                propertyDefinitionMethods.has(identifierNode.parent.parent.callee.property.name)\n            );\n        }\n\n        /**\n         * Check to see if object prototype access is part of a prototype\n         * extension. There are three ways a prototype can be extended:\n         * 1. Assignment to prototype property (Object.prototype.foo = 1)\n         * 2. Object.defineProperty()/Object.defineProperties() on a prototype\n         * If prototype extension is detected, report the AssignmentExpression\n         * or CallExpression node.\n         * @param {ASTNode} identifierNode The Identifier representing the object\n         * which prototype is being accessed and possibly extended.\n         * @returns {void}\n         */\n        function checkAndReportPrototypeExtension(identifierNode) {\n            if (isInPrototypePropertyAssignment(identifierNode)) {\n\n                // Identifier --> MemberExpression --> MemberExpression --> AssignmentExpression\n                reportNode(identifierNode.parent.parent.parent, identifierNode.name);\n            } else if (isInDefinePropertyCall(identifierNode)) {\n\n                // Identifier --> MemberExpression --> CallExpression\n                reportNode(identifierNode.parent.parent, identifierNode.name);\n            }\n        }\n\n        return {\n\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n\n                modifiedBuiltins.forEach(builtin => {\n                    const builtinVar = globalScope.set.get(builtin);\n\n                    if (builtinVar && builtinVar.references) {\n                        builtinVar.references\n                            .map(ref => ref.identifier)\n                            .forEach(checkAndReportPrototypeExtension);\n                    }\n                });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag unnecessary bind calls\n * @author Bence Dányi <bence@danyi.me>\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SIDE_EFFECT_FREE_NODE_TYPES = new Set([\"Literal\", \"Identifier\", \"ThisExpression\", \"FunctionExpression\"]);\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary calls to `.bind()`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-extra-bind\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            unexpected: \"The function binding is unnecessary.\"\n        }\n    },\n\n    create(context) {\n        let scopeInfo = null;\n\n        /**\n         * Checks if a node is free of side effects.\n         *\n         * This check is stricter than it needs to be, in order to keep the implementation simple.\n         *\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} True if the node is known to be side-effect free, false otherwise.\n         */\n        function isSideEffectFree(node) {\n            return SIDE_EFFECT_FREE_NODE_TYPES.has(node.type);\n        }\n\n        /**\n         * Reports a given function node.\n         *\n         * @param {ASTNode} node - A node to report. This is a FunctionExpression or\n         *      an ArrowFunctionExpression.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node: node.parent.parent,\n                messageId: \"unexpected\",\n                loc: node.parent.property.loc.start,\n                fix(fixer) {\n                    if (node.parent.parent.arguments.length && !isSideEffectFree(node.parent.parent.arguments[0])) {\n                        return null;\n                    }\n\n                    const firstTokenToRemove = context.getSourceCode()\n                        .getFirstTokenBetween(node.parent.object, node.parent.property, astUtils.isNotClosingParenToken);\n\n                    return fixer.removeRange([firstTokenToRemove.range[0], node.parent.parent.range[1]]);\n                }\n            });\n        }\n\n        /**\n         * Checks whether or not a given function node is the callee of `.bind()`\n         * method.\n         *\n         * e.g. `(function() {}.bind(foo))`\n         *\n         * @param {ASTNode} node - A node to report. This is a FunctionExpression or\n         *      an ArrowFunctionExpression.\n         * @returns {boolean} `true` if the node is the callee of `.bind()` method.\n         */\n        function isCalleeOfBindMethod(node) {\n            const parent = node.parent;\n            const grandparent = parent.parent;\n\n            return (\n                grandparent &&\n                grandparent.type === \"CallExpression\" &&\n                grandparent.callee === parent &&\n                grandparent.arguments.length === 1 &&\n                parent.type === \"MemberExpression\" &&\n                parent.object === node &&\n                astUtils.getStaticPropertyName(parent) === \"bind\"\n            );\n        }\n\n        /**\n         * Adds a scope information object to the stack.\n         *\n         * @param {ASTNode} node - A node to add. This node is a FunctionExpression\n         *      or a FunctionDeclaration node.\n         * @returns {void}\n         */\n        function enterFunction(node) {\n            scopeInfo = {\n                isBound: isCalleeOfBindMethod(node),\n                thisFound: false,\n                upper: scopeInfo\n            };\n        }\n\n        /**\n         * Removes the scope information object from the top of the stack.\n         * At the same time, this reports the function node if the function has\n         * `.bind()` and the `this` keywords found.\n         *\n         * @param {ASTNode} node - A node to remove. This node is a\n         *      FunctionExpression or a FunctionDeclaration node.\n         * @returns {void}\n         */\n        function exitFunction(node) {\n            if (scopeInfo.isBound && !scopeInfo.thisFound) {\n                report(node);\n            }\n\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Reports a given arrow function if the function is callee of `.bind()`\n         * method.\n         *\n         * @param {ASTNode} node - A node to report. This node is an\n         *      ArrowFunctionExpression.\n         * @returns {void}\n         */\n        function exitArrowFunction(node) {\n            if (isCalleeOfBindMethod(node)) {\n                report(node);\n            }\n        }\n\n        /**\n         * Set the mark as the `this` keyword was found in this scope.\n         *\n         * @returns {void}\n         */\n        function markAsThisFound() {\n            if (scopeInfo) {\n                scopeInfo.thisFound = true;\n            }\n        }\n\n        return {\n            \"ArrowFunctionExpression:exit\": exitArrowFunction,\n            FunctionDeclaration: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            FunctionExpression: enterFunction,\n            \"FunctionExpression:exit\": exitFunction,\n            ThisExpression: markAsThisFound\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag unnecessary double negation in Boolean contexts\n * @author Brandon Mills\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary boolean casts\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-extra-boolean-cast\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            unexpectedCall: \"Redundant Boolean call.\",\n            unexpectedNegation: \"Redundant double negation.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        // Node types which have a test which will coerce values to booleans.\n        const BOOLEAN_NODE_TYPES = [\n            \"IfStatement\",\n            \"DoWhileStatement\",\n            \"WhileStatement\",\n            \"ConditionalExpression\",\n            \"ForStatement\"\n        ];\n\n        /**\n         * Check if a node is in a context where its value would be coerced to a boolean at runtime.\n         *\n         * @param {Object} node The node\n         * @param {Object} parent Its parent\n         * @returns {boolean} If it is in a boolean context\n         */\n        function isInBooleanContext(node, parent) {\n            return (\n                (BOOLEAN_NODE_TYPES.indexOf(parent.type) !== -1 &&\n                    node === parent.test) ||\n\n                // !<bool>\n                (parent.type === \"UnaryExpression\" &&\n                    parent.operator === \"!\")\n            );\n        }\n\n\n        return {\n            UnaryExpression(node) {\n                const ancestors = context.getAncestors(),\n                    parent = ancestors.pop(),\n                    grandparent = ancestors.pop();\n\n                // Exit early if it's guaranteed not to match\n                if (node.operator !== \"!\" ||\n                        parent.type !== \"UnaryExpression\" ||\n                        parent.operator !== \"!\") {\n                    return;\n                }\n\n                if (isInBooleanContext(parent, grandparent) ||\n\n                    // Boolean(<bool>) and new Boolean(<bool>)\n                    ((grandparent.type === \"CallExpression\" || grandparent.type === \"NewExpression\") &&\n                        grandparent.callee.type === \"Identifier\" &&\n                        grandparent.callee.name === \"Boolean\")\n                ) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedNegation\",\n                        fix: fixer => fixer.replaceText(parent, sourceCode.getText(node.argument))\n                    });\n                }\n            },\n            CallExpression(node) {\n                const parent = node.parent;\n\n                if (node.callee.type !== \"Identifier\" || node.callee.name !== \"Boolean\") {\n                    return;\n                }\n\n                if (isInBooleanContext(node, parent)) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedCall\",\n                        fix: fixer => {\n                            if (!node.arguments.length) {\n                                return fixer.replaceText(parent, \"true\");\n                            }\n\n                            if (node.arguments.length > 1 || node.arguments[0].type === \"SpreadElement\") {\n                                return null;\n                            }\n\n                            const argument = node.arguments[0];\n\n                            if (astUtils.getPrecedence(argument) < astUtils.getPrecedence(node.parent)) {\n                                return fixer.replaceText(node, `(${sourceCode.getText(argument)})`);\n                            }\n                            return fixer.replaceText(node, sourceCode.getText(argument));\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to disallow unnecessary labels\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary labels\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-extra-label\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            unexpected: \"This label '{{name}}' is unnecessary.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        let scopeInfo = null;\n\n        /**\n         * Creates a new scope with a breakable statement.\n         *\n         * @param {ASTNode} node - A node to create. This is a BreakableStatement.\n         * @returns {void}\n         */\n        function enterBreakableStatement(node) {\n            scopeInfo = {\n                label: node.parent.type === \"LabeledStatement\" ? node.parent.label : null,\n                breakable: true,\n                upper: scopeInfo\n            };\n        }\n\n        /**\n         * Removes the top scope of the stack.\n         *\n         * @returns {void}\n         */\n        function exitBreakableStatement() {\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Creates a new scope with a labeled statement.\n         *\n         * This ignores it if the body is a breakable statement.\n         * In this case it's handled in the `enterBreakableStatement` function.\n         *\n         * @param {ASTNode} node - A node to create. This is a LabeledStatement.\n         * @returns {void}\n         */\n        function enterLabeledStatement(node) {\n            if (!astUtils.isBreakableStatement(node.body)) {\n                scopeInfo = {\n                    label: node.label,\n                    breakable: false,\n                    upper: scopeInfo\n                };\n            }\n        }\n\n        /**\n         * Removes the top scope of the stack.\n         *\n         * This ignores it if the body is a breakable statement.\n         * In this case it's handled in the `exitBreakableStatement` function.\n         *\n         * @param {ASTNode} node - A node. This is a LabeledStatement.\n         * @returns {void}\n         */\n        function exitLabeledStatement(node) {\n            if (!astUtils.isBreakableStatement(node.body)) {\n                scopeInfo = scopeInfo.upper;\n            }\n        }\n\n        /**\n         * Reports a given control node if it's unnecessary.\n         *\n         * @param {ASTNode} node - A node. This is a BreakStatement or a\n         *      ContinueStatement.\n         * @returns {void}\n         */\n        function reportIfUnnecessary(node) {\n            if (!node.label) {\n                return;\n            }\n\n            const labelNode = node.label;\n\n            for (let info = scopeInfo; info !== null; info = info.upper) {\n                if (info.breakable || info.label && info.label.name === labelNode.name) {\n                    if (info.breakable && info.label && info.label.name === labelNode.name) {\n                        context.report({\n                            node: labelNode,\n                            messageId: \"unexpected\",\n                            data: labelNode,\n                            fix: fixer => fixer.removeRange([sourceCode.getFirstToken(node).range[1], labelNode.range[1]])\n                        });\n                    }\n                    return;\n                }\n            }\n        }\n\n        return {\n            WhileStatement: enterBreakableStatement,\n            \"WhileStatement:exit\": exitBreakableStatement,\n            DoWhileStatement: enterBreakableStatement,\n            \"DoWhileStatement:exit\": exitBreakableStatement,\n            ForStatement: enterBreakableStatement,\n            \"ForStatement:exit\": exitBreakableStatement,\n            ForInStatement: enterBreakableStatement,\n            \"ForInStatement:exit\": exitBreakableStatement,\n            ForOfStatement: enterBreakableStatement,\n            \"ForOfStatement:exit\": exitBreakableStatement,\n            SwitchStatement: enterBreakableStatement,\n            \"SwitchStatement:exit\": exitBreakableStatement,\n            LabeledStatement: enterLabeledStatement,\n            \"LabeledStatement:exit\": exitLabeledStatement,\n            BreakStatement: reportIfUnnecessary,\n            ContinueStatement: reportIfUnnecessary\n        };\n    }\n};\n","/**\n * @fileoverview Disallow parenthesising higher precedence subexpressions.\n * @author Michael Ficarra\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils.js\");\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow unnecessary parentheses\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-extra-parens\"\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"functions\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"all\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                conditionalAssign: { type: \"boolean\" },\n                                nestedBinaryExpressions: { type: \"boolean\" },\n                                returnAssign: { type: \"boolean\" },\n                                ignoreJSX: { enum: [\"none\", \"all\", \"single-line\", \"multi-line\"] },\n                                enforceForArrowConditionals: { type: \"boolean\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        messages: {\n            unexpected: \"Unnecessary parentheses around expression.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const tokensToIgnore = new WeakSet();\n        const isParenthesised = astUtils.isParenthesised.bind(astUtils, sourceCode);\n        const precedence = astUtils.getPrecedence;\n        const ALL_NODES = context.options[0] !== \"functions\";\n        const EXCEPT_COND_ASSIGN = ALL_NODES && context.options[1] && context.options[1].conditionalAssign === false;\n        const NESTED_BINARY = ALL_NODES && context.options[1] && context.options[1].nestedBinaryExpressions === false;\n        const EXCEPT_RETURN_ASSIGN = ALL_NODES && context.options[1] && context.options[1].returnAssign === false;\n        const IGNORE_JSX = ALL_NODES && context.options[1] && context.options[1].ignoreJSX;\n        const IGNORE_ARROW_CONDITIONALS = ALL_NODES && context.options[1] &&\n            context.options[1].enforceForArrowConditionals === false;\n\n        const PRECEDENCE_OF_ASSIGNMENT_EXPR = precedence({ type: \"AssignmentExpression\" });\n        const PRECEDENCE_OF_UPDATE_EXPR = precedence({ type: \"UpdateExpression\" });\n\n        /**\n         * Determines if this rule should be enforced for a node given the current configuration.\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the rule should be enforced for this node.\n         * @private\n         */\n        function ruleApplies(node) {\n            if (node.type === \"JSXElement\" || node.type === \"JSXFragment\") {\n                const isSingleLine = node.loc.start.line === node.loc.end.line;\n\n                switch (IGNORE_JSX) {\n\n                    // Exclude this JSX element from linting\n                    case \"all\":\n                        return false;\n\n                    // Exclude this JSX element if it is multi-line element\n                    case \"multi-line\":\n                        return isSingleLine;\n\n                    // Exclude this JSX element if it is single-line element\n                    case \"single-line\":\n                        return !isSingleLine;\n\n                    // Nothing special to be done for JSX elements\n                    case \"none\":\n                        break;\n\n                    // no default\n                }\n            }\n\n            return ALL_NODES || node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\";\n        }\n\n        /**\n         * Determines if a node is surrounded by parentheses twice.\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the node is doubly parenthesised.\n         * @private\n         */\n        function isParenthesisedTwice(node) {\n            const previousToken = sourceCode.getTokenBefore(node, 1),\n                nextToken = sourceCode.getTokenAfter(node, 1);\n\n            return isParenthesised(node) && previousToken && nextToken &&\n                astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] &&\n                astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\n        }\n\n        /**\n         * Determines if a node is surrounded by (potentially) invalid parentheses.\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the node is incorrectly parenthesised.\n         * @private\n         */\n        function hasExcessParens(node) {\n            return ruleApplies(node) && isParenthesised(node);\n        }\n\n        /**\n         * Determines if a node that is expected to be parenthesised is surrounded by\n         * (potentially) invalid extra parentheses.\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.\n         * @private\n         */\n        function hasDoubleExcessParens(node) {\n            return ruleApplies(node) && isParenthesisedTwice(node);\n        }\n\n        /**\n         * Determines if a node test expression is allowed to have a parenthesised assignment\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the assignment can be parenthesised.\n         * @private\n         */\n        function isCondAssignException(node) {\n            return EXCEPT_COND_ASSIGN && node.test.type === \"AssignmentExpression\";\n        }\n\n        /**\n         * Determines if a node is in a return statement\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the node is in a return statement.\n         * @private\n         */\n        function isInReturnStatement(node) {\n            for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n                if (\n                    currentNode.type === \"ReturnStatement\" ||\n                    (currentNode.type === \"ArrowFunctionExpression\" && currentNode.body.type !== \"BlockStatement\")\n                ) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a constructor function is newed-up with parens\n         * @param {ASTNode} newExpression - The NewExpression node to be checked.\n         * @returns {boolean} True if the constructor is called with parens.\n         * @private\n         */\n        function isNewExpressionWithParens(newExpression) {\n            const lastToken = sourceCode.getLastToken(newExpression);\n            const penultimateToken = sourceCode.getTokenBefore(lastToken);\n\n            return newExpression.arguments.length > 0 || astUtils.isOpeningParenToken(penultimateToken) && astUtils.isClosingParenToken(lastToken);\n        }\n\n        /**\n         * Determines if a node is or contains an assignment expression\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the node is or contains an assignment expression.\n         * @private\n         */\n        function containsAssignment(node) {\n            if (node.type === \"AssignmentExpression\") {\n                return true;\n            }\n            if (node.type === \"ConditionalExpression\" &&\n                    (node.consequent.type === \"AssignmentExpression\" || node.alternate.type === \"AssignmentExpression\")) {\n                return true;\n            }\n            if ((node.left && node.left.type === \"AssignmentExpression\") ||\n                    (node.right && node.right.type === \"AssignmentExpression\")) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a node is contained by or is itself a return statement and is allowed to have a parenthesised assignment\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the assignment can be parenthesised.\n         * @private\n         */\n        function isReturnAssignException(node) {\n            if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) {\n                return false;\n            }\n\n            if (node.type === \"ReturnStatement\") {\n                return node.argument && containsAssignment(node.argument);\n            }\n            if (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") {\n                return containsAssignment(node.body);\n            }\n            return containsAssignment(node);\n\n        }\n\n        /**\n         * Determines if a node following a [no LineTerminator here] restriction is\n         * surrounded by (potentially) invalid extra parentheses.\n         * @param {Token} token - The token preceding the [no LineTerminator here] restriction.\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the node is incorrectly parenthesised.\n         * @private\n         */\n        function hasExcessParensNoLineTerminator(token, node) {\n            if (token.loc.end.line === node.loc.start.line) {\n                return hasExcessParens(node);\n            }\n\n            return hasDoubleExcessParens(node);\n        }\n\n        /**\n         * Determines whether a node should be preceded by an additional space when removing parens\n         * @param {ASTNode} node node to evaluate; must be surrounded by parentheses\n         * @returns {boolean} `true` if a space should be inserted before the node\n         * @private\n         */\n        function requiresLeadingSpace(node) {\n            const leftParenToken = sourceCode.getTokenBefore(node);\n            const tokenBeforeLeftParen = sourceCode.getTokenBefore(node, 1);\n            const firstToken = sourceCode.getFirstToken(node);\n\n            return tokenBeforeLeftParen &&\n                tokenBeforeLeftParen.range[1] === leftParenToken.range[0] &&\n                leftParenToken.range[1] === firstToken.range[0] &&\n                !astUtils.canTokensBeAdjacent(tokenBeforeLeftParen, firstToken);\n        }\n\n        /**\n         * Determines whether a node should be followed by an additional space when removing parens\n         * @param {ASTNode} node node to evaluate; must be surrounded by parentheses\n         * @returns {boolean} `true` if a space should be inserted after the node\n         * @private\n         */\n        function requiresTrailingSpace(node) {\n            const nextTwoTokens = sourceCode.getTokensAfter(node, { count: 2 });\n            const rightParenToken = nextTwoTokens[0];\n            const tokenAfterRightParen = nextTwoTokens[1];\n            const tokenBeforeRightParen = sourceCode.getLastToken(node);\n\n            return rightParenToken && tokenAfterRightParen &&\n                !sourceCode.isSpaceBetweenTokens(rightParenToken, tokenAfterRightParen) &&\n                !astUtils.canTokensBeAdjacent(tokenBeforeRightParen, tokenAfterRightParen);\n        }\n\n        /**\n         * Determines if a given expression node is an IIFE\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} `true` if the given node is an IIFE\n         */\n        function isIIFE(node) {\n            return node.type === \"CallExpression\" && node.callee.type === \"FunctionExpression\";\n        }\n\n        /**\n         * Report the node\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            const leftParenToken = sourceCode.getTokenBefore(node);\n            const rightParenToken = sourceCode.getTokenAfter(node);\n\n            if (!isParenthesisedTwice(node)) {\n                if (tokensToIgnore.has(sourceCode.getFirstToken(node))) {\n                    return;\n                }\n\n                if (isIIFE(node) && !isParenthesised(node.callee)) {\n                    return;\n                }\n            }\n\n            context.report({\n                node,\n                loc: leftParenToken.loc.start,\n                messageId: \"unexpected\",\n                fix(fixer) {\n                    const parenthesizedSource = sourceCode.text.slice(leftParenToken.range[1], rightParenToken.range[0]);\n\n                    return fixer.replaceTextRange([\n                        leftParenToken.range[0],\n                        rightParenToken.range[1]\n                    ], (requiresLeadingSpace(node) ? \" \" : \"\") + parenthesizedSource + (requiresTrailingSpace(node) ? \" \" : \"\"));\n                }\n            });\n        }\n\n        /**\n         * Evaluate Unary update\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkUnaryUpdate(node) {\n            if (node.type === \"UnaryExpression\" && node.argument.type === \"BinaryExpression\" && node.argument.operator === \"**\") {\n                return;\n            }\n\n            if (hasExcessParens(node.argument) && precedence(node.argument) >= precedence(node)) {\n                report(node.argument);\n            }\n        }\n\n        /**\n         * Check if a member expression contains a call expression\n         * @param {ASTNode} node MemberExpression node to evaluate\n         * @returns {boolean} true if found, false if not\n         */\n        function doesMemberExpressionContainCallExpression(node) {\n            let currentNode = node.object;\n            let currentNodeType = node.object.type;\n\n            while (currentNodeType === \"MemberExpression\") {\n                currentNode = currentNode.object;\n                currentNodeType = currentNode.type;\n            }\n\n            return currentNodeType === \"CallExpression\";\n        }\n\n        /**\n         * Evaluate a new call\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkCallNew(node) {\n            const callee = node.callee;\n\n            if (hasExcessParens(callee) && precedence(callee) >= precedence(node)) {\n                const hasNewParensException = callee.type === \"NewExpression\" && !isNewExpressionWithParens(callee);\n\n                if (\n                    hasDoubleExcessParens(callee) ||\n                    !isIIFE(node) && !hasNewParensException && !(\n\n                        /*\n                         * Allow extra parens around a new expression if\n                         * there are intervening parentheses.\n                         */\n                        (callee.type === \"MemberExpression\" && doesMemberExpressionContainCallExpression(callee))\n                    )\n                ) {\n                    report(node.callee);\n                }\n            }\n            if (node.arguments.length === 1) {\n                if (hasDoubleExcessParens(node.arguments[0]) && precedence(node.arguments[0]) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n                    report(node.arguments[0]);\n                }\n            } else {\n                node.arguments\n                    .filter(arg => hasExcessParens(arg) && precedence(arg) >= PRECEDENCE_OF_ASSIGNMENT_EXPR)\n                    .forEach(report);\n            }\n        }\n\n        /**\n         * Evaluate binary logicals\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkBinaryLogical(node) {\n            const prec = precedence(node);\n            const leftPrecedence = precedence(node.left);\n            const rightPrecedence = precedence(node.right);\n            const isExponentiation = node.operator === \"**\";\n            const shouldSkipLeft = (NESTED_BINARY && (node.left.type === \"BinaryExpression\" || node.left.type === \"LogicalExpression\")) ||\n              node.left.type === \"UnaryExpression\" && isExponentiation;\n            const shouldSkipRight = NESTED_BINARY && (node.right.type === \"BinaryExpression\" || node.right.type === \"LogicalExpression\");\n\n            if (!shouldSkipLeft && hasExcessParens(node.left) && (leftPrecedence > prec || (leftPrecedence === prec && !isExponentiation))) {\n                report(node.left);\n            }\n            if (!shouldSkipRight && hasExcessParens(node.right) && (rightPrecedence > prec || (rightPrecedence === prec && isExponentiation))) {\n                report(node.right);\n            }\n        }\n\n        /**\n         * Check the parentheses around the super class of the given class definition.\n         * @param {ASTNode} node The node of class declarations to check.\n         * @returns {void}\n         */\n        function checkClass(node) {\n            if (!node.superClass) {\n                return;\n            }\n\n            /*\n             * If `node.superClass` is a LeftHandSideExpression, parentheses are extra.\n             * Otherwise, parentheses are needed.\n             */\n            const hasExtraParens = precedence(node.superClass) > PRECEDENCE_OF_UPDATE_EXPR\n                ? hasExcessParens(node.superClass)\n                : hasDoubleExcessParens(node.superClass);\n\n            if (hasExtraParens) {\n                report(node.superClass);\n            }\n        }\n\n        /**\n         * Check the parentheses around the argument of the given spread operator.\n         * @param {ASTNode} node The node of spread elements/properties to check.\n         * @returns {void}\n         */\n        function checkSpreadOperator(node) {\n            const hasExtraParens = precedence(node.argument) >= PRECEDENCE_OF_ASSIGNMENT_EXPR\n                ? hasExcessParens(node.argument)\n                : hasDoubleExcessParens(node.argument);\n\n            if (hasExtraParens) {\n                report(node.argument);\n            }\n        }\n\n        /**\n         * Checks the parentheses for an ExpressionStatement or ExportDefaultDeclaration\n         * @param {ASTNode} node The ExpressionStatement.expression or ExportDefaultDeclaration.declaration node\n         * @returns {void}\n         */\n        function checkExpressionOrExportStatement(node) {\n            const firstToken = isParenthesised(node) ? sourceCode.getTokenBefore(node) : sourceCode.getFirstToken(node);\n            const secondToken = sourceCode.getTokenAfter(firstToken, astUtils.isNotOpeningParenToken);\n            const thirdToken = secondToken ? sourceCode.getTokenAfter(secondToken) : null;\n            const tokenAfterClosingParens = secondToken ? sourceCode.getTokenAfter(secondToken, astUtils.isNotClosingParenToken) : null;\n\n            if (\n                astUtils.isOpeningParenToken(firstToken) &&\n                (\n                    astUtils.isOpeningBraceToken(secondToken) ||\n                    secondToken.type === \"Keyword\" && (\n                        secondToken.value === \"function\" ||\n                        secondToken.value === \"class\" ||\n                        secondToken.value === \"let\" &&\n                            tokenAfterClosingParens &&\n                            (\n                                astUtils.isOpeningBracketToken(tokenAfterClosingParens) ||\n                                tokenAfterClosingParens.type === \"Identifier\"\n                            )\n                    ) ||\n                    secondToken && secondToken.type === \"Identifier\" && secondToken.value === \"async\" && thirdToken && thirdToken.type === \"Keyword\" && thirdToken.value === \"function\"\n                )\n            ) {\n                tokensToIgnore.add(secondToken);\n            }\n\n            if (hasExcessParens(node)) {\n                report(node);\n            }\n        }\n\n        return {\n            ArrayExpression(node) {\n                node.elements\n                    .filter(e => e && hasExcessParens(e) && precedence(e) >= PRECEDENCE_OF_ASSIGNMENT_EXPR)\n                    .forEach(report);\n            },\n\n            ArrowFunctionExpression(node) {\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (node.body.type === \"ConditionalExpression\" &&\n                    IGNORE_ARROW_CONDITIONALS &&\n                    !isParenthesisedTwice(node.body)\n                ) {\n                    return;\n                }\n\n                if (node.body.type !== \"BlockStatement\") {\n                    const firstBodyToken = sourceCode.getFirstToken(node.body, astUtils.isNotOpeningParenToken);\n                    const tokenBeforeFirst = sourceCode.getTokenBefore(firstBodyToken);\n\n                    if (astUtils.isOpeningParenToken(tokenBeforeFirst) && astUtils.isOpeningBraceToken(firstBodyToken)) {\n                        tokensToIgnore.add(firstBodyToken);\n                    }\n                    if (hasExcessParens(node.body) && precedence(node.body) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n                        report(node.body);\n                    }\n                }\n            },\n\n            AssignmentExpression(node) {\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (hasExcessParens(node.right) && precedence(node.right) >= precedence(node)) {\n                    report(node.right);\n                }\n            },\n\n            BinaryExpression: checkBinaryLogical,\n            CallExpression: checkCallNew,\n\n            ConditionalExpression(node) {\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (hasExcessParens(node.test) && precedence(node.test) >= precedence({ type: \"LogicalExpression\", operator: \"||\" })) {\n                    report(node.test);\n                }\n\n                if (hasExcessParens(node.consequent) && precedence(node.consequent) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n                    report(node.consequent);\n                }\n\n                if (hasExcessParens(node.alternate) && precedence(node.alternate) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n                    report(node.alternate);\n                }\n            },\n\n            DoWhileStatement(node) {\n                if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n            },\n\n            ExportDefaultDeclaration: node => checkExpressionOrExportStatement(node.declaration),\n            ExpressionStatement: node => checkExpressionOrExportStatement(node.expression),\n\n            \"ForInStatement, ForOfStatement\"(node) {\n                if (node.left.type !== \"VariableDeclarator\") {\n                    const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);\n\n                    if (\n                        firstLeftToken.value === \"let\" && (\n\n                            /*\n                             * If `let` is the only thing on the left side of the loop, it's the loop variable: `for ((let) of foo);`\n                             * Removing it will cause a syntax error, because it will be parsed as the start of a VariableDeclarator.\n                             */\n                            (firstLeftToken.range[1] === node.left.range[1] || /*\n                             * If `let` is followed by a `[` token, it's a property access on the `let` value: `for ((let[foo]) of bar);`\n                             * Removing it will cause the property access to be parsed as a destructuring declaration of `foo` instead.\n                             */\n                            astUtils.isOpeningBracketToken(\n                                sourceCode.getTokenAfter(firstLeftToken, astUtils.isNotClosingParenToken)\n                            ))\n                        )\n                    ) {\n                        tokensToIgnore.add(firstLeftToken);\n                    }\n                }\n                if (!(node.type === \"ForOfStatement\" && node.right.type === \"SequenceExpression\") && hasExcessParens(node.right)) {\n                    report(node.right);\n                }\n                if (hasExcessParens(node.left)) {\n                    report(node.left);\n                }\n            },\n\n            ForStatement(node) {\n                if (node.init && hasExcessParens(node.init)) {\n                    report(node.init);\n                }\n\n                if (node.test && hasExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n\n                if (node.update && hasExcessParens(node.update)) {\n                    report(node.update);\n                }\n            },\n\n            IfStatement(node) {\n                if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n            },\n\n            LogicalExpression: checkBinaryLogical,\n\n            MemberExpression(node) {\n                const nodeObjHasExcessParens = hasExcessParens(node.object);\n\n                if (\n                    nodeObjHasExcessParens &&\n                    precedence(node.object) >= precedence(node) &&\n                    (\n                        node.computed ||\n                        !(\n                            astUtils.isDecimalInteger(node.object) ||\n\n                            // RegExp literal is allowed to have parens (#1589)\n                            (node.object.type === \"Literal\" && node.object.regex)\n                        )\n                    )\n                ) {\n                    report(node.object);\n                }\n\n                if (nodeObjHasExcessParens &&\n                  node.object.type === \"CallExpression\" &&\n                  node.parent.type !== \"NewExpression\") {\n                    report(node.object);\n                }\n\n                if (node.computed && hasExcessParens(node.property)) {\n                    report(node.property);\n                }\n            },\n\n            NewExpression: checkCallNew,\n\n            ObjectExpression(node) {\n                node.properties\n                    .filter(property => {\n                        const value = property.value;\n\n                        return value && hasExcessParens(value) && precedence(value) >= PRECEDENCE_OF_ASSIGNMENT_EXPR;\n                    }).forEach(property => report(property.value));\n            },\n\n            ReturnStatement(node) {\n                const returnToken = sourceCode.getFirstToken(node);\n\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (node.argument &&\n                        hasExcessParensNoLineTerminator(returnToken, node.argument) &&\n\n                        // RegExp literal is allowed to have parens (#1589)\n                        !(node.argument.type === \"Literal\" && node.argument.regex)) {\n                    report(node.argument);\n                }\n            },\n\n            SequenceExpression(node) {\n                node.expressions\n                    .filter(e => hasExcessParens(e) && precedence(e) >= precedence(node))\n                    .forEach(report);\n            },\n\n            SwitchCase(node) {\n                if (node.test && hasExcessParens(node.test)) {\n                    report(node.test);\n                }\n            },\n\n            SwitchStatement(node) {\n                if (hasDoubleExcessParens(node.discriminant)) {\n                    report(node.discriminant);\n                }\n            },\n\n            ThrowStatement(node) {\n                const throwToken = sourceCode.getFirstToken(node);\n\n                if (hasExcessParensNoLineTerminator(throwToken, node.argument)) {\n                    report(node.argument);\n                }\n            },\n\n            UnaryExpression: checkUnaryUpdate,\n            UpdateExpression: checkUnaryUpdate,\n            AwaitExpression: checkUnaryUpdate,\n\n            VariableDeclarator(node) {\n                if (node.init && hasExcessParens(node.init) &&\n                        precedence(node.init) >= PRECEDENCE_OF_ASSIGNMENT_EXPR &&\n\n                        // RegExp literal is allowed to have parens (#1589)\n                        !(node.init.type === \"Literal\" && node.init.regex)) {\n                    report(node.init);\n                }\n            },\n\n            WhileStatement(node) {\n                if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n            },\n\n            WithStatement(node) {\n                if (hasDoubleExcessParens(node.object)) {\n                    report(node.object);\n                }\n            },\n\n            YieldExpression(node) {\n                if (node.argument) {\n                    const yieldToken = sourceCode.getFirstToken(node);\n\n                    if ((precedence(node.argument) >= precedence(node) &&\n                            hasExcessParensNoLineTerminator(yieldToken, node.argument)) ||\n                            hasDoubleExcessParens(node.argument)) {\n                        report(node.argument);\n                    }\n                }\n            },\n\n            ClassDeclaration: checkClass,\n            ClassExpression: checkClass,\n\n            SpreadElement: checkSpreadOperator,\n            SpreadProperty: checkSpreadOperator,\n            ExperimentalSpreadProperty: checkSpreadOperator\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use of unnecessary semicolons\n * @author Nicholas C. Zakas\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst FixTracker = require(\"../util/fix-tracker\");\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary semicolons\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-extra-semi\"\n        },\n\n        fixable: \"code\",\n        schema: [],\n\n        messages: {\n            unexpected: \"Unnecessary semicolon.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports an unnecessary semicolon error.\n         * @param {Node|Token} nodeOrToken - A node or a token to be reported.\n         * @returns {void}\n         */\n        function report(nodeOrToken) {\n            context.report({\n                node: nodeOrToken,\n                messageId: \"unexpected\",\n                fix(fixer) {\n\n                    /*\n                     * Expand the replacement range to include the surrounding\n                     * tokens to avoid conflicting with semi.\n                     * https://github.com/eslint/eslint/issues/7928\n                     */\n                    return new FixTracker(fixer, context.getSourceCode())\n                        .retainSurroundingTokens(nodeOrToken)\n                        .remove(nodeOrToken);\n                }\n            });\n        }\n\n        /**\n         * Checks for a part of a class body.\n         * This checks tokens from a specified token to a next MethodDefinition or the end of class body.\n         *\n         * @param {Token} firstToken - The first token to check.\n         * @returns {void}\n         */\n        function checkForPartOfClassBody(firstToken) {\n            for (let token = firstToken;\n                token.type === \"Punctuator\" && !astUtils.isClosingBraceToken(token);\n                token = sourceCode.getTokenAfter(token)\n            ) {\n                if (astUtils.isSemicolonToken(token)) {\n                    report(token);\n                }\n            }\n        }\n\n        return {\n\n            /**\n             * Reports this empty statement, except if the parent node is a loop.\n             * @param {Node} node - A EmptyStatement node to be reported.\n             * @returns {void}\n             */\n            EmptyStatement(node) {\n                const parent = node.parent,\n                    allowedParentTypes = [\n                        \"ForStatement\",\n                        \"ForInStatement\",\n                        \"ForOfStatement\",\n                        \"WhileStatement\",\n                        \"DoWhileStatement\",\n                        \"IfStatement\",\n                        \"LabeledStatement\",\n                        \"WithStatement\"\n                    ];\n\n                if (allowedParentTypes.indexOf(parent.type) === -1) {\n                    report(node);\n                }\n            },\n\n            /**\n             * Checks tokens from the head of this class body to the first MethodDefinition or the end of this class body.\n             * @param {Node} node - A ClassBody node to check.\n             * @returns {void}\n             */\n            ClassBody(node) {\n                checkForPartOfClassBody(sourceCode.getFirstToken(node, 1)); // 0 is `{`.\n            },\n\n            /**\n             * Checks tokens from this MethodDefinition to the next MethodDefinition or the end of this class body.\n             * @param {Node} node - A MethodDefinition node of the start point.\n             * @returns {void}\n             */\n            MethodDefinition(node) {\n                checkForPartOfClassBody(sourceCode.getTokenAfter(node));\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag fall-through cases in switch statements.\n * @author Matt DuVall <http://mattduvall.com/>\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_FALLTHROUGH_COMMENT = /falls?\\s?through/iu;\n\n/**\n * Checks whether or not a given node has a fallthrough comment.\n * @param {ASTNode} node - A SwitchCase node to get comments.\n * @param {RuleContext} context - A rule context which stores comments.\n * @param {RegExp} fallthroughCommentPattern - A pattern to match comment to.\n * @returns {boolean} `true` if the node has a valid fallthrough comment.\n */\nfunction hasFallthroughComment(node, context, fallthroughCommentPattern) {\n    const sourceCode = context.getSourceCode();\n    const comment = lodash.last(sourceCode.getCommentsBefore(node));\n\n    return Boolean(comment && fallthroughCommentPattern.test(comment.value));\n}\n\n/**\n * Checks whether or not a given code path segment is reachable.\n * @param {CodePathSegment} segment - A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Checks whether a node and a token are separated by blank lines\n * @param {ASTNode} node - The node to check\n * @param {Token} token - The token to compare against\n * @returns {boolean} `true` if there are blank lines between node and token\n */\nfunction hasBlankLinesBetween(node, token) {\n    return token.loc.start.line > node.loc.end.line + 1;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow fallthrough of `case` statements\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-fallthrough\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    commentPattern: {\n                        type: \"string\",\n                        default: \"\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            case: \"Expected a 'break' statement before 'case'.\",\n            default: \"Expected a 'break' statement before 'default'.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        let currentCodePath = null;\n        const sourceCode = context.getSourceCode();\n\n        /*\n         * We need to use leading comments of the next SwitchCase node because\n         * trailing comments is wrong if semicolons are omitted.\n         */\n        let fallthroughCase = null;\n        let fallthroughCommentPattern = null;\n\n        if (options.commentPattern) {\n            fallthroughCommentPattern = new RegExp(options.commentPattern); // eslint-disable-line require-unicode-regexp\n        } else {\n            fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;\n        }\n\n        return {\n            onCodePathStart(codePath) {\n                currentCodePath = codePath;\n            },\n            onCodePathEnd() {\n                currentCodePath = currentCodePath.upper;\n            },\n\n            SwitchCase(node) {\n\n                /*\n                 * Checks whether or not there is a fallthrough comment.\n                 * And reports the previous fallthrough node if that does not exist.\n                 */\n                if (fallthroughCase && !hasFallthroughComment(node, context, fallthroughCommentPattern)) {\n                    context.report({\n                        messageId: node.test ? \"case\" : \"default\",\n                        node\n                    });\n                }\n                fallthroughCase = null;\n            },\n\n            \"SwitchCase:exit\"(node) {\n                const nextToken = sourceCode.getTokenAfter(node);\n\n                /*\n                 * `reachable` meant fall through because statements preceded by\n                 * `break`, `return`, or `throw` are unreachable.\n                 * And allows empty cases and the last case.\n                 */\n                if (currentCodePath.currentSegments.some(isReachable) &&\n                    (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) &&\n                    lodash.last(node.parent.cases) !== node) {\n                    fallthroughCase = node;\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag use of a leading/trailing decimal point in a numeric literal\n * @author James Allardice\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow leading or trailing decimal points in numeric literals\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-floating-decimal\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n        messages: {\n            leading: \"A leading decimal point can be confused with a dot.\",\n            trailing: \"A trailing decimal point can be confused with a dot.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            Literal(node) {\n\n                if (typeof node.value === \"number\") {\n                    if (node.raw.startsWith(\".\")) {\n                        context.report({\n                            node,\n                            messageId: \"leading\",\n                            fix(fixer) {\n                                const tokenBefore = sourceCode.getTokenBefore(node);\n                                const needsSpaceBefore = tokenBefore &&\n                                    tokenBefore.range[1] === node.range[0] &&\n                                    !astUtils.canTokensBeAdjacent(tokenBefore, `0${node.raw}`);\n\n                                return fixer.insertTextBefore(node, needsSpaceBefore ? \" 0\" : \"0\");\n                            }\n                        });\n                    }\n                    if (node.raw.indexOf(\".\") === node.raw.length - 1) {\n                        context.report({\n                            node,\n                            messageId: \"trailing\",\n                            fix: fixer => fixer.insertTextAfter(node, \"0\")\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use of function declaration identifiers as variables.\n * @author Ian Christian Myers\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow reassigning `function` declarations\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-func-assign\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Reports a reference if is non initializer and writable.\n         * @param {References} references - Collection of reference to check.\n         * @returns {void}\n         */\n        function checkReference(references) {\n            astUtils.getModifyingReferences(references).forEach(reference => {\n                context.report({ node: reference.identifier, message: \"'{{name}}' is a function.\", data: { name: reference.identifier.name } });\n            });\n        }\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable - A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            if (variable.defs[0].type === \"FunctionName\") {\n                checkReference(variable.references);\n            }\n        }\n\n        /**\n         * Checks parameters of a given function node.\n         * @param {ASTNode} node - A function node to check.\n         * @returns {void}\n         */\n        function checkForFunction(node) {\n            context.getDeclaredVariables(node).forEach(checkVariable);\n        }\n\n        return {\n            FunctionDeclaration: checkForFunction,\n            FunctionExpression: checkForFunction\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow assignments to native objects or read-only global variables\n * @author Ilya Volodin\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow assignments to native objects or read-only global variables\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-global-assign\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: { type: \"string\" },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const config = context.options[0];\n        const exceptions = (config && config.exceptions) || [];\n\n        /**\n         * Reports write references.\n         * @param {Reference} reference - A reference to check.\n         * @param {int} index - The index of the reference in the references.\n         * @param {Reference[]} references - The array that the reference belongs to.\n         * @returns {void}\n         */\n        function checkReference(reference, index, references) {\n            const identifier = reference.identifier;\n\n            if (reference.init === false &&\n                reference.isWrite() &&\n\n                /*\n                 * Destructuring assignments can have multiple default value,\n                 * so possibly there are multiple writeable references for the same identifier.\n                 */\n                (index === 0 || references[index - 1].identifier !== identifier)\n            ) {\n                context.report({\n                    node: identifier,\n                    message: \"Read-only global '{{name}}' should not be modified.\",\n                    data: identifier\n                });\n            }\n        }\n\n        /**\n         * Reports write references if a given variable is read-only builtin.\n         * @param {Variable} variable - A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {\n                variable.references.forEach(checkReference);\n            }\n        }\n\n        return {\n            Program() {\n                const globalScope = context.getScope();\n\n                globalScope.variables.forEach(checkVariable);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A rule to disallow the type conversions with shorter notations.\n * @author Toru Nagashima\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/u;\nconst ALLOWABLE_OPERATORS = [\"~\", \"!!\", \"+\", \"*\"];\n\n/**\n * Parses and normalizes an option object.\n * @param {Object} options - An option object to parse.\n * @returns {Object} The parsed and normalized option object.\n */\nfunction parseOptions(options) {\n    return {\n        boolean: \"boolean\" in options ? options.boolean : true,\n        number: \"number\" in options ? options.number : true,\n        string: \"string\" in options ? options.string : true,\n        allow: options.allow || []\n    };\n}\n\n/**\n * Checks whether or not a node is a double logical nigating.\n * @param {ASTNode} node - An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a double logical nigating.\n */\nfunction isDoubleLogicalNegating(node) {\n    return (\n        node.operator === \"!\" &&\n        node.argument.type === \"UnaryExpression\" &&\n        node.argument.operator === \"!\"\n    );\n}\n\n/**\n * Checks whether or not a node is a binary negating of `.indexOf()` method calling.\n * @param {ASTNode} node - An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a binary negating of `.indexOf()` method calling.\n */\nfunction isBinaryNegatingOfIndexOf(node) {\n    return (\n        node.operator === \"~\" &&\n        node.argument.type === \"CallExpression\" &&\n        node.argument.callee.type === \"MemberExpression\" &&\n        node.argument.callee.property.type === \"Identifier\" &&\n        INDEX_OF_PATTERN.test(node.argument.callee.property.name)\n    );\n}\n\n/**\n * Checks whether or not a node is a multiplying by one.\n * @param {BinaryExpression} node - A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a multiplying by one.\n */\nfunction isMultiplyByOne(node) {\n    return node.operator === \"*\" && (\n        node.left.type === \"Literal\" && node.left.value === 1 ||\n        node.right.type === \"Literal\" && node.right.value === 1\n    );\n}\n\n/**\n * Checks whether the result of a node is numeric or not\n * @param {ASTNode} node The node to test\n * @returns {boolean} true if the node is a number literal or a `Number()`, `parseInt` or `parseFloat` call\n */\nfunction isNumeric(node) {\n    return (\n        node.type === \"Literal\" && typeof node.value === \"number\" ||\n        node.type === \"CallExpression\" && (\n            node.callee.name === \"Number\" ||\n            node.callee.name === \"parseInt\" ||\n            node.callee.name === \"parseFloat\"\n        )\n    );\n}\n\n/**\n * Returns the first non-numeric operand in a BinaryExpression. Designed to be\n * used from bottom to up since it walks up the BinaryExpression trees using\n * node.parent to find the result.\n * @param {BinaryExpression} node The BinaryExpression node to be walked up on\n * @returns {ASTNode|null} The first non-numeric item in the BinaryExpression tree or null\n */\nfunction getNonNumericOperand(node) {\n    const left = node.left,\n        right = node.right;\n\n    if (right.type !== \"BinaryExpression\" && !isNumeric(right)) {\n        return right;\n    }\n\n    if (left.type !== \"BinaryExpression\" && !isNumeric(left)) {\n        return left;\n    }\n\n    return null;\n}\n\n/**\n * Checks whether a node is an empty string literal or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} Whether or not the passed in node is an\n * empty string literal or not.\n */\nfunction isEmptyString(node) {\n    return astUtils.isStringLiteral(node) && (node.value === \"\" || (node.type === \"TemplateLiteral\" && node.quasis.length === 1 && node.quasis[0].value.cooked === \"\"));\n}\n\n/**\n * Checks whether or not a node is a concatenating with an empty string.\n * @param {ASTNode} node - A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a concatenating with an empty string.\n */\nfunction isConcatWithEmptyString(node) {\n    return node.operator === \"+\" && (\n        (isEmptyString(node.left) && !astUtils.isStringLiteral(node.right)) ||\n        (isEmptyString(node.right) && !astUtils.isStringLiteral(node.left))\n    );\n}\n\n/**\n * Checks whether or not a node is appended with an empty string.\n * @param {ASTNode} node - An AssignmentExpression node to check.\n * @returns {boolean} Whether or not the node is appended with an empty string.\n */\nfunction isAppendEmptyString(node) {\n    return node.operator === \"+=\" && isEmptyString(node.right);\n}\n\n/**\n * Returns the operand that is not an empty string from a flagged BinaryExpression.\n * @param {ASTNode} node - The flagged BinaryExpression node to check.\n * @returns {ASTNode} The operand that is not an empty string from a flagged BinaryExpression.\n */\nfunction getNonEmptyOperand(node) {\n    return isEmptyString(node.left) ? node.right : node.left;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow shorthand type conversions\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-implicit-coercion\"\n        },\n\n        fixable: \"code\",\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                boolean: {\n                    type: \"boolean\",\n                    default: true\n                },\n                number: {\n                    type: \"boolean\",\n                    default: true\n                },\n                string: {\n                    type: \"boolean\",\n                    default: true\n                },\n                allow: {\n                    type: \"array\",\n                    items: {\n                        enum: ALLOWABLE_OPERATORS\n                    },\n                    uniqueItems: true\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n\n    create(context) {\n        const options = parseOptions(context.options[0] || {});\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports an error and autofixes the node\n         * @param {ASTNode} node - An ast node to report the error on.\n         * @param {string} recommendation - The recommended code for the issue\n         * @param {bool} shouldFix - Whether this report should fix the node\n         * @returns {void}\n         */\n        function report(node, recommendation, shouldFix) {\n            context.report({\n                node,\n                message: \"use `{{recommendation}}` instead.\",\n                data: {\n                    recommendation\n                },\n                fix(fixer) {\n                    if (!shouldFix) {\n                        return null;\n                    }\n\n                    const tokenBefore = sourceCode.getTokenBefore(node);\n\n                    if (\n                        tokenBefore &&\n                        tokenBefore.range[1] === node.range[0] &&\n                        !astUtils.canTokensBeAdjacent(tokenBefore, recommendation)\n                    ) {\n                        return fixer.replaceText(node, ` ${recommendation}`);\n                    }\n                    return fixer.replaceText(node, recommendation);\n                }\n            });\n        }\n\n        return {\n            UnaryExpression(node) {\n                let operatorAllowed;\n\n                // !!foo\n                operatorAllowed = options.allow.indexOf(\"!!\") >= 0;\n                if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {\n                    const recommendation = `Boolean(${sourceCode.getText(node.argument.argument)})`;\n\n                    report(node, recommendation, true);\n                }\n\n                // ~foo.indexOf(bar)\n                operatorAllowed = options.allow.indexOf(\"~\") >= 0;\n                if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {\n                    const recommendation = `${sourceCode.getText(node.argument)} !== -1`;\n\n                    report(node, recommendation, false);\n                }\n\n                // +foo\n                operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n                if (!operatorAllowed && options.number && node.operator === \"+\" && !isNumeric(node.argument)) {\n                    const recommendation = `Number(${sourceCode.getText(node.argument)})`;\n\n                    report(node, recommendation, true);\n                }\n            },\n\n            // Use `:exit` to prevent double reporting\n            \"BinaryExpression:exit\"(node) {\n                let operatorAllowed;\n\n                // 1 * foo\n                operatorAllowed = options.allow.indexOf(\"*\") >= 0;\n                const nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && getNonNumericOperand(node);\n\n                if (nonNumericOperand) {\n                    const recommendation = `Number(${sourceCode.getText(nonNumericOperand)})`;\n\n                    report(node, recommendation, true);\n                }\n\n                // \"\" + foo\n                operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n                if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {\n                    const recommendation = `String(${sourceCode.getText(getNonEmptyOperand(node))})`;\n\n                    report(node, recommendation, true);\n                }\n            },\n\n            AssignmentExpression(node) {\n\n                // foo += \"\"\n                const operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n\n                if (!operatorAllowed && options.string && isAppendEmptyString(node)) {\n                    const code = sourceCode.getText(getNonEmptyOperand(node));\n                    const recommendation = `${code} = String(${code})`;\n\n                    report(node, recommendation, true);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to check for implicit global variables and functions.\n * @author Joshua Peek\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow variable and `function` declarations in the global scope\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-implicit-globals\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        return {\n            Program() {\n                const scope = context.getScope();\n\n                scope.variables.forEach(variable => {\n                    if (variable.writeable) {\n                        return;\n                    }\n\n                    variable.defs.forEach(def => {\n                        if (def.type === \"FunctionName\" || (def.type === \"Variable\" && def.parent.kind === \"var\")) {\n                            context.report({ node: def.node, message: \"Implicit global variable, assign as global property instead.\" });\n                        }\n                    });\n                });\n\n                scope.implicit.variables.forEach(variable => {\n                    const scopeVariable = scope.set.get(variable.name);\n\n                    if (scopeVariable && scopeVariable.writeable) {\n                        return;\n                    }\n\n                    variable.defs.forEach(def => {\n                        context.report({ node: def.node, message: \"Implicit global variable, assign as global property instead.\" });\n                    });\n                });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use of implied eval via setTimeout and setInterval\n * @author James Allardice\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `eval()`-like methods\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-implied-eval\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const CALLEE_RE = /^(setTimeout|setInterval|execScript)$/u;\n\n        /*\n         * Figures out if we should inspect a given binary expression. Is a stack\n         * of stacks, where the first element in each substack is a CallExpression.\n         */\n        const impliedEvalAncestorsStack = [];\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Get the last element of an array, without modifying arr, like pop(), but non-destructive.\n         * @param {Array} arr What to inspect\n         * @returns {*} The last element of arr\n         * @private\n         */\n        function last(arr) {\n            return arr ? arr[arr.length - 1] : null;\n        }\n\n        /**\n         * Checks if the given MemberExpression node is a potentially implied eval identifier on window.\n         * @param {ASTNode} node The MemberExpression node to check.\n         * @returns {boolean} Whether or not the given node is potentially an implied eval.\n         * @private\n         */\n        function isImpliedEvalMemberExpression(node) {\n            const object = node.object,\n                property = node.property,\n                hasImpliedEvalName = CALLEE_RE.test(property.name) || CALLEE_RE.test(property.value);\n\n            return object.name === \"window\" && hasImpliedEvalName;\n        }\n\n        /**\n         * Determines if a node represents a call to a potentially implied eval.\n         *\n         * This checks the callee name and that there's an argument, but not the type of the argument.\n         *\n         * @param {ASTNode} node The CallExpression to check.\n         * @returns {boolean} True if the node matches, false if not.\n         * @private\n         */\n        function isImpliedEvalCallExpression(node) {\n            const isMemberExpression = (node.callee.type === \"MemberExpression\"),\n                isIdentifier = (node.callee.type === \"Identifier\"),\n                isImpliedEvalCallee =\n                    (isIdentifier && CALLEE_RE.test(node.callee.name)) ||\n                    (isMemberExpression && isImpliedEvalMemberExpression(node.callee));\n\n            return isImpliedEvalCallee && node.arguments.length;\n        }\n\n        /**\n         * Checks that the parent is a direct descendent of an potential implied eval CallExpression, and if the parent is a CallExpression, that we're the first argument.\n         * @param {ASTNode} node The node to inspect the parent of.\n         * @returns {boolean} Was the parent a direct descendent, and is the child therefore potentially part of a dangerous argument?\n         * @private\n         */\n        function hasImpliedEvalParent(node) {\n\n            // make sure our parent is marked\n            return node.parent === last(last(impliedEvalAncestorsStack)) &&\n\n                // if our parent is a CallExpression, make sure we're the first argument\n                (node.parent.type !== \"CallExpression\" || node === node.parent.arguments[0]);\n        }\n\n        /**\n         * Checks if our parent is marked as part of an implied eval argument. If\n         * so, collapses the top of impliedEvalAncestorsStack and reports on the\n         * original CallExpression.\n         * @param {ASTNode} node The CallExpression to check.\n         * @returns {boolean} True if the node matches, false if not.\n         * @private\n         */\n        function checkString(node) {\n            if (hasImpliedEvalParent(node)) {\n\n                // remove the entire substack, to avoid duplicate reports\n                const substack = impliedEvalAncestorsStack.pop();\n\n                context.report({ node: substack[0], message: \"Implied eval. Consider passing a function instead of a string.\" });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            CallExpression(node) {\n                if (isImpliedEvalCallExpression(node)) {\n\n                    // call expressions create a new substack\n                    impliedEvalAncestorsStack.push([node]);\n                }\n            },\n\n            \"CallExpression:exit\"(node) {\n                if (node === last(last(impliedEvalAncestorsStack))) {\n\n                    /*\n                     * Destroys the entire sub-stack, rather than just using\n                     * last(impliedEvalAncestorsStack).pop(), as a CallExpression is\n                     * always the bottom of a impliedEvalAncestorsStack substack.\n                     */\n                    impliedEvalAncestorsStack.pop();\n                }\n            },\n\n            BinaryExpression(node) {\n                if (node.operator === \"+\" && hasImpliedEvalParent(node)) {\n                    last(impliedEvalAncestorsStack).push(node);\n                }\n            },\n\n            \"BinaryExpression:exit\"(node) {\n                if (node === last(last(impliedEvalAncestorsStack))) {\n                    last(impliedEvalAncestorsStack).pop();\n                }\n            },\n\n            Literal(node) {\n                if (typeof node.value === \"string\") {\n                    checkString(node);\n                }\n            },\n\n            TemplateLiteral(node) {\n                checkString(node);\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Enforces or disallows inline comments.\n * @author Greg Cochard\n */\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow inline comments after code\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-inline-comments\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Will check that comments are not on lines starting with or ending with code\n         * @param {ASTNode} node The comment node to check\n         * @private\n         * @returns {void}\n         */\n        function testCodeAroundComment(node) {\n\n            // Get the whole line and cut it off at the start of the comment\n            const startLine = String(sourceCode.lines[node.loc.start.line - 1]);\n            const endLine = String(sourceCode.lines[node.loc.end.line - 1]);\n\n            const preamble = startLine.slice(0, node.loc.start.column).trim();\n\n            // Also check after the comment\n            const postamble = endLine.slice(node.loc.end.column).trim();\n\n            // Check that this comment isn't an ESLint directive\n            const isDirective = astUtils.isDirectiveComment(node);\n\n            // Should be empty if there was only whitespace around the comment\n            if (!isDirective && (preamble || postamble)) {\n                context.report({ node, message: \"Unexpected comment inline with code.\" });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments.filter(token => token.type !== \"Shebang\").forEach(testCodeAroundComment);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce declarations in program or function body root.\n * @author Brandon Mills\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow variable or `function` declarations in nested blocks\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-inner-declarations\"\n        },\n\n        schema: [\n            {\n                enum: [\"functions\", \"both\"]\n            }\n        ]\n    },\n\n    create(context) {\n\n        /**\n         * Find the nearest Program or Function ancestor node.\n         * @returns {Object} Ancestor's type and distance from node.\n         */\n        function nearestBody() {\n            const ancestors = context.getAncestors();\n            let ancestor = ancestors.pop(),\n                generation = 1;\n\n            while (ancestor && [\"Program\", \"FunctionDeclaration\",\n                \"FunctionExpression\", \"ArrowFunctionExpression\"\n            ].indexOf(ancestor.type) < 0) {\n                generation += 1;\n                ancestor = ancestors.pop();\n            }\n\n            return {\n\n                // Type of containing ancestor\n                type: ancestor.type,\n\n                // Separation between ancestor and node\n                distance: generation\n            };\n        }\n\n        /**\n         * Ensure that a given node is at a program or function body's root.\n         * @param {ASTNode} node Declaration node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            const body = nearestBody(),\n                valid = ((body.type === \"Program\" && body.distance === 1) ||\n                    body.distance === 2);\n\n            if (!valid) {\n                context.report({\n                    node,\n                    message: \"Move {{type}} declaration to {{body}} root.\",\n                    data: {\n                        type: (node.type === \"FunctionDeclaration\" ? \"function\" : \"variable\"),\n                        body: (body.type === \"Program\" ? \"program\" : \"function body\")\n                    }\n                });\n            }\n        }\n\n        return {\n\n            FunctionDeclaration: check,\n            VariableDeclaration(node) {\n                if (context.options[0] === \"both\" && node.kind === \"var\") {\n                    check(node);\n                }\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Validate strings passed to the RegExp constructor\n * @author Michael Ficarra\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst RegExpValidator = require(\"regexpp\").RegExpValidator;\nconst validator = new RegExpValidator({ ecmaVersion: 2018 });\nconst validFlags = /[gimuys]/gu;\nconst undefined1 = void 0;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow invalid regular expression strings in `RegExp` constructors\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-invalid-regexp\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowConstructorFlags: {\n                    type: \"array\",\n                    items: {\n                        type: \"string\"\n                    }\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n\n    create(context) {\n\n        const options = context.options[0];\n        let allowedFlags = null;\n\n        if (options && options.allowConstructorFlags) {\n            const temp = options.allowConstructorFlags.join(\"\").replace(validFlags, \"\");\n\n            if (temp) {\n                allowedFlags = new RegExp(`[${temp}]`, \"giu\");\n            }\n        }\n\n        /**\n         * Check if node is a string\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if its a string\n         * @private\n         */\n        function isString(node) {\n            return node && node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Check syntax error in a given pattern.\n         * @param {string} pattern The RegExp pattern to validate.\n         * @param {boolean} uFlag The Unicode flag.\n         * @returns {string|null} The syntax error.\n         */\n        function validateRegExpPattern(pattern, uFlag) {\n            try {\n                validator.validatePattern(pattern, undefined1, undefined1, uFlag);\n                return null;\n            } catch (err) {\n                return err.message;\n            }\n        }\n\n        /**\n         * Check syntax error in a given flags.\n         * @param {string} flags The RegExp flags to validate.\n         * @returns {string|null} The syntax error.\n         */\n        function validateRegExpFlags(flags) {\n            try {\n                validator.validateFlags(flags);\n                return null;\n            } catch (err) {\n                return `Invalid flags supplied to RegExp constructor '${flags}'`;\n            }\n        }\n\n        return {\n            \"CallExpression, NewExpression\"(node) {\n                if (node.callee.type !== \"Identifier\" || node.callee.name !== \"RegExp\" || !isString(node.arguments[0])) {\n                    return;\n                }\n                const pattern = node.arguments[0].value;\n                let flags = isString(node.arguments[1]) ? node.arguments[1].value : \"\";\n\n                if (allowedFlags) {\n                    flags = flags.replace(allowedFlags, \"\");\n                }\n\n                // If flags are unknown, check both are errored or not.\n                const message = validateRegExpFlags(flags) || (\n                    flags\n                        ? validateRegExpPattern(pattern, flags.indexOf(\"u\") !== -1)\n                        : validateRegExpPattern(pattern, true) && validateRegExpPattern(pattern, false)\n                );\n\n                if (message) {\n                    context.report({\n                        node,\n                        message: \"{{message}}.\",\n                        data: { message }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A rule to disallow `this` keywords outside of classes or class-like objects.\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `this` keywords outside of classes or class-like objects\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-invalid-this\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const stack = [],\n            sourceCode = context.getSourceCode();\n\n        /**\n         * Gets the current checking context.\n         *\n         * The return value has a flag that whether or not `this` keyword is valid.\n         * The flag is initialized when got at the first time.\n         *\n         * @returns {{valid: boolean}}\n         *   an object which has a flag that whether or not `this` keyword is valid.\n         */\n        stack.getCurrent = function() {\n            const current = this[this.length - 1];\n\n            if (!current.init) {\n                current.init = true;\n                current.valid = !astUtils.isDefaultThisBinding(\n                    current.node,\n                    sourceCode\n                );\n            }\n            return current;\n        };\n\n        /**\n         * Pushs new checking context into the stack.\n         *\n         * The checking context is not initialized yet.\n         * Because most functions don't have `this` keyword.\n         * When `this` keyword was found, the checking context is initialized.\n         *\n         * @param {ASTNode} node - A function node that was entered.\n         * @returns {void}\n         */\n        function enterFunction(node) {\n\n            // `this` can be invalid only under strict mode.\n            stack.push({\n                init: !context.getScope().isStrict,\n                node,\n                valid: true\n            });\n        }\n\n        /**\n         * Pops the current checking context from the stack.\n         * @returns {void}\n         */\n        function exitFunction() {\n            stack.pop();\n        }\n\n        return {\n\n            /*\n             * `this` is invalid only under strict mode.\n             * Modules is always strict mode.\n             */\n            Program(node) {\n                const scope = context.getScope(),\n                    features = context.parserOptions.ecmaFeatures || {};\n\n                stack.push({\n                    init: true,\n                    node,\n                    valid: !(\n                        scope.isStrict ||\n                        node.sourceType === \"module\" ||\n                        (features.globalReturn && scope.childScopes[0].isStrict)\n                    )\n                });\n            },\n\n            \"Program:exit\"() {\n                stack.pop();\n            },\n\n            FunctionDeclaration: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            FunctionExpression: enterFunction,\n            \"FunctionExpression:exit\": exitFunction,\n\n            // Reports if `this` of the current context is invalid.\n            ThisExpression(node) {\n                const current = stack.getCurrent();\n\n                if (current && !current.valid) {\n                    context.report({ node, message: \"Unexpected 'this'.\" });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disalow whitespace that is not a tab or space, whitespace inside strings and comments are allowed\n * @author Jonathan Kingston\n * @author Christophe Porteneuve\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst ALL_IRREGULARS = /[\\f\\v\\u0085\\ufeff\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000\\u2028\\u2029]/u;\nconst IRREGULAR_WHITESPACE = /[\\f\\v\\u0085\\ufeff\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000]+/mgu;\nconst IRREGULAR_LINE_TERMINATORS = /[\\u2028\\u2029]/mgu;\nconst LINE_BREAK = astUtils.createGlobalLinebreakMatcher();\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow irregular whitespace\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-irregular-whitespace\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    skipComments: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    skipStrings: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    skipTemplates: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    skipRegExps: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        // Module store of errors that we have found\n        let errors = [];\n\n        // Lookup the `skipComments` option, which defaults to `false`.\n        const options = context.options[0] || {};\n        const skipComments = !!options.skipComments;\n        const skipStrings = options.skipStrings !== false;\n        const skipRegExps = !!options.skipRegExps;\n        const skipTemplates = !!options.skipTemplates;\n\n        const sourceCode = context.getSourceCode();\n        const commentNodes = sourceCode.getAllComments();\n\n        /**\n         * Removes errors that occur inside a string node\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeWhitespaceError(node) {\n            const locStart = node.loc.start;\n            const locEnd = node.loc.end;\n\n            errors = errors.filter(({ loc: errorLoc }) => {\n                if (errorLoc.line >= locStart.line && errorLoc.line <= locEnd.line) {\n                    if (errorLoc.column >= locStart.column && (errorLoc.column <= locEnd.column || errorLoc.line < locEnd.line)) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n\n        /**\n         * Checks identifier or literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeInvalidNodeErrorsInIdentifierOrLiteral(node) {\n            const shouldCheckStrings = skipStrings && (typeof node.value === \"string\");\n            const shouldCheckRegExps = skipRegExps && Boolean(node.regex);\n\n            if (shouldCheckStrings || shouldCheckRegExps) {\n\n                // If we have irregular characters remove them from the errors list\n                if (ALL_IRREGULARS.test(node.raw)) {\n                    removeWhitespaceError(node);\n                }\n            }\n        }\n\n        /**\n         * Checks template string literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeInvalidNodeErrorsInTemplateLiteral(node) {\n            if (typeof node.value.raw === \"string\") {\n                if (ALL_IRREGULARS.test(node.value.raw)) {\n                    removeWhitespaceError(node);\n                }\n            }\n        }\n\n        /**\n         * Checks comment nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeInvalidNodeErrorsInComment(node) {\n            if (ALL_IRREGULARS.test(node.value)) {\n                removeWhitespaceError(node);\n            }\n        }\n\n        /**\n         * Checks the program source for irregular whitespace\n         * @param {ASTNode} node The program node\n         * @returns {void}\n         * @private\n         */\n        function checkForIrregularWhitespace(node) {\n            const sourceLines = sourceCode.lines;\n\n            sourceLines.forEach((sourceLine, lineIndex) => {\n                const lineNumber = lineIndex + 1;\n                let match;\n\n                while ((match = IRREGULAR_WHITESPACE.exec(sourceLine)) !== null) {\n                    const location = {\n                        line: lineNumber,\n                        column: match.index\n                    };\n\n                    errors.push({ node, message: \"Irregular whitespace not allowed.\", loc: location });\n                }\n            });\n        }\n\n        /**\n         * Checks the program source for irregular line terminators\n         * @param {ASTNode} node The program node\n         * @returns {void}\n         * @private\n         */\n        function checkForIrregularLineTerminators(node) {\n            const source = sourceCode.getText(),\n                sourceLines = sourceCode.lines,\n                linebreaks = source.match(LINE_BREAK);\n            let lastLineIndex = -1,\n                match;\n\n            while ((match = IRREGULAR_LINE_TERMINATORS.exec(source)) !== null) {\n                const lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;\n                const location = {\n                    line: lineIndex + 1,\n                    column: sourceLines[lineIndex].length\n                };\n\n                errors.push({ node, message: \"Irregular whitespace not allowed.\", loc: location });\n                lastLineIndex = lineIndex;\n            }\n        }\n\n        /**\n         * A no-op function to act as placeholder for comment accumulation when the `skipComments` option is `false`.\n         * @returns {void}\n         * @private\n         */\n        function noop() {}\n\n        const nodes = {};\n\n        if (ALL_IRREGULARS.test(sourceCode.getText())) {\n            nodes.Program = function(node) {\n\n                /*\n                 * As we can easily fire warnings for all white space issues with\n                 * all the source its simpler to fire them here.\n                 * This means we can check all the application code without having\n                 * to worry about issues caused in the parser tokens.\n                 * When writing this code also evaluating per node was missing out\n                 * connecting tokens in some cases.\n                 * We can later filter the errors when they are found to be not an\n                 * issue in nodes we don't care about.\n                 */\n                checkForIrregularWhitespace(node);\n                checkForIrregularLineTerminators(node);\n            };\n\n            nodes.Identifier = removeInvalidNodeErrorsInIdentifierOrLiteral;\n            nodes.Literal = removeInvalidNodeErrorsInIdentifierOrLiteral;\n            nodes.TemplateElement = skipTemplates ? removeInvalidNodeErrorsInTemplateLiteral : noop;\n            nodes[\"Program:exit\"] = function() {\n                if (skipComments) {\n\n                    // First strip errors occurring in comment nodes.\n                    commentNodes.forEach(removeInvalidNodeErrorsInComment);\n                }\n\n                // If we have any errors remaining report on them\n                errors.forEach(error => context.report(error));\n            };\n        } else {\n            nodes.Program = noop;\n        }\n\n        return nodes;\n    }\n};\n","/**\n * @fileoverview Rule to flag usage of __iterator__ property\n * @author Ian Christian Myers\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of the `__iterator__` property\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-iterator\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            MemberExpression(node) {\n\n                if (node.property &&\n                        (node.property.type === \"Identifier\" && node.property.name === \"__iterator__\" && !node.computed) ||\n                        (node.property.type === \"Literal\" && node.property.value === \"__iterator__\")) {\n                    context.report({ node, message: \"Reserved name '__iterator__'.\" });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag labels that are the same as an identifier\n * @author Ian Christian Myers\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow labels that share a name with a variable\",\n            category: \"Variables\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-label-var\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Check if the identifier is present inside current scope\n         * @param {Object} scope current scope\n         * @param {string} name To evaluate\n         * @returns {boolean} True if its present\n         * @private\n         */\n        function findIdentifier(scope, name) {\n            return astUtils.getVariableByName(scope, name) !== null;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            LabeledStatement(node) {\n\n                // Fetch the innermost scope.\n                const scope = context.getScope();\n\n                /*\n                 * Recursively find the identifier walking up the scope, starting\n                 * with the innermost scope.\n                 */\n                if (findIdentifier(scope, node.label.name)) {\n                    context.report({ node, message: \"Found identifier with same name as label.\" });\n                }\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallow Labeled Statements\n * @author Nicholas C. Zakas\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow labeled statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-labels\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowLoop: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowSwitch: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0];\n        const allowLoop = options && options.allowLoop;\n        const allowSwitch = options && options.allowSwitch;\n        let scopeInfo = null;\n\n        /**\n         * Gets the kind of a given node.\n         *\n         * @param {ASTNode} node - A node to get.\n         * @returns {string} The kind of the node.\n         */\n        function getBodyKind(node) {\n            if (astUtils.isLoop(node)) {\n                return \"loop\";\n            }\n            if (node.type === \"SwitchStatement\") {\n                return \"switch\";\n            }\n            return \"other\";\n        }\n\n        /**\n         * Checks whether the label of a given kind is allowed or not.\n         *\n         * @param {string} kind - A kind to check.\n         * @returns {boolean} `true` if the kind is allowed.\n         */\n        function isAllowed(kind) {\n            switch (kind) {\n                case \"loop\": return allowLoop;\n                case \"switch\": return allowSwitch;\n                default: return false;\n            }\n        }\n\n        /**\n         * Checks whether a given name is a label of a loop or not.\n         *\n         * @param {string} label - A name of a label to check.\n         * @returns {boolean} `true` if the name is a label of a loop.\n         */\n        function getKind(label) {\n            let info = scopeInfo;\n\n            while (info) {\n                if (info.label === label) {\n                    return info.kind;\n                }\n                info = info.upper;\n            }\n\n            /* istanbul ignore next: syntax error */\n            return \"other\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            LabeledStatement(node) {\n                scopeInfo = {\n                    label: node.label.name,\n                    kind: getBodyKind(node.body),\n                    upper: scopeInfo\n                };\n            },\n\n            \"LabeledStatement:exit\"(node) {\n                if (!isAllowed(scopeInfo.kind)) {\n                    context.report({\n                        node,\n                        message: \"Unexpected labeled statement.\"\n                    });\n                }\n\n                scopeInfo = scopeInfo.upper;\n            },\n\n            BreakStatement(node) {\n                if (node.label && !isAllowed(getKind(node.label.name))) {\n                    context.report({\n                        node,\n                        message: \"Unexpected label in break statement.\"\n                    });\n                }\n            },\n\n            ContinueStatement(node) {\n                if (node.label && !isAllowed(getKind(node.label.name))) {\n                    context.report({\n                        node,\n                        message: \"Unexpected label in continue statement.\"\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag blocks with no reason to exist\n * @author Brandon Mills\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary nested blocks\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-lone-blocks\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        // A stack of lone blocks to be checked for block-level bindings\n        const loneBlocks = [];\n        let ruleDef;\n\n        /**\n         * Reports a node as invalid.\n         * @param {ASTNode} node - The node to be reported.\n         * @returns {void}\n         */\n        function report(node) {\n            const message = node.parent.type === \"BlockStatement\" ? \"Nested block is redundant.\" : \"Block is redundant.\";\n\n            context.report({ node, message });\n        }\n\n        /**\n         * Checks for any ocurrence of a BlockStatement in a place where lists of statements can appear\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} True if the node is a lone block.\n         */\n        function isLoneBlock(node) {\n            return node.parent.type === \"BlockStatement\" ||\n                node.parent.type === \"Program\" ||\n\n                // Don't report blocks in switch cases if the block is the only statement of the case.\n                node.parent.type === \"SwitchCase\" && !(node.parent.consequent[0] === node && node.parent.consequent.length === 1);\n        }\n\n        /**\n         * Checks the enclosing block of the current node for block-level bindings,\n         * and \"marks it\" as valid if any.\n         * @returns {void}\n         */\n        function markLoneBlock() {\n            if (loneBlocks.length === 0) {\n                return;\n            }\n\n            const block = context.getAncestors().pop();\n\n            if (loneBlocks[loneBlocks.length - 1] === block) {\n                loneBlocks.pop();\n            }\n        }\n\n        // Default rule definition: report all lone blocks\n        ruleDef = {\n            BlockStatement(node) {\n                if (isLoneBlock(node)) {\n                    report(node);\n                }\n            }\n        };\n\n        // ES6: report blocks without block-level bindings\n        if (context.parserOptions.ecmaVersion >= 6) {\n            ruleDef = {\n                BlockStatement(node) {\n                    if (isLoneBlock(node)) {\n                        loneBlocks.push(node);\n                    }\n                },\n                \"BlockStatement:exit\"(node) {\n                    if (loneBlocks.length > 0 && loneBlocks[loneBlocks.length - 1] === node) {\n                        loneBlocks.pop();\n                        report(node);\n                    }\n                }\n            };\n\n            ruleDef.VariableDeclaration = function(node) {\n                if (node.kind === \"let\" || node.kind === \"const\") {\n                    markLoneBlock();\n                }\n            };\n\n            ruleDef.FunctionDeclaration = function() {\n                if (context.getScope().isStrict) {\n                    markLoneBlock();\n                }\n            };\n\n            ruleDef.ClassDeclaration = markLoneBlock;\n        }\n\n        return ruleDef;\n    }\n};\n","/**\n * @fileoverview Rule to disallow if as the only statmenet in an else block\n * @author Brandon Mills\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `if` statements as the only statement in `else` blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-lonely-if\"\n        },\n\n        schema: [],\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            IfStatement(node) {\n                const ancestors = context.getAncestors(),\n                    parent = ancestors.pop(),\n                    grandparent = ancestors.pop();\n\n                if (parent && parent.type === \"BlockStatement\" &&\n                        parent.body.length === 1 && grandparent &&\n                        grandparent.type === \"IfStatement\" &&\n                        parent === grandparent.alternate) {\n                    context.report({\n                        node,\n                        message: \"Unexpected if as the only statement in an else block.\",\n                        fix(fixer) {\n                            const openingElseCurly = sourceCode.getFirstToken(parent);\n                            const closingElseCurly = sourceCode.getLastToken(parent);\n                            const elseKeyword = sourceCode.getTokenBefore(openingElseCurly);\n                            const tokenAfterElseBlock = sourceCode.getTokenAfter(closingElseCurly);\n                            const lastIfToken = sourceCode.getLastToken(node.consequent);\n                            const sourceText = sourceCode.getText();\n\n                            if (sourceText.slice(openingElseCurly.range[1],\n                                node.range[0]).trim() || sourceText.slice(node.range[1], closingElseCurly.range[0]).trim()) {\n\n                                // Don't fix if there are any non-whitespace characters interfering (e.g. comments)\n                                return null;\n                            }\n\n                            if (\n                                node.consequent.type !== \"BlockStatement\" && lastIfToken.value !== \";\" && tokenAfterElseBlock &&\n                                (\n                                    node.consequent.loc.end.line === tokenAfterElseBlock.loc.start.line ||\n                                    /^[([/+`-]/u.test(tokenAfterElseBlock.value) ||\n                                    lastIfToken.value === \"++\" ||\n                                    lastIfToken.value === \"--\"\n                                )\n                            ) {\n\n                                /*\n                                 * If the `if` statement has no block, and is not followed by a semicolon, make sure that fixing\n                                 * the issue would not change semantics due to ASI. If this would happen, don't do a fix.\n                                 */\n                                return null;\n                            }\n\n                            return fixer.replaceTextRange(\n                                [openingElseCurly.range[0], closingElseCurly.range[1]],\n                                (elseKeyword.range[1] === openingElseCurly.range[0] ? \" \" : \"\") + sourceCode.getText(node)\n                            );\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag creation of function inside a loop\n * @author Ilya Volodin\n */\n\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the containing loop node of a specified node.\n *\n * We don't need to check nested functions, so this ignores those.\n * `Scope.through` contains references of nested functions.\n *\n * @param {ASTNode} node - An AST node to get.\n * @returns {ASTNode|null} The containing loop node of the specified node, or\n *      `null`.\n */\nfunction getContainingLoopNode(node) {\n    for (let currentNode = node; currentNode.parent; currentNode = currentNode.parent) {\n        const parent = currentNode.parent;\n\n        switch (parent.type) {\n            case \"WhileStatement\":\n            case \"DoWhileStatement\":\n                return parent;\n\n            case \"ForStatement\":\n\n                // `init` is outside of the loop.\n                if (parent.init !== currentNode) {\n                    return parent;\n                }\n                break;\n\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n\n                // `right` is outside of the loop.\n                if (parent.right !== currentNode) {\n                    return parent;\n                }\n                break;\n\n            case \"ArrowFunctionExpression\":\n            case \"FunctionExpression\":\n            case \"FunctionDeclaration\":\n\n                // We don't need to check nested functions.\n                return null;\n\n            default:\n                break;\n        }\n    }\n\n    return null;\n}\n\n/**\n * Gets the containing loop node of a given node.\n * If the loop was nested, this returns the most outer loop.\n *\n * @param {ASTNode} node - A node to get. This is a loop node.\n * @param {ASTNode|null} excludedNode - A node that the result node should not\n *      include.\n * @returns {ASTNode} The most outer loop node.\n */\nfunction getTopLoopNode(node, excludedNode) {\n    const border = excludedNode ? excludedNode.range[1] : 0;\n    let retv = node;\n    let containingLoopNode = node;\n\n    while (containingLoopNode && containingLoopNode.range[0] >= border) {\n        retv = containingLoopNode;\n        containingLoopNode = getContainingLoopNode(containingLoopNode);\n    }\n\n    return retv;\n}\n\n/**\n * Checks whether a given reference which refers to an upper scope's variable is\n * safe or not.\n *\n * @param {ASTNode} loopNode - A containing loop node.\n * @param {eslint-scope.Reference} reference - A reference to check.\n * @returns {boolean} `true` if the reference is safe or not.\n */\nfunction isSafe(loopNode, reference) {\n    const variable = reference.resolved;\n    const definition = variable && variable.defs[0];\n    const declaration = definition && definition.parent;\n    const kind = (declaration && declaration.type === \"VariableDeclaration\")\n        ? declaration.kind\n        : \"\";\n\n    // Variables which are declared by `const` is safe.\n    if (kind === \"const\") {\n        return true;\n    }\n\n    /*\n     * Variables which are declared by `let` in the loop is safe.\n     * It's a different instance from the next loop step's.\n     */\n    if (kind === \"let\" &&\n        declaration.range[0] > loopNode.range[0] &&\n        declaration.range[1] < loopNode.range[1]\n    ) {\n        return true;\n    }\n\n    /*\n     * WriteReferences which exist after this border are unsafe because those\n     * can modify the variable.\n     */\n    const border = getTopLoopNode(\n        loopNode,\n        (kind === \"let\") ? declaration : null\n    ).range[0];\n\n    /**\n     * Checks whether a given reference is safe or not.\n     * The reference is every reference of the upper scope's variable we are\n     * looking now.\n     *\n     * It's safeafe if the reference matches one of the following condition.\n     * - is readonly.\n     * - doesn't exist inside a local function and after the border.\n     *\n     * @param {eslint-scope.Reference} upperRef - A reference to check.\n     * @returns {boolean} `true` if the reference is safe.\n     */\n    function isSafeReference(upperRef) {\n        const id = upperRef.identifier;\n\n        return (\n            !upperRef.isWrite() ||\n            variable.scope.variableScope === upperRef.from.variableScope &&\n            id.range[0] < border\n        );\n    }\n\n    return Boolean(variable) && variable.references.every(isSafeReference);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `function` declarations and expressions inside loop statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-loop-func\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Reports functions which match the following condition:\n         *\n         * - has a loop node in ancestors.\n         * - has any references which refers to an unsafe variable.\n         *\n         * @param {ASTNode} node The AST node to check.\n         * @returns {boolean} Whether or not the node is within a loop.\n         */\n        function checkForLoops(node) {\n            const loopNode = getContainingLoopNode(node);\n\n            if (!loopNode) {\n                return;\n            }\n\n            const references = context.getScope().through;\n\n            if (references.length > 0 &&\n                !references.every(isSafe.bind(null, loopNode))\n            ) {\n                context.report({ node, message: \"Don't make functions within a loop.\" });\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: checkForLoops,\n            FunctionExpression: checkForLoops,\n            FunctionDeclaration: checkForLoops\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag statements that use magic numbers (adapted from https://github.com/danielstjules/buddy.js)\n * @author Vincent Lemeunier\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow magic numbers\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-magic-numbers\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                detectObjects: {\n                    type: \"boolean\",\n                    default: false\n                },\n                enforceConst: {\n                    type: \"boolean\",\n                    default: false\n                },\n                ignore: {\n                    type: \"array\",\n                    items: {\n                        type: \"number\"\n                    },\n                    uniqueItems: true\n                },\n                ignoreArrayIndexes: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            useConst: \"Number constants declarations must use 'const'.\",\n            noMagic: \"No magic number: {{raw}}.\"\n        }\n    },\n\n    create(context) {\n        const config = context.options[0] || {},\n            detectObjects = !!config.detectObjects,\n            enforceConst = !!config.enforceConst,\n            ignore = config.ignore || [],\n            ignoreArrayIndexes = !!config.ignoreArrayIndexes;\n\n        /**\n         * Returns whether the node is number literal\n         * @param {Node} node - the node literal being evaluated\n         * @returns {boolean} true if the node is a number literal\n         */\n        function isNumber(node) {\n            return typeof node.value === \"number\";\n        }\n\n        /**\n         * Returns whether the number should be ignored\n         * @param {number} num - the number\n         * @returns {boolean} true if the number should be ignored\n         */\n        function shouldIgnoreNumber(num) {\n            return ignore.indexOf(num) !== -1;\n        }\n\n        /**\n         * Returns whether the number should be ignored when used as a radix within parseInt() or Number.parseInt()\n         * @param {ASTNode} parent - the non-\"UnaryExpression\" parent\n         * @param {ASTNode} node - the node literal being evaluated\n         * @returns {boolean} true if the number should be ignored\n         */\n        function shouldIgnoreParseInt(parent, node) {\n            return parent.type === \"CallExpression\" && node === parent.arguments[1] &&\n                (parent.callee.name === \"parseInt\" ||\n                parent.callee.type === \"MemberExpression\" &&\n                parent.callee.object.name === \"Number\" &&\n                parent.callee.property.name === \"parseInt\");\n        }\n\n        /**\n         * Returns whether the number should be ignored when used to define a JSX prop\n         * @param {ASTNode} parent - the non-\"UnaryExpression\" parent\n         * @returns {boolean} true if the number should be ignored\n         */\n        function shouldIgnoreJSXNumbers(parent) {\n            return parent.type.indexOf(\"JSX\") === 0;\n        }\n\n        /**\n         * Returns whether the number should be ignored when used as an array index with enabled 'ignoreArrayIndexes' option.\n         * @param {ASTNode} parent - the non-\"UnaryExpression\" parent.\n         * @returns {boolean} true if the number should be ignored\n         */\n        function shouldIgnoreArrayIndexes(parent) {\n            return parent.type === \"MemberExpression\" && ignoreArrayIndexes;\n        }\n\n        return {\n            Literal(node) {\n                const okTypes = detectObjects ? [] : [\"ObjectExpression\", \"Property\", \"AssignmentExpression\"];\n\n                if (!isNumber(node)) {\n                    return;\n                }\n\n                let fullNumberNode;\n                let parent;\n                let value;\n                let raw;\n\n                // For negative magic numbers: update the value and parent node\n                if (node.parent.type === \"UnaryExpression\" && node.parent.operator === \"-\") {\n                    fullNumberNode = node.parent;\n                    parent = fullNumberNode.parent;\n                    value = -node.value;\n                    raw = `-${node.raw}`;\n                } else {\n                    fullNumberNode = node;\n                    parent = node.parent;\n                    value = node.value;\n                    raw = node.raw;\n                }\n\n                if (shouldIgnoreNumber(value) ||\n                    shouldIgnoreParseInt(parent, fullNumberNode) ||\n                    shouldIgnoreArrayIndexes(parent) ||\n                    shouldIgnoreJSXNumbers(parent)) {\n                    return;\n                }\n\n                if (parent.type === \"VariableDeclarator\") {\n                    if (enforceConst && parent.parent.kind !== \"const\") {\n                        context.report({\n                            node: fullNumberNode,\n                            messageId: \"useConst\"\n                        });\n                    }\n                } else if (\n                    okTypes.indexOf(parent.type) === -1 ||\n                    (parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\")\n                ) {\n                    context.report({\n                        node: fullNumberNode,\n                        messageId: \"noMagic\",\n                        data: {\n                            raw\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\n\nconst { CALL, CONSTRUCT, ReferenceTracker, getStringIfConstant } = require(\"eslint-utils\");\nconst { RegExpParser, visitRegExpAST } = require(\"regexpp\");\nconst { isCombiningCharacter, isEmojiModifier, isRegionalIndicatorSymbol, isSurrogatePair } = require(\"../util/unicode\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Iterate character sequences of a given nodes.\n *\n * CharacterClassRange syntax can steal a part of character sequence,\n * so this function reverts CharacterClassRange syntax and restore the sequence.\n *\n * @param {regexpp.AST.CharacterClassElement[]} nodes The node list to iterate character sequences.\n * @returns {IterableIterator<number[]>} The list of character sequences.\n */\nfunction *iterateCharacterSequence(nodes) {\n    let seq = [];\n\n    for (const node of nodes) {\n        switch (node.type) {\n            case \"Character\":\n                seq.push(node.value);\n                break;\n\n            case \"CharacterClassRange\":\n                seq.push(node.min.value);\n                yield seq;\n                seq = [node.max.value];\n                break;\n\n            case \"CharacterSet\":\n                if (seq.length > 0) {\n                    yield seq;\n                    seq = [];\n                }\n                break;\n\n            // no default\n        }\n    }\n\n    if (seq.length > 0) {\n        yield seq;\n    }\n}\n\nconst hasCharacterSequence = {\n    surrogatePairWithoutUFlag(chars) {\n        return chars.some((c, i) => i !== 0 && isSurrogatePair(chars[i - 1], c));\n    },\n\n    combiningClass(chars) {\n        return chars.some((c, i) => (\n            i !== 0 &&\n            isCombiningCharacter(c) &&\n            !isCombiningCharacter(chars[i - 1])\n        ));\n    },\n\n    emojiModifier(chars) {\n        return chars.some((c, i) => (\n            i !== 0 &&\n            isEmojiModifier(c) &&\n            !isEmojiModifier(chars[i - 1])\n        ));\n    },\n\n    regionalIndicatorSymbol(chars) {\n        return chars.some((c, i) => (\n            i !== 0 &&\n            isRegionalIndicatorSymbol(c) &&\n            isRegionalIndicatorSymbol(chars[i - 1])\n        ));\n    },\n\n    zwj(chars) {\n        const lastIndex = chars.length - 1;\n\n        return chars.some((c, i) => (\n            i !== 0 &&\n            i !== lastIndex &&\n            c === 0x200d &&\n            chars[i - 1] !== 0x200d &&\n            chars[i + 1] !== 0x200d\n        ));\n    }\n};\n\nconst kinds = Object.keys(hasCharacterSequence);\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow characters which are made with multiple code points in character class syntax\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-misleading-character-class\"\n        },\n\n        schema: [],\n\n        messages: {\n            surrogatePairWithoutUFlag: \"Unexpected surrogate pair in character class. Use 'u' flag.\",\n            combiningClass: \"Unexpected combined character in character class.\",\n            emojiModifier: \"Unexpected modified Emoji in character class.\",\n            regionalIndicatorSymbol: \"Unexpected national flag in character class.\",\n            zwj: \"Unexpected joined character sequence in character class.\"\n        }\n    },\n    create(context) {\n        const parser = new RegExpParser();\n\n        /**\n         * Verify a given regular expression.\n         * @param {Node} node The node to report.\n         * @param {string} pattern The regular expression pattern to verify.\n         * @param {string} flags The flags of the regular expression.\n         * @returns {void}\n         */\n        function verify(node, pattern, flags) {\n            const patternNode = parser.parsePattern(\n                pattern,\n                0,\n                pattern.length,\n                flags.includes(\"u\")\n            );\n            const has = {\n                surrogatePairWithoutUFlag: false,\n                combiningClass: false,\n                variationSelector: false,\n                emojiModifier: false,\n                regionalIndicatorSymbol: false,\n                zwj: false\n            };\n\n            visitRegExpAST(patternNode, {\n                onCharacterClassEnter(ccNode) {\n                    for (const chars of iterateCharacterSequence(ccNode.elements)) {\n                        for (const kind of kinds) {\n                            has[kind] = has[kind] || hasCharacterSequence[kind](chars);\n                        }\n                    }\n                }\n            });\n\n            for (const kind of kinds) {\n                if (has[kind]) {\n                    context.report({ node, messageId: kind });\n                }\n            }\n        }\n\n        return {\n            \"Literal[regex]\"(node) {\n                verify(node, node.regex.pattern, node.regex.flags);\n            },\n            \"Program\"() {\n                const scope = context.getScope();\n                const tracker = new ReferenceTracker(scope);\n\n                /*\n                 * Iterate calls of RegExp.\n                 * E.g., `new RegExp()`, `RegExp()`, `new window.RegExp()`,\n                 *       `const {RegExp: a} = window; new a()`, etc...\n                 */\n                for (const { node } of tracker.iterateGlobalReferences({\n                    RegExp: { [CALL]: true, [CONSTRUCT]: true }\n                })) {\n                    const [patternNode, flagsNode] = node.arguments;\n                    const pattern = getStringIfConstant(patternNode, scope);\n                    const flags = getStringIfConstant(flagsNode, scope);\n\n                    if (typeof pattern === \"string\") {\n                        verify(node, pattern, flags || \"\");\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\n\nmodule.exports = {\n    isCombiningCharacter: require(\"./is-combining-character\"),\n    isEmojiModifier: require(\"./is-emoji-modifier\"),\n    isRegionalIndicatorSymbol: require(\"./is-regional-indicator-symbol\"),\n    isSurrogatePair: require(\"./is-surrogate-pair\")\n};\n","// THIS FILE WAS GENERATED BY 'tools/update-unicode-utils.js'\n\n\nconst combiningChars = new Set([768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,1155,1156,1157,1158,1159,1160,1161,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1471,1473,1474,1476,1477,1479,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1648,1750,1751,1752,1753,1754,1755,1756,1759,1760,1761,1762,1763,1764,1767,1768,1770,1771,1772,1773,1809,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849,1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,2027,2028,2029,2030,2031,2032,2033,2034,2035,2070,2071,2072,2073,2075,2076,2077,2078,2079,2080,2081,2082,2083,2085,2086,2087,2089,2090,2091,2092,2093,2137,2138,2139,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299,2300,2301,2302,2303,2304,2305,2306,2307,2362,2363,2364,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2385,2386,2387,2388,2389,2390,2391,2402,2403,2433,2434,2435,2492,2494,2495,2496,2497,2498,2499,2500,2503,2504,2507,2508,2509,2519,2530,2531,2561,2562,2563,2620,2622,2623,2624,2625,2626,2631,2632,2635,2636,2637,2641,2672,2673,2677,2689,2690,2691,2748,2750,2751,2752,2753,2754,2755,2756,2757,2759,2760,2761,2763,2764,2765,2786,2787,2810,2811,2812,2813,2814,2815,2817,2818,2819,2876,2878,2879,2880,2881,2882,2883,2884,2887,2888,2891,2892,2893,2902,2903,2914,2915,2946,3006,3007,3008,3009,3010,3014,3015,3016,3018,3019,3020,3021,3031,3072,3073,3074,3075,3134,3135,3136,3137,3138,3139,3140,3142,3143,3144,3146,3147,3148,3149,3157,3158,3170,3171,3201,3202,3203,3260,3262,3263,3264,3265,3266,3267,3268,3270,3271,3272,3274,3275,3276,3277,3285,3286,3298,3299,3328,3329,3330,3331,3387,3388,3390,3391,3392,3393,3394,3395,3396,3398,3399,3400,3402,3403,3404,3405,3415,3426,3427,3458,3459,3530,3535,3536,3537,3538,3539,3540,3542,3544,3545,3546,3547,3548,3549,3550,3551,3570,3571,3633,3636,3637,3638,3639,3640,3641,3642,3655,3656,3657,3658,3659,3660,3661,3662,3761,3764,3765,3766,3767,3768,3769,3771,3772,3784,3785,3786,3787,3788,3789,3864,3865,3893,3895,3897,3902,3903,3953,3954,3955,3956,3957,3958,3959,3960,3961,3962,3963,3964,3965,3966,3967,3968,3969,3970,3971,3972,3974,3975,3981,3982,3983,3984,3985,3986,3987,3988,3989,3990,3991,3993,3994,3995,3996,3997,3998,3999,4000,4001,4002,4003,4004,4005,4006,4007,4008,4009,4010,4011,4012,4013,4014,4015,4016,4017,4018,4019,4020,4021,4022,4023,4024,4025,4026,4027,4028,4038,4139,4140,4141,4142,4143,4144,4145,4146,4147,4148,4149,4150,4151,4152,4153,4154,4155,4156,4157,4158,4182,4183,4184,4185,4190,4191,4192,4194,4195,4196,4199,4200,4201,4202,4203,4204,4205,4209,4210,4211,4212,4226,4227,4228,4229,4230,4231,4232,4233,4234,4235,4236,4237,4239,4250,4251,4252,4253,4957,4958,4959,5906,5907,5908,5938,5939,5940,5970,5971,6002,6003,6068,6069,6070,6071,6072,6073,6074,6075,6076,6077,6078,6079,6080,6081,6082,6083,6084,6085,6086,6087,6088,6089,6090,6091,6092,6093,6094,6095,6096,6097,6098,6099,6109,6155,6156,6157,6277,6278,6313,6432,6433,6434,6435,6436,6437,6438,6439,6440,6441,6442,6443,6448,6449,6450,6451,6452,6453,6454,6455,6456,6457,6458,6459,6679,6680,6681,6682,6683,6741,6742,6743,6744,6745,6746,6747,6748,6749,6750,6752,6753,6754,6755,6756,6757,6758,6759,6760,6761,6762,6763,6764,6765,6766,6767,6768,6769,6770,6771,6772,6773,6774,6775,6776,6777,6778,6779,6780,6783,6832,6833,6834,6835,6836,6837,6838,6839,6840,6841,6842,6843,6844,6845,6846,6912,6913,6914,6915,6916,6964,6965,6966,6967,6968,6969,6970,6971,6972,6973,6974,6975,6976,6977,6978,6979,6980,7019,7020,7021,7022,7023,7024,7025,7026,7027,7040,7041,7042,7073,7074,7075,7076,7077,7078,7079,7080,7081,7082,7083,7084,7085,7142,7143,7144,7145,7146,7147,7148,7149,7150,7151,7152,7153,7154,7155,7204,7205,7206,7207,7208,7209,7210,7211,7212,7213,7214,7215,7216,7217,7218,7219,7220,7221,7222,7223,7376,7377,7378,7380,7381,7382,7383,7384,7385,7386,7387,7388,7389,7390,7391,7392,7393,7394,7395,7396,7397,7398,7399,7400,7405,7410,7411,7412,7415,7416,7417,7616,7617,7618,7619,7620,7621,7622,7623,7624,7625,7626,7627,7628,7629,7630,7631,7632,7633,7634,7635,7636,7637,7638,7639,7640,7641,7642,7643,7644,7645,7646,7647,7648,7649,7650,7651,7652,7653,7654,7655,7656,7657,7658,7659,7660,7661,7662,7663,7664,7665,7666,7667,7668,7669,7670,7671,7672,7673,7675,7676,7677,7678,7679,8400,8401,8402,8403,8404,8405,8406,8407,8408,8409,8410,8411,8412,8413,8414,8415,8416,8417,8418,8419,8420,8421,8422,8423,8424,8425,8426,8427,8428,8429,8430,8431,8432,11503,11504,11505,11647,11744,11745,11746,11747,11748,11749,11750,11751,11752,11753,11754,11755,11756,11757,11758,11759,11760,11761,11762,11763,11764,11765,11766,11767,11768,11769,11770,11771,11772,11773,11774,11775,12330,12331,12332,12333,12334,12335,12441,12442,42607,42608,42609,42610,42612,42613,42614,42615,42616,42617,42618,42619,42620,42621,42654,42655,42736,42737,43010,43014,43019,43043,43044,43045,43046,43047,43136,43137,43188,43189,43190,43191,43192,43193,43194,43195,43196,43197,43198,43199,43200,43201,43202,43203,43204,43205,43232,43233,43234,43235,43236,43237,43238,43239,43240,43241,43242,43243,43244,43245,43246,43247,43248,43249,43302,43303,43304,43305,43306,43307,43308,43309,43335,43336,43337,43338,43339,43340,43341,43342,43343,43344,43345,43346,43347,43392,43393,43394,43395,43443,43444,43445,43446,43447,43448,43449,43450,43451,43452,43453,43454,43455,43456,43493,43561,43562,43563,43564,43565,43566,43567,43568,43569,43570,43571,43572,43573,43574,43587,43596,43597,43643,43644,43645,43696,43698,43699,43700,43703,43704,43710,43711,43713,43755,43756,43757,43758,43759,43765,43766,44003,44004,44005,44006,44007,44008,44009,44010,44012,44013,64286,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65056,65057,65058,65059,65060,65061,65062,65063,65064,65065,65066,65067,65068,65069,65070,65071,66045,66272,66422,66423,66424,66425,66426,68097,68098,68099,68101,68102,68108,68109,68110,68111,68152,68153,68154,68159,68325,68326,69632,69633,69634,69688,69689,69690,69691,69692,69693,69694,69695,69696,69697,69698,69699,69700,69701,69702,69759,69760,69761,69762,69808,69809,69810,69811,69812,69813,69814,69815,69816,69817,69818,69888,69889,69890,69927,69928,69929,69930,69931,69932,69933,69934,69935,69936,69937,69938,69939,69940,70003,70016,70017,70018,70067,70068,70069,70070,70071,70072,70073,70074,70075,70076,70077,70078,70079,70080,70090,70091,70092,70188,70189,70190,70191,70192,70193,70194,70195,70196,70197,70198,70199,70206,70367,70368,70369,70370,70371,70372,70373,70374,70375,70376,70377,70378,70400,70401,70402,70403,70460,70462,70463,70464,70465,70466,70467,70468,70471,70472,70475,70476,70477,70487,70498,70499,70502,70503,70504,70505,70506,70507,70508,70512,70513,70514,70515,70516,70709,70710,70711,70712,70713,70714,70715,70716,70717,70718,70719,70720,70721,70722,70723,70724,70725,70726,70832,70833,70834,70835,70836,70837,70838,70839,70840,70841,70842,70843,70844,70845,70846,70847,70848,70849,70850,70851,71087,71088,71089,71090,71091,71092,71093,71096,71097,71098,71099,71100,71101,71102,71103,71104,71132,71133,71216,71217,71218,71219,71220,71221,71222,71223,71224,71225,71226,71227,71228,71229,71230,71231,71232,71339,71340,71341,71342,71343,71344,71345,71346,71347,71348,71349,71350,71351,71453,71454,71455,71456,71457,71458,71459,71460,71461,71462,71463,71464,71465,71466,71467,72193,72194,72195,72196,72197,72198,72199,72200,72201,72202,72243,72244,72245,72246,72247,72248,72249,72251,72252,72253,72254,72263,72273,72274,72275,72276,72277,72278,72279,72280,72281,72282,72283,72330,72331,72332,72333,72334,72335,72336,72337,72338,72339,72340,72341,72342,72343,72344,72345,72751,72752,72753,72754,72755,72756,72757,72758,72760,72761,72762,72763,72764,72765,72766,72767,72850,72851,72852,72853,72854,72855,72856,72857,72858,72859,72860,72861,72862,72863,72864,72865,72866,72867,72868,72869,72870,72871,72873,72874,72875,72876,72877,72878,72879,72880,72881,72882,72883,72884,72885,72886,73009,73010,73011,73012,73013,73014,73018,73020,73021,73023,73024,73025,73026,73027,73028,73029,73031,92912,92913,92914,92915,92916,92976,92977,92978,92979,92980,92981,92982,94033,94034,94035,94036,94037,94038,94039,94040,94041,94042,94043,94044,94045,94046,94047,94048,94049,94050,94051,94052,94053,94054,94055,94056,94057,94058,94059,94060,94061,94062,94063,94064,94065,94066,94067,94068,94069,94070,94071,94072,94073,94074,94075,94076,94077,94078,94095,94096,94097,94098,113821,113822,119141,119142,119143,119144,119145,119149,119150,119151,119152,119153,119154,119163,119164,119165,119166,119167,119168,119169,119170,119173,119174,119175,119176,119177,119178,119179,119210,119211,119212,119213,119362,119363,119364,121344,121345,121346,121347,121348,121349,121350,121351,121352,121353,121354,121355,121356,121357,121358,121359,121360,121361,121362,121363,121364,121365,121366,121367,121368,121369,121370,121371,121372,121373,121374,121375,121376,121377,121378,121379,121380,121381,121382,121383,121384,121385,121386,121387,121388,121389,121390,121391,121392,121393,121394,121395,121396,121397,121398,121403,121404,121405,121406,121407,121408,121409,121410,121411,121412,121413,121414,121415,121416,121417,121418,121419,121420,121421,121422,121423,121424,121425,121426,121427,121428,121429,121430,121431,121432,121433,121434,121435,121436,121437,121438,121439,121440,121441,121442,121443,121444,121445,121446,121447,121448,121449,121450,121451,121452,121461,121476,121499,121500,121501,121502,121503,121505,121506,121507,121508,121509,121510,121511,121512,121513,121514,121515,121516,121517,121518,121519,122880,122881,122882,122883,122884,122885,122886,122888,122889,122890,122891,122892,122893,122894,122895,122896,122897,122898,122899,122900,122901,122902,122903,122904,122907,122908,122909,122910,122911,122912,122913,122915,122916,122918,122919,122920,122921,122922,125136,125137,125138,125139,125140,125141,125142,125252,125253,125254,125255,125256,125257,125258,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999])\n\n/**\n * Check whether a given character is a combining mark or not.\n * @param {number} c The character code to check.\n * @returns {boolean} `true` if the character belongs to the category, one of `Mc`, `Me`, and `Mn`.\n */\nmodule.exports = function isCombiningCharacter(c) {\n    return combiningChars.has(c);\n};\n","/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\n\n/**\n * Check whether a given character is an emoji modifier.\n * @param {number} code The character code to check.\n * @returns {boolean} `true` if the character is an emoji modifier.\n */\nmodule.exports = function isEmojiModifier(code) {\n    return code >= 0x1F3FB && code <= 0x1F3FF;\n};\n","/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\n\n/**\n * Check whether a given character is a regional indicator symbol.\n * @param {number} code The character code to check.\n * @returns {boolean} `true` if the character is a regional indicator symbol.\n */\nmodule.exports = function isRegionalIndicatorSymbol(code) {\n    return code >= 0x1F1E6 && code <= 0x1F1FF;\n};\n","/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\n\n/**\n * Check whether given two characters are a surrogate pair.\n * @param {number} lead The code of the lead character.\n * @param {number} tail The code of the tail character.\n * @returns {boolean} `true` if the character pair is a surrogate pair.\n */\nmodule.exports = function isSurrogatePair(lead, tail) {\n    return lead >= 0xD800 && lead < 0xDC00 && tail >= 0xDC00 && tail < 0xE000;\n};\n","/**\n * @fileoverview Rule to disallow mixed binary operators.\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils.js\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst ARITHMETIC_OPERATORS = [\"+\", \"-\", \"*\", \"/\", \"%\", \"**\"];\nconst BITWISE_OPERATORS = [\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"];\nconst COMPARISON_OPERATORS = [\"==\", \"!=\", \"===\", \"!==\", \">\", \">=\", \"<\", \"<=\"];\nconst LOGICAL_OPERATORS = [\"&&\", \"||\"];\nconst RELATIONAL_OPERATORS = [\"in\", \"instanceof\"];\nconst ALL_OPERATORS = [].concat(\n    ARITHMETIC_OPERATORS,\n    BITWISE_OPERATORS,\n    COMPARISON_OPERATORS,\n    LOGICAL_OPERATORS,\n    RELATIONAL_OPERATORS\n);\nconst DEFAULT_GROUPS = [\n    ARITHMETIC_OPERATORS,\n    BITWISE_OPERATORS,\n    COMPARISON_OPERATORS,\n    LOGICAL_OPERATORS,\n    RELATIONAL_OPERATORS\n];\nconst TARGET_NODE_TYPE = /^(?:Binary|Logical)Expression$/u;\n\n/**\n * Normalizes options.\n *\n * @param {Object|undefined} options - A options object to normalize.\n * @returns {Object} Normalized option object.\n */\nfunction normalizeOptions(options = {}) {\n    const hasGroups = options.groups && options.groups.length > 0;\n    const groups = hasGroups ? options.groups : DEFAULT_GROUPS;\n    const allowSamePrecedence = options.allowSamePrecedence !== false;\n\n    return {\n        groups,\n        allowSamePrecedence\n    };\n}\n\n/**\n * Checks whether any group which includes both given operator exists or not.\n *\n * @param {Array.<string[]>} groups - A list of groups to check.\n * @param {string} left - An operator.\n * @param {string} right - Another operator.\n * @returns {boolean} `true` if such group existed.\n */\nfunction includesBothInAGroup(groups, left, right) {\n    return groups.some(group => group.indexOf(left) !== -1 && group.indexOf(right) !== -1);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow mixed binary operators\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-mixed-operators\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    groups: {\n                        type: \"array\",\n                        items: {\n                            type: \"array\",\n                            items: { enum: ALL_OPERATORS },\n                            minItems: 2,\n                            uniqueItems: true\n                        },\n                        uniqueItems: true\n                    },\n                    allowSamePrecedence: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = normalizeOptions(context.options[0]);\n\n        /**\n         * Checks whether a given node should be ignored by options or not.\n         *\n         * @param {ASTNode} node - A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node. This parent node is one of\n         *      them, too.\n         * @returns {boolean} `true` if the node should be ignored.\n         */\n        function shouldIgnore(node) {\n            const a = node;\n            const b = node.parent;\n\n            return (\n                !includesBothInAGroup(options.groups, a.operator, b.operator) ||\n                (\n                    options.allowSamePrecedence &&\n                    astUtils.getPrecedence(a) === astUtils.getPrecedence(b)\n                )\n            );\n        }\n\n        /**\n         * Checks whether the operator of a given node is mixed with parent\n         * node's operator or not.\n         *\n         * @param {ASTNode} node - A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node. This parent node is one of\n         *      them, too.\n         * @returns {boolean} `true` if the node was mixed.\n         */\n        function isMixedWithParent(node) {\n            return (\n                node.operator !== node.parent.operator &&\n                !astUtils.isParenthesised(sourceCode, node)\n            );\n        }\n\n        /**\n         * Gets the operator token of a given node.\n         *\n         * @param {ASTNode} node - A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node.\n         * @returns {Token} The operator token of the node.\n         */\n        function getOperatorToken(node) {\n            return sourceCode.getTokenAfter(node.left, astUtils.isNotClosingParenToken);\n        }\n\n        /**\n         * Reports both the operator of a given node and the operator of the\n         * parent node.\n         *\n         * @param {ASTNode} node - A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node. This parent node is one of\n         *      them, too.\n         * @returns {void}\n         */\n        function reportBothOperators(node) {\n            const parent = node.parent;\n            const left = (parent.left === node) ? node : parent;\n            const right = (parent.left !== node) ? node : parent;\n            const message =\n                \"Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'.\";\n            const data = {\n                leftOperator: left.operator,\n                rightOperator: right.operator\n            };\n\n            context.report({\n                node: left,\n                loc: getOperatorToken(left).loc.start,\n                message,\n                data\n            });\n            context.report({\n                node: right,\n                loc: getOperatorToken(right).loc.start,\n                message,\n                data\n            });\n        }\n\n        /**\n         * Checks between the operator of this node and the operator of the\n         * parent node.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            if (TARGET_NODE_TYPE.test(node.parent.type) &&\n                isMixedWithParent(node) &&\n                !shouldIgnore(node)\n            ) {\n                reportBothOperators(node);\n            }\n        }\n\n        return {\n            BinaryExpression: check,\n            LogicalExpression: check\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce grouped require statements for Node.JS\n * @author Raphael Pigulla\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `require` calls to be mixed with regular variable declarations\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-mixed-requires\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"boolean\"\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            grouping: {\n                                type: \"boolean\"\n                            },\n                            allowCall: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n\n        const options = context.options[0];\n        let grouping = false,\n            allowCall = false;\n\n        if (typeof options === \"object\") {\n            grouping = options.grouping;\n            allowCall = options.allowCall;\n        } else {\n            grouping = !!options;\n        }\n\n        /**\n         * Returns the list of built-in modules.\n         *\n         * @returns {string[]} An array of built-in Node.js modules.\n         */\n        function getBuiltinModules() {\n\n            /*\n             * This list is generated using:\n             * `require(\"repl\")._builtinLibs.concat('repl').sort()`\n             * This particular list is as per nodejs v0.12.2 and iojs v0.7.1\n             */\n            return [\n                \"assert\", \"buffer\", \"child_process\", \"cluster\", \"crypto\",\n                \"dgram\", \"dns\", \"domain\", \"events\", \"fs\", \"http\", \"https\",\n                \"net\", \"os\", \"path\", \"punycode\", \"querystring\", \"readline\",\n                \"repl\", \"smalloc\", \"stream\", \"string_decoder\", \"tls\", \"tty\",\n                \"url\", \"util\", \"v8\", \"vm\", \"zlib\"\n            ];\n        }\n\n        const BUILTIN_MODULES = getBuiltinModules();\n\n        const DECL_REQUIRE = \"require\",\n            DECL_UNINITIALIZED = \"uninitialized\",\n            DECL_OTHER = \"other\";\n\n        const REQ_CORE = \"core\",\n            REQ_FILE = \"file\",\n            REQ_MODULE = \"module\",\n            REQ_COMPUTED = \"computed\";\n\n        /**\n         * Determines the type of a declaration statement.\n         * @param {ASTNode} initExpression The init node of the VariableDeclarator.\n         * @returns {string} The type of declaration represented by the expression.\n         */\n        function getDeclarationType(initExpression) {\n            if (!initExpression) {\n\n                // \"var x;\"\n                return DECL_UNINITIALIZED;\n            }\n\n            if (initExpression.type === \"CallExpression\" &&\n                initExpression.callee.type === \"Identifier\" &&\n                initExpression.callee.name === \"require\"\n            ) {\n\n                // \"var x = require('util');\"\n                return DECL_REQUIRE;\n            }\n            if (allowCall &&\n                initExpression.type === \"CallExpression\" &&\n                initExpression.callee.type === \"CallExpression\"\n            ) {\n\n                // \"var x = require('diagnose')('sub-module');\"\n                return getDeclarationType(initExpression.callee);\n            }\n            if (initExpression.type === \"MemberExpression\") {\n\n                // \"var x = require('glob').Glob;\"\n                return getDeclarationType(initExpression.object);\n            }\n\n            // \"var x = 42;\"\n            return DECL_OTHER;\n        }\n\n        /**\n         * Determines the type of module that is loaded via require.\n         * @param {ASTNode} initExpression The init node of the VariableDeclarator.\n         * @returns {string} The module type.\n         */\n        function inferModuleType(initExpression) {\n            if (initExpression.type === \"MemberExpression\") {\n\n                // \"var x = require('glob').Glob;\"\n                return inferModuleType(initExpression.object);\n            }\n            if (initExpression.arguments.length === 0) {\n\n                // \"var x = require();\"\n                return REQ_COMPUTED;\n            }\n\n            const arg = initExpression.arguments[0];\n\n            if (arg.type !== \"Literal\" || typeof arg.value !== \"string\") {\n\n                // \"var x = require(42);\"\n                return REQ_COMPUTED;\n            }\n\n            if (BUILTIN_MODULES.indexOf(arg.value) !== -1) {\n\n                // \"var fs = require('fs');\"\n                return REQ_CORE;\n            }\n            if (/^\\.{0,2}\\//u.test(arg.value)) {\n\n                // \"var utils = require('./utils');\"\n                return REQ_FILE;\n            }\n\n            // \"var async = require('async');\"\n            return REQ_MODULE;\n\n        }\n\n        /**\n         * Check if the list of variable declarations is mixed, i.e. whether it\n         * contains both require and other declarations.\n         * @param {ASTNode} declarations The list of VariableDeclarators.\n         * @returns {boolean} True if the declarations are mixed, false if not.\n         */\n        function isMixed(declarations) {\n            const contains = {};\n\n            declarations.forEach(declaration => {\n                const type = getDeclarationType(declaration.init);\n\n                contains[type] = true;\n            });\n\n            return !!(\n                contains[DECL_REQUIRE] &&\n                (contains[DECL_UNINITIALIZED] || contains[DECL_OTHER])\n            );\n        }\n\n        /**\n         * Check if all require declarations in the given list are of the same\n         * type.\n         * @param {ASTNode} declarations The list of VariableDeclarators.\n         * @returns {boolean} True if the declarations are grouped, false if not.\n         */\n        function isGrouped(declarations) {\n            const found = {};\n\n            declarations.forEach(declaration => {\n                if (getDeclarationType(declaration.init) === DECL_REQUIRE) {\n                    found[inferModuleType(declaration.init)] = true;\n                }\n            });\n\n            return Object.keys(found).length <= 1;\n        }\n\n\n        return {\n\n            VariableDeclaration(node) {\n\n                if (isMixed(node.declarations)) {\n                    context.report({ node, message: \"Do not mix 'require' and other declarations.\" });\n                } else if (grouping && !isGrouped(node.declarations)) {\n                    context.report({ node, message: \"Do not mix core, module, file and computed requires.\" });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallow mixed spaces and tabs for indentation\n * @author Jary Niebur\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow mixed spaces and tabs for indentation\",\n            category: \"Stylistic Issues\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-mixed-spaces-and-tabs\"\n        },\n\n        schema: [\n            {\n                enum: [\"smart-tabs\", true, false]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        let smartTabs;\n        const ignoredLocs = [];\n\n        switch (context.options[0]) {\n            case true: // Support old syntax, maybe add deprecation warning here\n            case \"smart-tabs\":\n                smartTabs = true;\n                break;\n            default:\n                smartTabs = false;\n        }\n\n        /**\n         * Determines if a given line and column are before a location.\n         * @param {Location} loc The location object from an AST node.\n         * @param {int} line The line to check.\n         * @param {int} column The column to check.\n         * @returns {boolean} True if the line and column are before the location, false if not.\n         * @private\n         */\n        function beforeLoc(loc, line, column) {\n            if (line < loc.start.line) {\n                return true;\n            }\n            return line === loc.start.line && column < loc.start.column;\n        }\n\n        /**\n         * Determines if a given line and column are after a location.\n         * @param {Location} loc The location object from an AST node.\n         * @param {int} line The line to check.\n         * @param {int} column The column to check.\n         * @returns {boolean} True if the line and column are after the location, false if not.\n         * @private\n         */\n        function afterLoc(loc, line, column) {\n            if (line > loc.end.line) {\n                return true;\n            }\n            return line === loc.end.line && column > loc.end.column;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            TemplateElement(node) {\n                ignoredLocs.push(node.loc);\n            },\n\n            \"Program:exit\"(node) {\n\n                /*\n                 * At least one space followed by a tab\n                 * or the reverse before non-tab/-space\n                 * characters begin.\n                 */\n                let regex = /^(?=[\\t ]*(\\t | \\t))/u;\n                const lines = sourceCode.lines,\n                    comments = sourceCode.getAllComments();\n\n                comments.forEach(comment => {\n                    ignoredLocs.push(comment.loc);\n                });\n\n                ignoredLocs.sort((first, second) => {\n                    if (beforeLoc(first, second.start.line, second.start.column)) {\n                        return 1;\n                    }\n\n                    if (beforeLoc(second, first.start.line, second.start.column)) {\n                        return -1;\n                    }\n\n                    return 0;\n                });\n\n                if (smartTabs) {\n\n                    /*\n                     * At least one space followed by a tab\n                     * before non-tab/-space characters begin.\n                     */\n                    regex = /^(?=[\\t ]* \\t)/u;\n                }\n\n                lines.forEach((line, i) => {\n                    const match = regex.exec(line);\n\n                    if (match) {\n                        const lineNumber = i + 1,\n                            column = match.index + 1;\n\n                        for (let j = 0; j < ignoredLocs.length; j++) {\n                            if (beforeLoc(ignoredLocs[j], lineNumber, column)) {\n                                continue;\n                            }\n                            if (afterLoc(ignoredLocs[j], lineNumber, column)) {\n                                continue;\n                            }\n\n                            return;\n                        }\n\n                        context.report({ node, loc: { line: lineNumber, column }, message: \"Mixed spaces and tabs.\" });\n                    }\n                });\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to check use of chained assignment expressions\n * @author Stewart Rand\n */\n\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow use of chained assignment expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-multi-assign\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            AssignmentExpression(node) {\n                if ([\"AssignmentExpression\", \"VariableDeclarator\"].indexOf(node.parent.type) !== -1) {\n                    context.report({\n                        node,\n                        message: \"Unexpected chained assignment.\"\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallow use of multiple spaces.\n * @author Nicholas C. Zakas\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow multiple spaces\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-multi-spaces\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"object\",\n                        patternProperties: {\n                            \"^([A-Z][a-z]*)+$\": {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    ignoreEOLComments: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = context.options[0] || {};\n        const ignoreEOLComments = options.ignoreEOLComments;\n        const exceptions = Object.assign({ Property: true }, options.exceptions);\n        const hasExceptions = Object.keys(exceptions).filter(key => exceptions[key]).length > 0;\n\n        /**\n         * Formats value of given comment token for error message by truncating its length.\n         * @param {Token} token comment token\n         * @returns {string} formatted value\n         * @private\n         */\n        function formatReportedCommentValue(token) {\n            const valueLines = token.value.split(\"\\n\");\n            const value = valueLines[0];\n            const formattedValue = `${value.slice(0, 12)}...`;\n\n            return valueLines.length === 1 && value.length <= 12 ? value : formattedValue;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program() {\n                sourceCode.tokensAndComments.forEach((leftToken, leftIndex, tokensAndComments) => {\n                    if (leftIndex === tokensAndComments.length - 1) {\n                        return;\n                    }\n                    const rightToken = tokensAndComments[leftIndex + 1];\n\n                    // Ignore tokens that don't have 2 spaces between them or are on different lines\n                    if (\n                        !sourceCode.text.slice(leftToken.range[1], rightToken.range[0]).includes(\"  \") ||\n                        leftToken.loc.end.line < rightToken.loc.start.line\n                    ) {\n                        return;\n                    }\n\n                    // Ignore comments that are the last token on their line if `ignoreEOLComments` is active.\n                    if (\n                        ignoreEOLComments &&\n                        astUtils.isCommentToken(rightToken) &&\n                        (\n                            leftIndex === tokensAndComments.length - 2 ||\n                            rightToken.loc.end.line < tokensAndComments[leftIndex + 2].loc.start.line\n                        )\n                    ) {\n                        return;\n                    }\n\n                    // Ignore tokens that are in a node in the \"exceptions\" object\n                    if (hasExceptions) {\n                        const parentNode = sourceCode.getNodeByRangeIndex(rightToken.range[0] - 1);\n\n                        if (parentNode && exceptions[parentNode.type]) {\n                            return;\n                        }\n                    }\n\n                    let displayValue;\n\n                    if (rightToken.type === \"Block\") {\n                        displayValue = `/*${formatReportedCommentValue(rightToken)}*/`;\n                    } else if (rightToken.type === \"Line\") {\n                        displayValue = `//${formatReportedCommentValue(rightToken)}`;\n                    } else {\n                        displayValue = rightToken.value;\n                    }\n\n                    context.report({\n                        node: rightToken,\n                        loc: rightToken.loc.start,\n                        message: \"Multiple spaces found before '{{displayValue}}'.\",\n                        data: { displayValue },\n                        fix: fixer => fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], \" \")\n                    });\n                });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag when using multiline strings\n * @author Ilya Volodin\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow multiline strings\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-multi-str\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Determines if a given node is part of JSX syntax.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is a JSX node, false if not.\n         * @private\n         */\n        function isJSXElement(node) {\n            return node.type.indexOf(\"JSX\") === 0;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            Literal(node) {\n                if (astUtils.LINEBREAK_MATCHER.test(node.raw) && !isJSXElement(node.parent)) {\n                    context.report({ node, message: \"Multiline support is limited to browsers supporting ES5 only.\" });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallows multiple blank lines.\n * implementation adapted from the no-trailing-spaces rule.\n * @author Greg Cochard\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow multiple empty lines\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-multiple-empty-lines\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    max: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    maxEOF: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    maxBOF: {\n                        type: \"integer\",\n                        minimum: 0\n                    }\n                },\n                required: [\"max\"],\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        // Use options.max or 2 as default\n        let max = 2,\n            maxEOF = max,\n            maxBOF = max;\n\n        if (context.options.length) {\n            max = context.options[0].max;\n            maxEOF = typeof context.options[0].maxEOF !== \"undefined\" ? context.options[0].maxEOF : max;\n            maxBOF = typeof context.options[0].maxBOF !== \"undefined\" ? context.options[0].maxBOF : max;\n        }\n\n        const sourceCode = context.getSourceCode();\n\n        // Swallow the final newline, as some editors add it automatically and we don't want it to cause an issue\n        const allLines = sourceCode.lines[sourceCode.lines.length - 1] === \"\" ? sourceCode.lines.slice(0, -1) : sourceCode.lines;\n        const templateLiteralLines = new Set();\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            TemplateLiteral(node) {\n                node.quasis.forEach(literalPart => {\n\n                    // Empty lines have a semantic meaning if they're inside template literals. Don't count these as empty lines.\n                    for (let ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) {\n                        templateLiteralLines.add(ignoredLine);\n                    }\n                });\n            },\n            \"Program:exit\"(node) {\n                return allLines\n\n                    // Given a list of lines, first get a list of line numbers that are non-empty.\n                    .reduce((nonEmptyLineNumbers, line, index) => {\n                        if (line.trim() || templateLiteralLines.has(index + 1)) {\n                            nonEmptyLineNumbers.push(index + 1);\n                        }\n                        return nonEmptyLineNumbers;\n                    }, [])\n\n                    // Add a value at the end to allow trailing empty lines to be checked.\n                    .concat(allLines.length + 1)\n\n                    // Given two line numbers of non-empty lines, report the lines between if the difference is too large.\n                    .reduce((lastLineNumber, lineNumber) => {\n                        let message, maxAllowed;\n\n                        if (lastLineNumber === 0) {\n                            message = \"Too many blank lines at the beginning of file. Max of {{max}} allowed.\";\n                            maxAllowed = maxBOF;\n                        } else if (lineNumber === allLines.length + 1) {\n                            message = \"Too many blank lines at the end of file. Max of {{max}} allowed.\";\n                            maxAllowed = maxEOF;\n                        } else {\n                            message = \"More than {{max}} blank {{pluralizedLines}} not allowed.\";\n                            maxAllowed = max;\n                        }\n\n                        if (lineNumber - lastLineNumber - 1 > maxAllowed) {\n                            context.report({\n                                node,\n                                loc: { start: { line: lastLineNumber + 1, column: 0 }, end: { line: lineNumber, column: 0 } },\n                                message,\n                                data: { max: maxAllowed, pluralizedLines: maxAllowed === 1 ? \"line\" : \"lines\" },\n                                fix(fixer) {\n                                    const rangeStart = sourceCode.getIndexFromLoc({ line: lastLineNumber + 1, column: 0 });\n\n                                    /*\n                                     * The end of the removal range is usually the start index of the next line.\n                                     * However, at the end of the file there is no next line, so the end of the\n                                     * range is just the length of the text.\n                                     */\n                                    const lineNumberAfterRemovedLines = lineNumber - maxAllowed;\n                                    const rangeEnd = lineNumberAfterRemovedLines <= allLines.length\n                                        ? sourceCode.getIndexFromLoc({ line: lineNumberAfterRemovedLines, column: 0 })\n                                        : sourceCode.text.length;\n\n                                    return fixer.removeRange([rangeStart, rangeEnd]);\n                                }\n                            });\n                        }\n\n                        return lineNumber;\n                    }, 0);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow assignments to native objects or read-only global variables\n * @author Ilya Volodin\n * @deprecated in ESLint v3.3.0\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow assignments to native objects or read-only global variables\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-native-reassign\"\n        },\n\n        deprecated: true,\n\n        replacedBy: [\"no-global-assign\"],\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: { type: \"string\" },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const config = context.options[0];\n        const exceptions = (config && config.exceptions) || [];\n\n        /**\n         * Reports write references.\n         * @param {Reference} reference - A reference to check.\n         * @param {int} index - The index of the reference in the references.\n         * @param {Reference[]} references - The array that the reference belongs to.\n         * @returns {void}\n         */\n        function checkReference(reference, index, references) {\n            const identifier = reference.identifier;\n\n            if (reference.init === false &&\n                reference.isWrite() &&\n\n                /*\n                 * Destructuring assignments can have multiple default value,\n                 * so possibly there are multiple writeable references for the same identifier.\n                 */\n                (index === 0 || references[index - 1].identifier !== identifier)\n            ) {\n                context.report({\n                    node: identifier,\n                    message: \"Read-only global '{{name}}' should not be modified.\",\n                    data: identifier\n                });\n            }\n        }\n\n        /**\n         * Reports write references if a given variable is read-only builtin.\n         * @param {Variable} variable - A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {\n                variable.references.forEach(checkReference);\n            }\n        }\n\n        return {\n            Program() {\n                const globalScope = context.getScope();\n\n                globalScope.variables.forEach(checkVariable);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow a negated condition\n * @author Alberto Rodríguez\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow negated conditions\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-negated-condition\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Determines if a given node is an if-else without a condition on the else\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node has an else without an if.\n         * @private\n         */\n        function hasElseWithoutCondition(node) {\n            return node.alternate && node.alternate.type !== \"IfStatement\";\n        }\n\n        /**\n         * Determines if a given node is a negated unary expression\n         * @param {Object} test The test object to check.\n         * @returns {boolean} True if the node is a negated unary expression.\n         * @private\n         */\n        function isNegatedUnaryExpression(test) {\n            return test.type === \"UnaryExpression\" && test.operator === \"!\";\n        }\n\n        /**\n         * Determines if a given node is a negated binary expression\n         * @param {Test} test The test to check.\n         * @returns {boolean} True if the node is a negated binary expression.\n         * @private\n         */\n        function isNegatedBinaryExpression(test) {\n            return test.type === \"BinaryExpression\" &&\n                (test.operator === \"!=\" || test.operator === \"!==\");\n        }\n\n        /**\n         * Determines if a given node has a negated if expression\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node has a negated if expression.\n         * @private\n         */\n        function isNegatedIf(node) {\n            return isNegatedUnaryExpression(node.test) || isNegatedBinaryExpression(node.test);\n        }\n\n        return {\n            IfStatement(node) {\n                if (!hasElseWithoutCondition(node)) {\n                    return;\n                }\n\n                if (isNegatedIf(node)) {\n                    context.report({ node, message: \"Unexpected negated condition.\" });\n                }\n            },\n            ConditionalExpression(node) {\n                if (isNegatedIf(node)) {\n                    context.report({ node, message: \"Unexpected negated condition.\" });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A rule to disallow negated left operands of the `in` operator\n * @author Michael Ficarra\n * @deprecated in ESLint v3.3.0\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow negating the left operand in `in` expressions\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-negated-in-lhs\"\n        },\n\n        replacedBy: [\"no-unsafe-negation\"],\n\n        deprecated: true,\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            BinaryExpression(node) {\n                if (node.operator === \"in\" && node.left.type === \"UnaryExpression\" && node.left.operator === \"!\") {\n                    context.report({ node, message: \"The 'in' expression's left operand is negated.\" });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag nested ternary expressions\n * @author Ian Christian Myers\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow nested ternary expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-nested-ternary\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n            ConditionalExpression(node) {\n                if (node.alternate.type === \"ConditionalExpression\" ||\n                        node.consequent.type === \"ConditionalExpression\") {\n                    context.report({ node, message: \"Do not nest ternary expressions.\" });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag statements with function invocation preceded by\n * \"new\" and not part of assignment\n * @author Ilya Volodin\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `new` operators outside of assignments or comparisons\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-new\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n            \"ExpressionStatement > NewExpression\"(node) {\n                context.report({ node: node.parent, message: \"Do not use 'new' for side effects.\" });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag when using new Function\n * @author Ilya Volodin\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `new` operators with the `Function` object\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-new-func\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports a node.\n         * @param {ASTNode} node The node to report\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            context.report({ node, message: \"The Function constructor is eval.\" });\n        }\n\n        return {\n            \"NewExpression[callee.name = 'Function']\": report,\n            \"CallExpression[callee.name = 'Function']\": report\n        };\n\n    }\n};\n","/**\n * @fileoverview A rule to disallow calls to the Object constructor\n * @author Matt DuVall <http://www.mattduvall.com/>\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `Object` constructors\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-new-object\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            NewExpression(node) {\n                if (node.callee.name === \"Object\") {\n                    context.report({ node, message: \"The object literal notation {} is preferrable.\" });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to disallow use of new operator with the `require` function\n * @author Wil Moore III\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `new` operators with calls to `require`\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-new-require\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            NewExpression(node) {\n                if (node.callee.type === \"Identifier\" && node.callee.name === \"require\") {\n                    context.report({ node, message: \"Unexpected use of new with require.\" });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to disallow use of the new operator with the `Symbol` object\n * @author Alberto Rodríguez\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow `new` operators with the `Symbol` object\",\n            category: \"ECMAScript 6\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-new-symbol\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n                const variable = globalScope.set.get(\"Symbol\");\n\n                if (variable && variable.defs.length === 0) {\n                    variable.references.forEach(ref => {\n                        const node = ref.identifier;\n\n                        if (node.parent && node.parent.type === \"NewExpression\") {\n                            context.report({ node, message: \"`Symbol` cannot be called as a constructor.\" });\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag when using constructor for wrapper objects\n * @author Ilya Volodin\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `new` operators with the `String`, `Number`, and `Boolean` objects\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-new-wrappers\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            NewExpression(node) {\n                const wrapperObjects = [\"String\", \"Number\", \"Boolean\", \"Math\", \"JSON\"];\n\n                if (wrapperObjects.indexOf(node.callee.name) > -1) {\n                    context.report({ node, message: \"Do not use {{fn}} as a constructor.\", data: { fn: node.callee.name } });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use of an object property of the global object (Math and JSON) as a function\n * @author James Allardice\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow calling global object properties as functions\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-obj-calls\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n            CallExpression(node) {\n\n                if (node.callee.type === \"Identifier\") {\n                    const name = node.callee.name;\n\n                    if (name === \"Math\" || name === \"JSON\" || name === \"Reflect\") {\n                        context.report({ node, message: \"'{{name}}' is not a function.\", data: { name } });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag when initializing octal literal\n * @author Ilya Volodin\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow octal literals\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-octal\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            Literal(node) {\n                if (typeof node.value === \"number\" && /^0[0-7]/u.test(node.raw)) {\n                    context.report({ node, message: \"Octal literals should not be used.\" });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag octal escape sequences in string literals.\n * @author Ian Christian Myers\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow octal escape sequences in string literals\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-octal-escape\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            Literal(node) {\n                if (typeof node.value !== \"string\") {\n                    return;\n                }\n\n                const match = node.raw.match(/^([^\\\\]|\\\\[^0-7])*\\\\([0-3][0-7]{1,2}|[4-7][0-7]|[0-7])/u);\n\n                if (match) {\n                    const octalDigit = match[2];\n\n                    // \\0 is actually not considered an octal\n                    if (match[2] !== \"0\" || typeof match[3] !== \"undefined\") {\n                        context.report({ node, message: \"Don't use octal: '\\\\{{octalDigit}}'. Use '\\\\u....' instead.\", data: { octalDigit } });\n                    }\n                }\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallow reassignment of function parameters.\n * @author Nat Burns\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/u;\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow reassigning `function` parameters\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-param-reassign\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"object\",\n                        properties: {\n                            props: {\n                                enum: [false]\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            props: {\n                                enum: [true]\n                            },\n                            ignorePropertyModificationsFor: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                },\n                                uniqueItems: true\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const props = context.options[0] && context.options[0].props;\n        const ignoredPropertyAssignmentsFor = context.options[0] && context.options[0].ignorePropertyModificationsFor || [];\n\n        /**\n         * Checks whether or not the reference modifies properties of its variable.\n         * @param {Reference} reference - A reference to check.\n         * @returns {boolean} Whether or not the reference modifies properties of its variable.\n         */\n        function isModifyingProp(reference) {\n            let node = reference.identifier;\n            let parent = node.parent;\n\n            while (parent && !stopNodePattern.test(parent.type)) {\n                switch (parent.type) {\n\n                    // e.g. foo.a = 0;\n                    case \"AssignmentExpression\":\n                        return parent.left === node;\n\n                    // e.g. ++foo.a;\n                    case \"UpdateExpression\":\n                        return true;\n\n                    // e.g. delete foo.a;\n                    case \"UnaryExpression\":\n                        if (parent.operator === \"delete\") {\n                            return true;\n                        }\n                        break;\n\n                    // EXCLUDES: e.g. cache.get(foo.a).b = 0;\n                    case \"CallExpression\":\n                        if (parent.callee !== node) {\n                            return false;\n                        }\n                        break;\n\n                    // EXCLUDES: e.g. cache[foo.a] = 0;\n                    case \"MemberExpression\":\n                        if (parent.property === node) {\n                            return false;\n                        }\n                        break;\n\n                    // EXCLUDES: e.g. ({ [foo]: a }) = bar;\n                    case \"Property\":\n                        if (parent.key === node) {\n                            return false;\n                        }\n\n                        break;\n\n                    // EXCLUDES: e.g. (foo ? a : b).c = bar;\n                    case \"ConditionalExpression\":\n                        if (parent.test === node) {\n                            return false;\n                        }\n\n                        break;\n\n                    // no default\n                }\n\n                node = parent;\n                parent = node.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Reports a reference if is non initializer and writable.\n         * @param {Reference} reference - A reference to check.\n         * @param {int} index - The index of the reference in the references.\n         * @param {Reference[]} references - The array that the reference belongs to.\n         * @returns {void}\n         */\n        function checkReference(reference, index, references) {\n            const identifier = reference.identifier;\n\n            if (identifier &&\n                !reference.init &&\n\n                /*\n                 * Destructuring assignments can have multiple default value,\n                 * so possibly there are multiple writeable references for the same identifier.\n                 */\n                (index === 0 || references[index - 1].identifier !== identifier)\n            ) {\n                if (reference.isWrite()) {\n                    context.report({ node: identifier, message: \"Assignment to function parameter '{{name}}'.\", data: { name: identifier.name } });\n                } else if (props && isModifyingProp(reference) && ignoredPropertyAssignmentsFor.indexOf(identifier.name) === -1) {\n                    context.report({ node: identifier, message: \"Assignment to property of function parameter '{{name}}'.\", data: { name: identifier.name } });\n                }\n            }\n        }\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable - A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            if (variable.defs[0].type === \"Parameter\") {\n                variable.references.forEach(checkReference);\n            }\n        }\n\n        /**\n         * Checks parameters of a given function node.\n         * @param {ASTNode} node - A function node to check.\n         * @returns {void}\n         */\n        function checkForFunction(node) {\n            context.getDeclaredVariables(node).forEach(checkVariable);\n        }\n\n        return {\n\n            // `:exit` is needed for the `node.parent` property of identifier nodes.\n            \"FunctionDeclaration:exit\": checkForFunction,\n            \"FunctionExpression:exit\": checkForFunction,\n            \"ArrowFunctionExpression:exit\": checkForFunction\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallow string concatenation when using __dirname and __filename\n * @author Nicholas C. Zakas\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow string concatenation with `__dirname` and `__filename`\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-path-concat\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        const MATCHER = /^__(?:dir|file)name$/u;\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            BinaryExpression(node) {\n\n                const left = node.left,\n                    right = node.right;\n\n                if (node.operator === \"+\" &&\n                        ((left.type === \"Identifier\" && MATCHER.test(left.name)) ||\n                        (right.type === \"Identifier\" && MATCHER.test(right.name)))\n                ) {\n\n                    context.report({ node, message: \"Use path.join() or path.resolve() instead of + to create paths.\" });\n                }\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use of unary increment and decrement operators.\n * @author Ian Christian Myers\n * @author Brody McKee (github.com/mrmckeb)\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the unary operators `++` and `--`\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-plusplus\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowForLoopAfterthoughts: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const config = context.options[0];\n        let allowInForAfterthought = false;\n\n        if (typeof config === \"object\") {\n            allowInForAfterthought = config.allowForLoopAfterthoughts === true;\n        }\n\n        return {\n\n            UpdateExpression(node) {\n                if (allowInForAfterthought && node.parent.type === \"ForStatement\") {\n                    return;\n                }\n                context.report({\n                    node,\n                    message: \"Unary operator '{{operator}}' used.\",\n                    data: {\n                        operator: node.operator\n                    }\n                });\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallow the use of process.env()\n * @author Vignesh Anand\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `process.env`\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-process-env\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            MemberExpression(node) {\n                const objectName = node.object.name,\n                    propertyName = node.property.name;\n\n                if (objectName === \"process\" && !node.computed && propertyName && propertyName === \"env\") {\n                    context.report({ node, message: \"Unexpected use of process.env.\" });\n                }\n\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallow the use of process.exit()\n * @author Nicholas C. Zakas\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `process.exit()`\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-process-exit\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            \"CallExpression > MemberExpression.callee[object.name = 'process'][property.name = 'exit']\"(node) {\n                context.report({ node: node.parent, message: \"Don't use process.exit(); throw an error instead.\" });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag usage of __proto__ property\n * @author Ilya Volodin\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of the `__proto__` property\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-proto\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            MemberExpression(node) {\n\n                if (node.property &&\n                        (node.property.type === \"Identifier\" && node.property.name === \"__proto__\" && !node.computed) ||\n                        (node.property.type === \"Literal\" && node.property.value === \"__proto__\")) {\n                    context.report({ node, message: \"The '__proto__' property is deprecated.\" });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to disallow use of Object.prototype builtins on objects\n * @author Andrew Levine\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow calling some `Object.prototype` methods directly on objects\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-prototype-builtins\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const DISALLOWED_PROPS = [\n            \"hasOwnProperty\",\n            \"isPrototypeOf\",\n            \"propertyIsEnumerable\"\n        ];\n\n        /**\n         * Reports if a disallowed property is used in a CallExpression\n         * @param {ASTNode} node The CallExpression node.\n         * @returns {void}\n         */\n        function disallowBuiltIns(node) {\n            if (node.callee.type !== \"MemberExpression\" || node.callee.computed) {\n                return;\n            }\n            const propName = node.callee.property.name;\n\n            if (DISALLOWED_PROPS.indexOf(propName) > -1) {\n                context.report({\n                    message: \"Do not access Object.prototype method '{{prop}}' from target object.\",\n                    loc: node.callee.property.loc.start,\n                    data: { prop: propName },\n                    node\n                });\n            }\n        }\n\n        return {\n            CallExpression: disallowBuiltIns\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag when the same variable is declared more then once.\n * @author Ilya Volodin\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow variable redeclaration\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-redeclare\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    builtinGlobals: { type: \"boolean\", default: false }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = {\n            builtinGlobals: context.options[0] && context.options[0].builtinGlobals\n        };\n\n        /**\n         * Find variables in a given scope and flag redeclared ones.\n         * @param {Scope} scope - An eslint-scope scope object.\n         * @returns {void}\n         * @private\n         */\n        function findVariablesInScope(scope) {\n            scope.variables.forEach(variable => {\n                const hasBuiltin = options.builtinGlobals && \"writeable\" in variable;\n                const count = (hasBuiltin ? 1 : 0) + variable.identifiers.length;\n\n                if (count >= 2) {\n                    variable.identifiers.sort((a, b) => a.range[1] - b.range[1]);\n\n                    for (let i = (hasBuiltin ? 0 : 1), l = variable.identifiers.length; i < l; i++) {\n                        context.report({ node: variable.identifiers[i], message: \"'{{a}}' is already defined.\", data: { a: variable.name } });\n                    }\n                }\n            });\n\n        }\n\n        /**\n         * Find variables in the current scope.\n         * @param {ASTNode} node - The Program node.\n         * @returns {void}\n         * @private\n         */\n        function checkForGlobal(node) {\n            const scope = context.getScope(),\n                parserOptions = context.parserOptions,\n                ecmaFeatures = parserOptions.ecmaFeatures || {};\n\n            // Nodejs env or modules has a special scope.\n            if (ecmaFeatures.globalReturn || node.sourceType === \"module\") {\n                findVariablesInScope(scope.childScopes[0]);\n            } else {\n                findVariablesInScope(scope);\n            }\n        }\n\n        /**\n         * Find variables in the current scope.\n         * @returns {void}\n         * @private\n         */\n        function checkForBlock() {\n            findVariablesInScope(context.getScope());\n        }\n\n        if (context.parserOptions.ecmaVersion >= 6) {\n            return {\n                Program: checkForGlobal,\n                BlockStatement: checkForBlock,\n                SwitchStatement: checkForBlock\n            };\n        }\n        return {\n            Program: checkForGlobal,\n            FunctionDeclaration: checkForBlock,\n            FunctionExpression: checkForBlock,\n            ArrowFunctionExpression: checkForBlock\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to count multiple spaces in regular expressions\n * @author Matt DuVall <http://www.mattduvall.com/>\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow multiple spaces in regular expressions\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-regex-spaces\"\n        },\n\n        schema: [],\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Validate regular expressions\n         * @param {ASTNode} node node to validate\n         * @param {string} value regular expression to validate\n         * @param {number} valueStart The start location of the regex/string literal. It will always be the case that\n         * `sourceCode.getText().slice(valueStart, valueStart + value.length) === value`\n         * @returns {void}\n         * @private\n         */\n        function checkRegex(node, value, valueStart) {\n            const multipleSpacesRegex = /( {2,})( [+*{?]|[^+*{?]|$)/u,\n                regexResults = multipleSpacesRegex.exec(value);\n\n            if (regexResults !== null) {\n                const count = regexResults[1].length;\n\n                context.report({\n                    node,\n                    message: \"Spaces are hard to count. Use {{{count}}}.\",\n                    data: { count },\n                    fix(fixer) {\n                        return fixer.replaceTextRange(\n                            [valueStart + regexResults.index, valueStart + regexResults.index + count],\n                            ` {${count}}`\n                        );\n                    }\n                });\n\n                /*\n                 * TODO: (platinumazure) Fix message to use rule message\n                 * substitution when api.report is fixed in lib/eslint.js.\n                 */\n            }\n        }\n\n        /**\n         * Validate regular expression literals\n         * @param {ASTNode} node node to validate\n         * @returns {void}\n         * @private\n         */\n        function checkLiteral(node) {\n            const token = sourceCode.getFirstToken(node),\n                nodeType = token.type,\n                nodeValue = token.value;\n\n            if (nodeType === \"RegularExpression\") {\n                checkRegex(node, nodeValue, token.range[0]);\n            }\n        }\n\n        /**\n         * Check if node is a string\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if its a string\n         * @private\n         */\n        function isString(node) {\n            return node && node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Validate strings passed to the RegExp constructor\n         * @param {ASTNode} node node to validate\n         * @returns {void}\n         * @private\n         */\n        function checkFunction(node) {\n            const scope = context.getScope();\n            const regExpVar = astUtils.getVariableByName(scope, \"RegExp\");\n            const shadowed = regExpVar && regExpVar.defs.length > 0;\n\n            if (node.callee.type === \"Identifier\" && node.callee.name === \"RegExp\" && isString(node.arguments[0]) && !shadowed) {\n                checkRegex(node, node.arguments[0].value, node.arguments[0].range[0] + 1);\n            }\n        }\n\n        return {\n            Literal: checkLiteral,\n            CallExpression: checkFunction,\n            NewExpression: checkFunction\n        };\n\n    }\n};\n","/**\n * @fileoverview Restrict usage of specified globals.\n * @author Benoît Zugmeyer\n */\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_MESSAGE_TEMPLATE = \"Unexpected use of '{{name}}'.\",\n    CUSTOM_MESSAGE_TEMPLATE = \"Unexpected use of '{{name}}'. {{customMessage}}\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow specified global variables\",\n            category: \"Variables\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-restricted-globals\"\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                oneOf: [\n                    {\n                        type: \"string\"\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            name: { type: \"string\" },\n                            message: { type: \"string\" }\n                        },\n                        required: [\"name\"],\n                        additionalProperties: false\n                    }\n                ]\n            },\n            uniqueItems: true,\n            minItems: 0\n        }\n    },\n\n    create(context) {\n\n        // If no globals are restricted, we don't need to do anything\n        if (context.options.length === 0) {\n            return {};\n        }\n\n        const restrictedGlobalMessages = context.options.reduce((memo, option) => {\n            if (typeof option === \"string\") {\n                memo[option] = null;\n            } else {\n                memo[option.name] = option.message;\n            }\n\n            return memo;\n        }, {});\n\n        /**\n         * Report a variable to be used as a restricted global.\n         * @param {Reference} reference the variable reference\n         * @returns {void}\n         * @private\n         */\n        function reportReference(reference) {\n            const name = reference.identifier.name,\n                customMessage = restrictedGlobalMessages[name],\n                message = customMessage\n                    ? CUSTOM_MESSAGE_TEMPLATE\n                    : DEFAULT_MESSAGE_TEMPLATE;\n\n            context.report({\n                node: reference.identifier,\n                message,\n                data: {\n                    name,\n                    customMessage\n                }\n            });\n        }\n\n        /**\n         * Check if the given name is a restricted global name.\n         * @param {string} name name of a variable\n         * @returns {boolean} whether the variable is a restricted global or not\n         * @private\n         */\n        function isRestricted(name) {\n            return Object.prototype.hasOwnProperty.call(restrictedGlobalMessages, name);\n        }\n\n        return {\n            Program() {\n                const scope = context.getScope();\n\n                // Report variables declared elsewhere (ex: variables defined as \"global\" by eslint)\n                scope.variables.forEach(variable => {\n                    if (!variable.defs.length && isRestricted(variable.name)) {\n                        variable.references.forEach(reportReference);\n                    }\n                });\n\n                // Report variables not declared at all\n                scope.through.forEach(reference => {\n                    if (isRestricted(reference.identifier.name)) {\n                        reportReference(reference);\n                    }\n                });\n\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Restrict usage of specified node imports.\n * @author Guy Ellis\n */\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_MESSAGE_TEMPLATE = \"'{{importSource}}' import is restricted from being used.\";\nconst CUSTOM_MESSAGE_TEMPLATE = \"'{{importSource}}' import is restricted from being used. {{customMessage}}\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst ignore = require(\"ignore\");\n\nconst arrayOfStrings = {\n    type: \"array\",\n    items: { type: \"string\" },\n    uniqueItems: true\n};\n\nconst arrayOfStringsOrObjects = {\n    type: \"array\",\n    items: {\n        anyOf: [\n            { type: \"string\" },\n            {\n                type: \"object\",\n                properties: {\n                    name: { type: \"string\" },\n                    message: {\n                        type: \"string\",\n                        minLength: 1\n                    },\n                    importNames: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    }\n                },\n                additionalProperties: false,\n                required: [\"name\"]\n            }\n        ]\n    },\n    uniqueItems: true\n};\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow specified modules when loaded by `import`\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-restricted-imports\"\n        },\n\n        schema: {\n            anyOf: [\n                arrayOfStringsOrObjects,\n                {\n                    type: \"array\",\n                    items: {\n                        type: \"object\",\n                        properties: {\n                            paths: arrayOfStringsOrObjects,\n                            patterns: arrayOfStrings\n                        },\n                        additionalProperties: false\n                    },\n                    additionalItems: false\n                }\n            ]\n        }\n    },\n\n    create(context) {\n        const options = Array.isArray(context.options) ? context.options : [];\n        const isPathAndPatternsObject =\n            typeof options[0] === \"object\" &&\n            (Object.prototype.hasOwnProperty.call(options[0], \"paths\") || Object.prototype.hasOwnProperty.call(options[0], \"patterns\"));\n\n        const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];\n        const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];\n\n        const restrictedPathMessages = restrictedPaths.reduce((memo, importSource) => {\n            if (typeof importSource === \"string\") {\n                memo[importSource] = { message: null };\n            } else {\n                memo[importSource.name] = {\n                    message: importSource.message,\n                    importNames: importSource.importNames\n                };\n            }\n            return memo;\n        }, {});\n\n        // if no imports are restricted we don\"t need to check\n        if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {\n            return {};\n        }\n\n        const restrictedPatternsMatcher = ignore().add(restrictedPatterns);\n\n        /**\n         * Checks to see if \"*\" is being used to import everything.\n         * @param {Set.<string>} importNames - Set of import names that are being imported\n         * @returns {boolean} whether everything is imported or not\n         */\n        function isEverythingImported(importNames) {\n            return importNames.has(\"*\");\n        }\n\n        /**\n         * Report a restricted path.\n         * @param {node} node representing the restricted path reference\n         * @returns {void}\n         * @private\n         */\n        function reportPath(node) {\n            const importSource = node.source.value.trim();\n            const customMessage = restrictedPathMessages[importSource] && restrictedPathMessages[importSource].message;\n            const message = customMessage\n                ? CUSTOM_MESSAGE_TEMPLATE\n                : DEFAULT_MESSAGE_TEMPLATE;\n\n            context.report({\n                node,\n                message,\n                data: {\n                    importSource,\n                    customMessage\n                }\n            });\n        }\n\n        /**\n         * Report a restricted path specifically for patterns.\n         * @param {node} node - representing the restricted path reference\n         * @returns {void}\n         * @private\n         */\n        function reportPathForPatterns(node) {\n            const importSource = node.source.value.trim();\n\n            context.report({\n                node,\n                message: \"'{{importSource}}' import is restricted from being used by a pattern.\",\n                data: {\n                    importSource\n                }\n            });\n        }\n\n        /**\n         * Report a restricted path specifically when using the '*' import.\n         * @param {string} importSource - path of the import\n         * @param {node} node - representing the restricted path reference\n         * @returns {void}\n         * @private\n         */\n        function reportPathForEverythingImported(importSource, node) {\n            const importNames = restrictedPathMessages[importSource].importNames;\n\n            context.report({\n                node,\n                message: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.\",\n                data: {\n                    importSource,\n                    importNames\n                }\n            });\n        }\n\n        /**\n         * Check if the given importSource is restricted because '*' is being imported.\n         * @param {string} importSource - path of the import\n         * @param {Set.<string>} importNames - Set of import names that are being imported\n         * @returns {boolean} whether the path is restricted\n         * @private\n         */\n        function isRestrictedForEverythingImported(importSource, importNames) {\n            return Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource) &&\n                restrictedPathMessages[importSource].importNames &&\n                isEverythingImported(importNames);\n        }\n\n        /**\n         * Check if the given importNames are restricted given a list of restrictedImportNames.\n         * @param {Set.<string>} importNames - Set of import names that are being imported\n         * @param {string[]} restrictedImportNames - array of import names that are restricted for this import\n         * @returns {boolean} whether the objectName is restricted\n         * @private\n         */\n        function isRestrictedObject(importNames, restrictedImportNames) {\n            return restrictedImportNames.some(restrictedObjectName => (\n                importNames.has(restrictedObjectName)\n            ));\n        }\n\n        /**\n         * Check if the given importSource is a restricted path.\n         * @param {string} importSource - path of the import\n         * @param {Set.<string>} importNames - Set of import names that are being imported\n         * @returns {boolean} whether the variable is a restricted path or not\n         * @private\n         */\n        function isRestrictedPath(importSource, importNames) {\n            let isRestricted = false;\n\n            if (Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource)) {\n                if (restrictedPathMessages[importSource].importNames) {\n                    isRestricted = isRestrictedObject(importNames, restrictedPathMessages[importSource].importNames);\n                } else {\n                    isRestricted = true;\n                }\n            }\n\n            return isRestricted;\n        }\n\n        /**\n         * Check if the given importSource is restricted by a pattern.\n         * @param {string} importSource - path of the import\n         * @returns {boolean} whether the variable is a restricted pattern or not\n         * @private\n         */\n        function isRestrictedPattern(importSource) {\n            return restrictedPatterns.length > 0 && restrictedPatternsMatcher.ignores(importSource);\n        }\n\n        /**\n         * Checks a node to see if any problems should be reported.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkNode(node) {\n            const importSource = node.source.value.trim();\n            const importNames = node.specifiers ? node.specifiers.reduce((set, specifier) => {\n                if (specifier.type === \"ImportDefaultSpecifier\") {\n                    set.add(\"default\");\n                } else if (specifier.type === \"ImportNamespaceSpecifier\") {\n                    set.add(\"*\");\n                } else if (specifier.imported) {\n                    set.add(specifier.imported.name);\n                } else if (specifier.local) {\n                    set.add(specifier.local.name);\n                }\n                return set;\n            }, new Set()) : new Set();\n\n            if (isRestrictedForEverythingImported(importSource, importNames)) {\n                reportPathForEverythingImported(importSource, node);\n            }\n\n            if (isRestrictedPath(importSource, importNames)) {\n                reportPath(node);\n            }\n            if (isRestrictedPattern(importSource)) {\n                reportPathForPatterns(node);\n            }\n        }\n\n        return {\n            ImportDeclaration: checkNode,\n            ExportNamedDeclaration(node) {\n                if (node.source) {\n                    checkNode(node);\n                }\n            },\n            ExportAllDeclaration: checkNode\n        };\n    }\n};\n","/**\n * @fileoverview Restrict usage of specified node modules.\n * @author Christian Schulz\n */\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_MESSAGE_TEMPLATE = \"'{{moduleName}}' module is restricted from being used.\";\nconst CUSTOM_MESSAGE_TEMPLATE = \"'{{moduleName}}' module is restricted from being used. {{customMessage}}\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst ignore = require(\"ignore\");\n\nconst arrayOfStrings = {\n    type: \"array\",\n    items: { type: \"string\" },\n    uniqueItems: true\n};\n\nconst arrayOfStringsOrObjects = {\n    type: \"array\",\n    items: {\n        anyOf: [\n            { type: \"string\" },\n            {\n                type: \"object\",\n                properties: {\n                    name: { type: \"string\" },\n                    message: {\n                        type: \"string\",\n                        minLength: 1\n                    }\n                },\n                additionalProperties: false,\n                required: [\"name\"]\n            }\n        ]\n    },\n    uniqueItems: true\n};\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow specified modules when loaded by `require`\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-restricted-modules\"\n        },\n\n        schema: {\n            anyOf: [\n                arrayOfStringsOrObjects,\n                {\n                    type: \"array\",\n                    items: {\n                        type: \"object\",\n                        properties: {\n                            paths: arrayOfStringsOrObjects,\n                            patterns: arrayOfStrings\n                        },\n                        additionalProperties: false\n                    },\n                    additionalItems: false\n                }\n            ]\n        }\n    },\n\n    create(context) {\n        const options = Array.isArray(context.options) ? context.options : [];\n        const isPathAndPatternsObject =\n            typeof options[0] === \"object\" &&\n            (Object.prototype.hasOwnProperty.call(options[0], \"paths\") || Object.prototype.hasOwnProperty.call(options[0], \"patterns\"));\n\n        const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];\n        const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];\n\n        const restrictedPathMessages = restrictedPaths.reduce((memo, importName) => {\n            if (typeof importName === \"string\") {\n                memo[importName] = null;\n            } else {\n                memo[importName.name] = importName.message;\n            }\n            return memo;\n        }, {});\n\n        // if no imports are restricted we don\"t need to check\n        if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {\n            return {};\n        }\n\n        const ig = ignore().add(restrictedPatterns);\n\n\n        /**\n         * Function to check if a node is a string literal.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} If the node is a string literal.\n         */\n        function isString(node) {\n            return node && node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Function to check if a node is a require call.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} If the node is a require call.\n         */\n        function isRequireCall(node) {\n            return node.callee.type === \"Identifier\" && node.callee.name === \"require\";\n        }\n\n        /**\n         * Report a restricted path.\n         * @param {node} node representing the restricted path reference\n         * @returns {void}\n         * @private\n         */\n        function reportPath(node) {\n            const moduleName = node.arguments[0].value.trim();\n            const customMessage = restrictedPathMessages[moduleName];\n            const message = customMessage\n                ? CUSTOM_MESSAGE_TEMPLATE\n                : DEFAULT_MESSAGE_TEMPLATE;\n\n            context.report({\n                node,\n                message,\n                data: {\n                    moduleName,\n                    customMessage\n                }\n            });\n        }\n\n        /**\n         * Check if the given name is a restricted path name\n         * @param {string} name name of a variable\n         * @returns {boolean} whether the variable is a restricted path or not\n         * @private\n         */\n        function isRestrictedPath(name) {\n            return Object.prototype.hasOwnProperty.call(restrictedPathMessages, name);\n        }\n\n        return {\n            CallExpression(node) {\n                if (isRequireCall(node)) {\n\n                    // node has arguments and first argument is string\n                    if (node.arguments.length && isString(node.arguments[0])) {\n                        const moduleName = node.arguments[0].value.trim();\n\n                        // check if argument value is in restricted modules array\n                        if (isRestrictedPath(moduleName)) {\n                            reportPath(node);\n                        }\n\n                        if (restrictedPatterns.length > 0 && ig.ignores(moduleName)) {\n                            context.report({\n                                node,\n                                message: \"'{{moduleName}}' module is restricted from being used by a pattern.\",\n                                data: { moduleName }\n                            });\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow certain object properties\n * @author Will Klein & Eli White\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow certain properties on certain objects\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-restricted-properties\"\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                anyOf: [ // `object` and `property` are both optional, but at least one of them must be provided.\n                    {\n                        type: \"object\",\n                        properties: {\n                            object: {\n                                type: \"string\"\n                            },\n                            property: {\n                                type: \"string\"\n                            },\n                            message: {\n                                type: \"string\"\n                            }\n                        },\n                        additionalProperties: false,\n                        required: [\"object\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            object: {\n                                type: \"string\"\n                            },\n                            property: {\n                                type: \"string\"\n                            },\n                            message: {\n                                type: \"string\"\n                            }\n                        },\n                        additionalProperties: false,\n                        required: [\"property\"]\n                    }\n                ]\n            },\n            uniqueItems: true\n        }\n    },\n\n    create(context) {\n        const restrictedCalls = context.options;\n\n        if (restrictedCalls.length === 0) {\n            return {};\n        }\n\n        const restrictedProperties = new Map();\n        const globallyRestrictedObjects = new Map();\n        const globallyRestrictedProperties = new Map();\n\n        restrictedCalls.forEach(option => {\n            const objectName = option.object;\n            const propertyName = option.property;\n\n            if (typeof objectName === \"undefined\") {\n                globallyRestrictedProperties.set(propertyName, { message: option.message });\n            } else if (typeof propertyName === \"undefined\") {\n                globallyRestrictedObjects.set(objectName, { message: option.message });\n            } else {\n                if (!restrictedProperties.has(objectName)) {\n                    restrictedProperties.set(objectName, new Map());\n                }\n\n                restrictedProperties.get(objectName).set(propertyName, {\n                    message: option.message\n                });\n            }\n        });\n\n        /**\n         * Checks to see whether a property access is restricted, and reports it if so.\n         * @param {ASTNode} node The node to report\n         * @param {string} objectName The name of the object\n         * @param {string} propertyName The name of the property\n         * @returns {undefined}\n         */\n        function checkPropertyAccess(node, objectName, propertyName) {\n            if (propertyName === null) {\n                return;\n            }\n            const matchedObject = restrictedProperties.get(objectName);\n            const matchedObjectProperty = matchedObject ? matchedObject.get(propertyName) : globallyRestrictedObjects.get(objectName);\n            const globalMatchedProperty = globallyRestrictedProperties.get(propertyName);\n\n            if (matchedObjectProperty) {\n                const message = matchedObjectProperty.message ? ` ${matchedObjectProperty.message}` : \"\";\n\n                context.report({\n                    node,\n                    // eslint-disable-next-line eslint-plugin/report-message-format\n                    message: \"'{{objectName}}.{{propertyName}}' is restricted from being used.{{message}}\",\n                    data: {\n                        objectName,\n                        propertyName,\n                        message\n                    }\n                });\n            } else if (globalMatchedProperty) {\n                const message = globalMatchedProperty.message ? ` ${globalMatchedProperty.message}` : \"\";\n\n                context.report({\n                    node,\n                    // eslint-disable-next-line eslint-plugin/report-message-format\n                    message: \"'{{propertyName}}' is restricted from being used.{{message}}\",\n                    data: {\n                        propertyName,\n                        message\n                    }\n                });\n            }\n        }\n\n        /**\n         * Checks property accesses in a destructuring assignment expression, e.g. `var foo; ({foo} = bar);`\n         * @param {ASTNode} node An AssignmentExpression or AssignmentPattern node\n         * @returns {undefined}\n         */\n        function checkDestructuringAssignment(node) {\n            if (node.right.type === \"Identifier\") {\n                const objectName = node.right.name;\n\n                if (node.left.type === \"ObjectPattern\") {\n                    node.left.properties.forEach(property => {\n                        checkPropertyAccess(node.left, objectName, astUtils.getStaticPropertyName(property));\n                    });\n                }\n            }\n        }\n\n        return {\n            MemberExpression(node) {\n                checkPropertyAccess(node, node.object && node.object.name, astUtils.getStaticPropertyName(node));\n            },\n            VariableDeclarator(node) {\n                if (node.init && node.init.type === \"Identifier\") {\n                    const objectName = node.init.name;\n\n                    if (node.id.type === \"ObjectPattern\") {\n                        node.id.properties.forEach(property => {\n                            checkPropertyAccess(node.id, objectName, astUtils.getStaticPropertyName(property));\n                        });\n                    }\n                }\n            },\n            AssignmentExpression: checkDestructuringAssignment,\n            AssignmentPattern: checkDestructuringAssignment\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag use of certain node types\n * @author Burak Yigit Kaya\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow specified syntax\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-restricted-syntax\"\n        },\n\n        schema: {\n            type: \"array\",\n            items: [{\n                oneOf: [\n                    {\n                        type: \"string\"\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            selector: { type: \"string\" },\n                            message: { type: \"string\" }\n                        },\n                        required: [\"selector\"],\n                        additionalProperties: false\n                    }\n                ]\n            }],\n            uniqueItems: true,\n            minItems: 0\n        }\n    },\n\n    create(context) {\n        return context.options.reduce((result, selectorOrObject) => {\n            const isStringFormat = (typeof selectorOrObject === \"string\");\n            const hasCustomMessage = !isStringFormat && Boolean(selectorOrObject.message);\n\n            const selector = isStringFormat ? selectorOrObject : selectorOrObject.selector;\n            const message = hasCustomMessage ? selectorOrObject.message : \"Using '{{selector}}' is not allowed.\";\n\n            return Object.assign(result, {\n                [selector](node) {\n                    context.report({\n                        node,\n                        message,\n                        data: hasCustomMessage ? {} : { selector }\n                    });\n                }\n            });\n        }, {});\n\n    }\n};\n","/**\n * @fileoverview Rule to flag when return statement contains assignment\n * @author Ilya Volodin\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_TYPE = /^(?:[a-zA-Z]+?Statement|ArrowFunctionExpression|FunctionExpression|ClassExpression)$/u;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow assignment operators in `return` statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-return-assign\"\n        },\n\n        schema: [\n            {\n                enum: [\"except-parens\", \"always\"]\n            }\n        ]\n    },\n\n    create(context) {\n        const always = (context.options[0] || \"except-parens\") !== \"except-parens\";\n        const sourceCode = context.getSourceCode();\n\n        return {\n            AssignmentExpression(node) {\n                if (!always && astUtils.isParenthesised(sourceCode, node)) {\n                    return;\n                }\n\n                let currentChild = node;\n                let parent = currentChild.parent;\n\n                // Find ReturnStatement or ArrowFunctionExpression in ancestors.\n                while (parent && !SENTINEL_TYPE.test(parent.type)) {\n                    currentChild = parent;\n                    parent = parent.parent;\n                }\n\n                // Reports.\n                if (parent && parent.type === \"ReturnStatement\") {\n                    context.report({\n                        node: parent,\n                        message: \"Return statement should not contain assignment.\"\n                    });\n                } else if (parent && parent.type === \"ArrowFunctionExpression\" && parent.body === currentChild) {\n                    context.report({\n                        node: parent,\n                        message: \"Arrow function should not return assignment.\"\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Disallows unnecessary `return await`\n * @author Jordan Harband\n */\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst message = \"Redundant use of `await` on a return value.\";\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary `return await`\",\n            category: \"Best Practices\",\n\n            recommended: false,\n\n            url: \"https://eslint.org/docs/rules/no-return-await\"\n        },\n\n        fixable: null,\n\n        schema: [\n        ]\n    },\n\n    create(context) {\n\n        /**\n         * Reports a found unnecessary `await` expression.\n         * @param {ASTNode} node The node representing the `await` expression to report\n         * @returns {void}\n         */\n        function reportUnnecessaryAwait(node) {\n            context.report({\n                node: context.getSourceCode().getFirstToken(node),\n                loc: node.loc,\n                message\n            });\n        }\n\n        /**\n         * Determines whether a thrown error from this node will be caught/handled within this function rather than immediately halting\n         * this function. For example, a statement in a `try` block will always have an error handler. A statement in\n         * a `catch` block will only have an error handler if there is also a `finally` block.\n         * @param {ASTNode} node A node representing a location where an could be thrown\n         * @returns {boolean} `true` if a thrown error will be caught/handled in this function\n         */\n        function hasErrorHandler(node) {\n            let ancestor = node;\n\n            while (!astUtils.isFunction(ancestor) && ancestor.type !== \"Program\") {\n                if (ancestor.parent.type === \"TryStatement\" && (ancestor === ancestor.parent.block || ancestor === ancestor.parent.handler && ancestor.parent.finalizer)) {\n                    return true;\n                }\n                ancestor = ancestor.parent;\n            }\n            return false;\n        }\n\n        /**\n         * Checks if a node is placed in tail call position. Once `return` arguments (or arrow function expressions) can be a complex expression,\n         * an `await` expression could or could not be unnecessary by the definition of this rule. So we're looking for `await` expressions that are in tail position.\n         * @param {ASTNode} node A node representing the `await` expression to check\n         * @returns {boolean} The checking result\n         */\n        function isInTailCallPosition(node) {\n            if (node.parent.type === \"ArrowFunctionExpression\") {\n                return true;\n            }\n            if (node.parent.type === \"ReturnStatement\") {\n                return !hasErrorHandler(node.parent);\n            }\n            if (node.parent.type === \"ConditionalExpression\" && (node === node.parent.consequent || node === node.parent.alternate)) {\n                return isInTailCallPosition(node.parent);\n            }\n            if (node.parent.type === \"LogicalExpression\" && node === node.parent.right) {\n                return isInTailCallPosition(node.parent);\n            }\n            if (node.parent.type === \"SequenceExpression\" && node === node.parent.expressions[node.parent.expressions.length - 1]) {\n                return isInTailCallPosition(node.parent);\n            }\n            return false;\n        }\n\n        return {\n            AwaitExpression(node) {\n                if (isInTailCallPosition(node) && !hasErrorHandler(node)) {\n                    reportUnnecessaryAwait(node);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag when using javascript: urls\n * @author Ilya Volodin\n */\n/* jshint scripturl: true */\n/* eslint no-script-url: 0 */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `javascript:` urls\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-script-url\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            Literal(node) {\n                if (node.value && typeof node.value === \"string\") {\n                    const value = node.value.toLowerCase();\n\n                    if (value.indexOf(\"javascript:\") === 0) {\n                        context.report({ node, message: \"Script URL is a form of eval.\" });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to disallow assignments where both sides are exactly the same\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SPACES = /\\s+/gu;\n\n/**\n * Checks whether the property of 2 given member expression nodes are the same\n * property or not.\n *\n * @param {ASTNode} left - A member expression node to check.\n * @param {ASTNode} right - Another member expression node to check.\n * @returns {boolean} `true` if the member expressions have the same property.\n */\nfunction isSameProperty(left, right) {\n    if (left.property.type === \"Identifier\" &&\n        left.property.type === right.property.type &&\n        left.property.name === right.property.name &&\n        left.computed === right.computed\n    ) {\n        return true;\n    }\n\n    const lname = astUtils.getStaticPropertyName(left);\n    const rname = astUtils.getStaticPropertyName(right);\n\n    return lname !== null && lname === rname;\n}\n\n/**\n * Checks whether 2 given member expression nodes are the reference to the same\n * property or not.\n *\n * @param {ASTNode} left - A member expression node to check.\n * @param {ASTNode} right - Another member expression node to check.\n * @returns {boolean} `true` if the member expressions are the reference to the\n *  same property or not.\n */\nfunction isSameMember(left, right) {\n    if (!isSameProperty(left, right)) {\n        return false;\n    }\n\n    const lobj = left.object;\n    const robj = right.object;\n\n    if (lobj.type !== robj.type) {\n        return false;\n    }\n    if (lobj.type === \"MemberExpression\") {\n        return isSameMember(lobj, robj);\n    }\n    return lobj.type === \"Identifier\" && lobj.name === robj.name;\n}\n\n/**\n * Traverses 2 Pattern nodes in parallel, then reports self-assignments.\n *\n * @param {ASTNode|null} left - A left node to traverse. This is a Pattern or\n *      a Property.\n * @param {ASTNode|null} right - A right node to traverse. This is a Pattern or\n *      a Property.\n * @param {boolean} props - The flag to check member expressions as well.\n * @param {Function} report - A callback function to report.\n * @returns {void}\n */\nfunction eachSelfAssignment(left, right, props, report) {\n    if (!left || !right) {\n\n        // do nothing\n    } else if (\n        left.type === \"Identifier\" &&\n        right.type === \"Identifier\" &&\n        left.name === right.name\n    ) {\n        report(right);\n    } else if (\n        left.type === \"ArrayPattern\" &&\n        right.type === \"ArrayExpression\"\n    ) {\n        const end = Math.min(left.elements.length, right.elements.length);\n\n        for (let i = 0; i < end; ++i) {\n            const rightElement = right.elements[i];\n\n            eachSelfAssignment(left.elements[i], rightElement, props, report);\n\n            // After a spread element, those indices are unknown.\n            if (rightElement && rightElement.type === \"SpreadElement\") {\n                break;\n            }\n        }\n    } else if (\n        left.type === \"RestElement\" &&\n        right.type === \"SpreadElement\"\n    ) {\n        eachSelfAssignment(left.argument, right.argument, props, report);\n    } else if (\n        left.type === \"ObjectPattern\" &&\n        right.type === \"ObjectExpression\" &&\n        right.properties.length >= 1\n    ) {\n\n        /*\n         * Gets the index of the last spread property.\n         * It's possible to overwrite properties followed by it.\n         */\n        let startJ = 0;\n\n        for (let i = right.properties.length - 1; i >= 0; --i) {\n            const propType = right.properties[i].type;\n\n            if (propType === \"SpreadElement\" || propType === \"ExperimentalSpreadProperty\") {\n                startJ = i + 1;\n                break;\n            }\n        }\n\n        for (let i = 0; i < left.properties.length; ++i) {\n            for (let j = startJ; j < right.properties.length; ++j) {\n                eachSelfAssignment(\n                    left.properties[i],\n                    right.properties[j],\n                    props,\n                    report\n                );\n            }\n        }\n    } else if (\n        left.type === \"Property\" &&\n        right.type === \"Property\" &&\n        !left.computed &&\n        !right.computed &&\n        right.kind === \"init\" &&\n        !right.method &&\n        left.key.name === right.key.name\n    ) {\n        eachSelfAssignment(left.value, right.value, props, report);\n    } else if (\n        props &&\n        left.type === \"MemberExpression\" &&\n        right.type === \"MemberExpression\" &&\n        isSameMember(left, right)\n    ) {\n        report(right);\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow assignments where both sides are exactly the same\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-self-assign\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    props: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const [{ props = true } = {}] = context.options;\n\n        /**\n         * Reports a given node as self assignments.\n         *\n         * @param {ASTNode} node - A node to report. This is an Identifier node.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node,\n                message: \"'{{name}}' is assigned to itself.\",\n                data: {\n                    name: sourceCode.getText(node).replace(SPACES, \"\")\n                }\n            });\n        }\n\n        return {\n            AssignmentExpression(node) {\n                if (node.operator === \"=\") {\n                    eachSelfAssignment(node.left, node.right, props, report);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag comparison where left part is the same as the right\n * part.\n * @author Ilya Volodin\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow comparisons where both sides are exactly the same\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-self-compare\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether two nodes are composed of the same tokens.\n         * @param {ASTNode} nodeA The first node\n         * @param {ASTNode} nodeB The second node\n         * @returns {boolean} true if the nodes have identical token representations\n         */\n        function hasSameTokens(nodeA, nodeB) {\n            const tokensA = sourceCode.getTokens(nodeA);\n            const tokensB = sourceCode.getTokens(nodeB);\n\n            return tokensA.length === tokensB.length &&\n                tokensA.every((token, index) => token.type === tokensB[index].type && token.value === tokensB[index].value);\n        }\n\n        return {\n\n            BinaryExpression(node) {\n                const operators = new Set([\"===\", \"==\", \"!==\", \"!=\", \">\", \"<\", \">=\", \"<=\"]);\n\n                if (operators.has(node.operator) && hasSameTokens(node.left, node.right)) {\n                    context.report({ node, message: \"Comparing to itself is potentially pointless.\" });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use of comma operator\n * @author Brandon Mills\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow comma operators\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-sequences\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Parts of the grammar that are required to have parens.\n         */\n        const parenthesized = {\n            DoWhileStatement: \"test\",\n            IfStatement: \"test\",\n            SwitchStatement: \"discriminant\",\n            WhileStatement: \"test\",\n            WithStatement: \"object\",\n            ArrowFunctionExpression: \"body\"\n\n            /*\n             * Omitting CallExpression - commas are parsed as argument separators\n             * Omitting NewExpression - commas are parsed as argument separators\n             * Omitting ForInStatement - parts aren't individually parenthesised\n             * Omitting ForStatement - parts aren't individually parenthesised\n             */\n        };\n\n        /**\n         * Determines whether a node is required by the grammar to be wrapped in\n         * parens, e.g. the test of an if statement.\n         * @param {ASTNode} node - The AST node\n         * @returns {boolean} True if parens around node belong to parent node.\n         */\n        function requiresExtraParens(node) {\n            return node.parent && parenthesized[node.parent.type] &&\n                    node === node.parent[parenthesized[node.parent.type]];\n        }\n\n        /**\n         * Check if a node is wrapped in parens.\n         * @param {ASTNode} node - The AST node\n         * @returns {boolean} True if the node has a paren on each side.\n         */\n        function isParenthesised(node) {\n            return astUtils.isParenthesised(sourceCode, node);\n        }\n\n        /**\n         * Check if a node is wrapped in two levels of parens.\n         * @param {ASTNode} node - The AST node\n         * @returns {boolean} True if two parens surround the node on each side.\n         */\n        function isParenthesisedTwice(node) {\n            const previousToken = sourceCode.getTokenBefore(node, 1),\n                nextToken = sourceCode.getTokenAfter(node, 1);\n\n            return isParenthesised(node) && previousToken && nextToken &&\n                astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] &&\n                astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\n        }\n\n        return {\n            SequenceExpression(node) {\n\n                // Always allow sequences in for statement update\n                if (node.parent.type === \"ForStatement\" &&\n                        (node === node.parent.init || node === node.parent.update)) {\n                    return;\n                }\n\n                // Wrapping a sequence in extra parens indicates intent\n                if (requiresExtraParens(node)) {\n                    if (isParenthesisedTwice(node)) {\n                        return;\n                    }\n                } else {\n                    if (isParenthesised(node)) {\n                        return;\n                    }\n                }\n\n                const child = sourceCode.getTokenAfter(node.expressions[0]);\n\n                context.report({ node, loc: child.loc.start, message: \"Unexpected use of comma operator.\" });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag on declaring variables already declared in the outer scope\n * @author Ilya Volodin\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow variable declarations from shadowing variables declared in the outer scope\",\n            category: \"Variables\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-shadow\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    builtinGlobals: { type: \"boolean\", default: false },\n                    hoist: { enum: [\"all\", \"functions\", \"never\"], default: \"functions\" },\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const options = {\n            builtinGlobals: context.options[0] && context.options[0].builtinGlobals,\n            hoist: (context.options[0] && context.options[0].hoist) || \"functions\",\n            allow: (context.options[0] && context.options[0].allow) || []\n        };\n\n        /**\n         * Check if variable name is allowed.\n         *\n         * @param  {ASTNode} variable The variable to check.\n         * @returns {boolean} Whether or not the variable name is allowed.\n         */\n        function isAllowed(variable) {\n            return options.allow.indexOf(variable.name) !== -1;\n        }\n\n        /**\n         * Checks if a variable of the class name in the class scope of ClassDeclaration.\n         *\n         * ClassDeclaration creates two variables of its name into its outer scope and its class scope.\n         * So we should ignore the variable in the class scope.\n         *\n         * @param {Object} variable The variable to check.\n         * @returns {boolean} Whether or not the variable of the class name in the class scope of ClassDeclaration.\n         */\n        function isDuplicatedClassNameVariable(variable) {\n            const block = variable.scope.block;\n\n            return block.type === \"ClassDeclaration\" && block.id === variable.identifiers[0];\n        }\n\n        /**\n         * Checks if a variable is inside the initializer of scopeVar.\n         *\n         * To avoid reporting at declarations such as `var a = function a() {};`.\n         * But it should report `var a = function(a) {};` or `var a = function() { function a() {} };`.\n         *\n         * @param {Object} variable The variable to check.\n         * @param {Object} scopeVar The scope variable to look for.\n         * @returns {boolean} Whether or not the variable is inside initializer of scopeVar.\n         */\n        function isOnInitializer(variable, scopeVar) {\n            const outerScope = scopeVar.scope;\n            const outerDef = scopeVar.defs[0];\n            const outer = outerDef && outerDef.parent && outerDef.parent.range;\n            const innerScope = variable.scope;\n            const innerDef = variable.defs[0];\n            const inner = innerDef && innerDef.name.range;\n\n            return (\n                outer &&\n                inner &&\n                outer[0] < inner[0] &&\n                inner[1] < outer[1] &&\n                ((innerDef.type === \"FunctionName\" && innerDef.node.type === \"FunctionExpression\") || innerDef.node.type === \"ClassExpression\") &&\n                outerScope === innerScope.upper\n            );\n        }\n\n        /**\n         * Get a range of a variable's identifier node.\n         * @param {Object} variable The variable to get.\n         * @returns {Array|undefined} The range of the variable's identifier node.\n         */\n        function getNameRange(variable) {\n            const def = variable.defs[0];\n\n            return def && def.name.range;\n        }\n\n        /**\n         * Checks if a variable is in TDZ of scopeVar.\n         * @param {Object} variable The variable to check.\n         * @param {Object} scopeVar The variable of TDZ.\n         * @returns {boolean} Whether or not the variable is in TDZ of scopeVar.\n         */\n        function isInTdz(variable, scopeVar) {\n            const outerDef = scopeVar.defs[0];\n            const inner = getNameRange(variable);\n            const outer = getNameRange(scopeVar);\n\n            return (\n                inner &&\n                outer &&\n                inner[1] < outer[0] &&\n\n                // Excepts FunctionDeclaration if is {\"hoist\":\"function\"}.\n                (options.hoist !== \"functions\" || !outerDef || outerDef.node.type !== \"FunctionDeclaration\")\n            );\n        }\n\n        /**\n         * Checks the current context for shadowed variables.\n         * @param {Scope} scope - Fixme\n         * @returns {void}\n         */\n        function checkForShadows(scope) {\n            const variables = scope.variables;\n\n            for (let i = 0; i < variables.length; ++i) {\n                const variable = variables[i];\n\n                // Skips \"arguments\" or variables of a class name in the class scope of ClassDeclaration.\n                if (variable.identifiers.length === 0 ||\n                    isDuplicatedClassNameVariable(variable) ||\n                    isAllowed(variable)\n                ) {\n                    continue;\n                }\n\n                // Gets shadowed variable.\n                const shadowed = astUtils.getVariableByName(scope.upper, variable.name);\n\n                if (shadowed &&\n                    (shadowed.identifiers.length > 0 || (options.builtinGlobals && \"writeable\" in shadowed)) &&\n                    !isOnInitializer(variable, shadowed) &&\n                    !(options.hoist !== \"all\" && isInTdz(variable, shadowed))\n                ) {\n                    context.report({\n                        node: variable.identifiers[0],\n                        message: \"'{{name}}' is already declared in the upper scope.\",\n                        data: variable\n                    });\n                }\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n                const stack = globalScope.childScopes.slice();\n\n                while (stack.length) {\n                    const scope = stack.pop();\n\n                    stack.push(...scope.childScopes);\n                    checkForShadows(scope);\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallow shadowing of NaN, undefined, and Infinity (ES5 section 15.1.1)\n * @author Michael Ficarra\n */\n\n\n/**\n * Determines if a variable safely shadows undefined.\n * This is the case when a variable named `undefined` is never assigned to a value (i.e. it always shares the same value\n * as the global).\n * @param {eslintScope.Variable} variable The variable to check\n * @returns {boolean} true if this variable safely shadows `undefined`\n */\nfunction safelyShadowsUndefined(variable) {\n    return variable.name === \"undefined\" &&\n        variable.references.every(ref => !ref.isWrite()) &&\n        variable.defs.every(def => def.node.type === \"VariableDeclarator\" && def.node.init === null);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow identifiers from shadowing restricted names\",\n            category: \"Variables\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-shadow-restricted-names\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n\n        const RESTRICTED = new Set([\"undefined\", \"NaN\", \"Infinity\", \"arguments\", \"eval\"]);\n\n        return {\n            \"VariableDeclaration, :function, CatchClause\"(node) {\n                for (const variable of context.getDeclaredVariables(node)) {\n                    if (variable.defs.length > 0 && RESTRICTED.has(variable.name) && !safelyShadowsUndefined(variable)) {\n                        context.report({\n                            node: variable.defs[0].name,\n                            message: \"Shadowing of global property '{{idName}}'.\",\n                            data: {\n                                idName: variable.name\n                            }\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to check that spaced function application\n * @author Matt DuVall <http://www.mattduvall.com>\n * @deprecated in ESLint v3.3.0\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow spacing between function identifiers and their applications (deprecated)\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-spaced-func\"\n        },\n\n        deprecated: true,\n\n        replacedBy: [\"func-call-spacing\"],\n\n        fixable: \"whitespace\",\n        schema: []\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check if open space is present in a function name\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function detectOpenSpaces(node) {\n            const lastCalleeToken = sourceCode.getLastToken(node.callee);\n            let prevToken = lastCalleeToken,\n                parenToken = sourceCode.getTokenAfter(lastCalleeToken);\n\n            // advances to an open parenthesis.\n            while (\n                parenToken &&\n                parenToken.range[1] < node.range[1] &&\n                parenToken.value !== \"(\"\n            ) {\n                prevToken = parenToken;\n                parenToken = sourceCode.getTokenAfter(parenToken);\n            }\n\n            // look for a space between the callee and the open paren\n            if (parenToken &&\n                parenToken.range[1] < node.range[1] &&\n                sourceCode.isSpaceBetweenTokens(prevToken, parenToken)\n            ) {\n                context.report({\n                    node,\n                    loc: lastCalleeToken.loc.start,\n                    message: \"Unexpected space between function name and paren.\",\n                    fix(fixer) {\n                        return fixer.removeRange([prevToken.range[1], parenToken.range[0]]);\n                    }\n                });\n            }\n        }\n\n        return {\n            CallExpression: detectOpenSpaces,\n            NewExpression: detectOpenSpaces\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallow sparse arrays\n * @author Nicholas C. Zakas\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow sparse arrays\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-sparse-arrays\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            ArrayExpression(node) {\n\n                const emptySpot = node.elements.indexOf(null) > -1;\n\n                if (emptySpot) {\n                    context.report({ node, message: \"Unexpected comma in middle of array.\" });\n                }\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to check for properties whose identifier ends with the string Sync\n * @author Matt DuVall<http://mattduvall.com/>\n */\n\n/* jshint node:true */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow synchronous methods\",\n            category: \"Node.js and CommonJS\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-sync\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowAtRootLevel: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const selector = context.options[0] && context.options[0].allowAtRootLevel\n            ? \":function MemberExpression[property.name=/.*Sync$/]\"\n            : \"MemberExpression[property.name=/.*Sync$/]\";\n\n        return {\n            [selector](node) {\n                context.report({\n                    node,\n                    message: \"Unexpected sync method: '{{propertyName}}'.\",\n                    data: {\n                        propertyName: node.property.name\n                    }\n                });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to check for tabs inside a file\n * @author Gyandeep Singh\n */\n\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst tabRegex = /\\t+/gu;\nconst anyNonWhitespaceRegex = /\\S/u;\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow all tabs\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-tabs\"\n        },\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowIndentationTabs: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const allowIndentationTabs = context.options && context.options[0] && context.options[0].allowIndentationTabs;\n\n        return {\n            Program(node) {\n                sourceCode.getLines().forEach((line, index) => {\n                    let match;\n\n                    while ((match = tabRegex.exec(line)) !== null) {\n                        if (allowIndentationTabs && !anyNonWhitespaceRegex.test(line.slice(0, match.index))) {\n                            continue;\n                        }\n\n                        context.report({\n                            node,\n                            loc: {\n                                line: index + 1,\n                                column: match.index\n                            },\n                            message: \"Unexpected tab character.\"\n                        });\n                    }\n                });\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Warn when using template string syntax in regular strings\n * @author Jeroen Engels\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow template literal placeholder syntax in regular strings\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-template-curly-in-string\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const regex = /\\$\\{[^}]+\\}/u;\n\n        return {\n            Literal(node) {\n                if (typeof node.value === \"string\" && regex.test(node.value)) {\n                    context.report({\n                        node,\n                        message: \"Unexpected template string expression.\"\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use of ternary operators.\n * @author Ian Christian Myers\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow ternary operators\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-ternary\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            ConditionalExpression(node) {\n                context.report({ node, message: \"Ternary operator used.\" });\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview A rule to disallow using `this`/`super` before `super()`.\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a constructor.\n * @param {ASTNode} node - A node to check. This node type is one of\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\n *   `ArrowFunctionExpression`.\n * @returns {boolean} `true` if the node is a constructor.\n */\nfunction isConstructorFunction(node) {\n    return (\n        node.type === \"FunctionExpression\" &&\n        node.parent.type === \"MethodDefinition\" &&\n        node.parent.kind === \"constructor\"\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow `this`/`super` before calling `super()` in constructors\",\n            category: \"ECMAScript 6\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-this-before-super\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /*\n         * Information for each constructor.\n         * - upper:      Information of the upper constructor.\n         * - hasExtends: A flag which shows whether the owner class has a valid\n         *   `extends` part.\n         * - scope:      The scope of the owner class.\n         * - codePath:   The code path of this constructor.\n         */\n        let funcInfo = null;\n\n        /*\n         * Information for each code path segment.\n         * Each key is the id of a code path segment.\n         * Each value is an object:\n         * - superCalled:  The flag which shows `super()` called in all code paths.\n         * - invalidNodes: The array of invalid ThisExpression and Super nodes.\n         */\n        let segInfoMap = Object.create(null);\n\n        /**\n         * Gets whether or not `super()` is called in a given code path segment.\n         * @param {CodePathSegment} segment - A code path segment to get.\n         * @returns {boolean} `true` if `super()` is called.\n         */\n        function isCalled(segment) {\n            return !segment.reachable || segInfoMap[segment.id].superCalled;\n        }\n\n        /**\n         * Checks whether or not this is in a constructor.\n         * @returns {boolean} `true` if this is in a constructor.\n         */\n        function isInConstructorOfDerivedClass() {\n            return Boolean(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends);\n        }\n\n        /**\n         * Checks whether or not this is before `super()` is called.\n         * @returns {boolean} `true` if this is before `super()` is called.\n         */\n        function isBeforeCallOfSuper() {\n            return (\n                isInConstructorOfDerivedClass() &&\n                !funcInfo.codePath.currentSegments.every(isCalled)\n            );\n        }\n\n        /**\n         * Sets a given node as invalid.\n         * @param {ASTNode} node - A node to set as invalid. This is one of\n         *      a ThisExpression and a Super.\n         * @returns {void}\n         */\n        function setInvalid(node) {\n            const segments = funcInfo.codePath.currentSegments;\n\n            for (let i = 0; i < segments.length; ++i) {\n                const segment = segments[i];\n\n                if (segment.reachable) {\n                    segInfoMap[segment.id].invalidNodes.push(node);\n                }\n            }\n        }\n\n        /**\n         * Sets the current segment as `super` was called.\n         * @returns {void}\n         */\n        function setSuperCalled() {\n            const segments = funcInfo.codePath.currentSegments;\n\n            for (let i = 0; i < segments.length; ++i) {\n                const segment = segments[i];\n\n                if (segment.reachable) {\n                    segInfoMap[segment.id].superCalled = true;\n                }\n            }\n        }\n\n        return {\n\n            /**\n             * Adds information of a constructor into the stack.\n             * @param {CodePath} codePath - A code path which was started.\n             * @param {ASTNode} node - The current node.\n             * @returns {void}\n             */\n            onCodePathStart(codePath, node) {\n                if (isConstructorFunction(node)) {\n\n                    // Class > ClassBody > MethodDefinition > FunctionExpression\n                    const classNode = node.parent.parent.parent;\n\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: true,\n                        hasExtends: Boolean(\n                            classNode.superClass &&\n                            !astUtils.isNullOrUndefined(classNode.superClass)\n                        ),\n                        codePath\n                    };\n                } else {\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: false,\n                        hasExtends: false,\n                        codePath\n                    };\n                }\n            },\n\n            /**\n             * Removes the top of stack item.\n             *\n             * And this treverses all segments of this code path then reports every\n             * invalid node.\n             *\n             * @param {CodePath} codePath - A code path which was ended.\n             * @returns {void}\n             */\n            onCodePathEnd(codePath) {\n                const isDerivedClass = funcInfo.hasExtends;\n\n                funcInfo = funcInfo.upper;\n                if (!isDerivedClass) {\n                    return;\n                }\n\n                codePath.traverseSegments((segment, controller) => {\n                    const info = segInfoMap[segment.id];\n\n                    for (let i = 0; i < info.invalidNodes.length; ++i) {\n                        const invalidNode = info.invalidNodes[i];\n\n                        context.report({\n                            message: \"'{{kind}}' is not allowed before 'super()'.\",\n                            node: invalidNode,\n                            data: {\n                                kind: invalidNode.type === \"Super\" ? \"super\" : \"this\"\n                            }\n                        });\n                    }\n\n                    if (info.superCalled) {\n                        controller.skip();\n                    }\n                });\n            },\n\n            /**\n             * Initialize information of a given code path segment.\n             * @param {CodePathSegment} segment - A code path segment to initialize.\n             * @returns {void}\n             */\n            onCodePathSegmentStart(segment) {\n                if (!isInConstructorOfDerivedClass()) {\n                    return;\n                }\n\n                // Initialize info.\n                segInfoMap[segment.id] = {\n                    superCalled: (\n                        segment.prevSegments.length > 0 &&\n                        segment.prevSegments.every(isCalled)\n                    ),\n                    invalidNodes: []\n                };\n            },\n\n            /**\n             * Update information of the code path segment when a code path was\n             * looped.\n             * @param {CodePathSegment} fromSegment - The code path segment of the\n             *      end of a loop.\n             * @param {CodePathSegment} toSegment - A code path segment of the head\n             *      of a loop.\n             * @returns {void}\n             */\n            onCodePathSegmentLoop(fromSegment, toSegment) {\n                if (!isInConstructorOfDerivedClass()) {\n                    return;\n                }\n\n                // Update information inside of the loop.\n                funcInfo.codePath.traverseSegments(\n                    { first: toSegment, last: fromSegment },\n                    (segment, controller) => {\n                        const info = segInfoMap[segment.id];\n\n                        if (info.superCalled) {\n                            info.invalidNodes = [];\n                            controller.skip();\n                        } else if (\n                            segment.prevSegments.length > 0 &&\n                            segment.prevSegments.every(isCalled)\n                        ) {\n                            info.superCalled = true;\n                            info.invalidNodes = [];\n                        }\n                    }\n                );\n            },\n\n            /**\n             * Reports if this is before `super()`.\n             * @param {ASTNode} node - A target node.\n             * @returns {void}\n             */\n            ThisExpression(node) {\n                if (isBeforeCallOfSuper()) {\n                    setInvalid(node);\n                }\n            },\n\n            /**\n             * Reports if this is before `super()`.\n             * @param {ASTNode} node - A target node.\n             * @returns {void}\n             */\n            Super(node) {\n                if (!astUtils.isCallee(node) && isBeforeCallOfSuper()) {\n                    setInvalid(node);\n                }\n            },\n\n            /**\n             * Marks `super()` called.\n             * @param {ASTNode} node - A target node.\n             * @returns {void}\n             */\n            \"CallExpression:exit\"(node) {\n                if (node.callee.type === \"Super\" && isBeforeCallOfSuper()) {\n                    setSuperCalled();\n                }\n            },\n\n            /**\n             * Resets state.\n             * @returns {void}\n             */\n            \"Program:exit\"() {\n                segInfoMap = Object.create(null);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to restrict what can be thrown as an exception.\n * @author Dieter Oberkofler\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow throwing literals as exceptions\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-throw-literal\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            ThrowStatement(node) {\n                if (!astUtils.couldBeError(node.argument)) {\n                    context.report({ node, message: \"Expected an object to be thrown.\" });\n                } else if (node.argument.type === \"Identifier\") {\n                    if (node.argument.name === \"undefined\") {\n                        context.report({ node, message: \"Do not throw undefined.\" });\n                    }\n                }\n\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Disallow trailing spaces at the end of lines.\n * @author Nodeca Team <https://github.com/nodeca>\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow trailing whitespace at the end of lines\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-trailing-spaces\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    skipBlankLines: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoreComments: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const BLANK_CLASS = \"[ \\t\\u00a0\\u2000-\\u200b\\u3000]\",\n            SKIP_BLANK = `^${BLANK_CLASS}*$`,\n            NONBLANK = `${BLANK_CLASS}+$`;\n\n        const options = context.options[0] || {},\n            skipBlankLines = options.skipBlankLines || false,\n            ignoreComments = options.ignoreComments || false;\n\n        /**\n         * Report the error message\n         * @param {ASTNode} node node to report\n         * @param {int[]} location range information\n         * @param {int[]} fixRange Range based on the whole program\n         * @returns {void}\n         */\n        function report(node, location, fixRange) {\n\n            /*\n             * Passing node is a bit dirty, because message data will contain big\n             * text in `source`. But... who cares :) ?\n             * One more kludge will not make worse the bloody wizardry of this\n             * plugin.\n             */\n            context.report({\n                node,\n                loc: location,\n                message: \"Trailing spaces not allowed.\",\n                fix(fixer) {\n                    return fixer.removeRange(fixRange);\n                }\n            });\n        }\n\n        /**\n         * Given a list of comment nodes, return the line numbers for those comments.\n         * @param {Array} comments An array of comment nodes.\n         * @returns {number[]} An array of line numbers containing comments.\n         */\n        function getCommentLineNumbers(comments) {\n            const lines = new Set();\n\n            comments.forEach(comment => {\n                for (let i = comment.loc.start.line; i <= comment.loc.end.line; i++) {\n                    lines.add(i);\n                }\n            });\n\n            return lines;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            Program: function checkTrailingSpaces(node) {\n\n                /*\n                 * Let's hack. Since Espree does not return whitespace nodes,\n                 * fetch the source code and do matching via regexps.\n                 */\n\n                const re = new RegExp(NONBLANK, \"u\"),\n                    skipMatch = new RegExp(SKIP_BLANK, \"u\"),\n                    lines = sourceCode.lines,\n                    linebreaks = sourceCode.getText().match(astUtils.createGlobalLinebreakMatcher()),\n                    comments = sourceCode.getAllComments(),\n                    commentLineNumbers = getCommentLineNumbers(comments);\n\n                let totalLength = 0,\n                    fixRange = [];\n\n                for (let i = 0, ii = lines.length; i < ii; i++) {\n                    const matches = re.exec(lines[i]);\n\n                    /*\n                     * Always add linebreak length to line length to accommodate for line break (\\n or \\r\\n)\n                     * Because during the fix time they also reserve one spot in the array.\n                     * Usually linebreak length is 2 for \\r\\n (CRLF) and 1 for \\n (LF)\n                     */\n                    const linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;\n                    const lineLength = lines[i].length + linebreakLength;\n\n                    if (matches) {\n                        const location = {\n                            line: i + 1,\n                            column: matches.index\n                        };\n\n                        const rangeStart = totalLength + location.column;\n                        const rangeEnd = totalLength + lineLength - linebreakLength;\n                        const containingNode = sourceCode.getNodeByRangeIndex(rangeStart);\n\n                        if (containingNode && containingNode.type === \"TemplateElement\" &&\n                          rangeStart > containingNode.parent.range[0] &&\n                          rangeEnd < containingNode.parent.range[1]) {\n                            totalLength += lineLength;\n                            continue;\n                        }\n\n                        /*\n                         * If the line has only whitespace, and skipBlankLines\n                         * is true, don't report it\n                         */\n                        if (skipBlankLines && skipMatch.test(lines[i])) {\n                            totalLength += lineLength;\n                            continue;\n                        }\n\n                        fixRange = [rangeStart, rangeEnd];\n\n                        if (!ignoreComments || !commentLineNumbers.has(location.line)) {\n                            report(node, location, fixRange);\n                        }\n                    }\n\n                    totalLength += lineLength;\n                }\n            }\n\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag references to undeclared variables.\n * @author Mark Macdonald\n */\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks if the given node is the argument of a typeof operator.\n * @param {ASTNode} node The AST node being checked.\n * @returns {boolean} Whether or not the node is the argument of a typeof operator.\n */\nfunction hasTypeOfOperator(node) {\n    const parent = node.parent;\n\n    return parent.type === \"UnaryExpression\" && parent.operator === \"typeof\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow the use of undeclared variables unless mentioned in `/*global */` comments\",\n            category: \"Variables\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-undef\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    typeof: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            undef: \"'{{name}}' is not defined.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0];\n        const considerTypeOf = options && options.typeof === true || false;\n\n        return {\n            \"Program:exit\"(/* node */) {\n                const globalScope = context.getScope();\n\n                globalScope.through.forEach(ref => {\n                    const identifier = ref.identifier;\n\n                    if (!considerTypeOf && hasTypeOfOperator(identifier)) {\n                        return;\n                    }\n\n                    context.report({\n                        node: identifier,\n                        messageId: \"undef\",\n                        data: identifier\n                    });\n                });\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag when initializing to undefined\n * @author Ilya Volodin\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow initializing variables to `undefined`\",\n            category: \"Variables\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-undef-init\"\n        },\n\n        schema: [],\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n\n        return {\n\n            VariableDeclarator(node) {\n                const name = sourceCode.getText(node.id),\n                    init = node.init && node.init.name,\n                    scope = context.getScope(),\n                    undefinedVar = astUtils.getVariableByName(scope, \"undefined\"),\n                    shadowed = undefinedVar && undefinedVar.defs.length > 0;\n\n                if (init === \"undefined\" && node.parent.kind !== \"const\" && !shadowed) {\n                    context.report({\n                        node,\n                        message: \"It's not necessary to initialize '{{name}}' to undefined.\",\n                        data: { name },\n                        fix(fixer) {\n                            if (node.parent.kind === \"var\") {\n                                return null;\n                            }\n\n                            if (node.id.type === \"ArrayPattern\" || node.id.type === \"ObjectPattern\") {\n\n                                // Don't fix destructuring assignment to `undefined`.\n                                return null;\n                            }\n                            return fixer.removeRange([node.id.range[1], node.range[1]]);\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag references to the undefined variable.\n * @author Michael Ficarra\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow the use of `undefined` as an identifier\",\n            category: \"Variables\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-undefined\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Report an invalid \"undefined\" identifier node.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node,\n                message: \"Unexpected use of undefined.\"\n            });\n        }\n\n        /**\n         * Checks the given scope for references to `undefined` and reports\n         * all references found.\n         * @param {eslint-scope.Scope} scope The scope to check.\n         * @returns {void}\n         */\n        function checkScope(scope) {\n            const undefinedVar = scope.set.get(\"undefined\");\n\n            if (!undefinedVar) {\n                return;\n            }\n\n            const references = undefinedVar.references;\n\n            const defs = undefinedVar.defs;\n\n            // Report non-initializing references (those are covered in defs below)\n            references\n                .filter(ref => !ref.init)\n                .forEach(ref => report(ref.identifier));\n\n            defs.forEach(def => report(def.name));\n        }\n\n        return {\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n\n                const stack = [globalScope];\n\n                while (stack.length) {\n                    const scope = stack.pop();\n\n                    stack.push(...scope.childScopes);\n                    checkScope(scope);\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag trailing underscores in variable declarations.\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow dangling underscores in identifiers\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-underscore-dangle\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    allowAfterThis: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowAfterSuper: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    enforceInMethodNames: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const options = context.options[0] || {};\n        const ALLOWED_VARIABLES = options.allow ? options.allow : [];\n        const allowAfterThis = typeof options.allowAfterThis !== \"undefined\" ? options.allowAfterThis : false;\n        const allowAfterSuper = typeof options.allowAfterSuper !== \"undefined\" ? options.allowAfterSuper : false;\n        const enforceInMethodNames = typeof options.enforceInMethodNames !== \"undefined\" ? options.enforceInMethodNames : false;\n\n        //-------------------------------------------------------------------------\n        // Helpers\n        //-------------------------------------------------------------------------\n\n        /**\n         * Check if identifier is present inside the allowed option\n         * @param {string} identifier name of the node\n         * @returns {boolean} true if its is present\n         * @private\n         */\n        function isAllowed(identifier) {\n            return ALLOWED_VARIABLES.some(ident => ident === identifier);\n        }\n\n        /**\n         * Check if identifier has a underscore at the end\n         * @param {ASTNode} identifier node to evaluate\n         * @returns {boolean} true if its is present\n         * @private\n         */\n        function hasTrailingUnderscore(identifier) {\n            const len = identifier.length;\n\n            return identifier !== \"_\" && (identifier[0] === \"_\" || identifier[len - 1] === \"_\");\n        }\n\n        /**\n         * Check if identifier is a special case member expression\n         * @param {ASTNode} identifier node to evaluate\n         * @returns {boolean} true if its is a special case\n         * @private\n         */\n        function isSpecialCaseIdentifierForMemberExpression(identifier) {\n            return identifier === \"__proto__\";\n        }\n\n        /**\n         * Check if identifier is a special case variable expression\n         * @param {ASTNode} identifier node to evaluate\n         * @returns {boolean} true if its is a special case\n         * @private\n         */\n        function isSpecialCaseIdentifierInVariableExpression(identifier) {\n\n            // Checks for the underscore library usage here\n            return identifier === \"_\";\n        }\n\n        /**\n         * Check if function has a underscore at the end\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForTrailingUnderscoreInFunctionDeclaration(node) {\n            if (node.id) {\n                const identifier = node.id.name;\n\n                if (typeof identifier !== \"undefined\" && hasTrailingUnderscore(identifier) && !isAllowed(identifier)) {\n                    context.report({\n                        node,\n                        message: \"Unexpected dangling '_' in '{{identifier}}'.\",\n                        data: {\n                            identifier\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Check if variable expression has a underscore at the end\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForTrailingUnderscoreInVariableExpression(node) {\n            const identifier = node.id.name;\n\n            if (typeof identifier !== \"undefined\" && hasTrailingUnderscore(identifier) &&\n                !isSpecialCaseIdentifierInVariableExpression(identifier) && !isAllowed(identifier)) {\n                context.report({\n                    node,\n                    message: \"Unexpected dangling '_' in '{{identifier}}'.\",\n                    data: {\n                        identifier\n                    }\n                });\n            }\n        }\n\n        /**\n         * Check if member expression has a underscore at the end\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForTrailingUnderscoreInMemberExpression(node) {\n            const identifier = node.property.name,\n                isMemberOfThis = node.object.type === \"ThisExpression\",\n                isMemberOfSuper = node.object.type === \"Super\";\n\n            if (typeof identifier !== \"undefined\" && hasTrailingUnderscore(identifier) &&\n                !(isMemberOfThis && allowAfterThis) &&\n                !(isMemberOfSuper && allowAfterSuper) &&\n                !isSpecialCaseIdentifierForMemberExpression(identifier) && !isAllowed(identifier)) {\n                context.report({\n                    node,\n                    message: \"Unexpected dangling '_' in '{{identifier}}'.\",\n                    data: {\n                        identifier\n                    }\n                });\n            }\n        }\n\n        /**\n         * Check if method declaration or method property has a underscore at the end\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForTrailingUnderscoreInMethod(node) {\n            const identifier = node.key.name;\n            const isMethod = node.type === \"MethodDefinition\" || node.type === \"Property\" && node.method;\n\n            if (typeof identifier !== \"undefined\" && enforceInMethodNames && isMethod && hasTrailingUnderscore(identifier)) {\n                context.report({\n                    node,\n                    message: \"Unexpected dangling '_' in '{{identifier}}'.\",\n                    data: {\n                        identifier\n                    }\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            FunctionDeclaration: checkForTrailingUnderscoreInFunctionDeclaration,\n            VariableDeclarator: checkForTrailingUnderscoreInVariableExpression,\n            MemberExpression: checkForTrailingUnderscoreInMemberExpression,\n            MethodDefinition: checkForTrailingUnderscoreInMethod,\n            Property: checkForTrailingUnderscoreInMethod\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to spot scenarios where a newline looks like it is ending a statement, but is not.\n * @author Glen Mailer\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow confusing multiline expressions\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-unexpected-multiline\"\n        },\n\n        schema: [],\n        messages: {\n            function: \"Unexpected newline between function and ( of function call.\",\n            property: \"Unexpected newline between object and [ of property access.\",\n            taggedTemplate: \"Unexpected newline between template tag and template literal.\",\n            division: \"Unexpected newline between numerator and division operator.\"\n        }\n    },\n\n    create(context) {\n\n        const REGEX_FLAG_MATCHER = /^[gimsuy]+$/u;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check to see if there is a newline between the node and the following open bracket\n         * line's expression\n         * @param {ASTNode} node The node to check.\n         * @param {string} messageId The error messageId to use.\n         * @returns {void}\n         * @private\n         */\n        function checkForBreakAfter(node, messageId) {\n            const openParen = sourceCode.getTokenAfter(node, astUtils.isNotClosingParenToken);\n            const nodeExpressionEnd = sourceCode.getTokenBefore(openParen);\n\n            if (openParen.loc.start.line !== nodeExpressionEnd.loc.end.line) {\n                context.report({ node, loc: openParen.loc.start, messageId, data: { char: openParen.value } });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            MemberExpression(node) {\n                if (!node.computed) {\n                    return;\n                }\n                checkForBreakAfter(node.object, \"property\");\n            },\n\n            TaggedTemplateExpression(node) {\n                if (node.tag.loc.end.line === node.quasi.loc.start.line) {\n                    return;\n                }\n                context.report({ node, loc: node.loc.start, messageId: \"taggedTemplate\" });\n            },\n\n            CallExpression(node) {\n                if (node.arguments.length === 0) {\n                    return;\n                }\n                checkForBreakAfter(node.callee, \"function\");\n            },\n\n            \"BinaryExpression[operator='/'] > BinaryExpression[operator='/'].left\"(node) {\n                const secondSlash = sourceCode.getTokenAfter(node, token => token.value === \"/\");\n                const tokenAfterOperator = sourceCode.getTokenAfter(secondSlash);\n\n                if (\n                    tokenAfterOperator.type === \"Identifier\" &&\n                    REGEX_FLAG_MATCHER.test(tokenAfterOperator.value) &&\n                    secondSlash.range[1] === tokenAfterOperator.range[0]\n                ) {\n                    checkForBreakAfter(node.left, \"division\");\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to disallow use of unmodified expressions in loop conditions\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Traverser = require(\"../util/traverser\"),\n    astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_PATTERN = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/u;\nconst LOOP_PATTERN = /^(?:DoWhile|For|While)Statement$/u; // for-in/of statements don't have `test` property.\nconst GROUP_PATTERN = /^(?:BinaryExpression|ConditionalExpression)$/u;\nconst SKIP_PATTERN = /^(?:ArrowFunction|Class|Function)Expression$/u;\nconst DYNAMIC_PATTERN = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/u;\n\n/**\n * @typedef {Object} LoopConditionInfo\n * @property {eslint-scope.Reference} reference - The reference.\n * @property {ASTNode} group - BinaryExpression or ConditionalExpression nodes\n *      that the reference is belonging to.\n * @property {Function} isInLoop - The predicate which checks a given reference\n *      is in this loop.\n * @property {boolean} modified - The flag that the reference is modified in\n *      this loop.\n */\n\n/**\n * Checks whether or not a given reference is a write reference.\n *\n * @param {eslint-scope.Reference} reference - A reference to check.\n * @returns {boolean} `true` if the reference is a write reference.\n */\nfunction isWriteReference(reference) {\n    if (reference.init) {\n        const def = reference.resolved && reference.resolved.defs[0];\n\n        if (!def || def.type !== \"Variable\" || def.parent.kind !== \"var\") {\n            return false;\n        }\n    }\n    return reference.isWrite();\n}\n\n/**\n * Checks whether or not a given loop condition info does not have the modified\n * flag.\n *\n * @param {LoopConditionInfo} condition - A loop condition info to check.\n * @returns {boolean} `true` if the loop condition info is \"unmodified\".\n */\nfunction isUnmodified(condition) {\n    return !condition.modified;\n}\n\n/**\n * Checks whether or not a given loop condition info does not have the modified\n * flag and does not have the group this condition belongs to.\n *\n * @param {LoopConditionInfo} condition - A loop condition info to check.\n * @returns {boolean} `true` if the loop condition info is \"unmodified\".\n */\nfunction isUnmodifiedAndNotBelongToGroup(condition) {\n    return !(condition.modified || condition.group);\n}\n\n/**\n * Checks whether or not a given reference is inside of a given node.\n *\n * @param {ASTNode} node - A node to check.\n * @param {eslint-scope.Reference} reference - A reference to check.\n * @returns {boolean} `true` if the reference is inside of the node.\n */\nfunction isInRange(node, reference) {\n    const or = node.range;\n    const ir = reference.identifier.range;\n\n    return or[0] <= ir[0] && ir[1] <= or[1];\n}\n\n/**\n * Checks whether or not a given reference is inside of a loop node's condition.\n *\n * @param {ASTNode} node - A node to check.\n * @param {eslint-scope.Reference} reference - A reference to check.\n * @returns {boolean} `true` if the reference is inside of the loop node's\n *      condition.\n */\nconst isInLoop = {\n    WhileStatement: isInRange,\n    DoWhileStatement: isInRange,\n    ForStatement(node, reference) {\n        return (\n            isInRange(node, reference) &&\n            !(node.init && isInRange(node.init, reference))\n        );\n    }\n};\n\n/**\n * Gets the function which encloses a given reference.\n * This supports only FunctionDeclaration.\n *\n * @param {eslint-scope.Reference} reference - A reference to get.\n * @returns {ASTNode|null} The function node or null.\n */\nfunction getEncloseFunctionDeclaration(reference) {\n    let node = reference.identifier;\n\n    while (node) {\n        if (node.type === \"FunctionDeclaration\") {\n            return node.id ? node : null;\n        }\n\n        node = node.parent;\n    }\n\n    return null;\n}\n\n/**\n * Updates the \"modified\" flags of given loop conditions with given modifiers.\n *\n * @param {LoopConditionInfo[]} conditions - The loop conditions to be updated.\n * @param {eslint-scope.Reference[]} modifiers - The references to update.\n * @returns {void}\n */\nfunction updateModifiedFlag(conditions, modifiers) {\n\n    for (let i = 0; i < conditions.length; ++i) {\n        const condition = conditions[i];\n\n        for (let j = 0; !condition.modified && j < modifiers.length; ++j) {\n            const modifier = modifiers[j];\n            let funcNode, funcVar;\n\n            /*\n             * Besides checking for the condition being in the loop, we want to\n             * check the function that this modifier is belonging to is called\n             * in the loop.\n             * FIXME: This should probably be extracted to a function.\n             */\n            const inLoop = condition.isInLoop(modifier) || Boolean(\n                (funcNode = getEncloseFunctionDeclaration(modifier)) &&\n                (funcVar = astUtils.getVariableByName(modifier.from.upper, funcNode.id.name)) &&\n                funcVar.references.some(condition.isInLoop)\n            );\n\n            condition.modified = inLoop;\n        }\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow unmodified loop conditions\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-unmodified-loop-condition\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        let groupMap = null;\n\n        /**\n         * Reports a given condition info.\n         *\n         * @param {LoopConditionInfo} condition - A loop condition info to report.\n         * @returns {void}\n         */\n        function report(condition) {\n            const node = condition.reference.identifier;\n\n            context.report({\n                node,\n                message: \"'{{name}}' is not modified in this loop.\",\n                data: node\n            });\n        }\n\n        /**\n         * Registers given conditions to the group the condition belongs to.\n         *\n         * @param {LoopConditionInfo[]} conditions - A loop condition info to\n         *      register.\n         * @returns {void}\n         */\n        function registerConditionsToGroup(conditions) {\n            for (let i = 0; i < conditions.length; ++i) {\n                const condition = conditions[i];\n\n                if (condition.group) {\n                    let group = groupMap.get(condition.group);\n\n                    if (!group) {\n                        group = [];\n                        groupMap.set(condition.group, group);\n                    }\n                    group.push(condition);\n                }\n            }\n        }\n\n        /**\n         * Reports references which are inside of unmodified groups.\n         *\n         * @param {LoopConditionInfo[]} conditions - A loop condition info to report.\n         * @returns {void}\n         */\n        function checkConditionsInGroup(conditions) {\n            if (conditions.every(isUnmodified)) {\n                conditions.forEach(report);\n            }\n        }\n\n        /**\n         * Checks whether or not a given group node has any dynamic elements.\n         *\n         * @param {ASTNode} root - A node to check.\n         *      This node is one of BinaryExpression or ConditionalExpression.\n         * @returns {boolean} `true` if the node is dynamic.\n         */\n        function hasDynamicExpressions(root) {\n            let retv = false;\n\n            Traverser.traverse(root, {\n                visitorKeys: sourceCode.visitorKeys,\n                enter(node) {\n                    if (DYNAMIC_PATTERN.test(node.type)) {\n                        retv = true;\n                        this.break();\n                    } else if (SKIP_PATTERN.test(node.type)) {\n                        this.skip();\n                    }\n                }\n            });\n\n            return retv;\n        }\n\n        /**\n         * Creates the loop condition information from a given reference.\n         *\n         * @param {eslint-scope.Reference} reference - A reference to create.\n         * @returns {LoopConditionInfo|null} Created loop condition info, or null.\n         */\n        function toLoopCondition(reference) {\n            if (reference.init) {\n                return null;\n            }\n\n            let group = null;\n            let child = reference.identifier;\n            let node = child.parent;\n\n            while (node) {\n                if (SENTINEL_PATTERN.test(node.type)) {\n                    if (LOOP_PATTERN.test(node.type) && node.test === child) {\n\n                        // This reference is inside of a loop condition.\n                        return {\n                            reference,\n                            group,\n                            isInLoop: isInLoop[node.type].bind(null, node),\n                            modified: false\n                        };\n                    }\n\n                    // This reference is outside of a loop condition.\n                    break;\n                }\n\n                /*\n                 * If it's inside of a group, OK if either operand is modified.\n                 * So stores the group this reference belongs to.\n                 */\n                if (GROUP_PATTERN.test(node.type)) {\n\n                    // If this expression is dynamic, no need to check.\n                    if (hasDynamicExpressions(node)) {\n                        break;\n                    } else {\n                        group = node;\n                    }\n                }\n\n                child = node;\n                node = node.parent;\n            }\n\n            return null;\n        }\n\n        /**\n         * Finds unmodified references which are inside of a loop condition.\n         * Then reports the references which are outside of groups.\n         *\n         * @param {eslint-scope.Variable} variable - A variable to report.\n         * @returns {void}\n         */\n        function checkReferences(variable) {\n\n            // Gets references that exist in loop conditions.\n            const conditions = variable\n                .references\n                .map(toLoopCondition)\n                .filter(Boolean);\n\n            if (conditions.length === 0) {\n                return;\n            }\n\n            // Registers the conditions to belonging groups.\n            registerConditionsToGroup(conditions);\n\n            // Check the conditions are modified.\n            const modifiers = variable.references.filter(isWriteReference);\n\n            if (modifiers.length > 0) {\n                updateModifiedFlag(conditions, modifiers);\n            }\n\n            /*\n             * Reports the conditions which are not belonging to groups.\n             * Others will be reported after all variables are done.\n             */\n            conditions\n                .filter(isUnmodifiedAndNotBelongToGroup)\n                .forEach(report);\n        }\n\n        return {\n            \"Program:exit\"() {\n                const queue = [context.getScope()];\n\n                groupMap = new Map();\n\n                let scope;\n\n                while ((scope = queue.pop())) {\n                    queue.push(...scope.childScopes);\n                    scope.variables.forEach(checkReferences);\n                }\n\n                groupMap.forEach(checkConditionsInGroup);\n                groupMap = null;\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag no-unneeded-ternary\n * @author Gyandeep Singh\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n// Operators that always result in a boolean value\nconst BOOLEAN_OPERATORS = new Set([\"==\", \"===\", \"!=\", \"!==\", \">\", \">=\", \"<\", \"<=\", \"in\", \"instanceof\"]);\nconst OPERATOR_INVERSES = {\n    \"==\": \"!=\",\n    \"!=\": \"==\",\n    \"===\": \"!==\",\n    \"!==\": \"===\"\n\n    // Operators like < and >= are not true inverses, since both will return false with NaN.\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow ternary operators when simpler alternatives exist\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-unneeded-ternary\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    defaultAssignment: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const defaultAssignment = options.defaultAssignment !== false;\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Test if the node is a boolean literal\n         * @param {ASTNode} node - The node to report.\n         * @returns {boolean} True if the its a boolean literal\n         * @private\n         */\n        function isBooleanLiteral(node) {\n            return node.type === \"Literal\" && typeof node.value === \"boolean\";\n        }\n\n        /**\n         * Creates an expression that represents the boolean inverse of the expression represented by the original node\n         * @param {ASTNode} node A node representing an expression\n         * @returns {string} A string representing an inverted expression\n         */\n        function invertExpression(node) {\n            if (node.type === \"BinaryExpression\" && Object.prototype.hasOwnProperty.call(OPERATOR_INVERSES, node.operator)) {\n                const operatorToken = sourceCode.getFirstTokenBetween(\n                    node.left,\n                    node.right,\n                    token => token.value === node.operator\n                );\n                const text = sourceCode.getText();\n\n                return text.slice(node.range[0],\n                    operatorToken.range[0]) + OPERATOR_INVERSES[node.operator] + text.slice(operatorToken.range[1], node.range[1]);\n            }\n\n            if (astUtils.getPrecedence(node) < astUtils.getPrecedence({ type: \"UnaryExpression\" })) {\n                return `!(${astUtils.getParenthesisedText(sourceCode, node)})`;\n            }\n            return `!${astUtils.getParenthesisedText(sourceCode, node)}`;\n        }\n\n        /**\n         * Tests if a given node always evaluates to a boolean value\n         * @param {ASTNode} node - An expression node\n         * @returns {boolean} True if it is determined that the node will always evaluate to a boolean value\n         */\n        function isBooleanExpression(node) {\n            return node.type === \"BinaryExpression\" && BOOLEAN_OPERATORS.has(node.operator) ||\n                node.type === \"UnaryExpression\" && node.operator === \"!\";\n        }\n\n        /**\n         * Test if the node matches the pattern id ? id : expression\n         * @param {ASTNode} node - The ConditionalExpression to check.\n         * @returns {boolean} True if the pattern is matched, and false otherwise\n         * @private\n         */\n        function matchesDefaultAssignment(node) {\n            return node.test.type === \"Identifier\" &&\n                   node.consequent.type === \"Identifier\" &&\n                   node.test.name === node.consequent.name;\n        }\n\n        return {\n\n            ConditionalExpression(node) {\n                if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {\n                    context.report({\n                        node,\n                        loc: node.consequent.loc.start,\n                        message: \"Unnecessary use of boolean literals in conditional expression.\",\n                        fix(fixer) {\n                            if (node.consequent.value === node.alternate.value) {\n\n                                // Replace `foo ? true : true` with just `true`, but don't replace `foo() ? true : true`\n                                return node.test.type === \"Identifier\" ? fixer.replaceText(node, node.consequent.value.toString()) : null;\n                            }\n                            if (node.alternate.value) {\n\n                                // Replace `foo() ? false : true` with `!(foo())`\n                                return fixer.replaceText(node, invertExpression(node.test));\n                            }\n\n                            // Replace `foo ? true : false` with `foo` if `foo` is guaranteed to be a boolean, or `!!foo` otherwise.\n\n                            return fixer.replaceText(node, isBooleanExpression(node.test) ? astUtils.getParenthesisedText(sourceCode, node.test) : `!${invertExpression(node.test)}`);\n                        }\n                    });\n                } else if (!defaultAssignment && matchesDefaultAssignment(node)) {\n                    context.report({\n                        node,\n                        loc: node.consequent.loc.start,\n                        message: \"Unnecessary use of conditional expression for default assignment.\",\n                        fix: fixer => {\n                            let nodeAlternate = astUtils.getParenthesisedText(sourceCode, node.alternate);\n\n                            if (node.alternate.type === \"ConditionalExpression\" || node.alternate.type === \"YieldExpression\") {\n                                const isAlternateParenthesised = astUtils.isParenthesised(sourceCode, node.alternate);\n\n                                nodeAlternate = isAlternateParenthesised ? nodeAlternate : `(${nodeAlternate})`;\n                            }\n\n                            return fixer.replaceText(node, `${astUtils.getParenthesisedText(sourceCode, node.test)} || ${nodeAlternate}`);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Checks for unreachable code due to return, throws, break, and continue.\n * @author Joel Feenstra\n */\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given variable declarator has the initializer.\n * @param {ASTNode} node - A VariableDeclarator node to check.\n * @returns {boolean} `true` if the node has the initializer.\n */\nfunction isInitialized(node) {\n    return Boolean(node.init);\n}\n\n/**\n * Checks whether or not a given code path segment is unreachable.\n * @param {CodePathSegment} segment - A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is unreachable.\n */\nfunction isUnreachable(segment) {\n    return !segment.reachable;\n}\n\n/**\n * The class to distinguish consecutive unreachable statements.\n */\nclass ConsecutiveRange {\n    constructor(sourceCode) {\n        this.sourceCode = sourceCode;\n        this.startNode = null;\n        this.endNode = null;\n    }\n\n    /**\n     * The location object of this range.\n     * @type {Object}\n     */\n    get location() {\n        return {\n            start: this.startNode.loc.start,\n            end: this.endNode.loc.end\n        };\n    }\n\n    /**\n     * `true` if this range is empty.\n     * @type {boolean}\n     */\n    get isEmpty() {\n        return !(this.startNode && this.endNode);\n    }\n\n    /**\n     * Checks whether the given node is inside of this range.\n     * @param {ASTNode|Token} node - The node to check.\n     * @returns {boolean} `true` if the node is inside of this range.\n     */\n    contains(node) {\n        return (\n            node.range[0] >= this.startNode.range[0] &&\n            node.range[1] <= this.endNode.range[1]\n        );\n    }\n\n    /**\n     * Checks whether the given node is consecutive to this range.\n     * @param {ASTNode} node - The node to check.\n     * @returns {boolean} `true` if the node is consecutive to this range.\n     */\n    isConsecutive(node) {\n        return this.contains(this.sourceCode.getTokenBefore(node));\n    }\n\n    /**\n     * Merges the given node to this range.\n     * @param {ASTNode} node - The node to merge.\n     * @returns {void}\n     */\n    merge(node) {\n        this.endNode = node;\n    }\n\n    /**\n     * Resets this range by the given node or null.\n     * @param {ASTNode|null} node - The node to reset, or null.\n     * @returns {void}\n     */\n    reset(node) {\n        this.startNode = this.endNode = node;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow unreachable code after `return`, `throw`, `continue`, and `break` statements\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-unreachable\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        let currentCodePath = null;\n\n        const range = new ConsecutiveRange(context.getSourceCode());\n\n        /**\n         * Reports a given node if it's unreachable.\n         * @param {ASTNode} node - A statement node to report.\n         * @returns {void}\n         */\n        function reportIfUnreachable(node) {\n            let nextNode = null;\n\n            if (node && currentCodePath.currentSegments.every(isUnreachable)) {\n\n                // Store this statement to distinguish consecutive statements.\n                if (range.isEmpty) {\n                    range.reset(node);\n                    return;\n                }\n\n                // Skip if this statement is inside of the current range.\n                if (range.contains(node)) {\n                    return;\n                }\n\n                // Merge if this statement is consecutive to the current range.\n                if (range.isConsecutive(node)) {\n                    range.merge(node);\n                    return;\n                }\n\n                nextNode = node;\n            }\n\n            /*\n             * Report the current range since this statement is reachable or is\n             * not consecutive to the current range.\n             */\n            if (!range.isEmpty) {\n                context.report({\n                    message: \"Unreachable code.\",\n                    loc: range.location,\n                    node: range.startNode\n                });\n            }\n\n            // Update the current range.\n            range.reset(nextNode);\n        }\n\n        return {\n\n            // Manages the current code path.\n            onCodePathStart(codePath) {\n                currentCodePath = codePath;\n            },\n\n            onCodePathEnd() {\n                currentCodePath = currentCodePath.upper;\n            },\n\n            // Registers for all statement nodes (excludes FunctionDeclaration).\n            BlockStatement: reportIfUnreachable,\n            BreakStatement: reportIfUnreachable,\n            ClassDeclaration: reportIfUnreachable,\n            ContinueStatement: reportIfUnreachable,\n            DebuggerStatement: reportIfUnreachable,\n            DoWhileStatement: reportIfUnreachable,\n            ExpressionStatement: reportIfUnreachable,\n            ForInStatement: reportIfUnreachable,\n            ForOfStatement: reportIfUnreachable,\n            ForStatement: reportIfUnreachable,\n            IfStatement: reportIfUnreachable,\n            ImportDeclaration: reportIfUnreachable,\n            LabeledStatement: reportIfUnreachable,\n            ReturnStatement: reportIfUnreachable,\n            SwitchStatement: reportIfUnreachable,\n            ThrowStatement: reportIfUnreachable,\n            TryStatement: reportIfUnreachable,\n\n            VariableDeclaration(node) {\n                if (node.kind !== \"var\" || node.declarations.some(isInitialized)) {\n                    reportIfUnreachable(node);\n                }\n            },\n\n            WhileStatement: reportIfUnreachable,\n            WithStatement: reportIfUnreachable,\n            ExportNamedDeclaration: reportIfUnreachable,\n            ExportDefaultDeclaration: reportIfUnreachable,\n            ExportAllDeclaration: reportIfUnreachable,\n\n            \"Program:exit\"() {\n                reportIfUnreachable();\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag unsafe statements in finally block\n * @author Onur Temizkan\n */\n\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_NODE_TYPE_RETURN_THROW = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression)$/u;\nconst SENTINEL_NODE_TYPE_BREAK = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement|SwitchStatement)$/u;\nconst SENTINEL_NODE_TYPE_CONTINUE = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement)$/u;\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow control flow statements in `finally` blocks\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-unsafe-finally\"\n        },\n\n        schema: []\n    },\n    create(context) {\n\n        /**\n         * Checks if the node is the finalizer of a TryStatement\n         *\n         * @param {ASTNode} node - node to check.\n         * @returns {boolean} - true if the node is the finalizer of a TryStatement\n         */\n        function isFinallyBlock(node) {\n            return node.parent.type === \"TryStatement\" && node.parent.finalizer === node;\n        }\n\n        /**\n         * Climbs up the tree if the node is not a sentinel node\n         *\n         * @param {ASTNode} node - node to check.\n         * @param {string} label - label of the break or continue statement\n         * @returns {boolean} - return whether the node is a finally block or a sentinel node\n         */\n        function isInFinallyBlock(node, label) {\n            let labelInside = false;\n            let sentinelNodeType;\n\n            if (node.type === \"BreakStatement\" && !node.label) {\n                sentinelNodeType = SENTINEL_NODE_TYPE_BREAK;\n            } else if (node.type === \"ContinueStatement\") {\n                sentinelNodeType = SENTINEL_NODE_TYPE_CONTINUE;\n            } else {\n                sentinelNodeType = SENTINEL_NODE_TYPE_RETURN_THROW;\n            }\n\n            for (\n                let currentNode = node;\n                currentNode && !sentinelNodeType.test(currentNode.type);\n                currentNode = currentNode.parent\n            ) {\n                if (currentNode.parent.label && label && (currentNode.parent.label.name === label.name)) {\n                    labelInside = true;\n                }\n                if (isFinallyBlock(currentNode)) {\n                    if (label && labelInside) {\n                        return false;\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * Checks whether the possibly-unsafe statement is inside a finally block.\n         *\n         * @param {ASTNode} node - node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            if (isInFinallyBlock(node, node.label)) {\n                context.report({\n                    message: \"Unsafe usage of {{nodeType}}.\",\n                    data: {\n                        nodeType: node.type\n                    },\n                    node,\n                    line: node.loc.line,\n                    column: node.loc.column\n                });\n            }\n        }\n\n        return {\n            ReturnStatement: check,\n            ThrowStatement: check,\n            BreakStatement: check,\n            ContinueStatement: check\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow negating the left operand of relational operators\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether the given operator is a relational operator or not.\n *\n * @param {string} op - The operator type to check.\n * @returns {boolean} `true` if the operator is a relational operator.\n */\nfunction isRelationalOperator(op) {\n    return op === \"in\" || op === \"instanceof\";\n}\n\n/**\n * Checks whether the given node is a logical negation expression or not.\n *\n * @param {ASTNode} node - The node to check.\n * @returns {boolean} `true` if the node is a logical negation expression.\n */\nfunction isNegation(node) {\n    return node.type === \"UnaryExpression\" && node.operator === \"!\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow negating the left operand of relational operators\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-unsafe-negation\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n        messages: {\n            unexpected: \"Unexpected negating the left operand of '{{operator}}' operator.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            BinaryExpression(node) {\n                if (isRelationalOperator(node.operator) &&\n                    isNegation(node.left) &&\n                    !astUtils.isParenthesised(sourceCode, node.left)\n                ) {\n                    context.report({\n                        node,\n                        loc: node.left.loc,\n                        messageId: \"unexpected\",\n                        data: { operator: node.operator },\n\n                        fix(fixer) {\n                            const negationToken = sourceCode.getFirstToken(node.left);\n                            const fixRange = [negationToken.range[1], node.range[1]];\n                            const text = sourceCode.text.slice(fixRange[0], fixRange[1]);\n\n                            return fixer.replaceTextRange(fixRange, `(${text})`);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Flag expressions in statement position that do not side effect\n * @author Michael Ficarra\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unused expressions\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-unused-expressions\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowShortCircuit: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowTernary: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowTaggedTemplates: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const config = context.options[0] || {},\n            allowShortCircuit = config.allowShortCircuit || false,\n            allowTernary = config.allowTernary || false,\n            allowTaggedTemplates = config.allowTaggedTemplates || false;\n\n        /**\n         * @param {ASTNode} node - any node\n         * @returns {boolean} whether the given node structurally represents a directive\n         */\n        function looksLikeDirective(node) {\n            return node.type === \"ExpressionStatement\" &&\n                node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n        }\n\n        /**\n         * @param {Function} predicate - ([a] -> Boolean) the function used to make the determination\n         * @param {a[]} list - the input list\n         * @returns {a[]} the leading sequence of members in the given list that pass the given predicate\n         */\n        function takeWhile(predicate, list) {\n            for (let i = 0; i < list.length; ++i) {\n                if (!predicate(list[i])) {\n                    return list.slice(0, i);\n                }\n            }\n            return list.slice();\n        }\n\n        /**\n         * @param {ASTNode} node - a Program or BlockStatement node\n         * @returns {ASTNode[]} the leading sequence of directive nodes in the given node's body\n         */\n        function directives(node) {\n            return takeWhile(looksLikeDirective, node.body);\n        }\n\n        /**\n         * @param {ASTNode} node - any node\n         * @param {ASTNode[]} ancestors - the given node's ancestors\n         * @returns {boolean} whether the given node is considered a directive in its current position\n         */\n        function isDirective(node, ancestors) {\n            const parent = ancestors[ancestors.length - 1],\n                grandparent = ancestors[ancestors.length - 2];\n\n            return (parent.type === \"Program\" || parent.type === \"BlockStatement\" &&\n                    (/Function/u.test(grandparent.type))) &&\n                    directives(parent).indexOf(node) >= 0;\n        }\n\n        /**\n         * Determines whether or not a given node is a valid expression. Recurses on short circuit eval and ternary nodes if enabled by flags.\n         * @param {ASTNode} node - any node\n         * @returns {boolean} whether the given node is a valid expression\n         */\n        function isValidExpression(node) {\n            if (allowTernary) {\n\n                // Recursive check for ternary and logical expressions\n                if (node.type === \"ConditionalExpression\") {\n                    return isValidExpression(node.consequent) && isValidExpression(node.alternate);\n                }\n            }\n\n            if (allowShortCircuit) {\n                if (node.type === \"LogicalExpression\") {\n                    return isValidExpression(node.right);\n                }\n            }\n\n            if (allowTaggedTemplates && node.type === \"TaggedTemplateExpression\") {\n                return true;\n            }\n\n            return /^(?:Assignment|Call|New|Update|Yield|Await)Expression$/u.test(node.type) ||\n                (node.type === \"UnaryExpression\" && [\"delete\", \"void\"].indexOf(node.operator) >= 0);\n        }\n\n        return {\n            ExpressionStatement(node) {\n                if (!isValidExpression(node.expression) && !isDirective(node, context.getAncestors())) {\n                    context.report({ node, message: \"Expected an assignment or function call and instead saw an expression.\" });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to disallow unused labels.\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unused labels\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-unused-labels\"\n        },\n\n        schema: [],\n\n        fixable: \"code\",\n\n        messages: {\n            unused: \"'{{name}}:' is defined but never used.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        let scopeInfo = null;\n\n        /**\n         * Adds a scope info to the stack.\n         *\n         * @param {ASTNode} node - A node to add. This is a LabeledStatement.\n         * @returns {void}\n         */\n        function enterLabeledScope(node) {\n            scopeInfo = {\n                label: node.label.name,\n                used: false,\n                upper: scopeInfo\n            };\n        }\n\n        /**\n         * Removes the top of the stack.\n         * At the same time, this reports the label if it's never used.\n         *\n         * @param {ASTNode} node - A node to report. This is a LabeledStatement.\n         * @returns {void}\n         */\n        function exitLabeledScope(node) {\n            if (!scopeInfo.used) {\n                context.report({\n                    node: node.label,\n                    messageId: \"unused\",\n                    data: node.label,\n                    fix(fixer) {\n\n                        /*\n                         * Only perform a fix if there are no comments between the label and the body. This will be the case\n                         * when there is exactly one token/comment (the \":\") between the label and the body.\n                         */\n                        if (sourceCode.getTokenAfter(node.label, { includeComments: true }) ===\n                                sourceCode.getTokenBefore(node.body, { includeComments: true })) {\n                            return fixer.removeRange([node.range[0], node.body.range[0]]);\n                        }\n\n                        return null;\n                    }\n                });\n            }\n\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Marks the label of a given node as used.\n         *\n         * @param {ASTNode} node - A node to mark. This is a BreakStatement or\n         *      ContinueStatement.\n         * @returns {void}\n         */\n        function markAsUsed(node) {\n            if (!node.label) {\n                return;\n            }\n\n            const label = node.label.name;\n            let info = scopeInfo;\n\n            while (info) {\n                if (info.label === label) {\n                    info.used = true;\n                    break;\n                }\n                info = info.upper;\n            }\n        }\n\n        return {\n            LabeledStatement: enterLabeledScope,\n            \"LabeledStatement:exit\": exitLabeledScope,\n            BreakStatement: markAsUsed,\n            ContinueStatement: markAsUsed\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag declared but unused variables\n * @author Ilya Volodin\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow unused variables\",\n            category: \"Variables\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-unused-vars\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"all\", \"local\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            vars: {\n                                enum: [\"all\", \"local\"]\n                            },\n                            varsIgnorePattern: {\n                                type: \"string\"\n                            },\n                            args: {\n                                enum: [\"all\", \"after-used\", \"none\"]\n                            },\n                            ignoreRestSiblings: {\n                                type: \"boolean\"\n                            },\n                            argsIgnorePattern: {\n                                type: \"string\"\n                            },\n                            caughtErrors: {\n                                enum: [\"all\", \"none\"]\n                            },\n                            caughtErrorsIgnorePattern: {\n                                type: \"string\"\n                            }\n                        }\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const REST_PROPERTY_TYPE = /^(?:RestElement|(?:Experimental)?RestProperty)$/u;\n\n        const config = {\n            vars: \"all\",\n            args: \"after-used\",\n            ignoreRestSiblings: false,\n            caughtErrors: \"none\"\n        };\n\n        const firstOption = context.options[0];\n\n        if (firstOption) {\n            if (typeof firstOption === \"string\") {\n                config.vars = firstOption;\n            } else {\n                config.vars = firstOption.vars || config.vars;\n                config.args = firstOption.args || config.args;\n                config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;\n                config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;\n\n                if (firstOption.varsIgnorePattern) {\n                    config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern); // eslint-disable-line require-unicode-regexp\n                }\n\n                if (firstOption.argsIgnorePattern) {\n                    config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern); // eslint-disable-line require-unicode-regexp\n                }\n\n                if (firstOption.caughtErrorsIgnorePattern) {\n                    config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern); // eslint-disable-line require-unicode-regexp\n                }\n            }\n        }\n\n        /**\n         * Generate the warning message about the variable being\n         * defined and unused, including the ignore pattern if configured.\n         * @param {Variable} unusedVar - eslint-scope variable object.\n         * @returns {string} The warning message to be used with this unused variable.\n         */\n        function getDefinedMessage(unusedVar) {\n            const defType = unusedVar.defs && unusedVar.defs[0] && unusedVar.defs[0].type;\n            let type;\n            let pattern;\n\n            if (defType === \"CatchClause\" && config.caughtErrorsIgnorePattern) {\n                type = \"args\";\n                pattern = config.caughtErrorsIgnorePattern.toString();\n            } else if (defType === \"Parameter\" && config.argsIgnorePattern) {\n                type = \"args\";\n                pattern = config.argsIgnorePattern.toString();\n            } else if (defType !== \"Parameter\" && config.varsIgnorePattern) {\n                type = \"vars\";\n                pattern = config.varsIgnorePattern.toString();\n            }\n\n            const additional = type ? ` Allowed unused ${type} must match ${pattern}.` : \"\";\n\n            return `'{{name}}' is defined but never used.${additional}`;\n        }\n\n        /**\n         * Generate the warning message about the variable being\n         * assigned and unused, including the ignore pattern if configured.\n         * @returns {string} The warning message to be used with this unused variable.\n         */\n        function getAssignedMessage() {\n            const additional = config.varsIgnorePattern ? ` Allowed unused vars must match ${config.varsIgnorePattern.toString()}.` : \"\";\n\n            return `'{{name}}' is assigned a value but never used.${additional}`;\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const STATEMENT_TYPE = /(?:Statement|Declaration)$/u;\n\n        /**\n         * Determines if a given variable is being exported from a module.\n         * @param {Variable} variable - eslint-scope variable object.\n         * @returns {boolean} True if the variable is exported, false if not.\n         * @private\n         */\n        function isExported(variable) {\n\n            const definition = variable.defs[0];\n\n            if (definition) {\n\n                let node = definition.node;\n\n                if (node.type === \"VariableDeclarator\") {\n                    node = node.parent;\n                } else if (definition.type === \"Parameter\") {\n                    return false;\n                }\n\n                return node.parent.type.indexOf(\"Export\") === 0;\n            }\n            return false;\n\n        }\n\n        /**\n         * Determines if a variable has a sibling rest property\n         * @param {Variable} variable - eslint-scope variable object.\n         * @returns {boolean} True if the variable is exported, false if not.\n         * @private\n         */\n        function hasRestSpreadSibling(variable) {\n            if (config.ignoreRestSiblings) {\n                return variable.defs.some(def => {\n                    const propertyNode = def.name.parent;\n                    const patternNode = propertyNode.parent;\n\n                    return (\n                        propertyNode.type === \"Property\" &&\n                        patternNode.type === \"ObjectPattern\" &&\n                        REST_PROPERTY_TYPE.test(patternNode.properties[patternNode.properties.length - 1].type)\n                    );\n                });\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a reference is a read operation.\n         * @param {Reference} ref - An eslint-scope Reference\n         * @returns {boolean} whether the given reference represents a read operation\n         * @private\n         */\n        function isReadRef(ref) {\n            return ref.isRead();\n        }\n\n        /**\n         * Determine if an identifier is referencing an enclosing function name.\n         * @param {Reference} ref - The reference to check.\n         * @param {ASTNode[]} nodes - The candidate function nodes.\n         * @returns {boolean} True if it's a self-reference, false if not.\n         * @private\n         */\n        function isSelfReference(ref, nodes) {\n            let scope = ref.from;\n\n            while (scope) {\n                if (nodes.indexOf(scope.block) >= 0) {\n                    return true;\n                }\n\n                scope = scope.upper;\n            }\n\n            return false;\n        }\n\n        /**\n         * Gets a list of function definitions for a specified variable.\n         * @param {Variable} variable - eslint-scope variable object.\n         * @returns {ASTNode[]} Function nodes.\n         * @private\n         */\n        function getFunctionDefinitions(variable) {\n            const functionDefinitions = [];\n\n            variable.defs.forEach(def => {\n                const { type, node } = def;\n\n                // FunctionDeclarations\n                if (type === \"FunctionName\") {\n                    functionDefinitions.push(node);\n                }\n\n                // FunctionExpressions\n                if (type === \"Variable\" && node.init &&\n                    (node.init.type === \"FunctionExpression\" || node.init.type === \"ArrowFunctionExpression\")) {\n                    functionDefinitions.push(node.init);\n                }\n            });\n            return functionDefinitions;\n        }\n\n        /**\n         * Checks the position of given nodes.\n         *\n         * @param {ASTNode} inner - A node which is expected as inside.\n         * @param {ASTNode} outer - A node which is expected as outside.\n         * @returns {boolean} `true` if the `inner` node exists in the `outer` node.\n         * @private\n         */\n        function isInside(inner, outer) {\n            return (\n                inner.range[0] >= outer.range[0] &&\n                inner.range[1] <= outer.range[1]\n            );\n        }\n\n        /**\n         * If a given reference is left-hand side of an assignment, this gets\n         * the right-hand side node of the assignment.\n         *\n         * In the following cases, this returns null.\n         *\n         * - The reference is not the LHS of an assignment expression.\n         * - The reference is inside of a loop.\n         * - The reference is inside of a function scope which is different from\n         *   the declaration.\n         *\n         * @param {eslint-scope.Reference} ref - A reference to check.\n         * @param {ASTNode} prevRhsNode - The previous RHS node.\n         * @returns {ASTNode|null} The RHS node or null.\n         * @private\n         */\n        function getRhsNode(ref, prevRhsNode) {\n            const id = ref.identifier;\n            const parent = id.parent;\n            const granpa = parent.parent;\n            const refScope = ref.from.variableScope;\n            const varScope = ref.resolved.scope.variableScope;\n            const canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);\n\n            /*\n             * Inherits the previous node if this reference is in the node.\n             * This is for `a = a + a`-like code.\n             */\n            if (prevRhsNode && isInside(id, prevRhsNode)) {\n                return prevRhsNode;\n            }\n\n            if (parent.type === \"AssignmentExpression\" &&\n                granpa.type === \"ExpressionStatement\" &&\n                id === parent.left &&\n                !canBeUsedLater\n            ) {\n                return parent.right;\n            }\n            return null;\n        }\n\n        /**\n         * Checks whether a given function node is stored to somewhere or not.\n         * If the function node is stored, the function can be used later.\n         *\n         * @param {ASTNode} funcNode - A function node to check.\n         * @param {ASTNode} rhsNode - The RHS node of the previous assignment.\n         * @returns {boolean} `true` if under the following conditions:\n         *      - the funcNode is assigned to a variable.\n         *      - the funcNode is bound as an argument of a function call.\n         *      - the function is bound to a property and the object satisfies above conditions.\n         * @private\n         */\n        function isStorableFunction(funcNode, rhsNode) {\n            let node = funcNode;\n            let parent = funcNode.parent;\n\n            while (parent && isInside(parent, rhsNode)) {\n                switch (parent.type) {\n                    case \"SequenceExpression\":\n                        if (parent.expressions[parent.expressions.length - 1] !== node) {\n                            return false;\n                        }\n                        break;\n\n                    case \"CallExpression\":\n                    case \"NewExpression\":\n                        return parent.callee !== node;\n\n                    case \"AssignmentExpression\":\n                    case \"TaggedTemplateExpression\":\n                    case \"YieldExpression\":\n                        return true;\n\n                    default:\n                        if (STATEMENT_TYPE.test(parent.type)) {\n\n                            /*\n                             * If it encountered statements, this is a complex pattern.\n                             * Since analyzeing complex patterns is hard, this returns `true` to avoid false positive.\n                             */\n                            return true;\n                        }\n                }\n\n                node = parent;\n                parent = parent.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether a given Identifier node exists inside of a function node which can be used later.\n         *\n         * \"can be used later\" means:\n         * - the function is assigned to a variable.\n         * - the function is bound to a property and the object can be used later.\n         * - the function is bound as an argument of a function call.\n         *\n         * If a reference exists in a function which can be used later, the reference is read when the function is called.\n         *\n         * @param {ASTNode} id - An Identifier node to check.\n         * @param {ASTNode} rhsNode - The RHS node of the previous assignment.\n         * @returns {boolean} `true` if the `id` node exists inside of a function node which can be used later.\n         * @private\n         */\n        function isInsideOfStorableFunction(id, rhsNode) {\n            const funcNode = astUtils.getUpperFunction(id);\n\n            return (\n                funcNode &&\n                isInside(funcNode, rhsNode) &&\n                isStorableFunction(funcNode, rhsNode)\n            );\n        }\n\n        /**\n         * Checks whether a given reference is a read to update itself or not.\n         *\n         * @param {eslint-scope.Reference} ref - A reference to check.\n         * @param {ASTNode} rhsNode - The RHS node of the previous assignment.\n         * @returns {boolean} The reference is a read to update itself.\n         * @private\n         */\n        function isReadForItself(ref, rhsNode) {\n            const id = ref.identifier;\n            const parent = id.parent;\n            const granpa = parent.parent;\n\n            return ref.isRead() && (\n\n                // self update. e.g. `a += 1`, `a++`\n                (// in RHS of an assignment for itself. e.g. `a = a + 1`\n                    ((\n                        parent.type === \"AssignmentExpression\" &&\n                    granpa.type === \"ExpressionStatement\" &&\n                    parent.left === id\n                    ) ||\n                (\n                    parent.type === \"UpdateExpression\" &&\n                    granpa.type === \"ExpressionStatement\"\n                ) || rhsNode &&\n                isInside(id, rhsNode) &&\n                !isInsideOfStorableFunction(id, rhsNode)))\n            );\n        }\n\n        /**\n         * Determine if an identifier is used either in for-in loops.\n         *\n         * @param {Reference} ref - The reference to check.\n         * @returns {boolean} whether reference is used in the for-in loops\n         * @private\n         */\n        function isForInRef(ref) {\n            let target = ref.identifier.parent;\n\n\n            // \"for (var ...) { return; }\"\n            if (target.type === \"VariableDeclarator\") {\n                target = target.parent.parent;\n            }\n\n            if (target.type !== \"ForInStatement\") {\n                return false;\n            }\n\n            // \"for (...) { return; }\"\n            if (target.body.type === \"BlockStatement\") {\n                target = target.body.body[0];\n\n            // \"for (...) return;\"\n            } else {\n                target = target.body;\n            }\n\n            // For empty loop body\n            if (!target) {\n                return false;\n            }\n\n            return target.type === \"ReturnStatement\";\n        }\n\n        /**\n         * Determines if the variable is used.\n         * @param {Variable} variable - The variable to check.\n         * @returns {boolean} True if the variable is used\n         * @private\n         */\n        function isUsedVariable(variable) {\n            const functionNodes = getFunctionDefinitions(variable),\n                isFunctionDefinition = functionNodes.length > 0;\n            let rhsNode = null;\n\n            return variable.references.some(ref => {\n                if (isForInRef(ref)) {\n                    return true;\n                }\n\n                const forItself = isReadForItself(ref, rhsNode);\n\n                rhsNode = getRhsNode(ref, rhsNode);\n\n                return (\n                    isReadRef(ref) &&\n                    !forItself &&\n                    !(isFunctionDefinition && isSelfReference(ref, functionNodes))\n                );\n            });\n        }\n\n        /**\n         * Checks whether the given variable is after the last used parameter.\n         *\n         * @param {eslint-scope.Variable} variable - The variable to check.\n         * @returns {boolean} `true` if the variable is defined after the last\n         * used parameter.\n         */\n        function isAfterLastUsedArg(variable) {\n            const def = variable.defs[0];\n            const params = context.getDeclaredVariables(def.node);\n            const posteriorParams = params.slice(params.indexOf(variable) + 1);\n\n            // If any used parameters occur after this parameter, do not report.\n            return !posteriorParams.some(v => v.references.length > 0 || v.eslintUsed);\n        }\n\n        /**\n         * Gets an array of variables without read references.\n         * @param {Scope} scope - an eslint-scope Scope object.\n         * @param {Variable[]} unusedVars - an array that saving result.\n         * @returns {Variable[]} unused variables of the scope and descendant scopes.\n         * @private\n         */\n        function collectUnusedVariables(scope, unusedVars) {\n            const variables = scope.variables;\n            const childScopes = scope.childScopes;\n            let i, l;\n\n            if (scope.type !== \"TDZ\" && (scope.type !== \"global\" || config.vars === \"all\")) {\n                for (i = 0, l = variables.length; i < l; ++i) {\n                    const variable = variables[i];\n\n                    // skip a variable of class itself name in the class scope\n                    if (scope.type === \"class\" && scope.block.id === variable.identifiers[0]) {\n                        continue;\n                    }\n\n                    // skip function expression names and variables marked with markVariableAsUsed()\n                    if (scope.functionExpressionScope || variable.eslintUsed) {\n                        continue;\n                    }\n\n                    // skip implicit \"arguments\" variable\n                    if (scope.type === \"function\" && variable.name === \"arguments\" && variable.identifiers.length === 0) {\n                        continue;\n                    }\n\n                    // explicit global variables don't have definitions.\n                    const def = variable.defs[0];\n\n                    if (def) {\n                        const type = def.type;\n\n                        // skip catch variables\n                        if (type === \"CatchClause\") {\n                            if (config.caughtErrors === \"none\") {\n                                continue;\n                            }\n\n                            // skip ignored parameters\n                            if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n                        }\n\n                        if (type === \"Parameter\") {\n\n                            // skip any setter argument\n                            if ((def.node.parent.type === \"Property\" || def.node.parent.type === \"MethodDefinition\") && def.node.parent.kind === \"set\") {\n                                continue;\n                            }\n\n                            // if \"args\" option is \"none\", skip any parameter\n                            if (config.args === \"none\") {\n                                continue;\n                            }\n\n                            // skip ignored parameters\n                            if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n\n                            // if \"args\" option is \"after-used\", skip used variables\n                            if (config.args === \"after-used\" && astUtils.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {\n                                continue;\n                            }\n                        } else {\n\n                            // skip ignored variables\n                            if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n                        }\n                    }\n\n                    if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {\n                        unusedVars.push(variable);\n                    }\n                }\n            }\n\n            for (i = 0, l = childScopes.length; i < l; ++i) {\n                collectUnusedVariables(childScopes[i], unusedVars);\n            }\n\n            return unusedVars;\n        }\n\n        /**\n         * Gets the index of a given variable name in a given comment.\n         * @param {eslint-scope.Variable} variable - A variable to get.\n         * @param {ASTNode} comment - A comment node which includes the variable name.\n         * @returns {number} The index of the variable name's location.\n         * @private\n         */\n        function getColumnInComment(variable, comment) {\n            const namePattern = new RegExp(`[\\\\s,]${lodash.escapeRegExp(variable.name)}(?:$|[\\\\s,:])`, \"gu\");\n\n            // To ignore the first text \"global\".\n            namePattern.lastIndex = comment.value.indexOf(\"global\") + 6;\n\n            // Search a given variable name.\n            const match = namePattern.exec(comment.value);\n\n            return match ? match.index + 1 : 0;\n        }\n\n        /**\n         * Creates the correct location of a given variables.\n         * The location is at its name string in a `/*global` comment.\n         *\n         * @param {eslint-scope.Variable} variable - A variable to get its location.\n         * @returns {{line: number, column: number}} The location object for the variable.\n         * @private\n         */\n        function getLocation(variable) {\n            const comment = variable.eslintExplicitGlobalComment;\n\n            return sourceCode.getLocFromIndex(comment.range[0] + 2 + getColumnInComment(variable, comment));\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            \"Program:exit\"(programNode) {\n                const unusedVars = collectUnusedVariables(context.getScope(), []);\n\n                for (let i = 0, l = unusedVars.length; i < l; ++i) {\n                    const unusedVar = unusedVars[i];\n\n                    if (unusedVar.eslintExplicitGlobal) {\n                        context.report({\n                            node: programNode,\n                            loc: getLocation(unusedVar),\n                            message: getDefinedMessage(unusedVar),\n                            data: unusedVar\n                        });\n                    } else if (unusedVar.defs.length > 0) {\n                        context.report({\n                            node: unusedVar.identifiers[0],\n                            message: unusedVar.references.some(ref => ref.isWrite())\n                                ? getAssignedMessage()\n                                : getDefinedMessage(unusedVar),\n                            data: unusedVar\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use of variables before they are defined\n * @author Ilya Volodin\n */\n\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;\nconst FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;\n\n/**\n * Parses a given value as options.\n *\n * @param {any} options - A value to parse.\n * @returns {Object} The parsed options.\n */\nfunction parseOptions(options) {\n    let functions = true;\n    let classes = true;\n    let variables = true;\n\n    if (typeof options === \"string\") {\n        functions = (options !== \"nofunc\");\n    } else if (typeof options === \"object\" && options !== null) {\n        functions = options.functions !== false;\n        classes = options.classes !== false;\n        variables = options.variables !== false;\n    }\n\n    return { functions, classes, variables };\n}\n\n/**\n * Checks whether or not a given variable is a function declaration.\n *\n * @param {eslint-scope.Variable} variable - A variable to check.\n * @returns {boolean} `true` if the variable is a function declaration.\n */\nfunction isFunction(variable) {\n    return variable.defs[0].type === \"FunctionName\";\n}\n\n/**\n * Checks whether or not a given variable is a class declaration in an upper function scope.\n *\n * @param {eslint-scope.Variable} variable - A variable to check.\n * @param {eslint-scope.Reference} reference - A reference to check.\n * @returns {boolean} `true` if the variable is a class declaration.\n */\nfunction isOuterClass(variable, reference) {\n    return (\n        variable.defs[0].type === \"ClassName\" &&\n        variable.scope.variableScope !== reference.from.variableScope\n    );\n}\n\n/**\n * Checks whether or not a given variable is a variable declaration in an upper function scope.\n * @param {eslint-scope.Variable} variable - A variable to check.\n * @param {eslint-scope.Reference} reference - A reference to check.\n * @returns {boolean} `true` if the variable is a variable declaration.\n */\nfunction isOuterVariable(variable, reference) {\n    return (\n        variable.defs[0].type === \"Variable\" &&\n        variable.scope.variableScope !== reference.from.variableScope\n    );\n}\n\n/**\n * Checks whether or not a given location is inside of the range of a given node.\n *\n * @param {ASTNode} node - An node to check.\n * @param {number} location - A location to check.\n * @returns {boolean} `true` if the location is inside of the range of the node.\n */\nfunction isInRange(node, location) {\n    return node && node.range[0] <= location && location <= node.range[1];\n}\n\n/**\n * Checks whether or not a given reference is inside of the initializers of a given variable.\n *\n * This returns `true` in the following cases:\n *\n *     var a = a\n *     var [a = a] = list\n *     var {a = a} = obj\n *     for (var a in a) {}\n *     for (var a of a) {}\n *\n * @param {Variable} variable - A variable to check.\n * @param {Reference} reference - A reference to check.\n * @returns {boolean} `true` if the reference is inside of the initializers.\n */\nfunction isInInitializer(variable, reference) {\n    if (variable.scope !== reference.from) {\n        return false;\n    }\n\n    let node = variable.identifiers[0].parent;\n    const location = reference.identifier.range[1];\n\n    while (node) {\n        if (node.type === \"VariableDeclarator\") {\n            if (isInRange(node.init, location)) {\n                return true;\n            }\n            if (FOR_IN_OF_TYPE.test(node.parent.parent.type) &&\n                isInRange(node.parent.parent.right, location)\n            ) {\n                return true;\n            }\n            break;\n        } else if (node.type === \"AssignmentPattern\") {\n            if (isInRange(node.right, location)) {\n                return true;\n            }\n        } else if (SENTINEL_TYPE.test(node.type)) {\n            break;\n        }\n\n        node = node.parent;\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow the use of variables before they are defined\",\n            category: \"Variables\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-use-before-define\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"nofunc\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            functions: { type: \"boolean\" },\n                            classes: { type: \"boolean\" },\n                            variables: { type: \"boolean\" }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const options = parseOptions(context.options[0]);\n\n        /**\n         * Determines whether a given use-before-define case should be reported according to the options.\n         * @param {eslint-scope.Variable} variable The variable that gets used before being defined\n         * @param {eslint-scope.Reference} reference The reference to the variable\n         * @returns {boolean} `true` if the usage should be reported\n         */\n        function isForbidden(variable, reference) {\n            if (isFunction(variable)) {\n                return options.functions;\n            }\n            if (isOuterClass(variable, reference)) {\n                return options.classes;\n            }\n            if (isOuterVariable(variable, reference)) {\n                return options.variables;\n            }\n            return true;\n        }\n\n        /**\n         * Finds and validates all variables in a given scope.\n         * @param {Scope} scope The scope object.\n         * @returns {void}\n         * @private\n         */\n        function findVariablesInScope(scope) {\n            scope.references.forEach(reference => {\n                const variable = reference.resolved;\n\n                /*\n                 * Skips when the reference is:\n                 * - initialization's.\n                 * - referring to an undefined variable.\n                 * - referring to a global environment variable (there're no identifiers).\n                 * - located preceded by the variable (except in initializers).\n                 * - allowed by options.\n                 */\n                if (reference.init ||\n                    !variable ||\n                    variable.identifiers.length === 0 ||\n                    (variable.identifiers[0].range[1] < reference.identifier.range[1] && !isInInitializer(variable, reference)) ||\n                    !isForbidden(variable, reference)\n                ) {\n                    return;\n                }\n\n                // Reports.\n                context.report({\n                    node: reference.identifier,\n                    message: \"'{{name}}' was used before it was defined.\",\n                    data: reference.identifier\n                });\n            });\n\n            scope.childScopes.forEach(findVariablesInScope);\n        }\n\n        return {\n            Program() {\n                findVariablesInScope(context.getScope());\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A rule to disallow unnecessary `.call()` and `.apply()`.\n * @author Toru Nagashima\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a node is a `.call()`/`.apply()`.\n * @param {ASTNode} node - A CallExpression node to check.\n * @returns {boolean} Whether or not the node is a `.call()`/`.apply()`.\n */\nfunction isCallOrNonVariadicApply(node) {\n    return (\n        node.callee.type === \"MemberExpression\" &&\n        node.callee.property.type === \"Identifier\" &&\n        node.callee.computed === false &&\n        (\n            (node.callee.property.name === \"call\" && node.arguments.length >= 1) ||\n            (node.callee.property.name === \"apply\" && node.arguments.length === 2 && node.arguments[1].type === \"ArrayExpression\")\n        )\n    );\n}\n\n\n/**\n * Checks whether or not `thisArg` is not changed by `.call()`/`.apply()`.\n * @param {ASTNode|null} expectedThis - The node that is the owner of the applied function.\n * @param {ASTNode} thisArg - The node that is given to the first argument of the `.call()`/`.apply()`.\n * @param {SourceCode} sourceCode - The ESLint source code object.\n * @returns {boolean} Whether or not `thisArg` is not changed by `.call()`/`.apply()`.\n */\nfunction isValidThisArg(expectedThis, thisArg, sourceCode) {\n    if (!expectedThis) {\n        return astUtils.isNullOrUndefined(thisArg);\n    }\n    return astUtils.equalTokens(expectedThis, thisArg, sourceCode);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary calls to `.call()` and `.apply()`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-call\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            CallExpression(node) {\n                if (!isCallOrNonVariadicApply(node)) {\n                    return;\n                }\n\n                const applied = node.callee.object;\n                const expectedThis = (applied.type === \"MemberExpression\") ? applied.object : null;\n                const thisArg = node.arguments[0];\n\n                if (isValidThisArg(expectedThis, thisArg, sourceCode)) {\n                    context.report({ node, message: \"unnecessary '.{{name}}()'.\", data: { name: node.callee.property.name } });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Reports useless `catch` clauses that just rethrow their error.\n * @author Teddy Katz\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary `catch` clauses\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-catch\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        return {\n            CatchClause(node) {\n                if (\n                    node.param &&\n                    node.param.type === \"Identifier\" &&\n                    node.body.body.length &&\n                    node.body.body[0].type === \"ThrowStatement\" &&\n                    node.body.body[0].argument.type === \"Identifier\" &&\n                    node.body.body[0].argument.name === node.param.name\n                ) {\n                    if (node.parent.finalizer) {\n                        context.report({\n                            node,\n                            message: \"Unnecessary catch clause.\"\n                        });\n                    } else {\n                        context.report({\n                            node: node.parent,\n                            message: \"Unnecessary try/catch wrapper.\"\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow unnecessary computed property keys in object literals\n * @author Burak Yigit Kaya\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst MESSAGE_UNNECESSARY_COMPUTED = \"Unnecessarily computed property [{{property}}] found.\";\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary computed property keys in object literals\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-computed-key\"\n        },\n\n        schema: [],\n        fixable: \"code\"\n    },\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            Property(node) {\n                if (!node.computed) {\n                    return;\n                }\n\n                const key = node.key,\n                    nodeType = typeof key.value;\n\n                if (key.type === \"Literal\" && (nodeType === \"string\" || nodeType === \"number\") && key.value !== \"__proto__\") {\n                    context.report({\n                        node,\n                        message: MESSAGE_UNNECESSARY_COMPUTED,\n                        data: { property: sourceCode.getText(key) },\n                        fix(fixer) {\n                            const leftSquareBracket = sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken);\n                            const rightSquareBracket = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken);\n                            const tokensBetween = sourceCode.getTokensBetween(leftSquareBracket, rightSquareBracket, 1);\n\n                            if (tokensBetween.slice(0, -1).some((token, index) =>\n                                sourceCode.getText().slice(token.range[1], tokensBetween[index + 1].range[0]).trim())) {\n\n                                // If there are comments between the brackets and the property name, don't do a fix.\n                                return null;\n                            }\n\n                            const tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket);\n\n                            // Insert a space before the key to avoid changing identifiers, e.g. ({ get[2]() {} }) to ({ get2() {} })\n                            const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] &&\n                                !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));\n\n                            const replacementKey = (needsSpaceBeforeKey ? \" \" : \"\") + key.raw;\n\n                            return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview disallow unncessary concatenation of template strings\n * @author Henry Zhu\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a concatenation.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a concatenation.\n */\nfunction isConcatenation(node) {\n    return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n\n/**\n * Checks if the given token is a `+` token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a `+` token.\n */\nfunction isConcatOperatorToken(token) {\n    return token.value === \"+\" && token.type === \"Punctuator\";\n}\n\n/**\n * Get's the right most node on the left side of a BinaryExpression with + operator.\n * @param {ASTNode} node - A BinaryExpression node to check.\n * @returns {ASTNode} node\n */\nfunction getLeft(node) {\n    let left = node.left;\n\n    while (isConcatenation(left)) {\n        left = left.right;\n    }\n    return left;\n}\n\n/**\n * Get's the left most node on the right side of a BinaryExpression with + operator.\n * @param {ASTNode} node - A BinaryExpression node to check.\n * @returns {ASTNode} node\n */\nfunction getRight(node) {\n    let right = node.right;\n\n    while (isConcatenation(right)) {\n        right = right.left;\n    }\n    return right;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary concatenation of literals or template literals\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-concat\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            BinaryExpression(node) {\n\n                // check if not concatenation\n                if (node.operator !== \"+\") {\n                    return;\n                }\n\n                // account for the `foo + \"a\" + \"b\"` case\n                const left = getLeft(node);\n                const right = getRight(node);\n\n                if (astUtils.isStringLiteral(left) &&\n                    astUtils.isStringLiteral(right) &&\n                    astUtils.isTokenOnSameLine(left, right)\n                ) {\n                    const operatorToken = sourceCode.getFirstTokenBetween(left, right, isConcatOperatorToken);\n\n                    context.report({\n                        node,\n                        loc: operatorToken.loc.start,\n                        message: \"Unexpected string concatenation of literals.\"\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag the use of redundant constructors in classes.\n * @author Alberto Rodríguez\n */\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a given array of statements is a single call of `super`.\n *\n * @param {ASTNode[]} body - An array of statements to check.\n * @returns {boolean} `true` if the body is a single call of `super`.\n */\nfunction isSingleSuperCall(body) {\n    return (\n        body.length === 1 &&\n        body[0].type === \"ExpressionStatement\" &&\n        body[0].expression.type === \"CallExpression\" &&\n        body[0].expression.callee.type === \"Super\"\n    );\n}\n\n/**\n * Checks whether a given node is a pattern which doesn't have any side effects.\n * Default parameters and Destructuring parameters can have side effects.\n *\n * @param {ASTNode} node - A pattern node.\n * @returns {boolean} `true` if the node doesn't have any side effects.\n */\nfunction isSimple(node) {\n    return node.type === \"Identifier\" || node.type === \"RestElement\";\n}\n\n/**\n * Checks whether a given array of expressions is `...arguments` or not.\n * `super(...arguments)` passes all arguments through.\n *\n * @param {ASTNode[]} superArgs - An array of expressions to check.\n * @returns {boolean} `true` if the superArgs is `...arguments`.\n */\nfunction isSpreadArguments(superArgs) {\n    return (\n        superArgs.length === 1 &&\n        superArgs[0].type === \"SpreadElement\" &&\n        superArgs[0].argument.type === \"Identifier\" &&\n        superArgs[0].argument.name === \"arguments\"\n    );\n}\n\n/**\n * Checks whether given 2 nodes are identifiers which have the same name or not.\n *\n * @param {ASTNode} ctorParam - A node to check.\n * @param {ASTNode} superArg - A node to check.\n * @returns {boolean} `true` if the nodes are identifiers which have the same\n *      name.\n */\nfunction isValidIdentifierPair(ctorParam, superArg) {\n    return (\n        ctorParam.type === \"Identifier\" &&\n        superArg.type === \"Identifier\" &&\n        ctorParam.name === superArg.name\n    );\n}\n\n/**\n * Checks whether given 2 nodes are a rest/spread pair which has the same values.\n *\n * @param {ASTNode} ctorParam - A node to check.\n * @param {ASTNode} superArg - A node to check.\n * @returns {boolean} `true` if the nodes are a rest/spread pair which has the\n *      same values.\n */\nfunction isValidRestSpreadPair(ctorParam, superArg) {\n    return (\n        ctorParam.type === \"RestElement\" &&\n        superArg.type === \"SpreadElement\" &&\n        isValidIdentifierPair(ctorParam.argument, superArg.argument)\n    );\n}\n\n/**\n * Checks whether given 2 nodes have the same value or not.\n *\n * @param {ASTNode} ctorParam - A node to check.\n * @param {ASTNode} superArg - A node to check.\n * @returns {boolean} `true` if the nodes have the same value or not.\n */\nfunction isValidPair(ctorParam, superArg) {\n    return (\n        isValidIdentifierPair(ctorParam, superArg) ||\n        isValidRestSpreadPair(ctorParam, superArg)\n    );\n}\n\n/**\n * Checks whether the parameters of a constructor and the arguments of `super()`\n * have the same values or not.\n *\n * @param {ASTNode} ctorParams - The parameters of a constructor to check.\n * @param {ASTNode} superArgs - The arguments of `super()` to check.\n * @returns {boolean} `true` if those have the same values.\n */\nfunction isPassingThrough(ctorParams, superArgs) {\n    if (ctorParams.length !== superArgs.length) {\n        return false;\n    }\n\n    for (let i = 0; i < ctorParams.length; ++i) {\n        if (!isValidPair(ctorParams[i], superArgs[i])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Checks whether the constructor body is a redundant super call.\n *\n * @param {Array} body - constructor body content.\n * @param {Array} ctorParams - The params to check against super call.\n * @returns {boolean} true if the construtor body is redundant\n */\nfunction isRedundantSuperCall(body, ctorParams) {\n    return (\n        isSingleSuperCall(body) &&\n        ctorParams.every(isSimple) &&\n        (\n            isSpreadArguments(body[0].expression.arguments) ||\n            isPassingThrough(ctorParams, body[0].expression.arguments)\n        )\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary constructors\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-constructor\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Checks whether a node is a redundant constructor\n         * @param {ASTNode} node - node to check\n         * @returns {void}\n         */\n        function checkForConstructor(node) {\n            if (node.kind !== \"constructor\") {\n                return;\n            }\n\n            const body = node.value.body.body;\n            const ctorParams = node.value.params;\n            const superClass = node.parent.parent.superClass;\n\n            if (superClass ? isRedundantSuperCall(body, ctorParams) : (body.length === 0)) {\n                context.report({\n                    node,\n                    message: \"Useless constructor.\"\n                });\n            }\n        }\n\n        return {\n            MethodDefinition: checkForConstructor\n        };\n    }\n};\n","/**\n * @fileoverview Look for useless escapes in strings and regexes\n * @author Onur Temizkan\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Returns the union of two sets.\n * @param {Set} setA The first set\n * @param {Set} setB The second set\n * @returns {Set} The union of the two sets\n */\nfunction union(setA, setB) {\n    return new Set(function *() {\n        yield* setA;\n        yield* setB;\n    }());\n}\n\nconst VALID_STRING_ESCAPES = union(new Set(\"\\\\nrvtbfux\"), astUtils.LINEBREAKS);\nconst REGEX_GENERAL_ESCAPES = new Set(\"\\\\bcdDfnpPrsStvwWxu0123456789]\");\nconst REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set(\"^/.$*+?[{}|()Bk\"));\n\n/**\n * Parses a regular expression into a list of characters with character class info.\n * @param {string} regExpText The raw text used to create the regular expression\n * @returns {Object[]} A list of characters, each with info on escaping and whether they're in a character class.\n * @example\n *\n * parseRegExp('a\\\\b[cd-]')\n *\n * returns:\n * [\n *   {text: 'a', index: 0, escaped: false, inCharClass: false, startsCharClass: false, endsCharClass: false},\n *   {text: 'b', index: 2, escaped: true, inCharClass: false, startsCharClass: false, endsCharClass: false},\n *   {text: 'c', index: 4, escaped: false, inCharClass: true, startsCharClass: true, endsCharClass: false},\n *   {text: 'd', index: 5, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false},\n *   {text: '-', index: 6, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false}\n * ]\n */\nfunction parseRegExp(regExpText) {\n    const charList = [];\n\n    regExpText.split(\"\").reduce((state, char, index) => {\n        if (!state.escapeNextChar) {\n            if (char === \"\\\\\") {\n                return Object.assign(state, { escapeNextChar: true });\n            }\n            if (char === \"[\" && !state.inCharClass) {\n                return Object.assign(state, { inCharClass: true, startingCharClass: true });\n            }\n            if (char === \"]\" && state.inCharClass) {\n                if (charList.length && charList[charList.length - 1].inCharClass) {\n                    charList[charList.length - 1].endsCharClass = true;\n                }\n                return Object.assign(state, { inCharClass: false, startingCharClass: false });\n            }\n        }\n        charList.push({\n            text: char,\n            index,\n            escaped: state.escapeNextChar,\n            inCharClass: state.inCharClass,\n            startsCharClass: state.startingCharClass,\n            endsCharClass: false\n        });\n        return Object.assign(state, { escapeNextChar: false, startingCharClass: false });\n    }, { escapeNextChar: false, inCharClass: false, startingCharClass: false });\n\n    return charList;\n}\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow unnecessary escape characters\",\n            category: \"Best Practices\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-useless-escape\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports a node\n         * @param {ASTNode} node The node to report\n         * @param {number} startOffset The backslash's offset from the start of the node\n         * @param {string} character The uselessly escaped character (not including the backslash)\n         * @returns {void}\n         */\n        function report(node, startOffset, character) {\n            context.report({\n                node,\n                loc: sourceCode.getLocFromIndex(sourceCode.getIndexFromLoc(node.loc.start) + startOffset),\n                message: \"Unnecessary escape character: \\\\{{character}}.\",\n                data: { character }\n            });\n        }\n\n        /**\n         * Checks if the escape character in given string slice is unnecessary.\n         *\n         * @private\n         * @param {ASTNode} node - node to validate.\n         * @param {string} match - string slice to validate.\n         * @returns {void}\n         */\n        function validateString(node, match) {\n            const isTemplateElement = node.type === \"TemplateElement\";\n            const escapedChar = match[0][1];\n            let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);\n            let isQuoteEscape;\n\n            if (isTemplateElement) {\n                isQuoteEscape = escapedChar === \"`\";\n\n                if (escapedChar === \"$\") {\n\n                    // Warn if `\\$` is not followed by `{`\n                    isUnnecessaryEscape = match.input[match.index + 2] !== \"{\";\n                } else if (escapedChar === \"{\") {\n\n                    /*\n                     * Warn if `\\{` is not preceded by `$`. If preceded by `$`, escaping\n                     * is necessary and the rule should not warn. If preceded by `/$`, the rule\n                     * will warn for the `/$` instead, as it is the first unnecessarily escaped character.\n                     */\n                    isUnnecessaryEscape = match.input[match.index - 1] !== \"$\";\n                }\n            } else {\n                isQuoteEscape = escapedChar === node.raw[0];\n            }\n\n            if (isUnnecessaryEscape && !isQuoteEscape) {\n                report(node, match.index + 1, match[0].slice(1));\n            }\n        }\n\n        /**\n         * Checks if a node has an escape.\n         *\n         * @param {ASTNode} node - node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            const isTemplateElement = node.type === \"TemplateElement\";\n\n            if (\n                isTemplateElement &&\n                node.parent &&\n                node.parent.parent &&\n                node.parent.parent.type === \"TaggedTemplateExpression\" &&\n                node.parent === node.parent.parent.quasi\n            ) {\n\n                // Don't report tagged template literals, because the backslash character is accessible to the tag function.\n                return;\n            }\n\n            if (typeof node.value === \"string\" || isTemplateElement) {\n\n                /*\n                 * JSXAttribute doesn't have any escape sequence: https://facebook.github.io/jsx/.\n                 * In addition, backticks are not supported by JSX yet: https://github.com/facebook/jsx/issues/25.\n                 */\n                if (node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\" || node.parent.type === \"JSXFragment\") {\n                    return;\n                }\n\n                const value = isTemplateElement ? node.value.raw : node.raw.slice(1, -1);\n                const pattern = /\\\\[^\\d]/gu;\n                let match;\n\n                while ((match = pattern.exec(value))) {\n                    validateString(node, match);\n                }\n            } else if (node.regex) {\n                parseRegExp(node.regex.pattern)\n\n                    /*\n                     * The '-' character is a special case, because it's only valid to escape it if it's in a character\n                     * class, and is not at either edge of the character class. To account for this, don't consider '-'\n                     * characters to be valid in general, and filter out '-' characters that appear in the middle of a\n                     * character class.\n                     */\n                    .filter(charInfo => !(charInfo.text === \"-\" && charInfo.inCharClass && !charInfo.startsCharClass && !charInfo.endsCharClass))\n\n                    /*\n                     * The '^' character is also a special case; it must always be escaped outside of character classes, but\n                     * it only needs to be escaped in character classes if it's at the beginning of the character class. To\n                     * account for this, consider it to be a valid escape character outside of character classes, and filter\n                     * out '^' characters that appear at the start of a character class.\n                     */\n                    .filter(charInfo => !(charInfo.text === \"^\" && charInfo.startsCharClass))\n\n                    // Filter out characters that aren't escaped.\n                    .filter(charInfo => charInfo.escaped)\n\n                    // Filter out characters that are valid to escape, based on their position in the regular expression.\n                    .filter(charInfo => !(charInfo.inCharClass ? REGEX_GENERAL_ESCAPES : REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text))\n\n                    // Report all the remaining characters.\n                    .forEach(charInfo => report(node, charInfo.index, charInfo.text));\n            }\n\n        }\n\n        return {\n            Literal: check,\n            TemplateElement: check\n        };\n    }\n};\n","/**\n * @fileoverview Disallow renaming import, export, and destructured assignments to the same name.\n * @author Kai Cataldo\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow renaming import, export, and destructured assignments to the same name\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-rename\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreDestructuring: { type: \"boolean\", default: false },\n                    ignoreImport: { type: \"boolean\", default: false },\n                    ignoreExport: { type: \"boolean\", default: false }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0] || {},\n            ignoreDestructuring = options.ignoreDestructuring === true,\n            ignoreImport = options.ignoreImport === true,\n            ignoreExport = options.ignoreExport === true;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports error for unnecessarily renamed assignments\n         * @param {ASTNode} node - node to report\n         * @param {ASTNode} initial - node with initial name value\n         * @param {ASTNode} result - node with new name value\n         * @param {string} type - the type of the offending node\n         * @returns {void}\n         */\n        function reportError(node, initial, result, type) {\n            const name = initial.type === \"Identifier\" ? initial.name : initial.value;\n\n            return context.report({\n                node,\n                message: \"{{type}} {{name}} unnecessarily renamed.\",\n                data: {\n                    name,\n                    type\n                },\n                fix(fixer) {\n                    return fixer.replaceTextRange([\n                        initial.range[0],\n                        result.range[1]\n                    ], name);\n                }\n            });\n        }\n\n        /**\n         * Checks whether a destructured assignment is unnecessarily renamed\n         * @param {ASTNode} node - node to check\n         * @returns {void}\n         */\n        function checkDestructured(node) {\n            if (ignoreDestructuring) {\n                return;\n            }\n\n            const properties = node.properties;\n\n            for (let i = 0; i < properties.length; i++) {\n                if (properties[i].shorthand) {\n                    continue;\n                }\n\n                /**\n                 * If an ObjectPattern property is computed, we have no idea\n                 * if a rename is useless or not. If an ObjectPattern property\n                 * lacks a key, it is likely an ExperimentalRestProperty and\n                 * so there is no \"renaming\" occurring here.\n                 */\n                if (properties[i].computed || !properties[i].key) {\n                    continue;\n                }\n\n                if (properties[i].key.type === \"Identifier\" && properties[i].key.name === properties[i].value.name ||\n                        properties[i].key.type === \"Literal\" && properties[i].key.value === properties[i].value.name) {\n                    reportError(properties[i], properties[i].key, properties[i].value, \"Destructuring assignment\");\n                }\n            }\n        }\n\n        /**\n         * Checks whether an import is unnecessarily renamed\n         * @param {ASTNode} node - node to check\n         * @returns {void}\n         */\n        function checkImport(node) {\n            if (ignoreImport) {\n                return;\n            }\n\n            if (node.imported.name === node.local.name &&\n                    node.imported.range[0] !== node.local.range[0]) {\n                reportError(node, node.imported, node.local, \"Import\");\n            }\n        }\n\n        /**\n         * Checks whether an export is unnecessarily renamed\n         * @param {ASTNode} node - node to check\n         * @returns {void}\n         */\n        function checkExport(node) {\n            if (ignoreExport) {\n                return;\n            }\n\n            if (node.local.name === node.exported.name &&\n                    node.local.range[0] !== node.exported.range[0]) {\n                reportError(node, node.local, node.exported, \"Export\");\n            }\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ObjectPattern: checkDestructured,\n            ImportSpecifier: checkImport,\n            ExportSpecifier: checkExport\n        };\n    }\n};\n","/**\n * @fileoverview Disallow redundant return statements\n * @author Teddy Katz\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\"),\n    FixTracker = require(\"../util/fix-tracker\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Removes the given element from the array.\n *\n * @param {Array} array - The source array to remove.\n * @param {any} element - The target item to remove.\n * @returns {void}\n */\nfunction remove(array, element) {\n    const index = array.indexOf(element);\n\n    if (index !== -1) {\n        array.splice(index, 1);\n    }\n}\n\n/**\n * Checks whether it can remove the given return statement or not.\n *\n * @param {ASTNode} node - The return statement node to check.\n * @returns {boolean} `true` if the node is removeable.\n */\nfunction isRemovable(node) {\n    return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\n}\n\n/**\n * Checks whether the given return statement is in a `finally` block or not.\n *\n * @param {ASTNode} node - The return statement node to check.\n * @returns {boolean} `true` if the node is in a `finally` block.\n */\nfunction isInFinally(node) {\n    for (\n        let currentNode = node;\n        currentNode && currentNode.parent && !astUtils.isFunction(currentNode);\n        currentNode = currentNode.parent\n    ) {\n        if (currentNode.parent.type === \"TryStatement\" && currentNode.parent.finalizer === currentNode) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow redundant return statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-return\"\n        },\n\n        fixable: \"code\",\n        schema: []\n    },\n\n    create(context) {\n        const segmentInfoMap = new WeakMap();\n        const usedUnreachableSegments = new WeakSet();\n        let scopeInfo = null;\n\n        /**\n         * Checks whether the given segment is terminated by a return statement or not.\n         *\n         * @param {CodePathSegment} segment - The segment to check.\n         * @returns {boolean} `true` if the segment is terminated by a return statement, or if it's still a part of unreachable.\n         */\n        function isReturned(segment) {\n            const info = segmentInfoMap.get(segment);\n\n            return !info || info.returned;\n        }\n\n        /**\n         * Collects useless return statements from the given previous segments.\n         *\n         * A previous segment may be an unreachable segment.\n         * In that case, the information object of the unreachable segment is not\n         * initialized because `onCodePathSegmentStart` event is not notified for\n         * unreachable segments.\n         * This goes to the previous segments of the unreachable segment recursively\n         * if the unreachable segment was generated by a return statement. Otherwise,\n         * this ignores the unreachable segment.\n         *\n         * This behavior would simulate code paths for the case that the return\n         * statement does not exist.\n         *\n         * @param {ASTNode[]} uselessReturns - The collected return statements.\n         * @param {CodePathSegment[]} prevSegments - The previous segments to traverse.\n         * @param {WeakSet<CodePathSegment>} [providedTraversedSegments] A set of segments that have already been traversed in this call\n         * @returns {ASTNode[]} `uselessReturns`.\n         */\n        function getUselessReturns(uselessReturns, prevSegments, providedTraversedSegments) {\n            const traversedSegments = providedTraversedSegments || new WeakSet();\n\n            for (const segment of prevSegments) {\n                if (!segment.reachable) {\n                    if (!traversedSegments.has(segment)) {\n                        traversedSegments.add(segment);\n                        getUselessReturns(\n                            uselessReturns,\n                            segment.allPrevSegments.filter(isReturned),\n                            traversedSegments\n                        );\n                    }\n                    continue;\n                }\n\n                uselessReturns.push(...segmentInfoMap.get(segment).uselessReturns);\n            }\n\n            return uselessReturns;\n        }\n\n        /**\n         * Removes the return statements on the given segment from the useless return\n         * statement list.\n         *\n         * This segment may be an unreachable segment.\n         * In that case, the information object of the unreachable segment is not\n         * initialized because `onCodePathSegmentStart` event is not notified for\n         * unreachable segments.\n         * This goes to the previous segments of the unreachable segment recursively\n         * if the unreachable segment was generated by a return statement. Otherwise,\n         * this ignores the unreachable segment.\n         *\n         * This behavior would simulate code paths for the case that the return\n         * statement does not exist.\n         *\n         * @param {CodePathSegment} segment - The segment to get return statements.\n         * @returns {void}\n         */\n        function markReturnStatementsOnSegmentAsUsed(segment) {\n            if (!segment.reachable) {\n                usedUnreachableSegments.add(segment);\n                segment.allPrevSegments\n                    .filter(isReturned)\n                    .filter(prevSegment => !usedUnreachableSegments.has(prevSegment))\n                    .forEach(markReturnStatementsOnSegmentAsUsed);\n                return;\n            }\n\n            const info = segmentInfoMap.get(segment);\n\n            for (const node of info.uselessReturns) {\n                remove(scopeInfo.uselessReturns, node);\n            }\n            info.uselessReturns = [];\n        }\n\n        /**\n         * Removes the return statements on the current segments from the useless\n         * return statement list.\n         *\n         * This function will be called at every statement except FunctionDeclaration,\n         * BlockStatement, and BreakStatement.\n         *\n         * - FunctionDeclarations are always executed whether it's returned or not.\n         * - BlockStatements do nothing.\n         * - BreakStatements go the next merely.\n         *\n         * @returns {void}\n         */\n        function markReturnStatementsOnCurrentSegmentsAsUsed() {\n            scopeInfo\n                .codePath\n                .currentSegments\n                .forEach(markReturnStatementsOnSegmentAsUsed);\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n\n            // Makes and pushs a new scope information.\n            onCodePathStart(codePath) {\n                scopeInfo = {\n                    upper: scopeInfo,\n                    uselessReturns: [],\n                    codePath\n                };\n            },\n\n            // Reports useless return statements if exist.\n            onCodePathEnd() {\n                for (const node of scopeInfo.uselessReturns) {\n                    context.report({\n                        node,\n                        loc: node.loc,\n                        message: \"Unnecessary return statement.\",\n                        fix(fixer) {\n                            if (isRemovable(node)) {\n\n                                /*\n                                 * Extend the replacement range to include the\n                                 * entire function to avoid conflicting with\n                                 * no-else-return.\n                                 * https://github.com/eslint/eslint/issues/8026\n                                 */\n                                return new FixTracker(fixer, context.getSourceCode())\n                                    .retainEnclosingFunction(node)\n                                    .remove(node);\n                            }\n                            return null;\n                        }\n                    });\n                }\n\n                scopeInfo = scopeInfo.upper;\n            },\n\n            /*\n             * Initializes segments.\n             * NOTE: This event is notified for only reachable segments.\n             */\n            onCodePathSegmentStart(segment) {\n                const info = {\n                    uselessReturns: getUselessReturns([], segment.allPrevSegments),\n                    returned: false\n                };\n\n                // Stores the info.\n                segmentInfoMap.set(segment, info);\n            },\n\n            // Adds ReturnStatement node to check whether it's useless or not.\n            ReturnStatement(node) {\n                if (node.argument) {\n                    markReturnStatementsOnCurrentSegmentsAsUsed();\n                }\n                if (node.argument || astUtils.isInLoop(node) || isInFinally(node)) {\n                    return;\n                }\n\n                for (const segment of scopeInfo.codePath.currentSegments) {\n                    const info = segmentInfoMap.get(segment);\n\n                    if (info) {\n                        info.uselessReturns.push(node);\n                        info.returned = true;\n                    }\n                }\n                scopeInfo.uselessReturns.push(node);\n            },\n\n            /*\n             * Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.\n             * Removes return statements of the current segments from the useless return statement list.\n             */\n            ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed\n        };\n    }\n};\n","/**\n * @fileoverview Rule to check for the usage of var.\n * @author Jamund Ferguson\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Check whether a given variable is a global variable or not.\n * @param {eslint-scope.Variable} variable The variable to check.\n * @returns {boolean} `true` if the variable is a global variable.\n */\nfunction isGlobal(variable) {\n    return Boolean(variable.scope) && variable.scope.type === \"global\";\n}\n\n/**\n * Finds the nearest function scope or global scope walking up the scope\n * hierarchy.\n *\n * @param {eslint-scope.Scope} scope - The scope to traverse.\n * @returns {eslint-scope.Scope} a function scope or global scope containing the given\n *      scope.\n */\nfunction getEnclosingFunctionScope(scope) {\n    let currentScope = scope;\n\n    while (currentScope.type !== \"function\" && currentScope.type !== \"global\") {\n        currentScope = currentScope.upper;\n    }\n    return currentScope;\n}\n\n/**\n * Checks whether the given variable has any references from a more specific\n * function expression (i.e. a closure).\n *\n * @param {eslint-scope.Variable} variable - A variable to check.\n * @returns {boolean} `true` if the variable is used from a closure.\n */\nfunction isReferencedInClosure(variable) {\n    const enclosingFunctionScope = getEnclosingFunctionScope(variable.scope);\n\n    return variable.references.some(reference =>\n        getEnclosingFunctionScope(reference.from) !== enclosingFunctionScope);\n}\n\n/**\n * Checks whether the given node is the assignee of a loop.\n *\n * @param {ASTNode} node - A VariableDeclaration node to check.\n * @returns {boolean} `true` if the declaration is assigned as part of loop\n *      iteration.\n */\nfunction isLoopAssignee(node) {\n    return (node.parent.type === \"ForOfStatement\" || node.parent.type === \"ForInStatement\") &&\n        node === node.parent.left;\n}\n\n/**\n * Checks whether the given variable declaration is immediately initialized.\n *\n * @param {ASTNode} node - A VariableDeclaration node to check.\n * @returns {boolean} `true` if the declaration has an initializer.\n */\nfunction isDeclarationInitialized(node) {\n    return node.declarations.every(declarator => declarator.init !== null);\n}\n\nconst SCOPE_NODE_TYPE = /^(?:Program|BlockStatement|SwitchStatement|ForStatement|ForInStatement|ForOfStatement)$/u;\n\n/**\n * Gets the scope node which directly contains a given node.\n *\n * @param {ASTNode} node - A node to get. This is a `VariableDeclaration` or\n *      an `Identifier`.\n * @returns {ASTNode} A scope node. This is one of `Program`, `BlockStatement`,\n *      `SwitchStatement`, `ForStatement`, `ForInStatement`, and\n *      `ForOfStatement`.\n */\nfunction getScopeNode(node) {\n    for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n        if (SCOPE_NODE_TYPE.test(currentNode.type)) {\n            return currentNode;\n        }\n    }\n\n    /* istanbul ignore next : unreachable */\n    return null;\n}\n\n/**\n * Checks whether a given variable is redeclared or not.\n *\n * @param {eslint-scope.Variable} variable - A variable to check.\n * @returns {boolean} `true` if the variable is redeclared.\n */\nfunction isRedeclared(variable) {\n    return variable.defs.length >= 2;\n}\n\n/**\n * Checks whether a given variable is used from outside of the specified scope.\n *\n * @param {ASTNode} scopeNode - A scope node to check.\n * @returns {Function} The predicate function which checks whether a given\n *      variable is used from outside of the specified scope.\n */\nfunction isUsedFromOutsideOf(scopeNode) {\n\n    /**\n     * Checks whether a given reference is inside of the specified scope or not.\n     *\n     * @param {eslint-scope.Reference} reference - A reference to check.\n     * @returns {boolean} `true` if the reference is inside of the specified\n     *      scope.\n     */\n    function isOutsideOfScope(reference) {\n        const scope = scopeNode.range;\n        const id = reference.identifier.range;\n\n        return id[0] < scope[0] || id[1] > scope[1];\n    }\n\n    return function(variable) {\n        return variable.references.some(isOutsideOfScope);\n    };\n}\n\n/**\n * Creates the predicate function which checks whether a variable has their references in TDZ.\n *\n * The predicate function would return `true`:\n *\n * - if a reference is before the declarator. E.g. (var a = b, b = 1;)(var {a = b, b} = {};)\n * - if a reference is in the expression of their default value.  E.g. (var {a = a} = {};)\n * - if a reference is in the expression of their initializer.  E.g. (var a = a;)\n *\n * @param {ASTNode} node - The initializer node of VariableDeclarator.\n * @returns {Function} The predicate function.\n * @private\n */\nfunction hasReferenceInTDZ(node) {\n    const initStart = node.range[0];\n    const initEnd = node.range[1];\n\n    return variable => {\n        const id = variable.defs[0].name;\n        const idStart = id.range[0];\n        const defaultValue = (id.parent.type === \"AssignmentPattern\" ? id.parent.right : null);\n        const defaultStart = defaultValue && defaultValue.range[0];\n        const defaultEnd = defaultValue && defaultValue.range[1];\n\n        return variable.references.some(reference => {\n            const start = reference.identifier.range[0];\n            const end = reference.identifier.range[1];\n\n            return !reference.init && (\n                start < idStart ||\n                (defaultValue !== null && start >= defaultStart && end <= defaultEnd) ||\n                (start >= initStart && end <= initEnd)\n            );\n        });\n    };\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `let` or `const` instead of `var`\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-var\"\n        },\n\n        schema: [],\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Checks whether the variables which are defined by the given declarator node have their references in TDZ.\n         *\n         * @param {ASTNode} declarator - The VariableDeclarator node to check.\n         * @returns {boolean} `true` if one of the variables which are defined by the given declarator node have their references in TDZ.\n         */\n        function hasSelfReferenceInTDZ(declarator) {\n            if (!declarator.init) {\n                return false;\n            }\n            const variables = context.getDeclaredVariables(declarator);\n\n            return variables.some(hasReferenceInTDZ(declarator.init));\n        }\n\n        /**\n         * Checks whether it can fix a given variable declaration or not.\n         * It cannot fix if the following cases:\n         *\n         * - A variable is a global variable.\n         * - A variable is declared on a SwitchCase node.\n         * - A variable is redeclared.\n         * - A variable is used from outside the scope.\n         * - A variable is used from a closure within a loop.\n         * - A variable might be used before it is assigned within a loop.\n         * - A variable might be used in TDZ.\n         * - A variable is declared in statement position (e.g. a single-line `IfStatement`)\n         *\n         * ## A variable is declared on a SwitchCase node.\n         *\n         * If this rule modifies 'var' declarations on a SwitchCase node, it\n         * would generate the warnings of 'no-case-declarations' rule. And the\n         * 'eslint:recommended' preset includes 'no-case-declarations' rule, so\n         * this rule doesn't modify those declarations.\n         *\n         * ## A variable is redeclared.\n         *\n         * The language spec disallows redeclarations of `let` declarations.\n         * Those variables would cause syntax errors.\n         *\n         * ## A variable is used from outside the scope.\n         *\n         * The language spec disallows accesses from outside of the scope for\n         * `let` declarations. Those variables would cause reference errors.\n         *\n         * ## A variable is used from a closure within a loop.\n         *\n         * A `var` declaration within a loop shares the same variable instance\n         * across all loop iterations, while a `let` declaration creates a new\n         * instance for each iteration. This means if a variable in a loop is\n         * referenced by any closure, changing it from `var` to `let` would\n         * change the behavior in a way that is generally unsafe.\n         *\n         * ## A variable might be used before it is assigned within a loop.\n         *\n         * Within a loop, a `let` declaration without an initializer will be\n         * initialized to null, while a `var` declaration will retain its value\n         * from the previous iteration, so it is only safe to change `var` to\n         * `let` if we can statically determine that the variable is always\n         * assigned a value before its first access in the loop body. To keep\n         * the implementation simple, we only convert `var` to `let` within\n         * loops when the variable is a loop assignee or the declaration has an\n         * initializer.\n         *\n         * @param {ASTNode} node - A variable declaration node to check.\n         * @returns {boolean} `true` if it can fix the node.\n         */\n        function canFix(node) {\n            const variables = context.getDeclaredVariables(node);\n            const scopeNode = getScopeNode(node);\n\n            if (node.parent.type === \"SwitchCase\" ||\n                node.declarations.some(hasSelfReferenceInTDZ) ||\n                variables.some(isGlobal) ||\n                variables.some(isRedeclared) ||\n                variables.some(isUsedFromOutsideOf(scopeNode))\n            ) {\n                return false;\n            }\n\n            if (astUtils.isInLoop(node)) {\n                if (variables.some(isReferencedInClosure)) {\n                    return false;\n                }\n                if (!isLoopAssignee(node) && !isDeclarationInitialized(node)) {\n                    return false;\n                }\n            }\n\n            if (\n                !isLoopAssignee(node) &&\n                !(node.parent.type === \"ForStatement\" && node.parent.init === node) &&\n                !astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)\n            ) {\n\n                // If the declaration is not in a block, e.g. `if (foo) var bar = 1;`, then it can't be fixed.\n                return false;\n            }\n\n            return true;\n        }\n\n        /**\n         * Reports a given variable declaration node.\n         *\n         * @param {ASTNode} node - A variable declaration node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            const varToken = sourceCode.getFirstToken(node);\n\n            context.report({\n                node,\n                message: \"Unexpected var, use let or const instead.\",\n\n                fix(fixer) {\n                    if (canFix(node)) {\n                        return fixer.replaceText(varToken, \"let\");\n                    }\n                    return null;\n                }\n            });\n        }\n\n        return {\n            \"VariableDeclaration:exit\"(node) {\n                if (node.kind === \"var\") {\n                    report(node);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow use of void operator.\n * @author Mike Sidorov\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `void` operators\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-void\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            UnaryExpression(node) {\n                if (node.operator === \"void\") {\n                    context.report({ node, message: \"Expected 'undefined' and instead saw 'void'.\" });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule that warns about used warning comments\n * @author Alexander Schmidt <https://github.com/lxanders>\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow specified warning terms in comments\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-warning-comments\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    terms: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    location: {\n                        enum: [\"start\", \"anywhere\"]\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode(),\n            configuration = context.options[0] || {},\n            warningTerms = configuration.terms || [\"todo\", \"fixme\", \"xxx\"],\n            location = configuration.location || \"start\",\n            selfConfigRegEx = /\\bno-warning-comments\\b/u;\n\n        /**\n         * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified\n         * location (\"start\" or \"anywhere\"). If the term starts or ends with non word characters, then the match will not\n         * require word boundaries on that side.\n         *\n         * @param {string} term A term to convert to a RegExp\n         * @returns {RegExp} The term converted to a RegExp\n         */\n        function convertToRegExp(term) {\n            const escaped = term.replace(/[-/\\\\$^*+?.()|[\\]{}]/gu, \"\\\\$&\");\n            const wordBoundary = \"\\\\b\";\n            const eitherOrWordBoundary = `|${wordBoundary}`;\n            let prefix;\n\n            /*\n             * If the term ends in a word character (a-z0-9_), ensure a word\n             * boundary at the end, so that substrings do not get falsely\n             * matched. eg \"todo\" in a string such as \"mastodon\".\n             * If the term ends in a non-word character, then \\b won't match on\n             * the boundary to the next non-word character, which would likely\n             * be a space. For example `/\\bFIX!\\b/.test('FIX! blah') === false`.\n             * In these cases, use no bounding match. Same applies for the\n             * prefix, handled below.\n             */\n            const suffix = /\\w$/u.test(term) ? \"\\\\b\" : \"\";\n\n            if (location === \"start\") {\n\n                /*\n                 * When matching at the start, ignore leading whitespace, and\n                 * there's no need to worry about word boundaries.\n                 */\n                prefix = \"^\\\\s*\";\n            } else if (/^\\w/u.test(term)) {\n                prefix = wordBoundary;\n            } else {\n                prefix = \"\";\n            }\n\n            if (location === \"start\") {\n\n                /*\n                 * For location \"start\" the regex should be\n                 * ^\\s*TERM\\b.  This checks the word boundary\n                 * at the beginning of the comment.\n                 */\n                return new RegExp(prefix + escaped + suffix, \"i\"); // eslint-disable-line require-unicode-regexp\n            }\n\n            /*\n             * For location \"anywhere\" the regex should be\n             * \\bTERM\\b|\\bTERM\\b, this checks the entire comment\n             * for the term.\n             */\n            return new RegExp(prefix + escaped + suffix + eitherOrWordBoundary + term + wordBoundary, \"i\"); // eslint-disable-line require-unicode-regexp\n        }\n\n        const warningRegExps = warningTerms.map(convertToRegExp);\n\n        /**\n         * Checks the specified comment for matches of the configured warning terms and returns the matches.\n         * @param {string} comment The comment which is checked.\n         * @returns {Array} All matched warning terms for this comment.\n         */\n        function commentContainsWarningTerm(comment) {\n            const matches = [];\n\n            warningRegExps.forEach((regex, index) => {\n                if (regex.test(comment)) {\n                    matches.push(warningTerms[index]);\n                }\n            });\n\n            return matches;\n        }\n\n        /**\n         * Checks the specified node for matching warning comments and reports them.\n         * @param {ASTNode} node The AST node being checked.\n         * @returns {void} undefined.\n         */\n        function checkComment(node) {\n            if (astUtils.isDirectiveComment(node) && selfConfigRegEx.test(node.value)) {\n                return;\n            }\n\n            const matches = commentContainsWarningTerm(node.value);\n\n            matches.forEach(matchedTerm => {\n                context.report({\n                    node,\n                    message: \"Unexpected '{{matchedTerm}}' comment.\",\n                    data: {\n                        matchedTerm\n                    }\n                });\n            });\n        }\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments.filter(token => token.type !== \"Shebang\").forEach(checkComment);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow whitespace before properties\n * @author Kai Cataldo\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"disallow whitespace before properties\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-whitespace-before-property\"\n        },\n\n        fixable: \"whitespace\",\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports whitespace before property token\n         * @param {ASTNode} node - the node to report in the event of an error\n         * @param {Token} leftToken - the left token\n         * @param {Token} rightToken - the right token\n         * @returns {void}\n         * @private\n         */\n        function reportError(node, leftToken, rightToken) {\n            const replacementText = node.computed ? \"\" : \".\";\n\n            context.report({\n                node,\n                message: \"Unexpected whitespace before property {{propName}}.\",\n                data: {\n                    propName: sourceCode.getText(node.property)\n                },\n                fix(fixer) {\n                    if (!node.computed && astUtils.isDecimalInteger(node.object)) {\n\n                        /*\n                         * If the object is a number literal, fixing it to something like 5.toString() would cause a SyntaxError.\n                         * Don't fix this case.\n                         */\n                        return null;\n                    }\n                    return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], replacementText);\n                }\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            MemberExpression(node) {\n                let rightToken;\n                let leftToken;\n\n                if (!astUtils.isTokenOnSameLine(node.object, node.property)) {\n                    return;\n                }\n\n                if (node.computed) {\n                    rightToken = sourceCode.getTokenBefore(node.property, astUtils.isOpeningBracketToken);\n                    leftToken = sourceCode.getTokenBefore(rightToken);\n                } else {\n                    rightToken = sourceCode.getFirstToken(node.property);\n                    leftToken = sourceCode.getTokenBefore(rightToken, 1);\n                }\n\n                if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken)) {\n                    reportError(node, leftToken, rightToken);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag use of with statement\n * @author Nicholas C. Zakas\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `with` statements\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-with\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n            WithStatement(node) {\n                context.report({ node, message: \"Unexpected use of 'with' statement.\" });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview enforce the location of single-line statements\n * @author Teddy Katz\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst POSITION_SCHEMA = { enum: [\"beside\", \"below\", \"any\"] };\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce the location of single-line statements\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/nonblock-statement-body-position\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            POSITION_SCHEMA,\n            {\n                properties: {\n                    overrides: {\n                        properties: {\n                            if: POSITION_SCHEMA,\n                            else: POSITION_SCHEMA,\n                            while: POSITION_SCHEMA,\n                            do: POSITION_SCHEMA,\n                            for: POSITION_SCHEMA\n                        },\n                        additionalProperties: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Gets the applicable preference for a particular keyword\n         * @param {string} keywordName The name of a keyword, e.g. 'if'\n         * @returns {string} The applicable option for the keyword, e.g. 'beside'\n         */\n        function getOption(keywordName) {\n            return context.options[1] && context.options[1].overrides && context.options[1].overrides[keywordName] ||\n                context.options[0] ||\n                \"beside\";\n        }\n\n        /**\n         * Validates the location of a single-line statement\n         * @param {ASTNode} node The single-line statement\n         * @param {string} keywordName The applicable keyword name for the single-line statement\n         * @returns {void}\n         */\n        function validateStatement(node, keywordName) {\n            const option = getOption(keywordName);\n\n            if (node.type === \"BlockStatement\" || option === \"any\") {\n                return;\n            }\n\n            const tokenBefore = sourceCode.getTokenBefore(node);\n\n            if (tokenBefore.loc.end.line === node.loc.start.line && option === \"below\") {\n                context.report({\n                    node,\n                    message: \"Expected a linebreak before this statement.\",\n                    fix: fixer => fixer.insertTextBefore(node, \"\\n\")\n                });\n            } else if (tokenBefore.loc.end.line !== node.loc.start.line && option === \"beside\") {\n                context.report({\n                    node,\n                    message: \"Expected no linebreak before this statement.\",\n                    fix(fixer) {\n                        if (sourceCode.getText().slice(tokenBefore.range[1], node.range[0]).trim()) {\n                            return null;\n                        }\n                        return fixer.replaceTextRange([tokenBefore.range[1], node.range[0]], \" \");\n                    }\n                });\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            IfStatement(node) {\n                validateStatement(node.consequent, \"if\");\n\n                // Check the `else` node, but don't check 'else if' statements.\n                if (node.alternate && node.alternate.type !== \"IfStatement\") {\n                    validateStatement(node.alternate, \"else\");\n                }\n            },\n            WhileStatement: node => validateStatement(node.body, \"while\"),\n            DoWhileStatement: node => validateStatement(node.body, \"do\"),\n            ForStatement: node => validateStatement(node.body, \"for\"),\n            ForInStatement: node => validateStatement(node.body, \"for\"),\n            ForOfStatement: node => validateStatement(node.body, \"for\")\n        };\n    }\n};\n","/**\n * @fileoverview Rule to require or disallow line breaks inside braces.\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n// Schema objects.\nconst OPTION_VALUE = {\n    oneOf: [\n        {\n            enum: [\"always\", \"never\"]\n        },\n        {\n            type: \"object\",\n            properties: {\n                multiline: {\n                    type: \"boolean\"\n                },\n                minProperties: {\n                    type: \"integer\",\n                    minimum: 0\n                },\n                consistent: {\n                    type: \"boolean\"\n                }\n            },\n            additionalProperties: false,\n            minProperties: 1\n        }\n    ]\n};\n\n/**\n * Normalizes a given option value.\n *\n * @param {string|Object|undefined} value - An option value to parse.\n * @returns {{multiline: boolean, minProperties: number, consistent: boolean}} Normalized option object.\n */\nfunction normalizeOptionValue(value) {\n    let multiline = false;\n    let minProperties = Number.POSITIVE_INFINITY;\n    let consistent = false;\n\n    if (value) {\n        if (value === \"always\") {\n            minProperties = 0;\n        } else if (value === \"never\") {\n            minProperties = Number.POSITIVE_INFINITY;\n        } else {\n            multiline = Boolean(value.multiline);\n            minProperties = value.minProperties || Number.POSITIVE_INFINITY;\n            consistent = Boolean(value.consistent);\n        }\n    } else {\n        consistent = true;\n    }\n\n    return { multiline, minProperties, consistent };\n}\n\n/**\n * Normalizes a given option value.\n *\n * @param {string|Object|undefined} options - An option value to parse.\n * @returns {{\n *   ObjectExpression: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ObjectPattern: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ImportDeclaration: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ExportNamedDeclaration : {multiline: boolean, minProperties: number, consistent: boolean}\n * }} Normalized option object.\n */\nfunction normalizeOptions(options) {\n    const isNodeSpecificOption = lodash.overSome([lodash.isPlainObject, lodash.isString]);\n\n    if (lodash.isPlainObject(options) && lodash.some(options, isNodeSpecificOption)) {\n        return {\n            ObjectExpression: normalizeOptionValue(options.ObjectExpression),\n            ObjectPattern: normalizeOptionValue(options.ObjectPattern),\n            ImportDeclaration: normalizeOptionValue(options.ImportDeclaration),\n            ExportNamedDeclaration: normalizeOptionValue(options.ExportDeclaration)\n        };\n    }\n\n    const value = normalizeOptionValue(options);\n\n    return { ObjectExpression: value, ObjectPattern: value, ImportDeclaration: value, ExportNamedDeclaration: value };\n}\n\n/**\n * Determines if ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration\n * node needs to be checked for missing line breaks\n *\n * @param {ASTNode} node - Node under inspection\n * @param {Object} options - option specific to node type\n * @param {Token} first - First object property\n * @param {Token} last - Last object property\n * @returns {boolean} `true` if node needs to be checked for missing line breaks\n */\nfunction areLineBreaksRequired(node, options, first, last) {\n    let objectProperties;\n\n    if (node.type === \"ObjectExpression\" || node.type === \"ObjectPattern\") {\n        objectProperties = node.properties;\n    } else {\n\n        // is ImportDeclaration or ExportNamedDeclaration\n        objectProperties = node.specifiers\n            .filter(s => s.type === \"ImportSpecifier\" || s.type === \"ExportSpecifier\");\n    }\n\n    return objectProperties.length >= options.minProperties ||\n        (\n            options.multiline &&\n            objectProperties.length > 0 &&\n            first.loc.start.line !== last.loc.end.line\n        );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent line breaks inside braces\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/object-curly-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    OPTION_VALUE,\n                    {\n                        type: \"object\",\n                        properties: {\n                            ObjectExpression: OPTION_VALUE,\n                            ObjectPattern: OPTION_VALUE,\n                            ImportDeclaration: OPTION_VALUE,\n                            ExportDeclaration: OPTION_VALUE\n                        },\n                        additionalProperties: false,\n                        minProperties: 1\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const normalizedOptions = normalizeOptions(context.options[0]);\n\n        /**\n         * Reports a given node if it violated this rule.\n         * @param {ASTNode} node - A node to check. This is an ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration node.\n         * @returns {void}\n         */\n        function check(node) {\n            const options = normalizedOptions[node.type];\n\n            if (\n                (node.type === \"ImportDeclaration\" &&\n                    !node.specifiers.some(specifier => specifier.type === \"ImportSpecifier\")) ||\n                (node.type === \"ExportNamedDeclaration\" &&\n                    !node.specifiers.some(specifier => specifier.type === \"ExportSpecifier\"))\n            ) {\n                return;\n            }\n\n            const openBrace = sourceCode.getFirstToken(node, token => token.value === \"{\");\n\n            let closeBrace;\n\n            if (node.typeAnnotation) {\n                closeBrace = sourceCode.getTokenBefore(node.typeAnnotation);\n            } else {\n                closeBrace = sourceCode.getLastToken(node, token => token.value === \"}\");\n            }\n\n            let first = sourceCode.getTokenAfter(openBrace, { includeComments: true });\n            let last = sourceCode.getTokenBefore(closeBrace, { includeComments: true });\n\n            const needsLineBreaks = areLineBreaksRequired(node, options, first, last);\n\n            const hasCommentsFirstToken = astUtils.isCommentToken(first);\n            const hasCommentsLastToken = astUtils.isCommentToken(last);\n\n            /*\n             * Use tokens or comments to check multiline or not.\n             * But use only tokens to check whether line breaks are needed.\n             * This allows:\n             *     var obj = { // eslint-disable-line foo\n             *         a: 1\n             *     }\n             */\n            first = sourceCode.getTokenAfter(openBrace);\n            last = sourceCode.getTokenBefore(closeBrace);\n\n            if (needsLineBreaks) {\n                if (astUtils.isTokenOnSameLine(openBrace, first)) {\n                    context.report({\n                        message: \"Expected a line break after this opening brace.\",\n                        node,\n                        loc: openBrace.loc.start,\n                        fix(fixer) {\n                            if (hasCommentsFirstToken) {\n                                return null;\n                            }\n\n                            return fixer.insertTextAfter(openBrace, \"\\n\");\n                        }\n                    });\n                }\n                if (astUtils.isTokenOnSameLine(last, closeBrace)) {\n                    context.report({\n                        message: \"Expected a line break before this closing brace.\",\n                        node,\n                        loc: closeBrace.loc.start,\n                        fix(fixer) {\n                            if (hasCommentsLastToken) {\n                                return null;\n                            }\n\n                            return fixer.insertTextBefore(closeBrace, \"\\n\");\n                        }\n                    });\n                }\n            } else {\n                const consistent = options.consistent;\n                const hasLineBreakBetweenOpenBraceAndFirst = !astUtils.isTokenOnSameLine(openBrace, first);\n                const hasLineBreakBetweenCloseBraceAndLast = !astUtils.isTokenOnSameLine(last, closeBrace);\n\n                if (\n                    (!consistent && hasLineBreakBetweenOpenBraceAndFirst) ||\n                    (consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast)\n                ) {\n                    context.report({\n                        message: \"Unexpected line break after this opening brace.\",\n                        node,\n                        loc: openBrace.loc.start,\n                        fix(fixer) {\n                            if (hasCommentsFirstToken) {\n                                return null;\n                            }\n\n                            return fixer.removeRange([\n                                openBrace.range[1],\n                                first.range[0]\n                            ]);\n                        }\n                    });\n                }\n                if (\n                    (!consistent && hasLineBreakBetweenCloseBraceAndLast) ||\n                    (consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast)\n                ) {\n                    context.report({\n                        message: \"Unexpected line break before this closing brace.\",\n                        node,\n                        loc: closeBrace.loc.start,\n                        fix(fixer) {\n                            if (hasCommentsLastToken) {\n                                return null;\n                            }\n\n                            return fixer.removeRange([\n                                last.range[1],\n                                closeBrace.range[0]\n                            ]);\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            ObjectExpression: check,\n            ObjectPattern: check,\n            ImportDeclaration: check,\n            ExportNamedDeclaration: check\n        };\n    }\n};\n","/**\n * @fileoverview Disallows or enforces spaces inside of object literals.\n * @author Jamund Ferguson\n */\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing inside braces\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/object-curly-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    arraysInObjects: {\n                        type: \"boolean\"\n                    },\n                    objectsInObjects: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const spaced = context.options[0] === \"always\",\n            sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether an option is set, relative to the spacing option.\n         * If spaced is \"always\", then check whether option is set to false.\n         * If spaced is \"never\", then check whether option is set to true.\n         * @param {Object} option - The option to exclude.\n         * @returns {boolean} Whether or not the property is excluded.\n         */\n        function isOptionSet(option) {\n            return context.options[1] ? context.options[1][option] === !spaced : false;\n        }\n\n        const options = {\n            spaced,\n            arraysInObjectsException: isOptionSet(\"arraysInObjects\"),\n            objectsInObjectsException: isOptionSet(\"objectsInObjects\")\n        };\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports that there shouldn't be a space after the first token\n         * @param {ASTNode} node - The node to report in the event of an error.\n         * @param {Token} token - The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoBeginningSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"There should be no space after '{{token}}'.\",\n                data: {\n                    token: token.value\n                },\n                fix(fixer) {\n                    const nextToken = context.getSourceCode().getTokenAfter(token);\n\n                    return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there shouldn't be a space before the last token\n         * @param {ASTNode} node - The node to report in the event of an error.\n         * @param {Token} token - The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoEndingSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"There should be no space before '{{token}}'.\",\n                data: {\n                    token: token.value\n                },\n                fix(fixer) {\n                    const previousToken = context.getSourceCode().getTokenBefore(token);\n\n                    return fixer.removeRange([previousToken.range[1], token.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a space after the first token\n         * @param {ASTNode} node - The node to report in the event of an error.\n         * @param {Token} token - The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredBeginningSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"A space is required after '{{token}}'.\",\n                data: {\n                    token: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextAfter(token, \" \");\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a space before the last token\n         * @param {ASTNode} node - The node to report in the event of an error.\n         * @param {Token} token - The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredEndingSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"A space is required before '{{token}}'.\",\n                data: {\n                    token: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextBefore(token, \" \");\n                }\n            });\n        }\n\n        /**\n         * Determines if spacing in curly braces is valid.\n         * @param {ASTNode} node The AST node to check.\n         * @param {Token} first The first token to check (should be the opening brace)\n         * @param {Token} second The second token to check (should be first after the opening brace)\n         * @param {Token} penultimate The penultimate token to check (should be last before closing brace)\n         * @param {Token} last The last token to check (should be closing brace)\n         * @returns {void}\n         */\n        function validateBraceSpacing(node, first, second, penultimate, last) {\n            if (astUtils.isTokenOnSameLine(first, second)) {\n                const firstSpaced = sourceCode.isSpaceBetweenTokens(first, second);\n\n                if (options.spaced && !firstSpaced) {\n                    reportRequiredBeginningSpace(node, first);\n                }\n                if (!options.spaced && firstSpaced) {\n                    reportNoBeginningSpace(node, first);\n                }\n            }\n\n            if (astUtils.isTokenOnSameLine(penultimate, last)) {\n                const shouldCheckPenultimate = (\n                    options.arraysInObjectsException && astUtils.isClosingBracketToken(penultimate) ||\n                    options.objectsInObjectsException && astUtils.isClosingBraceToken(penultimate)\n                );\n                const penultimateType = shouldCheckPenultimate && sourceCode.getNodeByRangeIndex(penultimate.range[0]).type;\n\n                const closingCurlyBraceMustBeSpaced = (\n                    options.arraysInObjectsException && penultimateType === \"ArrayExpression\" ||\n                    options.objectsInObjectsException && (penultimateType === \"ObjectExpression\" || penultimateType === \"ObjectPattern\")\n                ) ? !options.spaced : options.spaced;\n\n                const lastSpaced = sourceCode.isSpaceBetweenTokens(penultimate, last);\n\n                if (closingCurlyBraceMustBeSpaced && !lastSpaced) {\n                    reportRequiredEndingSpace(node, last);\n                }\n                if (!closingCurlyBraceMustBeSpaced && lastSpaced) {\n                    reportNoEndingSpace(node, last);\n                }\n            }\n        }\n\n        /**\n         * Gets '}' token of an object node.\n         *\n         * Because the last token of object patterns might be a type annotation,\n         * this traverses tokens preceded by the last property, then returns the\n         * first '}' token.\n         *\n         * @param {ASTNode} node - The node to get. This node is an\n         *      ObjectExpression or an ObjectPattern. And this node has one or\n         *      more properties.\n         * @returns {Token} '}' token.\n         */\n        function getClosingBraceOfObject(node) {\n            const lastProperty = node.properties[node.properties.length - 1];\n\n            return sourceCode.getTokenAfter(lastProperty, astUtils.isClosingBraceToken);\n        }\n\n        /**\n         * Reports a given object node if spacing in curly braces is invalid.\n         * @param {ASTNode} node - An ObjectExpression or ObjectPattern node to check.\n         * @returns {void}\n         */\n        function checkForObject(node) {\n            if (node.properties.length === 0) {\n                return;\n            }\n\n            const first = sourceCode.getFirstToken(node),\n                last = getClosingBraceOfObject(node),\n                second = sourceCode.getTokenAfter(first),\n                penultimate = sourceCode.getTokenBefore(last);\n\n            validateBraceSpacing(node, first, second, penultimate, last);\n        }\n\n        /**\n         * Reports a given import node if spacing in curly braces is invalid.\n         * @param {ASTNode} node - An ImportDeclaration node to check.\n         * @returns {void}\n         */\n        function checkForImport(node) {\n            if (node.specifiers.length === 0) {\n                return;\n            }\n\n            let firstSpecifier = node.specifiers[0];\n            const lastSpecifier = node.specifiers[node.specifiers.length - 1];\n\n            if (lastSpecifier.type !== \"ImportSpecifier\") {\n                return;\n            }\n            if (firstSpecifier.type !== \"ImportSpecifier\") {\n                firstSpecifier = node.specifiers[1];\n            }\n\n            const first = sourceCode.getTokenBefore(firstSpecifier),\n                last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken),\n                second = sourceCode.getTokenAfter(first),\n                penultimate = sourceCode.getTokenBefore(last);\n\n            validateBraceSpacing(node, first, second, penultimate, last);\n        }\n\n        /**\n         * Reports a given export node if spacing in curly braces is invalid.\n         * @param {ASTNode} node - An ExportNamedDeclaration node to check.\n         * @returns {void}\n         */\n        function checkForExport(node) {\n            if (node.specifiers.length === 0) {\n                return;\n            }\n\n            const firstSpecifier = node.specifiers[0],\n                lastSpecifier = node.specifiers[node.specifiers.length - 1],\n                first = sourceCode.getTokenBefore(firstSpecifier),\n                last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken),\n                second = sourceCode.getTokenAfter(first),\n                penultimate = sourceCode.getTokenBefore(last);\n\n            validateBraceSpacing(node, first, second, penultimate, last);\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            // var {x} = y;\n            ObjectPattern: checkForObject,\n\n            // var y = {x: 'y'}\n            ObjectExpression: checkForObject,\n\n            // import {y} from 'x';\n            ImportDeclaration: checkForImport,\n\n            // export {name} from 'yo';\n            ExportNamedDeclaration: checkForExport\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to enforce placing object properties on separate lines.\n * @author Vitor Balocco\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce placing object properties on separate lines\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/object-property-newline\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowAllPropertiesOnSameLine: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowMultiplePropertiesPerLine: { // Deprecated\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"whitespace\"\n    },\n\n    create(context) {\n        const allowSameLine = context.options[0] && (\n            (context.options[0].allowAllPropertiesOnSameLine || context.options[0].allowMultiplePropertiesPerLine /* Deprecated */)\n        );\n        const errorMessage = allowSameLine\n            ? \"Object properties must go on a new line if they aren't all on the same line.\"\n            : \"Object properties must go on a new line.\";\n\n        const sourceCode = context.getSourceCode();\n\n        return {\n            ObjectExpression(node) {\n                if (allowSameLine) {\n                    if (node.properties.length > 1) {\n                        const firstTokenOfFirstProperty = sourceCode.getFirstToken(node.properties[0]);\n                        const lastTokenOfLastProperty = sourceCode.getLastToken(node.properties[node.properties.length - 1]);\n\n                        if (firstTokenOfFirstProperty.loc.end.line === lastTokenOfLastProperty.loc.start.line) {\n\n                            // All keys and values are on the same line\n                            return;\n                        }\n                    }\n                }\n\n                for (let i = 1; i < node.properties.length; i++) {\n                    const lastTokenOfPreviousProperty = sourceCode.getLastToken(node.properties[i - 1]);\n                    const firstTokenOfCurrentProperty = sourceCode.getFirstToken(node.properties[i]);\n\n                    if (lastTokenOfPreviousProperty.loc.end.line === firstTokenOfCurrentProperty.loc.start.line) {\n                        context.report({\n                            node,\n                            loc: firstTokenOfCurrentProperty.loc.start,\n                            message: errorMessage,\n                            fix(fixer) {\n                                const comma = sourceCode.getTokenBefore(firstTokenOfCurrentProperty);\n                                const rangeAfterComma = [comma.range[1], firstTokenOfCurrentProperty.range[0]];\n\n                                // Don't perform a fix if there are any comments between the comma and the next property.\n                                if (sourceCode.text.slice(rangeAfterComma[0], rangeAfterComma[1]).trim()) {\n                                    return null;\n                                }\n\n                                return fixer.replaceTextRange(rangeAfterComma, \"\\n\");\n                            }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce concise object methods and properties.\n * @author Jamund Ferguson\n */\n\n\n\nconst OPTIONS = {\n    always: \"always\",\n    never: \"never\",\n    methods: \"methods\",\n    properties: \"properties\",\n    consistent: \"consistent\",\n    consistentAsNeeded: \"consistent-as-needed\"\n};\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require or disallow method and property shorthand syntax for object literals\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/object-shorthand\"\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"methods\", \"properties\", \"never\", \"consistent\", \"consistent-as-needed\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"methods\", \"properties\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                avoidQuotes: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"methods\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                ignoreConstructors: {\n                                    type: \"boolean\"\n                                },\n                                avoidQuotes: {\n                                    type: \"boolean\"\n                                },\n                                avoidExplicitReturnArrows: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        }\n    },\n\n    create(context) {\n        const APPLY = context.options[0] || OPTIONS.always;\n        const APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;\n        const APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;\n        const APPLY_NEVER = APPLY === OPTIONS.never;\n        const APPLY_CONSISTENT = APPLY === OPTIONS.consistent;\n        const APPLY_CONSISTENT_AS_NEEDED = APPLY === OPTIONS.consistentAsNeeded;\n\n        const PARAMS = context.options[1] || {};\n        const IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;\n        const AVOID_QUOTES = PARAMS.avoidQuotes;\n        const AVOID_EXPLICIT_RETURN_ARROWS = !!PARAMS.avoidExplicitReturnArrows;\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Determines if the first character of the name is a capital letter.\n         * @param {string} name The name of the node to evaluate.\n         * @returns {boolean} True if the first character of the property name is a capital letter, false if not.\n         * @private\n         */\n        function isConstructor(name) {\n            const firstChar = name.charAt(0);\n\n            return firstChar === firstChar.toUpperCase();\n        }\n\n        /**\n         * Determines if the property can have a shorthand form.\n         * @param {ASTNode} property Property AST node\n         * @returns {boolean} True if the property can have a shorthand form\n         * @private\n         *\n         */\n        function canHaveShorthand(property) {\n            return (property.kind !== \"set\" && property.kind !== \"get\" && property.type !== \"SpreadElement\" && property.type !== \"SpreadProperty\" && property.type !== \"ExperimentalSpreadProperty\");\n        }\n\n        /**\n         * Checks whether a node is a string literal.\n         * @param   {ASTNode} node - Any AST node.\n         * @returns {boolean} `true` if it is a string literal.\n         */\n        function isStringLiteral(node) {\n            return node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Determines if the property is a shorthand or not.\n         * @param {ASTNode} property Property AST node\n         * @returns {boolean} True if the property is considered shorthand, false if not.\n         * @private\n         *\n         */\n        function isShorthand(property) {\n\n            // property.method is true when `{a(){}}`.\n            return (property.shorthand || property.method);\n        }\n\n        /**\n         * Determines if the property's key and method or value are named equally.\n         * @param {ASTNode} property Property AST node\n         * @returns {boolean} True if the key and value are named equally, false if not.\n         * @private\n         *\n         */\n        function isRedundant(property) {\n            const value = property.value;\n\n            if (value.type === \"FunctionExpression\") {\n                return !value.id; // Only anonymous should be shorthand method.\n            }\n            if (value.type === \"Identifier\") {\n                return astUtils.getStaticPropertyName(property) === value.name;\n            }\n\n            return false;\n        }\n\n        /**\n         * Ensures that an object's properties are consistently shorthand, or not shorthand at all.\n         * @param   {ASTNode} node Property AST node\n         * @param   {boolean} checkRedundancy Whether to check longform redundancy\n         * @returns {void}\n         *\n         */\n        function checkConsistency(node, checkRedundancy) {\n\n            // We are excluding getters/setters and spread properties as they are considered neither longform nor shorthand.\n            const properties = node.properties.filter(canHaveShorthand);\n\n            // Do we still have properties left after filtering the getters and setters?\n            if (properties.length > 0) {\n                const shorthandProperties = properties.filter(isShorthand);\n\n                /*\n                 * If we do not have an equal number of longform properties as\n                 * shorthand properties, we are using the annotations inconsistently\n                 */\n                if (shorthandProperties.length !== properties.length) {\n\n                    // We have at least 1 shorthand property\n                    if (shorthandProperties.length > 0) {\n                        context.report({ node, message: \"Unexpected mix of shorthand and non-shorthand properties.\" });\n                    } else if (checkRedundancy) {\n\n                        /*\n                         * If all properties of the object contain a method or value with a name matching it's key,\n                         * all the keys are redundant.\n                         */\n                        const canAlwaysUseShorthand = properties.every(isRedundant);\n\n                        if (canAlwaysUseShorthand) {\n                            context.report({ node, message: \"Expected shorthand for all properties.\" });\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Fixes a FunctionExpression node by making it into a shorthand property.\n         * @param {SourceCodeFixer} fixer The fixer object\n         * @param {ASTNode} node A `Property` node that has a `FunctionExpression` or `ArrowFunctionExpression` as its value\n         * @returns {Object} A fix for this node\n         */\n        function makeFunctionShorthand(fixer, node) {\n            const firstKeyToken = node.computed\n                ? sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken)\n                : sourceCode.getFirstToken(node.key);\n            const lastKeyToken = node.computed\n                ? sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken)\n                : sourceCode.getLastToken(node.key);\n            const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\n            let keyPrefix = \"\";\n\n            if (sourceCode.commentsExistBetween(lastKeyToken, node.value)) {\n                return null;\n            }\n\n            if (node.value.async) {\n                keyPrefix += \"async \";\n            }\n            if (node.value.generator) {\n                keyPrefix += \"*\";\n            }\n\n            if (node.value.type === \"FunctionExpression\") {\n                const functionToken = sourceCode.getTokens(node.value).find(token => token.type === \"Keyword\" && token.value === \"function\");\n                const tokenBeforeParams = node.value.generator ? sourceCode.getTokenAfter(functionToken) : functionToken;\n\n                return fixer.replaceTextRange(\n                    [firstKeyToken.range[0], node.range[1]],\n                    keyPrefix + keyText + sourceCode.text.slice(tokenBeforeParams.range[1], node.value.range[1])\n                );\n            }\n            const arrowToken = sourceCode.getTokenBefore(node.value.body, { filter: token => token.value === \"=>\" });\n            const tokenBeforeArrow = sourceCode.getTokenBefore(arrowToken);\n            const hasParensAroundParameters = tokenBeforeArrow.type === \"Punctuator\" && tokenBeforeArrow.value === \")\";\n            const oldParamText = sourceCode.text.slice(sourceCode.getFirstToken(node.value, node.value.async ? 1 : 0).range[0], tokenBeforeArrow.range[1]);\n            const newParamText = hasParensAroundParameters ? oldParamText : `(${oldParamText})`;\n\n            return fixer.replaceTextRange(\n                [firstKeyToken.range[0], node.range[1]],\n                keyPrefix + keyText + newParamText + sourceCode.text.slice(arrowToken.range[1], node.value.range[1])\n            );\n\n        }\n\n        /**\n         * Fixes a FunctionExpression node by making it into a longform property.\n         * @param {SourceCodeFixer} fixer The fixer object\n         * @param {ASTNode} node A `Property` node that has a `FunctionExpression` as its value\n         * @returns {Object} A fix for this node\n         */\n        function makeFunctionLongform(fixer, node) {\n            const firstKeyToken = node.computed ? sourceCode.getTokens(node).find(token => token.value === \"[\") : sourceCode.getFirstToken(node.key);\n            const lastKeyToken = node.computed ? sourceCode.getTokensBetween(node.key, node.value).find(token => token.value === \"]\") : sourceCode.getLastToken(node.key);\n            const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\n            let functionHeader = \"function\";\n\n            if (node.value.async) {\n                functionHeader = `async ${functionHeader}`;\n            }\n            if (node.value.generator) {\n                functionHeader = `${functionHeader}*`;\n            }\n\n            return fixer.replaceTextRange([node.range[0], lastKeyToken.range[1]], `${keyText}: ${functionHeader}`);\n        }\n\n        /*\n         * To determine whether a given arrow function has a lexical identifier (`this`, `arguments`, `super`, or `new.target`),\n         * create a stack of functions that define these identifiers (i.e. all functions except arrow functions) as the AST is\n         * traversed. Whenever a new function is encountered, create a new entry on the stack (corresponding to a different lexical\n         * scope of `this`), and whenever a function is exited, pop that entry off the stack. When an arrow function is entered,\n         * keep a reference to it on the current stack entry, and remove that reference when the arrow function is exited.\n         * When a lexical identifier is encountered, mark all the arrow functions on the current stack entry by adding them\n         * to an `arrowsWithLexicalIdentifiers` set. Any arrow function in that set will not be reported by this rule,\n         * because converting it into a method would change the value of one of the lexical identifiers.\n         */\n        const lexicalScopeStack = [];\n        const arrowsWithLexicalIdentifiers = new WeakSet();\n        const argumentsIdentifiers = new WeakSet();\n\n        /**\n         * Enters a function. This creates a new lexical identifier scope, so a new Set of arrow functions is pushed onto the stack.\n         * Also, this marks all `arguments` identifiers so that they can be detected later.\n         * @returns {void}\n         */\n        function enterFunction() {\n            lexicalScopeStack.unshift(new Set());\n            context.getScope().variables.filter(variable => variable.name === \"arguments\").forEach(variable => {\n                variable.references.map(ref => ref.identifier).forEach(identifier => argumentsIdentifiers.add(identifier));\n            });\n        }\n\n        /**\n         * Exits a function. This pops the current set of arrow functions off the lexical scope stack.\n         * @returns {void}\n         */\n        function exitFunction() {\n            lexicalScopeStack.shift();\n        }\n\n        /**\n         * Marks the current function as having a lexical keyword. This implies that all arrow functions\n         * in the current lexical scope contain a reference to this lexical keyword.\n         * @returns {void}\n         */\n        function reportLexicalIdentifier() {\n            lexicalScopeStack[0].forEach(arrowFunction => arrowsWithLexicalIdentifiers.add(arrowFunction));\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: enterFunction,\n            FunctionDeclaration: enterFunction,\n            FunctionExpression: enterFunction,\n            \"Program:exit\": exitFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            \"FunctionExpression:exit\": exitFunction,\n\n            ArrowFunctionExpression(node) {\n                lexicalScopeStack[0].add(node);\n            },\n            \"ArrowFunctionExpression:exit\"(node) {\n                lexicalScopeStack[0].delete(node);\n            },\n\n            ThisExpression: reportLexicalIdentifier,\n            Super: reportLexicalIdentifier,\n            MetaProperty(node) {\n                if (node.meta.name === \"new\" && node.property.name === \"target\") {\n                    reportLexicalIdentifier();\n                }\n            },\n            Identifier(node) {\n                if (argumentsIdentifiers.has(node)) {\n                    reportLexicalIdentifier();\n                }\n            },\n\n            ObjectExpression(node) {\n                if (APPLY_CONSISTENT) {\n                    checkConsistency(node, false);\n                } else if (APPLY_CONSISTENT_AS_NEEDED) {\n                    checkConsistency(node, true);\n                }\n            },\n\n            \"Property:exit\"(node) {\n                const isConciseProperty = node.method || node.shorthand;\n\n                // Ignore destructuring assignment\n                if (node.parent.type === \"ObjectPattern\") {\n                    return;\n                }\n\n                // getters and setters are ignored\n                if (node.kind === \"get\" || node.kind === \"set\") {\n                    return;\n                }\n\n                // only computed methods can fail the following checks\n                if (node.computed && node.value.type !== \"FunctionExpression\" && node.value.type !== \"ArrowFunctionExpression\") {\n                    return;\n                }\n\n                //--------------------------------------------------------------\n                // Checks for property/method shorthand.\n                if (isConciseProperty) {\n                    if (node.method && (APPLY_NEVER || AVOID_QUOTES && isStringLiteral(node.key))) {\n                        const message = APPLY_NEVER ? \"Expected longform method syntax.\" : \"Expected longform method syntax for string literal keys.\";\n\n                        // { x() {} } should be written as { x: function() {} }\n                        context.report({\n                            node,\n                            message,\n                            fix: fixer => makeFunctionLongform(fixer, node)\n                        });\n                    } else if (APPLY_NEVER) {\n\n                        // { x } should be written as { x: x }\n                        context.report({\n                            node,\n                            message: \"Expected longform property syntax.\",\n                            fix: fixer => fixer.insertTextAfter(node.key, `: ${node.key.name}`)\n                        });\n                    }\n                } else if (APPLY_TO_METHODS && !node.value.id && (node.value.type === \"FunctionExpression\" || node.value.type === \"ArrowFunctionExpression\")) {\n                    if (IGNORE_CONSTRUCTORS && node.key.type === \"Identifier\" && isConstructor(node.key.name)) {\n                        return;\n                    }\n                    if (AVOID_QUOTES && isStringLiteral(node.key)) {\n                        return;\n                    }\n\n                    // {[x]: function(){}} should be written as {[x]() {}}\n                    if (node.value.type === \"FunctionExpression\" ||\n                        node.value.type === \"ArrowFunctionExpression\" &&\n                        node.value.body.type === \"BlockStatement\" &&\n                        AVOID_EXPLICIT_RETURN_ARROWS &&\n                        !arrowsWithLexicalIdentifiers.has(node.value)\n                    ) {\n                        context.report({\n                            node,\n                            message: \"Expected method shorthand.\",\n                            fix: fixer => makeFunctionShorthand(fixer, node)\n                        });\n                    }\n                } else if (node.value.type === \"Identifier\" && node.key.name === node.value.name && APPLY_TO_PROPS) {\n\n                    // {x: x} should be written as {x}\n                    context.report({\n                        node,\n                        message: \"Expected property shorthand.\",\n                        fix(fixer) {\n                            return fixer.replaceText(node, node.value.name);\n                        }\n                    });\n                } else if (node.value.type === \"Identifier\" && node.key.type === \"Literal\" && node.key.value === node.value.name && APPLY_TO_PROPS) {\n                    if (AVOID_QUOTES) {\n                        return;\n                    }\n\n                    // {\"x\": x} should be written as {x}\n                    context.report({\n                        node,\n                        message: \"Expected property shorthand.\",\n                        fix(fixer) {\n                            return fixer.replaceText(node, node.value.name);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A rule to control the use of single variable declarations.\n * @author Ian Christian Myers\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce variables to be declared either together or separately in functions\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/one-var\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\", \"consecutive\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            separateRequires: {\n                                type: \"boolean\",\n                                default: false\n                            },\n                            var: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            },\n                            let: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            },\n                            const: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            initialized: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            },\n                            uninitialized: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const MODE_ALWAYS = \"always\";\n        const MODE_NEVER = \"never\";\n        const MODE_CONSECUTIVE = \"consecutive\";\n        const mode = context.options[0] || MODE_ALWAYS;\n\n        const options = {};\n\n        if (typeof mode === \"string\") { // simple options configuration with just a string\n            options.var = { uninitialized: mode, initialized: mode };\n            options.let = { uninitialized: mode, initialized: mode };\n            options.const = { uninitialized: mode, initialized: mode };\n        } else if (typeof mode === \"object\") { // options configuration is an object\n            options.separateRequires = mode.separateRequires;\n            options.var = { uninitialized: mode.var, initialized: mode.var };\n            options.let = { uninitialized: mode.let, initialized: mode.let };\n            options.const = { uninitialized: mode.const, initialized: mode.const };\n            if (Object.prototype.hasOwnProperty.call(mode, \"uninitialized\")) {\n                options.var.uninitialized = mode.uninitialized;\n                options.let.uninitialized = mode.uninitialized;\n                options.const.uninitialized = mode.uninitialized;\n            }\n            if (Object.prototype.hasOwnProperty.call(mode, \"initialized\")) {\n                options.var.initialized = mode.initialized;\n                options.let.initialized = mode.initialized;\n                options.const.initialized = mode.initialized;\n            }\n        }\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const functionStack = [];\n        const blockStack = [];\n\n        /**\n         * Increments the blockStack counter.\n         * @returns {void}\n         * @private\n         */\n        function startBlock() {\n            blockStack.push({\n                let: { initialized: false, uninitialized: false },\n                const: { initialized: false, uninitialized: false }\n            });\n        }\n\n        /**\n         * Increments the functionStack counter.\n         * @returns {void}\n         * @private\n         */\n        function startFunction() {\n            functionStack.push({ initialized: false, uninitialized: false });\n            startBlock();\n        }\n\n        /**\n         * Decrements the blockStack counter.\n         * @returns {void}\n         * @private\n         */\n        function endBlock() {\n            blockStack.pop();\n        }\n\n        /**\n         * Decrements the functionStack counter.\n         * @returns {void}\n         * @private\n         */\n        function endFunction() {\n            functionStack.pop();\n            endBlock();\n        }\n\n        /**\n         * Check if a variable declaration is a require.\n         * @param {ASTNode} decl variable declaration Node\n         * @returns {bool} if decl is a require, return true; else return false.\n         * @private\n         */\n        function isRequire(decl) {\n            return decl.init && decl.init.type === \"CallExpression\" && decl.init.callee.name === \"require\";\n        }\n\n        /**\n         * Records whether initialized/uninitialized/required variables are defined in current scope.\n         * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @param {ASTNode[]} declarations List of declarations\n         * @param {Object} currentScope The scope being investigated\n         * @returns {void}\n         * @private\n         */\n        function recordTypes(statementType, declarations, currentScope) {\n            for (let i = 0; i < declarations.length; i++) {\n                if (declarations[i].init === null) {\n                    if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {\n                        currentScope.uninitialized = true;\n                    }\n                } else {\n                    if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {\n                        if (options.separateRequires && isRequire(declarations[i])) {\n                            currentScope.required = true;\n                        } else {\n                            currentScope.initialized = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Determines the current scope (function or block)\n         * @param  {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @returns {Object} The scope associated with statementType\n         */\n        function getCurrentScope(statementType) {\n            let currentScope;\n\n            if (statementType === \"var\") {\n                currentScope = functionStack[functionStack.length - 1];\n            } else if (statementType === \"let\") {\n                currentScope = blockStack[blockStack.length - 1].let;\n            } else if (statementType === \"const\") {\n                currentScope = blockStack[blockStack.length - 1].const;\n            }\n            return currentScope;\n        }\n\n        /**\n         * Counts the number of initialized and uninitialized declarations in a list of declarations\n         * @param {ASTNode[]} declarations List of declarations\n         * @returns {Object} Counts of 'uninitialized' and 'initialized' declarations\n         * @private\n         */\n        function countDeclarations(declarations) {\n            const counts = { uninitialized: 0, initialized: 0 };\n\n            for (let i = 0; i < declarations.length; i++) {\n                if (declarations[i].init === null) {\n                    counts.uninitialized++;\n                } else {\n                    counts.initialized++;\n                }\n            }\n            return counts;\n        }\n\n        /**\n         * Determines if there is more than one var statement in the current scope.\n         * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @param {ASTNode[]} declarations List of declarations\n         * @returns {boolean} Returns true if it is the first var declaration, false if not.\n         * @private\n         */\n        function hasOnlyOneStatement(statementType, declarations) {\n\n            const declarationCounts = countDeclarations(declarations);\n            const currentOptions = options[statementType] || {};\n            const currentScope = getCurrentScope(statementType);\n            const hasRequires = declarations.some(isRequire);\n\n            if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {\n                if (currentScope.uninitialized || currentScope.initialized) {\n                    if (!hasRequires) {\n                        return false;\n                    }\n                }\n            }\n\n            if (declarationCounts.uninitialized > 0) {\n                if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {\n                    return false;\n                }\n            }\n            if (declarationCounts.initialized > 0) {\n                if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {\n                    if (!hasRequires) {\n                        return false;\n                    }\n                }\n            }\n            if (currentScope.required && hasRequires) {\n                return false;\n            }\n            recordTypes(statementType, declarations, currentScope);\n            return true;\n        }\n\n        /**\n         * Fixer to join VariableDeclaration's into a single declaration\n         * @param   {VariableDeclarator[]} declarations The `VariableDeclaration` to join\n         * @returns {Function}                         The fixer function\n         */\n        function joinDeclarations(declarations) {\n            const declaration = declarations[0];\n            const body = Array.isArray(declaration.parent.parent.body) ? declaration.parent.parent.body : [];\n            const currentIndex = body.findIndex(node => node.range[0] === declaration.parent.range[0]);\n            const previousNode = body[currentIndex - 1];\n\n            return fixer => {\n                const type = sourceCode.getTokenBefore(declaration);\n                const prevSemi = sourceCode.getTokenBefore(type);\n                const res = [];\n\n                if (previousNode && previousNode.kind === sourceCode.getText(type)) {\n                    if (prevSemi.value === \";\") {\n                        res.push(fixer.replaceText(prevSemi, \",\"));\n                    } else {\n                        res.push(fixer.insertTextAfter(prevSemi, \",\"));\n                    }\n                    res.push(fixer.replaceText(type, \"\"));\n                }\n\n                return res;\n            };\n        }\n\n        /**\n         * Fixer to split a VariableDeclaration into individual declarations\n         * @param   {VariableDeclaration}   declaration The `VariableDeclaration` to split\n         * @returns {Function}                          The fixer function\n         */\n        function splitDeclarations(declaration) {\n            return fixer => declaration.declarations.map(declarator => {\n                const tokenAfterDeclarator = sourceCode.getTokenAfter(declarator);\n\n                if (tokenAfterDeclarator === null) {\n                    return null;\n                }\n\n                const afterComma = sourceCode.getTokenAfter(tokenAfterDeclarator, { includeComments: true });\n\n                if (tokenAfterDeclarator.value !== \",\") {\n                    return null;\n                }\n\n                /*\n                 * `var x,y`\n                 * tokenAfterDeclarator ^^ afterComma\n                 */\n                if (afterComma.range[0] === tokenAfterDeclarator.range[1]) {\n                    return fixer.replaceText(tokenAfterDeclarator, `; ${declaration.kind} `);\n                }\n\n                /*\n                 * `var x,\n                 * tokenAfterDeclarator ^\n                 *      y`\n                 *      ^ afterComma\n                 */\n                if (\n                    afterComma.loc.start.line > tokenAfterDeclarator.loc.end.line ||\n                    afterComma.type === \"Line\" ||\n                    afterComma.type === \"Block\"\n                ) {\n                    let lastComment = afterComma;\n\n                    while (lastComment.type === \"Line\" || lastComment.type === \"Block\") {\n                        lastComment = sourceCode.getTokenAfter(lastComment, { includeComments: true });\n                    }\n\n                    return fixer.replaceTextRange(\n                        [tokenAfterDeclarator.range[0], lastComment.range[0]],\n                        `;${sourceCode.text.slice(tokenAfterDeclarator.range[1], lastComment.range[0])}${declaration.kind} `\n                    );\n                }\n\n                return fixer.replaceText(tokenAfterDeclarator, `; ${declaration.kind}`);\n            }).filter(x => x);\n        }\n\n        /**\n         * Checks a given VariableDeclaration node for errors.\n         * @param {ASTNode} node The VariableDeclaration node to check\n         * @returns {void}\n         * @private\n         */\n        function checkVariableDeclaration(node) {\n            const parent = node.parent;\n            const type = node.kind;\n\n            if (!options[type]) {\n                return;\n            }\n\n            const declarations = node.declarations;\n            const declarationCounts = countDeclarations(declarations);\n            const mixedRequires = declarations.some(isRequire) && !declarations.every(isRequire);\n\n            if (options[type].initialized === MODE_ALWAYS) {\n                if (options.separateRequires && mixedRequires) {\n                    context.report({\n                        node,\n                        message: \"Split requires to be separated into a single block.\"\n                    });\n                }\n            }\n\n            // consecutive\n            const nodeIndex = (parent.body && parent.body.length > 0 && parent.body.indexOf(node)) || 0;\n\n            if (nodeIndex > 0) {\n                const previousNode = parent.body[nodeIndex - 1];\n                const isPreviousNodeDeclaration = previousNode.type === \"VariableDeclaration\";\n                const declarationsWithPrevious = declarations.concat(previousNode.declarations || []);\n\n                if (\n                    isPreviousNodeDeclaration &&\n                    previousNode.kind === type &&\n                    !(declarationsWithPrevious.some(isRequire) && !declarationsWithPrevious.every(isRequire))\n                ) {\n                    const previousDeclCounts = countDeclarations(previousNode.declarations);\n\n                    if (options[type].initialized === MODE_CONSECUTIVE && options[type].uninitialized === MODE_CONSECUTIVE) {\n                        context.report({\n                            node,\n                            message: \"Combine this with the previous '{{type}}' statement.\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    } else if (options[type].initialized === MODE_CONSECUTIVE && declarationCounts.initialized > 0 && previousDeclCounts.initialized > 0) {\n                        context.report({\n                            node,\n                            message: \"Combine this with the previous '{{type}}' statement with initialized variables.\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    } else if (options[type].uninitialized === MODE_CONSECUTIVE &&\n                            declarationCounts.uninitialized > 0 &&\n                            previousDeclCounts.uninitialized > 0) {\n                        context.report({\n                            node,\n                            message: \"Combine this with the previous '{{type}}' statement with uninitialized variables.\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    }\n                }\n            }\n\n            // always\n            if (!hasOnlyOneStatement(type, declarations)) {\n                if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {\n                    context.report({\n                        node,\n                        message: \"Combine this with the previous '{{type}}' statement.\",\n                        data: {\n                            type\n                        },\n                        fix: joinDeclarations(declarations)\n                    });\n                } else {\n                    if (options[type].initialized === MODE_ALWAYS && declarationCounts.initialized > 0) {\n                        context.report({\n                            node,\n                            message: \"Combine this with the previous '{{type}}' statement with initialized variables.\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    }\n                    if (options[type].uninitialized === MODE_ALWAYS && declarationCounts.uninitialized > 0) {\n                        if (node.parent.left === node && (node.parent.type === \"ForInStatement\" || node.parent.type === \"ForOfStatement\")) {\n                            return;\n                        }\n                        context.report({\n                            node,\n                            message: \"Combine this with the previous '{{type}}' statement with uninitialized variables.\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    }\n                }\n            }\n\n            // never\n            if (parent.type !== \"ForStatement\" || parent.init !== node) {\n                const totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;\n\n                if (totalDeclarations > 1) {\n                    if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {\n\n                        // both initialized and uninitialized\n                        context.report({\n                            node,\n                            message: \"Split '{{type}}' declarations into multiple statements.\",\n                            data: {\n                                type\n                            },\n                            fix: splitDeclarations(node)\n                        });\n                    } else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {\n\n                        // initialized\n                        context.report({\n                            node,\n                            message: \"Split initialized '{{type}}' declarations into multiple statements.\",\n                            data: {\n                                type\n                            },\n                            fix: splitDeclarations(node)\n                        });\n                    } else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {\n\n                        // uninitialized\n                        context.report({\n                            node,\n                            message: \"Split uninitialized '{{type}}' declarations into multiple statements.\",\n                            data: {\n                                type\n                            },\n                            fix: splitDeclarations(node)\n                        });\n                    }\n                }\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: startFunction,\n            FunctionDeclaration: startFunction,\n            FunctionExpression: startFunction,\n            ArrowFunctionExpression: startFunction,\n            BlockStatement: startBlock,\n            ForStatement: startBlock,\n            ForInStatement: startBlock,\n            ForOfStatement: startBlock,\n            SwitchStatement: startBlock,\n            VariableDeclaration: checkVariableDeclaration,\n            \"ForStatement:exit\": endBlock,\n            \"ForOfStatement:exit\": endBlock,\n            \"ForInStatement:exit\": endBlock,\n            \"SwitchStatement:exit\": endBlock,\n            \"BlockStatement:exit\": endBlock,\n            \"Program:exit\": endFunction,\n            \"FunctionDeclaration:exit\": endFunction,\n            \"FunctionExpression:exit\": endFunction,\n            \"ArrowFunctionExpression:exit\": endFunction\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to check multiple var declarations per line\n * @author Alberto Rodríguez\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require or disallow newlines around variable declarations\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/one-var-declaration-per-line\"\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"initializations\"]\n            }\n        ],\n\n        fixable: \"whitespace\"\n    },\n\n    create(context) {\n\n        const ERROR_MESSAGE = \"Expected variable declaration to be on a new line.\";\n        const always = context.options[0] === \"always\";\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n\n        /**\n         * Determine if provided keyword is a variant of for specifiers\n         * @private\n         * @param {string} keyword - keyword to test\n         * @returns {boolean} True if `keyword` is a variant of for specifier\n         */\n        function isForTypeSpecifier(keyword) {\n            return keyword === \"ForStatement\" || keyword === \"ForInStatement\" || keyword === \"ForOfStatement\";\n        }\n\n        /**\n         * Checks newlines around variable declarations.\n         * @private\n         * @param {ASTNode} node - `VariableDeclaration` node to test\n         * @returns {void}\n         */\n        function checkForNewLine(node) {\n            if (isForTypeSpecifier(node.parent.type)) {\n                return;\n            }\n\n            const declarations = node.declarations;\n            let prev;\n\n            declarations.forEach(current => {\n                if (prev && prev.loc.end.line === current.loc.start.line) {\n                    if (always || prev.init || current.init) {\n                        context.report({\n                            node,\n                            message: ERROR_MESSAGE,\n                            loc: current.loc.start,\n                            fix: fixer => fixer.insertTextBefore(current, \"\\n\")\n                        });\n                    }\n                }\n                prev = current;\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclaration: checkForNewLine\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to replace assignment expressions with operator assignment\n * @author Brandon Mills\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether an operator is commutative and has an operator assignment\n * shorthand form.\n * @param   {string}  operator Operator to check.\n * @returns {boolean}          True if the operator is commutative and has a\n *     shorthand form.\n */\nfunction isCommutativeOperatorWithShorthand(operator) {\n    return [\"*\", \"&\", \"^\", \"|\"].indexOf(operator) >= 0;\n}\n\n/**\n * Checks whether an operator is not commuatative and has an operator assignment\n * shorthand form.\n * @param   {string}  operator Operator to check.\n * @returns {boolean}          True if the operator is not commuatative and has\n *     a shorthand form.\n */\nfunction isNonCommutativeOperatorWithShorthand(operator) {\n    return [\"+\", \"-\", \"/\", \"%\", \"<<\", \">>\", \">>>\", \"**\"].indexOf(operator) >= 0;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether two expressions reference the same value. For example:\n *     a = a\n *     a.b = a.b\n *     a[0] = a[0]\n *     a['b'] = a['b']\n * @param   {ASTNode} a Left side of the comparison.\n * @param   {ASTNode} b Right side of the comparison.\n * @returns {boolean}   True if both sides match and reference the same value.\n */\nfunction same(a, b) {\n    if (a.type !== b.type) {\n        return false;\n    }\n\n    switch (a.type) {\n        case \"Identifier\":\n            return a.name === b.name;\n\n        case \"Literal\":\n            return a.value === b.value;\n\n        case \"MemberExpression\":\n\n            /*\n             * x[0] = x[0]\n             * x[y] = x[y]\n             * x.y = x.y\n             */\n            return same(a.object, b.object) && same(a.property, b.property);\n\n        default:\n            return false;\n    }\n}\n\n/**\n * Determines if the left side of a node can be safely fixed (i.e. if it activates the same getters/setters and)\n * toString calls regardless of whether assignment shorthand is used)\n * @param {ASTNode} node The node on the left side of the expression\n * @returns {boolean} `true` if the node can be fixed\n */\nfunction canBeFixed(node) {\n    return node.type === \"Identifier\" ||\n        node.type === \"MemberExpression\" && node.object.type === \"Identifier\" && (!node.computed || node.property.type === \"Literal\");\n}\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require or disallow assignment operator shorthand where possible\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/operator-assignment\"\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            replaced: \"Assignment can be replaced with operator assignment.\",\n            unexpected: \"Unexpected operator assignment shorthand.\"\n        }\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Returns the operator token of an AssignmentExpression or BinaryExpression\n         * @param {ASTNode} node An AssignmentExpression or BinaryExpression node\n         * @returns {Token} The operator token in the node\n         */\n        function getOperatorToken(node) {\n            return sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n        }\n\n        /**\n         * Ensures that an assignment uses the shorthand form where possible.\n         * @param   {ASTNode} node An AssignmentExpression node.\n         * @returns {void}\n         */\n        function verify(node) {\n            if (node.operator !== \"=\" || node.right.type !== \"BinaryExpression\") {\n                return;\n            }\n\n            const left = node.left;\n            const expr = node.right;\n            const operator = expr.operator;\n\n            if (isCommutativeOperatorWithShorthand(operator) || isNonCommutativeOperatorWithShorthand(operator)) {\n                if (same(left, expr.left)) {\n                    context.report({\n                        node,\n                        messageId: \"replaced\",\n                        fix(fixer) {\n                            if (canBeFixed(left)) {\n                                const equalsToken = getOperatorToken(node);\n                                const operatorToken = getOperatorToken(expr);\n                                const leftText = sourceCode.getText().slice(node.range[0], equalsToken.range[0]);\n                                const rightText = sourceCode.getText().slice(operatorToken.range[1], node.right.range[1]);\n\n                                return fixer.replaceText(node, `${leftText}${expr.operator}=${rightText}`);\n                            }\n                            return null;\n                        }\n                    });\n                } else if (same(left, expr.right) && isCommutativeOperatorWithShorthand(operator)) {\n\n                    /*\n                     * This case can't be fixed safely.\n                     * If `a` and `b` both have custom valueOf() behavior, then fixing `a = b * a` to `a *= b` would\n                     * change the execution order of the valueOf() functions.\n                     */\n                    context.report({\n                        node,\n                        messageId: \"replaced\"\n                    });\n                }\n            }\n        }\n\n        /**\n         * Warns if an assignment expression uses operator assignment shorthand.\n         * @param   {ASTNode} node An AssignmentExpression node.\n         * @returns {void}\n         */\n        function prohibit(node) {\n            if (node.operator !== \"=\") {\n                context.report({\n                    node,\n                    messageId: \"unexpected\",\n                    fix(fixer) {\n                        if (canBeFixed(node.left)) {\n                            const operatorToken = getOperatorToken(node);\n                            const leftText = sourceCode.getText().slice(node.range[0], operatorToken.range[0]);\n                            const newOperator = node.operator.slice(0, -1);\n                            let rightText;\n\n                            // If this change would modify precedence (e.g. `foo *= bar + 1` => `foo = foo * (bar + 1)`), parenthesize the right side.\n                            if (\n                                astUtils.getPrecedence(node.right) <= astUtils.getPrecedence({ type: \"BinaryExpression\", operator: newOperator }) &&\n                                !astUtils.isParenthesised(sourceCode, node.right)\n                            ) {\n                                rightText = `${sourceCode.text.slice(operatorToken.range[1], node.right.range[0])}(${sourceCode.getText(node.right)})`;\n                            } else {\n                                rightText = sourceCode.text.slice(operatorToken.range[1], node.range[1]);\n                            }\n\n                            return fixer.replaceText(node, `${leftText}= ${leftText}${newOperator}${rightText}`);\n                        }\n                        return null;\n                    }\n                });\n            }\n        }\n\n        return {\n            AssignmentExpression: context.options[0] !== \"never\" ? verify : prohibit\n        };\n\n    }\n};\n","/**\n * @fileoverview Operator linebreak - enforces operator linebreak style of two types: after and before\n * @author Benoît Zugmeyer\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent linebreak style for operators\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/operator-linebreak\"\n        },\n\n        schema: [\n            {\n                enum: [\"after\", \"before\", \"none\", null]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    overrides: {\n                        type: \"object\",\n                        properties: {\n                            anyOf: {\n                                type: \"string\",\n                                enum: [\"after\", \"before\", \"none\", \"ignore\"]\n                            }\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const usedDefaultGlobal = !context.options[0];\n        const globalStyle = context.options[0] || \"after\";\n        const options = context.options[1] || {};\n        const styleOverrides = options.overrides ? Object.assign({}, options.overrides) : {};\n\n        if (usedDefaultGlobal && !styleOverrides[\"?\"]) {\n            styleOverrides[\"?\"] = \"before\";\n        }\n\n        if (usedDefaultGlobal && !styleOverrides[\":\"]) {\n            styleOverrides[\":\"] = \"before\";\n        }\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Gets a fixer function to fix rule issues\n         * @param {Token} operatorToken The operator token of an expression\n         * @param {string} desiredStyle The style for the rule. One of 'before', 'after', 'none'\n         * @returns {Function} A fixer function\n         */\n        function getFixer(operatorToken, desiredStyle) {\n            return fixer => {\n                const tokenBefore = sourceCode.getTokenBefore(operatorToken);\n                const tokenAfter = sourceCode.getTokenAfter(operatorToken);\n                const textBefore = sourceCode.text.slice(tokenBefore.range[1], operatorToken.range[0]);\n                const textAfter = sourceCode.text.slice(operatorToken.range[1], tokenAfter.range[0]);\n                const hasLinebreakBefore = !astUtils.isTokenOnSameLine(tokenBefore, operatorToken);\n                const hasLinebreakAfter = !astUtils.isTokenOnSameLine(operatorToken, tokenAfter);\n                let newTextBefore, newTextAfter;\n\n                if (hasLinebreakBefore !== hasLinebreakAfter && desiredStyle !== \"none\") {\n\n                    // If there is a comment before and after the operator, don't do a fix.\n                    if (sourceCode.getTokenBefore(operatorToken, { includeComments: true }) !== tokenBefore &&\n                        sourceCode.getTokenAfter(operatorToken, { includeComments: true }) !== tokenAfter) {\n\n                        return null;\n                    }\n\n                    /*\n                     * If there is only one linebreak and it's on the wrong side of the operator, swap the text before and after the operator.\n                     * foo &&\n                     *           bar\n                     * would get fixed to\n                     * foo\n                     *        && bar\n                     */\n                    newTextBefore = textAfter;\n                    newTextAfter = textBefore;\n                } else {\n                    const LINEBREAK_REGEX = astUtils.createGlobalLinebreakMatcher();\n\n                    // Otherwise, if no linebreak is desired and no comments interfere, replace the linebreaks with empty strings.\n                    newTextBefore = desiredStyle === \"before\" || textBefore.trim() ? textBefore : textBefore.replace(LINEBREAK_REGEX, \"\");\n                    newTextAfter = desiredStyle === \"after\" || textAfter.trim() ? textAfter : textAfter.replace(LINEBREAK_REGEX, \"\");\n\n                    // If there was no change (due to interfering comments), don't output a fix.\n                    if (newTextBefore === textBefore && newTextAfter === textAfter) {\n                        return null;\n                    }\n                }\n\n                if (newTextAfter === \"\" && tokenAfter.type === \"Punctuator\" && \"+-\".includes(operatorToken.value) && tokenAfter.value === operatorToken.value) {\n\n                    // To avoid accidentally creating a ++ or -- operator, insert a space if the operator is a +/- and the following token is a unary +/-.\n                    newTextAfter += \" \";\n                }\n\n                return fixer.replaceTextRange([tokenBefore.range[1], tokenAfter.range[0]], newTextBefore + operatorToken.value + newTextAfter);\n            };\n        }\n\n        /**\n         * Checks the operator placement\n         * @param {ASTNode} node The node to check\n         * @param {ASTNode} leftSide The node that comes before the operator in `node`\n         * @private\n         * @returns {void}\n         */\n        function validateNode(node, leftSide) {\n\n            /*\n             * When the left part of a binary expression is a single expression wrapped in\n             * parentheses (ex: `(a) + b`), leftToken will be the last token of the expression\n             * and operatorToken will be the closing parenthesis.\n             * The leftToken should be the last closing parenthesis, and the operatorToken\n             * should be the token right after that.\n             */\n            const operatorToken = sourceCode.getTokenAfter(leftSide, astUtils.isNotClosingParenToken);\n            const leftToken = sourceCode.getTokenBefore(operatorToken);\n            const rightToken = sourceCode.getTokenAfter(operatorToken);\n            const operator = operatorToken.value;\n            const operatorStyleOverride = styleOverrides[operator];\n            const style = operatorStyleOverride || globalStyle;\n            const fix = getFixer(operatorToken, style);\n\n            // if single line\n            if (astUtils.isTokenOnSameLine(leftToken, operatorToken) &&\n                    astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                // do nothing.\n\n            } else if (operatorStyleOverride !== \"ignore\" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) &&\n                    !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                // lone operator\n                context.report({\n                    node,\n                    loc: {\n                        line: operatorToken.loc.end.line,\n                        column: operatorToken.loc.end.column\n                    },\n                    message: \"Bad line breaking before and after '{{operator}}'.\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            } else if (style === \"before\" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {\n\n                context.report({\n                    node,\n                    loc: {\n                        line: operatorToken.loc.end.line,\n                        column: operatorToken.loc.end.column\n                    },\n                    message: \"'{{operator}}' should be placed at the beginning of the line.\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            } else if (style === \"after\" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                context.report({\n                    node,\n                    loc: {\n                        line: operatorToken.loc.end.line,\n                        column: operatorToken.loc.end.column\n                    },\n                    message: \"'{{operator}}' should be placed at the end of the line.\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            } else if (style === \"none\") {\n\n                context.report({\n                    node,\n                    loc: {\n                        line: operatorToken.loc.end.line,\n                        column: operatorToken.loc.end.column\n                    },\n                    message: \"There should be no line break before or after '{{operator}}'.\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            }\n        }\n\n        /**\n         * Validates a binary expression using `validateNode`\n         * @param {BinaryExpression|LogicalExpression|AssignmentExpression} node node to be validated\n         * @returns {void}\n         */\n        function validateBinaryExpression(node) {\n            validateNode(node, node.left);\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            BinaryExpression: validateBinaryExpression,\n            LogicalExpression: validateBinaryExpression,\n            AssignmentExpression: validateBinaryExpression,\n            VariableDeclarator(node) {\n                if (node.init) {\n                    validateNode(node, node.id);\n                }\n            },\n            ConditionalExpression(node) {\n                validateNode(node, node.test);\n                validateNode(node, node.consequent);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A rule to ensure blank lines within blocks.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow padding within blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/padded-blocks\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            blocks: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            switches: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            classes: {\n                                enum: [\"always\", \"never\"]\n                            }\n                        },\n                        additionalProperties: false,\n                        minProperties: 1\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    allowSingleLineBlocks: {\n                        type: \"boolean\"\n                    }\n                }\n            }\n        ]\n    },\n\n    create(context) {\n        const options = {};\n        const typeOptions = context.options[0] || \"always\";\n        const exceptOptions = context.options[1] || {};\n\n        if (typeof typeOptions === \"string\") {\n            const shouldHavePadding = typeOptions === \"always\";\n\n            options.blocks = shouldHavePadding;\n            options.switches = shouldHavePadding;\n            options.classes = shouldHavePadding;\n        } else {\n            if (Object.prototype.hasOwnProperty.call(typeOptions, \"blocks\")) {\n                options.blocks = typeOptions.blocks === \"always\";\n            }\n            if (Object.prototype.hasOwnProperty.call(typeOptions, \"switches\")) {\n                options.switches = typeOptions.switches === \"always\";\n            }\n            if (Object.prototype.hasOwnProperty.call(typeOptions, \"classes\")) {\n                options.classes = typeOptions.classes === \"always\";\n            }\n        }\n\n        if (Object.prototype.hasOwnProperty.call(exceptOptions, \"allowSingleLineBlocks\")) {\n            options.allowSingleLineBlocks = exceptOptions.allowSingleLineBlocks === true;\n        }\n\n        const ALWAYS_MESSAGE = \"Block must be padded by blank lines.\",\n            NEVER_MESSAGE = \"Block must not be padded by blank lines.\";\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Gets the open brace token from a given node.\n         * @param {ASTNode} node - A BlockStatement or SwitchStatement node from which to get the open brace.\n         * @returns {Token} The token of the open brace.\n         */\n        function getOpenBrace(node) {\n            if (node.type === \"SwitchStatement\") {\n                return sourceCode.getTokenBefore(node.cases[0]);\n            }\n            return sourceCode.getFirstToken(node);\n        }\n\n        /**\n         * Checks if the given parameter is a comment node\n         * @param {ASTNode|Token} node An AST node or token\n         * @returns {boolean} True if node is a comment\n         */\n        function isComment(node) {\n            return node.type === \"Line\" || node.type === \"Block\";\n        }\n\n        /**\n         * Checks if there is padding between two tokens\n         * @param {Token} first The first token\n         * @param {Token} second The second token\n         * @returns {boolean} True if there is at least a line between the tokens\n         */\n        function isPaddingBetweenTokens(first, second) {\n            return second.loc.start.line - first.loc.end.line >= 2;\n        }\n\n\n        /**\n         * Checks if the given token has a blank line after it.\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the token is followed by a blank line.\n         */\n        function getFirstBlockToken(token) {\n            let prev,\n                first = token;\n\n            do {\n                prev = first;\n                first = sourceCode.getTokenAfter(first, { includeComments: true });\n            } while (isComment(first) && first.loc.start.line === prev.loc.end.line);\n\n            return first;\n        }\n\n        /**\n         * Checks if the given token is preceeded by a blank line.\n         * @param {Token} token The token to check\n         * @returns {boolean} Whether or not the token is preceeded by a blank line\n         */\n        function getLastBlockToken(token) {\n            let last = token,\n                next;\n\n            do {\n                next = last;\n                last = sourceCode.getTokenBefore(last, { includeComments: true });\n            } while (isComment(last) && last.loc.end.line === next.loc.start.line);\n\n            return last;\n        }\n\n        /**\n         * Checks if a node should be padded, according to the rule config.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {boolean} True if the node should be padded, false otherwise.\n         */\n        function requirePaddingFor(node) {\n            switch (node.type) {\n                case \"BlockStatement\":\n                    return options.blocks;\n                case \"SwitchStatement\":\n                    return options.switches;\n                case \"ClassBody\":\n                    return options.classes;\n\n                /* istanbul ignore next */\n                default:\n                    throw new Error(\"unreachable\");\n            }\n        }\n\n        /**\n         * Checks the given BlockStatement node to be padded if the block is not empty.\n         * @param {ASTNode} node The AST node of a BlockStatement.\n         * @returns {void} undefined.\n         */\n        function checkPadding(node) {\n            const openBrace = getOpenBrace(node),\n                firstBlockToken = getFirstBlockToken(openBrace),\n                tokenBeforeFirst = sourceCode.getTokenBefore(firstBlockToken, { includeComments: true }),\n                closeBrace = sourceCode.getLastToken(node),\n                lastBlockToken = getLastBlockToken(closeBrace),\n                tokenAfterLast = sourceCode.getTokenAfter(lastBlockToken, { includeComments: true }),\n                blockHasTopPadding = isPaddingBetweenTokens(tokenBeforeFirst, firstBlockToken),\n                blockHasBottomPadding = isPaddingBetweenTokens(lastBlockToken, tokenAfterLast);\n\n            if (options.allowSingleLineBlocks && astUtils.isTokenOnSameLine(tokenBeforeFirst, tokenAfterLast)) {\n                return;\n            }\n\n            if (requirePaddingFor(node)) {\n                if (!blockHasTopPadding) {\n                    context.report({\n                        node,\n                        loc: { line: tokenBeforeFirst.loc.start.line, column: tokenBeforeFirst.loc.start.column },\n                        fix(fixer) {\n                            return fixer.insertTextAfter(tokenBeforeFirst, \"\\n\");\n                        },\n                        message: ALWAYS_MESSAGE\n                    });\n                }\n                if (!blockHasBottomPadding) {\n                    context.report({\n                        node,\n                        loc: { line: tokenAfterLast.loc.end.line, column: tokenAfterLast.loc.end.column - 1 },\n                        fix(fixer) {\n                            return fixer.insertTextBefore(tokenAfterLast, \"\\n\");\n                        },\n                        message: ALWAYS_MESSAGE\n                    });\n                }\n            } else {\n                if (blockHasTopPadding) {\n\n                    context.report({\n                        node,\n                        loc: { line: tokenBeforeFirst.loc.start.line, column: tokenBeforeFirst.loc.start.column },\n                        fix(fixer) {\n                            return fixer.replaceTextRange([tokenBeforeFirst.range[1], firstBlockToken.range[0] - firstBlockToken.loc.start.column], \"\\n\");\n                        },\n                        message: NEVER_MESSAGE\n                    });\n                }\n\n                if (blockHasBottomPadding) {\n\n                    context.report({\n                        node,\n                        loc: { line: tokenAfterLast.loc.end.line, column: tokenAfterLast.loc.end.column - 1 },\n                        message: NEVER_MESSAGE,\n                        fix(fixer) {\n                            return fixer.replaceTextRange([lastBlockToken.range[1], tokenAfterLast.range[0] - tokenAfterLast.loc.start.column], \"\\n\");\n                        }\n                    });\n                }\n            }\n        }\n\n        const rule = {};\n\n        if (Object.prototype.hasOwnProperty.call(options, \"switches\")) {\n            rule.SwitchStatement = function(node) {\n                if (node.cases.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        if (Object.prototype.hasOwnProperty.call(options, \"blocks\")) {\n            rule.BlockStatement = function(node) {\n                if (node.body.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        if (Object.prototype.hasOwnProperty.call(options, \"classes\")) {\n            rule.ClassBody = function(node) {\n                if (node.body.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        return rule;\n    }\n};\n","/**\n * @fileoverview Rule to require or disallow newlines between statements\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst LT = `[${Array.from(astUtils.LINEBREAKS).join(\"\")}]`;\nconst PADDING_LINE_SEQUENCE = new RegExp(\n    String.raw`^(\\s*?${LT})\\s*${LT}(\\s*;?)$`,\n    \"u\"\n);\nconst CJS_EXPORT = /^(?:module\\s*\\.\\s*)?exports(?:\\s*\\.|\\s*\\[|$)/u;\nconst CJS_IMPORT = /^require\\(/u;\n\n/**\n * Creates tester which check if a node starts with specific keyword.\n *\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newKeywordTester(keyword) {\n    return {\n        test: (node, sourceCode) =>\n            sourceCode.getFirstToken(node).value === keyword\n    };\n}\n\n/**\n * Creates tester which check if a node starts with specific keyword and spans a single line.\n *\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newSinglelineKeywordTester(keyword) {\n    return {\n        test: (node, sourceCode) =>\n            node.loc.start.line === node.loc.end.line &&\n            sourceCode.getFirstToken(node).value === keyword\n    };\n}\n\n/**\n * Creates tester which check if a node starts with specific keyword and spans multiple lines.\n *\n * @param {string} keyword The keyword to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newMultilineKeywordTester(keyword) {\n    return {\n        test: (node, sourceCode) =>\n            node.loc.start.line !== node.loc.end.line &&\n            sourceCode.getFirstToken(node).value === keyword\n    };\n}\n\n/**\n * Creates tester which check if a node is specific type.\n *\n * @param {string} type The node type to test.\n * @returns {Object} the created tester.\n * @private\n */\nfunction newNodeTypeTester(type) {\n    return {\n        test: node =>\n            node.type === type\n    };\n}\n\n/**\n * Checks the given node is an expression statement of IIFE.\n *\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is an expression statement of IIFE.\n * @private\n */\nfunction isIIFEStatement(node) {\n    if (node.type === \"ExpressionStatement\") {\n        let call = node.expression;\n\n        if (call.type === \"UnaryExpression\") {\n            call = call.argument;\n        }\n        return call.type === \"CallExpression\" && astUtils.isFunction(call.callee);\n    }\n    return false;\n}\n\n/**\n * Checks whether the given node is a block-like statement.\n * This checks the last token of the node is the closing brace of a block.\n *\n * @param {SourceCode} sourceCode The source code to get tokens.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a block-like statement.\n * @private\n */\nfunction isBlockLikeStatement(sourceCode, node) {\n\n    // do-while with a block is a block-like statement.\n    if (node.type === \"DoWhileStatement\" && node.body.type === \"BlockStatement\") {\n        return true;\n    }\n\n    /*\n     * IIFE is a block-like statement specially from\n     * JSCS#disallowPaddingNewLinesAfterBlocks.\n     */\n    if (isIIFEStatement(node)) {\n        return true;\n    }\n\n    // Checks the last token is a closing brace of blocks.\n    const lastToken = sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);\n    const belongingNode = lastToken && astUtils.isClosingBraceToken(lastToken)\n        ? sourceCode.getNodeByRangeIndex(lastToken.range[0])\n        : null;\n\n    return Boolean(belongingNode) && (\n        belongingNode.type === \"BlockStatement\" ||\n        belongingNode.type === \"SwitchStatement\"\n    );\n}\n\n/**\n * Check whether the given node is a directive or not.\n * @param {ASTNode} node The node to check.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {boolean} `true` if the node is a directive.\n */\nfunction isDirective(node, sourceCode) {\n    return (\n        node.type === \"ExpressionStatement\" &&\n        (\n            node.parent.type === \"Program\" ||\n            (\n                node.parent.type === \"BlockStatement\" &&\n                astUtils.isFunction(node.parent.parent)\n            )\n        ) &&\n        node.expression.type === \"Literal\" &&\n        typeof node.expression.value === \"string\" &&\n        !astUtils.isParenthesised(sourceCode, node.expression)\n    );\n}\n\n/**\n * Check whether the given node is a part of directive prologue or not.\n * @param {ASTNode} node The node to check.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {boolean} `true` if the node is a part of directive prologue.\n */\nfunction isDirectivePrologue(node, sourceCode) {\n    if (isDirective(node, sourceCode)) {\n        for (const sibling of node.parent.body) {\n            if (sibling === node) {\n                break;\n            }\n            if (!isDirective(sibling, sourceCode)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n\n/**\n * Gets the actual last token.\n *\n * If a semicolon is semicolon-less style's semicolon, this ignores it.\n * For example:\n *\n *     foo()\n *     ;[1, 2, 3].forEach(bar)\n *\n * @param {SourceCode} sourceCode The source code to get tokens.\n * @param {ASTNode} node The node to get.\n * @returns {Token} The actual last token.\n * @private\n */\nfunction getActualLastToken(sourceCode, node) {\n    const semiToken = sourceCode.getLastToken(node);\n    const prevToken = sourceCode.getTokenBefore(semiToken);\n    const nextToken = sourceCode.getTokenAfter(semiToken);\n    const isSemicolonLessStyle = Boolean(\n        prevToken &&\n        nextToken &&\n        prevToken.range[0] >= node.range[0] &&\n        astUtils.isSemicolonToken(semiToken) &&\n        semiToken.loc.start.line !== prevToken.loc.end.line &&\n        semiToken.loc.end.line === nextToken.loc.start.line\n    );\n\n    return isSemicolonLessStyle ? prevToken : semiToken;\n}\n\n/**\n * This returns the concatenation of the first 2 captured strings.\n * @param {string} _ Unused. Whole matched string.\n * @param {string} trailingSpaces The trailing spaces of the first line.\n * @param {string} indentSpaces The indentation spaces of the last line.\n * @returns {string} The concatenation of trailingSpaces and indentSpaces.\n * @private\n */\nfunction replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {\n    return trailingSpaces + indentSpaces;\n}\n\n/**\n * Check and report statements for `any` configuration.\n * It does nothing.\n *\n * @returns {void}\n * @private\n */\nfunction verifyForAny() {\n}\n\n/**\n * Check and report statements for `never` configuration.\n * This autofix removes blank lines between the given 2 statements.\n * However, if comments exist between 2 blank lines, it does not remove those\n * blank lines automatically.\n *\n * @param {RuleContext} context The rule context to report.\n * @param {ASTNode} _ Unused. The previous node to check.\n * @param {ASTNode} nextNode The next node to check.\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\n * lines exist between the pair.\n * @returns {void}\n * @private\n */\nfunction verifyForNever(context, _, nextNode, paddingLines) {\n    if (paddingLines.length === 0) {\n        return;\n    }\n\n    context.report({\n        node: nextNode,\n        message: \"Unexpected blank line before this statement.\",\n        fix(fixer) {\n            if (paddingLines.length >= 2) {\n                return null;\n            }\n\n            const prevToken = paddingLines[0][0];\n            const nextToken = paddingLines[0][1];\n            const start = prevToken.range[1];\n            const end = nextToken.range[0];\n            const text = context.getSourceCode().text\n                .slice(start, end)\n                .replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);\n\n            return fixer.replaceTextRange([start, end], text);\n        }\n    });\n}\n\n/**\n * Check and report statements for `always` configuration.\n * This autofix inserts a blank line between the given 2 statements.\n * If the `prevNode` has trailing comments, it inserts a blank line after the\n * trailing comments.\n *\n * @param {RuleContext} context The rule context to report.\n * @param {ASTNode} prevNode The previous node to check.\n * @param {ASTNode} nextNode The next node to check.\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\n * lines exist between the pair.\n * @returns {void}\n * @private\n */\nfunction verifyForAlways(context, prevNode, nextNode, paddingLines) {\n    if (paddingLines.length > 0) {\n        return;\n    }\n\n    context.report({\n        node: nextNode,\n        message: \"Expected blank line before this statement.\",\n        fix(fixer) {\n            const sourceCode = context.getSourceCode();\n            let prevToken = getActualLastToken(sourceCode, prevNode);\n            const nextToken = sourceCode.getFirstTokenBetween(\n                prevToken,\n                nextNode,\n                {\n                    includeComments: true,\n\n                    /**\n                     * Skip the trailing comments of the previous node.\n                     * This inserts a blank line after the last trailing comment.\n                     *\n                     * For example:\n                     *\n                     *     foo(); // trailing comment.\n                     *     // comment.\n                     *     bar();\n                     *\n                     * Get fixed to:\n                     *\n                     *     foo(); // trailing comment.\n                     *\n                     *     // comment.\n                     *     bar();\n                     *\n                     * @param {Token} token The token to check.\n                     * @returns {boolean} `true` if the token is not a trailing comment.\n                     * @private\n                     */\n                    filter(token) {\n                        if (astUtils.isTokenOnSameLine(prevToken, token)) {\n                            prevToken = token;\n                            return false;\n                        }\n                        return true;\n                    }\n                }\n            ) || nextNode;\n            const insertText = astUtils.isTokenOnSameLine(prevToken, nextToken)\n                ? \"\\n\\n\"\n                : \"\\n\";\n\n            return fixer.insertTextAfter(prevToken, insertText);\n        }\n    });\n}\n\n/**\n * Types of blank lines.\n * `any`, `never`, and `always` are defined.\n * Those have `verify` method to check and report statements.\n * @private\n */\nconst PaddingTypes = {\n    any: { verify: verifyForAny },\n    never: { verify: verifyForNever },\n    always: { verify: verifyForAlways }\n};\n\n/**\n * Types of statements.\n * Those have `test` method to check it matches to the given statement.\n * @private\n */\nconst StatementTypes = {\n    \"*\": { test: () => true },\n    \"block-like\": {\n        test: (node, sourceCode) => isBlockLikeStatement(sourceCode, node)\n    },\n    \"cjs-export\": {\n        test: (node, sourceCode) =>\n            node.type === \"ExpressionStatement\" &&\n            node.expression.type === \"AssignmentExpression\" &&\n            CJS_EXPORT.test(sourceCode.getText(node.expression.left))\n    },\n    \"cjs-import\": {\n        test: (node, sourceCode) =>\n            node.type === \"VariableDeclaration\" &&\n            node.declarations.length > 0 &&\n            Boolean(node.declarations[0].init) &&\n            CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init))\n    },\n    directive: {\n        test: isDirectivePrologue\n    },\n    expression: {\n        test: (node, sourceCode) =>\n            node.type === \"ExpressionStatement\" &&\n            !isDirectivePrologue(node, sourceCode)\n    },\n    iife: {\n        test: isIIFEStatement\n    },\n    \"multiline-block-like\": {\n        test: (node, sourceCode) =>\n            node.loc.start.line !== node.loc.end.line &&\n            isBlockLikeStatement(sourceCode, node)\n    },\n    \"multiline-expression\": {\n        test: (node, sourceCode) =>\n            node.loc.start.line !== node.loc.end.line &&\n            node.type === \"ExpressionStatement\" &&\n            !isDirectivePrologue(node, sourceCode)\n    },\n\n    \"multiline-const\": newMultilineKeywordTester(\"const\"),\n    \"multiline-let\": newMultilineKeywordTester(\"let\"),\n    \"multiline-var\": newMultilineKeywordTester(\"var\"),\n    \"singleline-const\": newSinglelineKeywordTester(\"const\"),\n    \"singleline-let\": newSinglelineKeywordTester(\"let\"),\n    \"singleline-var\": newSinglelineKeywordTester(\"var\"),\n\n    block: newNodeTypeTester(\"BlockStatement\"),\n    empty: newNodeTypeTester(\"EmptyStatement\"),\n    function: newNodeTypeTester(\"FunctionDeclaration\"),\n\n    break: newKeywordTester(\"break\"),\n    case: newKeywordTester(\"case\"),\n    class: newKeywordTester(\"class\"),\n    const: newKeywordTester(\"const\"),\n    continue: newKeywordTester(\"continue\"),\n    debugger: newKeywordTester(\"debugger\"),\n    default: newKeywordTester(\"default\"),\n    do: newKeywordTester(\"do\"),\n    export: newKeywordTester(\"export\"),\n    for: newKeywordTester(\"for\"),\n    if: newKeywordTester(\"if\"),\n    import: newKeywordTester(\"import\"),\n    let: newKeywordTester(\"let\"),\n    return: newKeywordTester(\"return\"),\n    switch: newKeywordTester(\"switch\"),\n    throw: newKeywordTester(\"throw\"),\n    try: newKeywordTester(\"try\"),\n    var: newKeywordTester(\"var\"),\n    while: newKeywordTester(\"while\"),\n    with: newKeywordTester(\"with\")\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow padding lines between statements\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/padding-line-between-statements\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: {\n            definitions: {\n                paddingType: {\n                    enum: Object.keys(PaddingTypes)\n                },\n                statementType: {\n                    anyOf: [\n                        { enum: Object.keys(StatementTypes) },\n                        {\n                            type: \"array\",\n                            items: { enum: Object.keys(StatementTypes) },\n                            minItems: 1,\n                            uniqueItems: true,\n                            additionalItems: false\n                        }\n                    ]\n                }\n            },\n            type: \"array\",\n            items: {\n                type: \"object\",\n                properties: {\n                    blankLine: { $ref: \"#/definitions/paddingType\" },\n                    prev: { $ref: \"#/definitions/statementType\" },\n                    next: { $ref: \"#/definitions/statementType\" }\n                },\n                additionalProperties: false,\n                required: [\"blankLine\", \"prev\", \"next\"]\n            },\n            additionalItems: false\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const configureList = context.options || [];\n        let scopeInfo = null;\n\n        /**\n         * Processes to enter to new scope.\n         * This manages the current previous statement.\n         * @returns {void}\n         * @private\n         */\n        function enterScope() {\n            scopeInfo = {\n                upper: scopeInfo,\n                prevNode: null\n            };\n        }\n\n        /**\n         * Processes to exit from the current scope.\n         * @returns {void}\n         * @private\n         */\n        function exitScope() {\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Checks whether the given node matches the given type.\n         *\n         * @param {ASTNode} node The statement node to check.\n         * @param {string|string[]} type The statement type to check.\n         * @returns {boolean} `true` if the statement node matched the type.\n         * @private\n         */\n        function match(node, type) {\n            let innerStatementNode = node;\n\n            while (innerStatementNode.type === \"LabeledStatement\") {\n                innerStatementNode = innerStatementNode.body;\n            }\n            if (Array.isArray(type)) {\n                return type.some(match.bind(null, innerStatementNode));\n            }\n            return StatementTypes[type].test(innerStatementNode, sourceCode);\n        }\n\n        /**\n         * Finds the last matched configure from configureList.\n         *\n         * @param {ASTNode} prevNode The previous statement to match.\n         * @param {ASTNode} nextNode The current statement to match.\n         * @returns {Object} The tester of the last matched configure.\n         * @private\n         */\n        function getPaddingType(prevNode, nextNode) {\n            for (let i = configureList.length - 1; i >= 0; --i) {\n                const configure = configureList[i];\n                const matched =\n                    match(prevNode, configure.prev) &&\n                    match(nextNode, configure.next);\n\n                if (matched) {\n                    return PaddingTypes[configure.blankLine];\n                }\n            }\n            return PaddingTypes.any;\n        }\n\n        /**\n         * Gets padding line sequences between the given 2 statements.\n         * Comments are separators of the padding line sequences.\n         *\n         * @param {ASTNode} prevNode The previous statement to count.\n         * @param {ASTNode} nextNode The current statement to count.\n         * @returns {Array<Token[]>} The array of token pairs.\n         * @private\n         */\n        function getPaddingLineSequences(prevNode, nextNode) {\n            const pairs = [];\n            let prevToken = getActualLastToken(sourceCode, prevNode);\n\n            if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {\n                do {\n                    const token = sourceCode.getTokenAfter(\n                        prevToken,\n                        { includeComments: true }\n                    );\n\n                    if (token.loc.start.line - prevToken.loc.end.line >= 2) {\n                        pairs.push([prevToken, token]);\n                    }\n                    prevToken = token;\n\n                } while (prevToken.range[0] < nextNode.range[0]);\n            }\n\n            return pairs;\n        }\n\n        /**\n         * Verify padding lines between the given node and the previous node.\n         *\n         * @param {ASTNode} node The node to verify.\n         * @returns {void}\n         * @private\n         */\n        function verify(node) {\n            const parentType = node.parent.type;\n            const validParent =\n                astUtils.STATEMENT_LIST_PARENTS.has(parentType) ||\n                parentType === \"SwitchStatement\";\n\n            if (!validParent) {\n                return;\n            }\n\n            // Save this node as the current previous statement.\n            const prevNode = scopeInfo.prevNode;\n\n            // Verify.\n            if (prevNode) {\n                const type = getPaddingType(prevNode, node);\n                const paddingLines = getPaddingLineSequences(prevNode, node);\n\n                type.verify(context, prevNode, node, paddingLines);\n            }\n\n            scopeInfo.prevNode = node;\n        }\n\n        /**\n         * Verify padding lines between the given node and the previous node.\n         * Then process to enter to new scope.\n         *\n         * @param {ASTNode} node The node to verify.\n         * @returns {void}\n         * @private\n         */\n        function verifyThenEnterScope(node) {\n            verify(node);\n            enterScope();\n        }\n\n        return {\n            Program: enterScope,\n            BlockStatement: enterScope,\n            SwitchStatement: enterScope,\n            \"Program:exit\": exitScope,\n            \"BlockStatement:exit\": exitScope,\n            \"SwitchStatement:exit\": exitScope,\n\n            \":statement\": verify,\n\n            SwitchCase: verifyThenEnterScope,\n            \"SwitchCase:exit\": exitScope\n        };\n    }\n};\n","/**\n * @fileoverview A rule to suggest using arrow functions as callbacks.\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given variable is a function name.\n * @param {eslint-scope.Variable} variable - A variable to check.\n * @returns {boolean} `true` if the variable is a function name.\n */\nfunction isFunctionName(variable) {\n    return variable && variable.defs[0].type === \"FunctionName\";\n}\n\n/**\n * Checks whether or not a given MetaProperty node equals to a given value.\n * @param {ASTNode} node - A MetaProperty node to check.\n * @param {string} metaName - The name of `MetaProperty.meta`.\n * @param {string} propertyName - The name of `MetaProperty.property`.\n * @returns {boolean} `true` if the node is the specific value.\n */\nfunction checkMetaProperty(node, metaName, propertyName) {\n    return node.meta.name === metaName && node.property.name === propertyName;\n}\n\n/**\n * Gets the variable object of `arguments` which is defined implicitly.\n * @param {eslint-scope.Scope} scope - A scope to get.\n * @returns {eslint-scope.Variable} The found variable object.\n */\nfunction getVariableOfArguments(scope) {\n    const variables = scope.variables;\n\n    for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i];\n\n        if (variable.name === \"arguments\") {\n\n            /*\n             * If there was a parameter which is named \"arguments\", the\n             * implicit \"arguments\" is not defined.\n             * So does fast return with null.\n             */\n            return (variable.identifiers.length === 0) ? variable : null;\n        }\n    }\n\n    /* istanbul ignore next */\n    return null;\n}\n\n/**\n * Checkes whether or not a given node is a callback.\n * @param {ASTNode} node - A node to check.\n * @returns {Object}\n *   {boolean} retv.isCallback - `true` if the node is a callback.\n *   {boolean} retv.isLexicalThis - `true` if the node is with `.bind(this)`.\n */\nfunction getCallbackInfo(node) {\n    const retv = { isCallback: false, isLexicalThis: false };\n    let currentNode = node;\n    let parent = node.parent;\n\n    while (currentNode) {\n        switch (parent.type) {\n\n            // Checks parents recursively.\n\n            case \"LogicalExpression\":\n            case \"ConditionalExpression\":\n                break;\n\n            // Checks whether the parent node is `.bind(this)` call.\n            case \"MemberExpression\":\n                if (parent.object === currentNode &&\n                    !parent.property.computed &&\n                    parent.property.type === \"Identifier\" &&\n                    parent.property.name === \"bind\" &&\n                    parent.parent.type === \"CallExpression\" &&\n                    parent.parent.callee === parent\n                ) {\n                    retv.isLexicalThis = (\n                        parent.parent.arguments.length === 1 &&\n                        parent.parent.arguments[0].type === \"ThisExpression\"\n                    );\n                    parent = parent.parent;\n                } else {\n                    return retv;\n                }\n                break;\n\n            // Checks whether the node is a callback.\n            case \"CallExpression\":\n            case \"NewExpression\":\n                if (parent.callee !== currentNode) {\n                    retv.isCallback = true;\n                }\n                return retv;\n\n            default:\n                return retv;\n        }\n\n        currentNode = parent;\n        parent = parent.parent;\n    }\n\n    /* istanbul ignore next */\n    throw new Error(\"unreachable\");\n}\n\n/**\n * Checks whether a simple list of parameters contains any duplicates. This does not handle complex\n * parameter lists (e.g. with destructuring), since complex parameter lists are a SyntaxError with duplicate\n * parameter names anyway. Instead, it always returns `false` for complex parameter lists.\n * @param {ASTNode[]} paramsList The list of parameters for a function\n * @returns {boolean} `true` if the list of parameters contains any duplicates\n */\nfunction hasDuplicateParams(paramsList) {\n    return paramsList.every(param => param.type === \"Identifier\") && paramsList.length !== new Set(paramsList.map(param => param.name)).size;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require using arrow functions for callbacks\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-arrow-callback\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowNamedFunctions: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowUnboundThis: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n\n        const allowUnboundThis = options.allowUnboundThis !== false; // default to true\n        const allowNamedFunctions = options.allowNamedFunctions;\n        const sourceCode = context.getSourceCode();\n\n        /*\n         * {Array<{this: boolean, super: boolean, meta: boolean}>}\n         * - this - A flag which shows there are one or more ThisExpression.\n         * - super - A flag which shows there are one or more Super.\n         * - meta - A flag which shows there are one or more MethProperty.\n         */\n        let stack = [];\n\n        /**\n         * Pushes new function scope with all `false` flags.\n         * @returns {void}\n         */\n        function enterScope() {\n            stack.push({ this: false, super: false, meta: false });\n        }\n\n        /**\n         * Pops a function scope from the stack.\n         * @returns {{this: boolean, super: boolean, meta: boolean}} The information of the last scope.\n         */\n        function exitScope() {\n            return stack.pop();\n        }\n\n        return {\n\n            // Reset internal state.\n            Program() {\n                stack = [];\n            },\n\n            // If there are below, it cannot replace with arrow functions merely.\n            ThisExpression() {\n                const info = stack[stack.length - 1];\n\n                if (info) {\n                    info.this = true;\n                }\n            },\n\n            Super() {\n                const info = stack[stack.length - 1];\n\n                if (info) {\n                    info.super = true;\n                }\n            },\n\n            MetaProperty(node) {\n                const info = stack[stack.length - 1];\n\n                if (info && checkMetaProperty(node, \"new\", \"target\")) {\n                    info.meta = true;\n                }\n            },\n\n            // To skip nested scopes.\n            FunctionDeclaration: enterScope,\n            \"FunctionDeclaration:exit\": exitScope,\n\n            // Main.\n            FunctionExpression: enterScope,\n            \"FunctionExpression:exit\"(node) {\n                const scopeInfo = exitScope();\n\n                // Skip named function expressions\n                if (allowNamedFunctions && node.id && node.id.name) {\n                    return;\n                }\n\n                // Skip generators.\n                if (node.generator) {\n                    return;\n                }\n\n                // Skip recursive functions.\n                const nameVar = context.getDeclaredVariables(node)[0];\n\n                if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n                    return;\n                }\n\n                // Skip if it's using arguments.\n                const variable = getVariableOfArguments(context.getScope());\n\n                if (variable && variable.references.length > 0) {\n                    return;\n                }\n\n                // Reports if it's a callback which can replace with arrows.\n                const callbackInfo = getCallbackInfo(node);\n\n                if (callbackInfo.isCallback &&\n                    (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) &&\n                    !scopeInfo.super &&\n                    !scopeInfo.meta\n                ) {\n                    context.report({\n                        node,\n                        message: \"Unexpected function expression.\",\n                        fix(fixer) {\n                            if ((!callbackInfo.isLexicalThis && scopeInfo.this) || hasDuplicateParams(node.params)) {\n\n                                /*\n                                 * If the callback function does not have .bind(this) and contains a reference to `this`, there\n                                 * is no way to determine what `this` should be, so don't perform any fixes.\n                                 * If the callback function has duplicates in its list of parameters (possible in sloppy mode),\n                                 * don't replace it with an arrow function, because this is a SyntaxError with arrow functions.\n                                 */\n                                return null;\n                            }\n\n                            const paramsLeftParen = node.params.length ? sourceCode.getTokenBefore(node.params[0]) : sourceCode.getTokenBefore(node.body, 1);\n                            const paramsRightParen = sourceCode.getTokenBefore(node.body);\n                            const asyncKeyword = node.async ? \"async \" : \"\";\n                            const paramsFullText = sourceCode.text.slice(paramsLeftParen.range[0], paramsRightParen.range[1]);\n                            const arrowFunctionText = `${asyncKeyword}${paramsFullText} => ${sourceCode.getText(node.body)}`;\n\n                            /*\n                             * If the callback function has `.bind(this)`, replace it with an arrow function and remove the binding.\n                             * Otherwise, just replace the arrow function itself.\n                             */\n                            const replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;\n\n                            /*\n                             * If the replaced node is part of a BinaryExpression, LogicalExpression, or MemberExpression, then\n                             * the arrow function needs to be parenthesized, because `foo || () => {}` is invalid syntax even\n                             * though `foo || function() {}` is valid.\n                             */\n                            const needsParens = replacedNode.parent.type !== \"CallExpression\" && replacedNode.parent.type !== \"ConditionalExpression\";\n                            const replacementText = needsParens ? `(${arrowFunctionText})` : arrowFunctionText;\n\n                            return fixer.replaceText(replacedNode, replacementText);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A rule to suggest using of const declaration for variables that are never reassigned after declared.\n * @author Toru Nagashima\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst PATTERN_TYPE = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/u;\nconst DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|SwitchCase)$/u;\nconst DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/u;\n\n/**\n * Checks whether a given node is located at `ForStatement.init` or not.\n *\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is located at `ForStatement.init`.\n */\nfunction isInitOfForStatement(node) {\n    return node.parent.type === \"ForStatement\" && node.parent.init === node;\n}\n\n/**\n * Checks whether a given Identifier node becomes a VariableDeclaration or not.\n *\n * @param {ASTNode} identifier - An Identifier node to check.\n * @returns {boolean} `true` if the node can become a VariableDeclaration.\n */\nfunction canBecomeVariableDeclaration(identifier) {\n    let node = identifier.parent;\n\n    while (PATTERN_TYPE.test(node.type)) {\n        node = node.parent;\n    }\n\n    return (\n        node.type === \"VariableDeclarator\" ||\n        (\n            node.type === \"AssignmentExpression\" &&\n            node.parent.type === \"ExpressionStatement\" &&\n            DECLARATION_HOST_TYPE.test(node.parent.parent.type)\n        )\n    );\n}\n\n/**\n * Checks if an property or element is from outer scope or function parameters\n * in destructing pattern.\n *\n * @param {string} name - A variable name to be checked.\n * @param {eslint-scope.Scope} initScope - A scope to start find.\n * @returns {boolean} Indicates if the variable is from outer scope or function parameters.\n */\nfunction isOuterVariableInDestructing(name, initScope) {\n\n    if (initScope.through.find(ref => ref.resolved && ref.resolved.name === name)) {\n        return true;\n    }\n\n    const variable = astUtils.getVariableByName(initScope, name);\n\n    if (variable !== null) {\n        return variable.defs.some(def => def.type === \"Parameter\");\n    }\n\n    return false;\n}\n\n/**\n * Gets the VariableDeclarator/AssignmentExpression node that a given reference\n * belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n *\n * @param {eslint-scope.Reference} reference - A reference to get.\n * @returns {ASTNode|null} A VariableDeclarator/AssignmentExpression node or\n *      null.\n */\nfunction getDestructuringHost(reference) {\n    if (!reference.isWrite()) {\n        return null;\n    }\n    let node = reference.identifier.parent;\n\n    while (PATTERN_TYPE.test(node.type)) {\n        node = node.parent;\n    }\n\n    if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {\n        return null;\n    }\n    return node;\n}\n\n/**\n * Determines if a destructuring assignment node contains\n * any MemberExpression nodes. This is used to determine if a\n * variable that is only written once using destructuring can be\n * safely converted into a const declaration.\n * @param {ASTNode} node The ObjectPattern or ArrayPattern node to check.\n * @returns {boolean} True if the destructuring pattern contains\n *      a MemberExpression, false if not.\n */\nfunction hasMemberExpressionAssignment(node) {\n    switch (node.type) {\n        case \"ObjectPattern\":\n            return node.properties.some(prop => {\n                if (prop) {\n\n                    /*\n                     * Spread elements have an argument property while\n                     * others have a value property. Because different\n                     * parsers use different node types for spread elements,\n                     * we just check if there is an argument property.\n                     */\n                    return hasMemberExpressionAssignment(prop.argument || prop.value);\n                }\n\n                return false;\n            });\n\n        case \"ArrayPattern\":\n            return node.elements.some(element => {\n                if (element) {\n                    return hasMemberExpressionAssignment(element);\n                }\n\n                return false;\n            });\n\n        case \"AssignmentPattern\":\n            return hasMemberExpressionAssignment(node.left);\n\n        case \"MemberExpression\":\n            return true;\n\n        // no default\n    }\n\n    return false;\n}\n\n/**\n * Gets an identifier node of a given variable.\n *\n * If the initialization exists or one or more reading references exist before\n * the first assignment, the identifier node is the node of the declaration.\n * Otherwise, the identifier node is the node of the first assignment.\n *\n * If the variable should not change to const, this function returns null.\n * - If the variable is reassigned.\n * - If the variable is never initialized nor assigned.\n * - If the variable is initialized in a different scope from the declaration.\n * - If the unique assignment of the variable cannot change to a declaration.\n *   e.g. `if (a) b = 1` / `return (b = 1)`\n * - If the variable is declared in the global scope and `eslintUsed` is `true`.\n *   `/*exported foo` directive comment makes such variables. This rule does not\n *   warn such variables because this rule cannot distinguish whether the\n *   exported variables are reassigned or not.\n *\n * @param {eslint-scope.Variable} variable - A variable to get.\n * @param {boolean} ignoreReadBeforeAssign -\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {ASTNode|null}\n *      An Identifier node if the variable should change to const.\n *      Otherwise, null.\n */\nfunction getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {\n    if (variable.eslintUsed && variable.scope.type === \"global\") {\n        return null;\n    }\n\n    // Finds the unique WriteReference.\n    let writer = null;\n    let isReadBeforeInit = false;\n    const references = variable.references;\n\n    for (let i = 0; i < references.length; ++i) {\n        const reference = references[i];\n\n        if (reference.isWrite()) {\n            const isReassigned = (\n                writer !== null &&\n                writer.identifier !== reference.identifier\n            );\n\n            if (isReassigned) {\n                return null;\n            }\n\n            const destructuringHost = getDestructuringHost(reference);\n\n            if (destructuringHost !== null && destructuringHost.left !== void 0) {\n                const leftNode = destructuringHost.left;\n                let hasOuterVariables = false,\n                    hasNonIdentifiers = false;\n\n                if (leftNode.type === \"ObjectPattern\") {\n                    const properties = leftNode.properties;\n\n                    hasOuterVariables = properties\n                        .filter(prop => prop.value)\n                        .map(prop => prop.value.name)\n                        .some(name => isOuterVariableInDestructing(name, variable.scope));\n\n                    hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n\n                } else if (leftNode.type === \"ArrayPattern\") {\n                    const elements = leftNode.elements;\n\n                    hasOuterVariables = elements\n                        .map(element => element && element.name)\n                        .some(name => isOuterVariableInDestructing(name, variable.scope));\n\n                    hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n                }\n\n                if (hasOuterVariables || hasNonIdentifiers) {\n                    return null;\n                }\n\n            }\n\n            writer = reference;\n\n        } else if (reference.isRead() && writer === null) {\n            if (ignoreReadBeforeAssign) {\n                return null;\n            }\n            isReadBeforeInit = true;\n        }\n    }\n\n    /*\n     * If the assignment is from a different scope, ignore it.\n     * If the assignment cannot change to a declaration, ignore it.\n     */\n    const shouldBeConst = (\n        writer !== null &&\n        writer.from === variable.scope &&\n        canBecomeVariableDeclaration(writer.identifier)\n    );\n\n    if (!shouldBeConst) {\n        return null;\n    }\n\n    if (isReadBeforeInit) {\n        return variable.defs[0].name;\n    }\n\n    return writer.identifier;\n}\n\n/**\n * Groups by the VariableDeclarator/AssignmentExpression node that each\n * reference of given variables belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n *\n * @param {eslint-scope.Variable[]} variables - Variables to group by destructuring.\n * @param {boolean} ignoreReadBeforeAssign -\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {Map<ASTNode, ASTNode[]>} Grouped identifier nodes.\n */\nfunction groupByDestructuring(variables, ignoreReadBeforeAssign) {\n    const identifierMap = new Map();\n\n    for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i];\n        const references = variable.references;\n        const identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);\n        let prevId = null;\n\n        for (let j = 0; j < references.length; ++j) {\n            const reference = references[j];\n            const id = reference.identifier;\n\n            /*\n             * Avoid counting a reference twice or more for default values of\n             * destructuring.\n             */\n            if (id === prevId) {\n                continue;\n            }\n            prevId = id;\n\n            // Add the identifier node into the destructuring group.\n            const group = getDestructuringHost(reference);\n\n            if (group) {\n                if (identifierMap.has(group)) {\n                    identifierMap.get(group).push(identifier);\n                } else {\n                    identifierMap.set(group, [identifier]);\n                }\n            }\n        }\n    }\n\n    return identifierMap;\n}\n\n/**\n * Finds the nearest parent of node with a given type.\n *\n * @param {ASTNode} node – The node to search from.\n * @param {string} type – The type field of the parent node.\n * @param {Function} shouldStop – a predicate that returns true if the traversal should stop, and false otherwise.\n * @returns {ASTNode} The closest ancestor with the specified type; null if no such ancestor exists.\n */\nfunction findUp(node, type, shouldStop) {\n    if (!node || shouldStop(node)) {\n        return null;\n    }\n    if (node.type === type) {\n        return node;\n    }\n    return findUp(node.parent, type, shouldStop);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `const` declarations for variables that are never reassigned after declared\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-const\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    destructuring: { enum: [\"any\", \"all\"], default: \"any\" },\n                    ignoreReadBeforeAssign: { type: \"boolean\", default: false }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            useConst: \"'{{name}}' is never reassigned. Use 'const' instead.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const sourceCode = context.getSourceCode();\n        const shouldMatchAnyDestructuredVariable = options.destructuring !== \"all\";\n        const ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;\n        const variables = [];\n        let reportCount = 0;\n        let name = \"\";\n\n        /**\n         * Reports given identifier nodes if all of the nodes should be declared\n         * as const.\n         *\n         * The argument 'nodes' is an array of Identifier nodes.\n         * This node is the result of 'getIdentifierIfShouldBeConst()', so it's\n         * nullable. In simple declaration or assignment cases, the length of\n         * the array is 1. In destructuring cases, the length of the array can\n         * be 2 or more.\n         *\n         * @param {(eslint-scope.Reference|null)[]} nodes -\n         *      References which are grouped by destructuring to report.\n         * @returns {void}\n         */\n        function checkGroup(nodes) {\n            const nodesToReport = nodes.filter(Boolean);\n\n            if (nodes.length && (shouldMatchAnyDestructuredVariable || nodesToReport.length === nodes.length)) {\n                const varDeclParent = findUp(nodes[0], \"VariableDeclaration\", parentNode => parentNode.type.endsWith(\"Statement\"));\n                const isVarDecParentNull = varDeclParent === null;\n\n                if (!isVarDecParentNull && varDeclParent.declarations.length > 0) {\n                    const firstDeclaration = varDeclParent.declarations[0];\n\n                    if (firstDeclaration.init) {\n                        const firstDecParent = firstDeclaration.init.parent;\n\n                        /*\n                         * First we check the declaration type and then depending on\n                         * if the type is a \"VariableDeclarator\" or its an \"ObjectPattern\"\n                         * we compare the name from the first identifier, if the names are different\n                         * we assign the new name and reset the count of reportCount and nodeCount in\n                         * order to check each block for the number of reported errors and base our fix\n                         * based on comparing nodes.length and nodesToReport.length.\n                         */\n\n                        if (firstDecParent.type === \"VariableDeclarator\") {\n\n                            if (firstDecParent.id.name !== name) {\n                                name = firstDecParent.id.name;\n                                reportCount = 0;\n                            }\n\n                            if (firstDecParent.id.type === \"ObjectPattern\") {\n                                if (firstDecParent.init.name !== name) {\n                                    name = firstDecParent.init.name;\n                                    reportCount = 0;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                let shouldFix = varDeclParent &&\n\n                    // Don't do a fix unless the variable is initialized (or it's in a for-in or for-of loop)\n                    (varDeclParent.parent.type === \"ForInStatement\" || varDeclParent.parent.type === \"ForOfStatement\" || varDeclParent.declarations[0].init) &&\n\n                    /*\n                     * If options.destructuring is \"all\", then this warning will not occur unless\n                     * every assignment in the destructuring should be const. In that case, it's safe\n                     * to apply the fix.\n                     */\n                    nodesToReport.length === nodes.length;\n\n                if (!isVarDecParentNull && varDeclParent.declarations && varDeclParent.declarations.length !== 1) {\n\n                    if (varDeclParent && varDeclParent.declarations && varDeclParent.declarations.length >= 1) {\n\n                        /*\n                         * Add nodesToReport.length to a count, then comparing the count to the length\n                         * of the declarations in the current block.\n                         */\n\n                        reportCount += nodesToReport.length;\n\n                        shouldFix = shouldFix && (reportCount === varDeclParent.declarations.length);\n                    }\n                }\n\n                nodesToReport.forEach(node => {\n                    context.report({\n                        node,\n                        messageId: \"useConst\",\n                        data: node,\n                        fix: shouldFix ? fixer => fixer.replaceText(sourceCode.getFirstToken(varDeclParent), \"const\") : null\n                    });\n                });\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(checkGroup);\n            },\n\n            VariableDeclaration(node) {\n                if (node.kind === \"let\" && !isInitOfForStatement(node)) {\n                    variables.push(...context.getDeclaredVariables(node));\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Prefer destructuring from arrays and objects\n * @author Alex LaFroscia\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require destructuring from arrays and/or objects\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-destructuring\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n\n                /*\n                 * old support {array: Boolean, object: Boolean}\n                 * new support {VariableDeclarator: {}, AssignmentExpression: {}}\n                 */\n                oneOf: [\n                    {\n                        type: \"object\",\n                        properties: {\n                            VariableDeclarator: {\n                                type: \"object\",\n                                properties: {\n                                    array: {\n                                        type: \"boolean\"\n                                    },\n                                    object: {\n                                        type: \"boolean\"\n                                    }\n                                },\n                                additionalProperties: false\n                            },\n                            AssignmentExpression: {\n                                type: \"object\",\n                                properties: {\n                                    array: {\n                                        type: \"boolean\"\n                                    },\n                                    object: {\n                                        type: \"boolean\"\n                                    }\n                                },\n                                additionalProperties: false\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            array: {\n                                type: \"boolean\"\n                            },\n                            object: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    enforceForRenamedProperties: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n    create(context) {\n\n        const enabledTypes = context.options[0];\n        const enforceForRenamedProperties = context.options[1] && context.options[1].enforceForRenamedProperties;\n        let normalizedOptions = {\n            VariableDeclarator: { array: true, object: true },\n            AssignmentExpression: { array: true, object: true }\n        };\n\n        if (enabledTypes) {\n            normalizedOptions = typeof enabledTypes.array !== \"undefined\" || typeof enabledTypes.object !== \"undefined\"\n                ? { VariableDeclarator: enabledTypes, AssignmentExpression: enabledTypes }\n                : enabledTypes;\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * @param {string} nodeType \"AssignmentExpression\" or \"VariableDeclarator\"\n         * @param {string} destructuringType \"array\" or \"object\"\n         * @returns {boolean} `true` if the destructuring type should be checked for the given node\n         */\n        function shouldCheck(nodeType, destructuringType) {\n            return normalizedOptions &&\n                normalizedOptions[nodeType] &&\n                normalizedOptions[nodeType][destructuringType];\n        }\n\n        /**\n         * Determines if the given node is accessing an array index\n         *\n         * This is used to differentiate array index access from object property\n         * access.\n         *\n         * @param {ASTNode} node the node to evaluate\n         * @returns {boolean} whether or not the node is an integer\n         */\n        function isArrayIndexAccess(node) {\n            return Number.isInteger(node.property.value);\n        }\n\n        /**\n         * Report that the given node should use destructuring\n         *\n         * @param {ASTNode} reportNode the node to report\n         * @param {string} type the type of destructuring that should have been done\n         * @param {Function|null} fix the fix function or null to pass to context.report\n         * @returns {void}\n         */\n        function report(reportNode, type, fix) {\n            context.report({\n                node: reportNode,\n                message: \"Use {{type}} destructuring.\",\n                data: { type },\n                fix\n            });\n        }\n\n        /**\n         * Determines if a node should be fixed into object destructuring\n         *\n         * The fixer only fixes the simplest case of object destructuring,\n         * like: `let x = a.x`;\n         *\n         * Assignment expression is not fixed.\n         * Array destructuring is not fixed.\n         * Renamed property is not fixed.\n         *\n         * @param {ASTNode} node the the node to evaluate\n         * @returns {boolean} whether or not the node should be fixed\n         */\n        function shouldFix(node) {\n            return node.type === \"VariableDeclarator\" &&\n                node.id.type === \"Identifier\" &&\n                node.init.type === \"MemberExpression\" &&\n                node.id.name === node.init.property.name;\n        }\n\n        /**\n         * Fix a node into object destructuring.\n         * This function only handles the simplest case of object destructuring,\n         * see {@link shouldFix}.\n         *\n         * @param {SourceCodeFixer} fixer the fixer object\n         * @param {ASTNode} node the node to be fixed.\n         * @returns {Object} a fix for the node\n         */\n        function fixIntoObjectDestructuring(fixer, node) {\n            const rightNode = node.init;\n            const sourceCode = context.getSourceCode();\n\n            return fixer.replaceText(\n                node,\n                `{${rightNode.property.name}} = ${sourceCode.getText(rightNode.object)}`\n            );\n        }\n\n        /**\n         * Check that the `prefer-destructuring` rules are followed based on the\n         * given left- and right-hand side of the assignment.\n         *\n         * Pulled out into a separate method so that VariableDeclarators and\n         * AssignmentExpressions can share the same verification logic.\n         *\n         * @param {ASTNode} leftNode the left-hand side of the assignment\n         * @param {ASTNode} rightNode the right-hand side of the assignment\n         * @param {ASTNode} reportNode the node to report the error on\n         * @returns {void}\n         */\n        function performCheck(leftNode, rightNode, reportNode) {\n            if (rightNode.type !== \"MemberExpression\" || rightNode.object.type === \"Super\") {\n                return;\n            }\n\n            if (isArrayIndexAccess(rightNode)) {\n                if (shouldCheck(reportNode.type, \"array\")) {\n                    report(reportNode, \"array\", null);\n                }\n                return;\n            }\n\n            const fix = shouldFix(reportNode)\n                ? fixer => fixIntoObjectDestructuring(fixer, reportNode)\n                : null;\n\n            if (shouldCheck(reportNode.type, \"object\") && enforceForRenamedProperties) {\n                report(reportNode, \"object\", fix);\n                return;\n            }\n\n            if (shouldCheck(reportNode.type, \"object\")) {\n                const property = rightNode.property;\n\n                if (\n                    (property.type === \"Literal\" && leftNode.name === property.value) ||\n                    (property.type === \"Identifier\" && leftNode.name === property.name && !rightNode.computed)\n                ) {\n                    report(reportNode, \"object\", fix);\n                }\n            }\n        }\n\n        /**\n         * Check if a given variable declarator is coming from an property access\n         * that should be using destructuring instead\n         *\n         * @param {ASTNode} node the variable declarator to check\n         * @returns {void}\n         */\n        function checkVariableDeclarator(node) {\n\n            // Skip if variable is declared without assignment\n            if (!node.init) {\n                return;\n            }\n\n            // We only care about member expressions past this point\n            if (node.init.type !== \"MemberExpression\") {\n                return;\n            }\n\n            performCheck(node.id, node.init, node);\n        }\n\n        /**\n         * Run the `prefer-destructuring` check on an AssignmentExpression\n         *\n         * @param {ASTNode} node the AssignmentExpression node\n         * @returns {void}\n         */\n        function checkAssigmentExpression(node) {\n            if (node.operator === \"=\") {\n                performCheck(node.left, node.right, node);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclarator: checkVariableDeclarator,\n            AssignmentExpression: checkAssigmentExpression\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce requiring named capture groups in regular expression.\n * @author Pig Fang <https://github.com/g-plane>\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst {\n    CALL,\n    CONSTRUCT,\n    ReferenceTracker,\n    getStringIfConstant\n} = require(\"eslint-utils\");\nconst regexpp = require(\"regexpp\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst parser = new regexpp.RegExpParser();\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce using named capture group in regular expression\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-named-capture-group\"\n        },\n\n        schema: [],\n\n        messages: {\n            required: \"Capture group '{{group}}' should be converted to a named or non-capturing group.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Function to check regular expression.\n         *\n         * @param {string} regex The regular expression to be check.\n         * @param {ASTNode} node AST node which contains regular expression.\n         * @param {boolean} uFlag Flag indicates whether unicode mode is enabled or not.\n         * @returns {void}\n         */\n        function checkRegex(regex, node, uFlag) {\n            let ast;\n\n            try {\n                ast = parser.parsePattern(regex, 0, regex.length, uFlag);\n            } catch (_) {\n\n                // ignore regex syntax errors\n                return;\n            }\n\n            regexpp.visitRegExpAST(ast, {\n                onCapturingGroupEnter(group) {\n                    if (!group.name) {\n                        const locNode = node.type === \"Literal\" ? node : node.arguments[0];\n\n                        context.report({\n                            node,\n                            messageId: \"required\",\n                            loc: {\n                                start: {\n                                    line: locNode.loc.start.line,\n                                    column: locNode.loc.start.column + group.start + 1\n                                },\n                                end: {\n                                    line: locNode.loc.start.line,\n                                    column: locNode.loc.start.column + group.end + 1\n                                }\n                            },\n                            data: {\n                                group: group.raw\n                            }\n                        });\n                    }\n                }\n            });\n        }\n\n        return {\n            Literal(node) {\n                if (node.regex) {\n                    checkRegex(node.regex.pattern, node, node.regex.flags.includes(\"u\"));\n                }\n            },\n            Program() {\n                const scope = context.getScope();\n                const tracker = new ReferenceTracker(scope);\n                const traceMap = {\n                    RegExp: {\n                        [CALL]: true,\n                        [CONSTRUCT]: true\n                    }\n                };\n\n                for (const { node } of tracker.iterateGlobalReferences(traceMap)) {\n                    const regex = getStringIfConstant(node.arguments[0]);\n                    const flags = getStringIfConstant(node.arguments[1]);\n\n                    if (regex) {\n                        checkRegex(regex, node, flags && flags.includes(\"u\"));\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow `parseInt()` in favor of binary, octal, and hexadecimal literals\n * @author Annie Zhang, Henry Zhu\n */\n\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks to see if a CallExpression's callee node is `parseInt` or\n * `Number.parseInt`.\n * @param {ASTNode} calleeNode The callee node to evaluate.\n * @returns {boolean} True if the callee is `parseInt` or `Number.parseInt`,\n * false otherwise.\n */\nfunction isParseInt(calleeNode) {\n    switch (calleeNode.type) {\n        case \"Identifier\":\n            return calleeNode.name === \"parseInt\";\n        case \"MemberExpression\":\n            return calleeNode.object.type === \"Identifier\" &&\n                calleeNode.object.name === \"Number\" &&\n                calleeNode.property.type === \"Identifier\" &&\n                calleeNode.property.name === \"parseInt\";\n\n        // no default\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-numeric-literals\"\n        },\n\n        schema: [],\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const radixMap = {\n            2: \"binary\",\n            8: \"octal\",\n            16: \"hexadecimal\"\n        };\n\n        const prefixMap = {\n            2: \"0b\",\n            8: \"0o\",\n            16: \"0x\"\n        };\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n\n            CallExpression(node) {\n\n                // doesn't check parseInt() if it doesn't have a radix argument\n                if (node.arguments.length !== 2) {\n                    return;\n                }\n\n                // only error if the radix is 2, 8, or 16\n                const radixName = radixMap[node.arguments[1].value];\n\n                if (isParseInt(node.callee) &&\n                    radixName &&\n                    node.arguments[0].type === \"Literal\"\n                ) {\n                    context.report({\n                        node,\n                        message: \"Use {{radixName}} literals instead of {{functionName}}().\",\n                        data: {\n                            radixName,\n                            functionName: sourceCode.getText(node.callee)\n                        },\n                        fix(fixer) {\n                            const newPrefix = prefixMap[node.arguments[1].value];\n\n                            if (+(newPrefix + node.arguments[0].value) !== parseInt(node.arguments[0].value, node.arguments[1].value)) {\n\n                                /*\n                                 * If the newly-produced literal would be invalid, (e.g. 0b1234),\n                                 * or it would yield an incorrect parseInt result for some other reason, don't make a fix.\n                                 */\n                                return null;\n                            }\n                            return fixer.replaceText(node, prefixMap[node.arguments[1].value] + node.arguments[0].value);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Prefers object spread property over Object.assign\n * @author Sharmila Jesupaul\n * See LICENSE file in root directory for full license.\n */\n\n\n\nconst { CALL, ReferenceTracker } = require(\"eslint-utils\");\nconst {\n    isCommaToken,\n    isOpeningParenToken,\n    isClosingParenToken,\n    isParenthesised\n} = require(\"../util/ast-utils\");\n\nconst ANY_SPACE = /\\s/u;\n\n/**\n * Helper that checks if the Object.assign call has array spread\n * @param {ASTNode} node - The node that the rule warns on\n * @returns {boolean} - Returns true if the Object.assign call has array spread\n */\nfunction hasArraySpread(node) {\n    return node.arguments.some(arg => arg.type === \"SpreadElement\");\n}\n\n/**\n * Helper that checks if the node needs parentheses to be valid JS.\n * The default is to wrap the node in parentheses to avoid parsing errors.\n * @param {ASTNode} node - The node that the rule warns on\n * @param {Object} sourceCode - in context sourcecode object\n * @returns {boolean} - Returns true if the node needs parentheses\n */\nfunction needsParens(node, sourceCode) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"VariableDeclarator\":\n        case \"ArrayExpression\":\n        case \"ReturnStatement\":\n        case \"CallExpression\":\n        case \"Property\":\n            return false;\n        case \"AssignmentExpression\":\n            return parent.left === node && !isParenthesised(sourceCode, node);\n        default:\n            return !isParenthesised(sourceCode, node);\n    }\n}\n\n/**\n * Determines if an argument needs parentheses. The default is to not add parens.\n * @param {ASTNode} node - The node to be checked.\n * @param {Object} sourceCode - in context sourcecode object\n * @returns {boolean} True if the node needs parentheses\n */\nfunction argNeedsParens(node, sourceCode) {\n    switch (node.type) {\n        case \"AssignmentExpression\":\n        case \"ArrowFunctionExpression\":\n        case \"ConditionalExpression\":\n            return !isParenthesised(sourceCode, node);\n        default:\n            return false;\n    }\n}\n\n/**\n * Get the parenthesis tokens of a given ObjectExpression node.\n * This incldues the braces of the object literal and enclosing parentheses.\n * @param {ASTNode} node The node to get.\n * @param {Token} leftArgumentListParen The opening paren token of the argument list.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {Token[]} The parenthesis tokens of the node. This is sorted by the location.\n */\nfunction getParenTokens(node, leftArgumentListParen, sourceCode) {\n    const parens = [sourceCode.getFirstToken(node), sourceCode.getLastToken(node)];\n    let leftNext = sourceCode.getTokenBefore(node);\n    let rightNext = sourceCode.getTokenAfter(node);\n\n    // Note: don't include the parens of the argument list.\n    while (\n        leftNext &&\n        rightNext &&\n        leftNext.range[0] > leftArgumentListParen.range[0] &&\n        isOpeningParenToken(leftNext) &&\n        isClosingParenToken(rightNext)\n    ) {\n        parens.push(leftNext, rightNext);\n        leftNext = sourceCode.getTokenBefore(leftNext);\n        rightNext = sourceCode.getTokenAfter(rightNext);\n    }\n\n    return parens.sort((a, b) => a.range[0] - b.range[0]);\n}\n\n/**\n * Get the range of a given token and around whitespaces.\n * @param {Token} token The token to get range.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {number} The end of the range of the token and around whitespaces.\n */\nfunction getStartWithSpaces(token, sourceCode) {\n    const text = sourceCode.text;\n    let start = token.range[0];\n\n    // If the previous token is a line comment then skip this step to avoid commenting this token out.\n    {\n        const prevToken = sourceCode.getTokenBefore(token, { includeComments: true });\n\n        if (prevToken && prevToken.type === \"Line\") {\n            return start;\n        }\n    }\n\n    // Detect spaces before the token.\n    while (ANY_SPACE.test(text[start - 1] || \"\")) {\n        start -= 1;\n    }\n\n    return start;\n}\n\n/**\n * Get the range of a given token and around whitespaces.\n * @param {Token} token The token to get range.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {number} The start of the range of the token and around whitespaces.\n */\nfunction getEndWithSpaces(token, sourceCode) {\n    const text = sourceCode.text;\n    let end = token.range[1];\n\n    // Detect spaces after the token.\n    while (ANY_SPACE.test(text[end] || \"\")) {\n        end += 1;\n    }\n\n    return end;\n}\n\n/**\n * Autofixes the Object.assign call to use an object spread instead.\n * @param {ASTNode|null} node - The node that the rule warns on, i.e. the Object.assign call\n * @param {string} sourceCode - sourceCode of the Object.assign call\n * @returns {Function} autofixer - replaces the Object.assign with a spread object.\n */\nfunction defineFixer(node, sourceCode) {\n    return function *(fixer) {\n        const leftParen = sourceCode.getTokenAfter(node.callee, isOpeningParenToken);\n        const rightParen = sourceCode.getLastToken(node);\n\n        // Remove the callee `Object.assign`\n        yield fixer.remove(node.callee);\n\n        // Replace the parens of argument list to braces.\n        if (needsParens(node, sourceCode)) {\n            yield fixer.replaceText(leftParen, \"({\");\n            yield fixer.replaceText(rightParen, \"})\");\n        } else {\n            yield fixer.replaceText(leftParen, \"{\");\n            yield fixer.replaceText(rightParen, \"}\");\n        }\n\n        // Process arguments.\n        for (const argNode of node.arguments) {\n            const innerParens = getParenTokens(argNode, leftParen, sourceCode);\n            const left = innerParens.shift();\n            const right = innerParens.pop();\n\n            if (argNode.type === \"ObjectExpression\") {\n                const maybeTrailingComma = sourceCode.getLastToken(argNode, 1);\n                const maybeArgumentComma = sourceCode.getTokenAfter(right);\n\n                /*\n                 * Make bare this object literal.\n                 * And remove spaces inside of the braces for better formatting.\n                 */\n                for (const innerParen of innerParens) {\n                    yield fixer.remove(innerParen);\n                }\n                const leftRange = [left.range[0], getEndWithSpaces(left, sourceCode)];\n                const rightRange = [\n                    Math.max(getStartWithSpaces(right, sourceCode), leftRange[1]), // Ensure ranges don't overlap\n                    right.range[1]\n                ];\n\n                yield fixer.removeRange(leftRange);\n                yield fixer.removeRange(rightRange);\n\n                // Remove the comma of this argument if it's duplication.\n                if (\n                    (argNode.properties.length === 0 || isCommaToken(maybeTrailingComma)) &&\n                    isCommaToken(maybeArgumentComma)\n                ) {\n                    yield fixer.remove(maybeArgumentComma);\n                }\n            } else {\n\n                // Make spread.\n                if (argNeedsParens(argNode, sourceCode)) {\n                    yield fixer.insertTextBefore(left, \"...(\");\n                    yield fixer.insertTextAfter(right, \")\");\n                } else {\n                    yield fixer.insertTextBefore(left, \"...\");\n                }\n            }\n        }\n    };\n}\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description:\n                \"disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead.\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-object-spread\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            useSpreadMessage: \"Use an object spread instead of `Object.assign` eg: `{ ...foo }`.\",\n            useLiteralMessage: \"Use an object literal instead of `Object.assign`. eg: `{ foo: bar }`.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            Program() {\n                const scope = context.getScope();\n                const tracker = new ReferenceTracker(scope);\n                const trackMap = {\n                    Object: {\n                        assign: { [CALL]: true }\n                    }\n                };\n\n                // Iterate all calls of `Object.assign` (only of the global variable `Object`).\n                for (const { node } of tracker.iterateGlobalReferences(trackMap)) {\n                    if (\n                        node.arguments.length >= 1 &&\n                        node.arguments[0].type === \"ObjectExpression\" &&\n                        !hasArraySpread(node)\n                    ) {\n                        const messageId = node.arguments.length === 1\n                            ? \"useLiteralMessage\"\n                            : \"useSpreadMessage\";\n                        const fix = defineFixer(node, sourceCode);\n\n                        context.report({ node, messageId, fix });\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview restrict values that can be used as Promise rejection reasons\n * @author Teddy Katz\n */\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require using Error objects as Promise rejection reasons\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-promise-reject-errors\"\n        },\n\n        fixable: null,\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowEmptyReject: { type: \"boolean\", default: false }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const ALLOW_EMPTY_REJECT = context.options.length && context.options[0].allowEmptyReject;\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Checks the argument of a reject() or Promise.reject() CallExpression, and reports it if it can't be an Error\n         * @param {ASTNode} callExpression A CallExpression node which is used to reject a Promise\n         * @returns {void}\n         */\n        function checkRejectCall(callExpression) {\n            if (!callExpression.arguments.length && ALLOW_EMPTY_REJECT) {\n                return;\n            }\n            if (\n                !callExpression.arguments.length ||\n                !astUtils.couldBeError(callExpression.arguments[0]) ||\n                callExpression.arguments[0].type === \"Identifier\" && callExpression.arguments[0].name === \"undefined\"\n            ) {\n                context.report({\n                    node: callExpression,\n                    message: \"Expected the Promise rejection reason to be an Error.\"\n                });\n            }\n        }\n\n        /**\n         * Determines whether a function call is a Promise.reject() call\n         * @param {ASTNode} node A CallExpression node\n         * @returns {boolean} `true` if the call is a Promise.reject() call\n         */\n        function isPromiseRejectCall(node) {\n            return node.callee.type === \"MemberExpression\" &&\n                node.callee.object.type === \"Identifier\" && node.callee.object.name === \"Promise\" &&\n                node.callee.property.type === \"Identifier\" && node.callee.property.name === \"reject\";\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n\n            // Check `Promise.reject(value)` calls.\n            CallExpression(node) {\n                if (isPromiseRejectCall(node)) {\n                    checkRejectCall(node);\n                }\n            },\n\n            /*\n             * Check for `new Promise((resolve, reject) => {})`, and check for reject() calls.\n             * This function is run on \"NewExpression:exit\" instead of \"NewExpression\" to ensure that\n             * the nodes in the expression already have the `parent` property.\n             */\n            \"NewExpression:exit\"(node) {\n                if (\n                    node.callee.type === \"Identifier\" && node.callee.name === \"Promise\" &&\n                    node.arguments.length && astUtils.isFunction(node.arguments[0]) &&\n                    node.arguments[0].params.length > 1 && node.arguments[0].params[1].type === \"Identifier\"\n                ) {\n                    context.getDeclaredVariables(node.arguments[0])\n\n                        /*\n                         * Find the first variable that matches the second parameter's name.\n                         * If the first parameter has the same name as the second parameter, then the variable will actually\n                         * be \"declared\" when the first parameter is evaluated, but then it will be immediately overwritten\n                         * by the second parameter. It's not possible for an expression with the variable to be evaluated before\n                         * the variable is overwritten, because functions with duplicate parameters cannot have destructuring or\n                         * default assignments in their parameter lists. Therefore, it's not necessary to explicitly account for\n                         * this case.\n                         */\n                        .find(variable => variable.name === node.arguments[0].params[1].name)\n\n                        // Get the references to that variable.\n                        .references\n\n                        // Only check the references that read the parameter's value.\n                        .filter(ref => ref.isRead())\n\n                        // Only check the references that are used as the callee in a function call, e.g. `reject(foo)`.\n                        .filter(ref => ref.identifier.parent.type === \"CallExpression\" && ref.identifier === ref.identifier.parent.callee)\n\n                        // Check the argument of the function call to determine whether it's an Error.\n                        .forEach(ref => checkRejectCall(ref.identifier.parent));\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to suggest using \"Reflect\" api over Function/Object methods\n * @author Keith Cirkel <http://keithcirkel.co.uk>\n * @deprecated in ESLint v3.9.0\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `Reflect` methods where applicable\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-reflect\"\n        },\n\n        deprecated: true,\n\n        replacedBy: [],\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            enum: [\n                                \"apply\",\n                                \"call\",\n                                \"delete\",\n                                \"defineProperty\",\n                                \"getOwnPropertyDescriptor\",\n                                \"getPrototypeOf\",\n                                \"setPrototypeOf\",\n                                \"isExtensible\",\n                                \"getOwnPropertyNames\",\n                                \"preventExtensions\"\n                            ]\n                        },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const existingNames = {\n            apply: \"Function.prototype.apply\",\n            call: \"Function.prototype.call\",\n            defineProperty: \"Object.defineProperty\",\n            getOwnPropertyDescriptor: \"Object.getOwnPropertyDescriptor\",\n            getPrototypeOf: \"Object.getPrototypeOf\",\n            setPrototypeOf: \"Object.setPrototypeOf\",\n            isExtensible: \"Object.isExtensible\",\n            getOwnPropertyNames: \"Object.getOwnPropertyNames\",\n            preventExtensions: \"Object.preventExtensions\"\n        };\n\n        const reflectSubsitutes = {\n            apply: \"Reflect.apply\",\n            call: \"Reflect.apply\",\n            defineProperty: \"Reflect.defineProperty\",\n            getOwnPropertyDescriptor: \"Reflect.getOwnPropertyDescriptor\",\n            getPrototypeOf: \"Reflect.getPrototypeOf\",\n            setPrototypeOf: \"Reflect.setPrototypeOf\",\n            isExtensible: \"Reflect.isExtensible\",\n            getOwnPropertyNames: \"Reflect.getOwnPropertyNames\",\n            preventExtensions: \"Reflect.preventExtensions\"\n        };\n\n        const exceptions = (context.options[0] || {}).exceptions || [];\n\n        /**\n         * Reports the Reflect violation based on the `existing` and `substitute`\n         * @param {Object} node The node that violates the rule.\n         * @param {string} existing The existing method name that has been used.\n         * @param {string} substitute The Reflect substitute that should be used.\n         * @returns {void}\n         */\n        function report(node, existing, substitute) {\n            context.report({\n                node,\n                message: \"Avoid using {{existing}}, instead use {{substitute}}.\",\n                data: {\n                    existing,\n                    substitute\n                }\n            });\n        }\n\n        return {\n            CallExpression(node) {\n                const methodName = (node.callee.property || {}).name;\n                const isReflectCall = (node.callee.object || {}).name === \"Reflect\";\n                const hasReflectSubsitute = Object.prototype.hasOwnProperty.call(reflectSubsitutes, methodName);\n                const userConfiguredException = exceptions.indexOf(methodName) !== -1;\n\n                if (hasReflectSubsitute && !isReflectCall && !userConfiguredException) {\n                    report(node, existingNames[methodName], reflectSubsitutes[methodName]);\n                }\n            },\n            UnaryExpression(node) {\n                const isDeleteOperator = node.operator === \"delete\";\n                const targetsIdentifier = node.argument.type === \"Identifier\";\n                const userConfiguredException = exceptions.indexOf(\"delete\") !== -1;\n\n                if (isDeleteOperator && !targetsIdentifier && !userConfiguredException) {\n                    report(node, \"the delete keyword\", \"Reflect.deleteProperty\");\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the variable object of `arguments` which is defined implicitly.\n * @param {eslint-scope.Scope} scope - A scope to get.\n * @returns {eslint-scope.Variable} The found variable object.\n */\nfunction getVariableOfArguments(scope) {\n    const variables = scope.variables;\n\n    for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i];\n\n        if (variable.name === \"arguments\") {\n\n            /*\n             * If there was a parameter which is named \"arguments\", the implicit \"arguments\" is not defined.\n             * So does fast return with null.\n             */\n            return (variable.identifiers.length === 0) ? variable : null;\n        }\n    }\n\n    /* istanbul ignore next : unreachable */\n    return null;\n}\n\n/**\n * Checks if the given reference is not normal member access.\n *\n * - arguments         .... true    // not member access\n * - arguments[i]      .... true    // computed member access\n * - arguments[0]      .... true    // computed member access\n * - arguments.length  .... false   // normal member access\n *\n * @param {eslint-scope.Reference} reference - The reference to check.\n * @returns {boolean} `true` if the reference is not normal member access.\n */\nfunction isNotNormalMemberAccess(reference) {\n    const id = reference.identifier;\n    const parent = id.parent;\n\n    return !(\n        parent.type === \"MemberExpression\" &&\n        parent.object === id &&\n        !parent.computed\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require rest parameters instead of `arguments`\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-rest-params\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Reports a given reference.\n         *\n         * @param {eslint-scope.Reference} reference - A reference to report.\n         * @returns {void}\n         */\n        function report(reference) {\n            context.report({\n                node: reference.identifier,\n                loc: reference.identifier.loc,\n                message: \"Use the rest parameters instead of 'arguments'.\"\n            });\n        }\n\n        /**\n         * Reports references of the implicit `arguments` variable if exist.\n         *\n         * @returns {void}\n         */\n        function checkForArguments() {\n            const argumentsVar = getVariableOfArguments(context.getScope());\n\n            if (argumentsVar) {\n                argumentsVar\n                    .references\n                    .filter(isNotNormalMemberAccess)\n                    .forEach(report);\n            }\n        }\n\n        return {\n            \"FunctionDeclaration:exit\": checkForArguments,\n            \"FunctionExpression:exit\": checkForArguments\n        };\n    }\n};\n","/**\n * @fileoverview A rule to suggest using of the spread operator instead of `.apply()`.\n * @author Toru Nagashima\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a node is a `.apply()` for variadic.\n * @param {ASTNode} node - A CallExpression node to check.\n * @returns {boolean} Whether or not the node is a `.apply()` for variadic.\n */\nfunction isVariadicApplyCalling(node) {\n    return (\n        node.callee.type === \"MemberExpression\" &&\n        node.callee.property.type === \"Identifier\" &&\n        node.callee.property.name === \"apply\" &&\n        node.callee.computed === false &&\n        node.arguments.length === 2 &&\n        node.arguments[1].type !== \"ArrayExpression\" &&\n        node.arguments[1].type !== \"SpreadElement\"\n    );\n}\n\n\n/**\n * Checks whether or not `thisArg` is not changed by `.apply()`.\n * @param {ASTNode|null} expectedThis - The node that is the owner of the applied function.\n * @param {ASTNode} thisArg - The node that is given to the first argument of the `.apply()`.\n * @param {RuleContext} context - The ESLint rule context object.\n * @returns {boolean} Whether or not `thisArg` is not changed by `.apply()`.\n */\nfunction isValidThisArg(expectedThis, thisArg, context) {\n    if (!expectedThis) {\n        return astUtils.isNullOrUndefined(thisArg);\n    }\n    return astUtils.equalTokens(expectedThis, thisArg, context);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require spread operators instead of `.apply()`\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-spread\"\n        },\n\n        schema: [],\n        fixable: null\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            CallExpression(node) {\n                if (!isVariadicApplyCalling(node)) {\n                    return;\n                }\n\n                const applied = node.callee.object;\n                const expectedThis = (applied.type === \"MemberExpression\") ? applied.object : null;\n                const thisArg = node.arguments[0];\n\n                if (isValidThisArg(expectedThis, thisArg, sourceCode)) {\n                    context.report({\n                        node,\n                        message: \"Use the spread operator instead of '.apply()'.\"\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A rule to suggest using template literals instead of string concatenation.\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a concatenation.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a concatenation.\n */\nfunction isConcatenation(node) {\n    return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n\n/**\n * Gets the top binary expression node for concatenation in parents of a given node.\n * @param {ASTNode} node - A node to get.\n * @returns {ASTNode} the top binary expression node in parents of a given node.\n */\nfunction getTopConcatBinaryExpression(node) {\n    let currentNode = node;\n\n    while (isConcatenation(currentNode.parent)) {\n        currentNode = currentNode.parent;\n    }\n    return currentNode;\n}\n\n/**\n * Determines whether a given node is a octal escape sequence\n * @param {ASTNode} node A node to check\n * @returns {boolean} `true` if the node is an octal escape sequence\n */\nfunction isOctalEscapeSequence(node) {\n\n    // No need to check TemplateLiterals – would throw error with octal escape\n    const isStringLiteral = node.type === \"Literal\" && typeof node.value === \"string\";\n\n    if (!isStringLiteral) {\n        return false;\n    }\n\n    const match = node.raw.match(/^([^\\\\]|\\\\[^0-7])*\\\\([0-7]{1,3})/u);\n\n    if (match) {\n\n        // \\0 is actually not considered an octal\n        if (match[2] !== \"0\" || typeof match[3] !== \"undefined\") {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Checks whether or not a node contains a octal escape sequence\n * @param {ASTNode} node A node to check\n * @returns {boolean} `true` if the node contains an octal escape sequence\n */\nfunction hasOctalEscapeSequence(node) {\n    if (isConcatenation(node)) {\n        return hasOctalEscapeSequence(node.left) || hasOctalEscapeSequence(node.right);\n    }\n\n    return isOctalEscapeSequence(node);\n}\n\n/**\n * Checks whether or not a given binary expression has string literals.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node has string literals.\n */\nfunction hasStringLiteral(node) {\n    if (isConcatenation(node)) {\n\n        // `left` is deeper than `right` normally.\n        return hasStringLiteral(node.right) || hasStringLiteral(node.left);\n    }\n    return astUtils.isStringLiteral(node);\n}\n\n/**\n * Checks whether or not a given binary expression has non string literals.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node has non string literals.\n */\nfunction hasNonStringLiteral(node) {\n    if (isConcatenation(node)) {\n\n        // `left` is deeper than `right` normally.\n        return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);\n    }\n    return !astUtils.isStringLiteral(node);\n}\n\n/**\n * Determines whether a given node will start with a template curly expression (`${}`) when being converted to a template literal.\n * @param {ASTNode} node The node that will be fixed to a template literal\n * @returns {boolean} `true` if the node will start with a template curly.\n */\nfunction startsWithTemplateCurly(node) {\n    if (node.type === \"BinaryExpression\") {\n        return startsWithTemplateCurly(node.left);\n    }\n    if (node.type === \"TemplateLiteral\") {\n        return node.expressions.length && node.quasis.length && node.quasis[0].range[0] === node.quasis[0].range[1];\n    }\n    return node.type !== \"Literal\" || typeof node.value !== \"string\";\n}\n\n/**\n * Determines whether a given node end with a template curly expression (`${}`) when being converted to a template literal.\n * @param {ASTNode} node The node that will be fixed to a template literal\n * @returns {boolean} `true` if the node will end with a template curly.\n */\nfunction endsWithTemplateCurly(node) {\n    if (node.type === \"BinaryExpression\") {\n        return startsWithTemplateCurly(node.right);\n    }\n    if (node.type === \"TemplateLiteral\") {\n        return node.expressions.length && node.quasis.length && node.quasis[node.quasis.length - 1].range[0] === node.quasis[node.quasis.length - 1].range[1];\n    }\n    return node.type !== \"Literal\" || typeof node.value !== \"string\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require template literals instead of string concatenation\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-template\"\n        },\n\n        schema: [],\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        let done = Object.create(null);\n\n        /**\n         * Gets the non-token text between two nodes, ignoring any other tokens that appear between the two tokens.\n         * @param {ASTNode} node1 The first node\n         * @param {ASTNode} node2 The second node\n         * @returns {string} The text between the nodes, excluding other tokens\n         */\n        function getTextBetween(node1, node2) {\n            const allTokens = [node1].concat(sourceCode.getTokensBetween(node1, node2)).concat(node2);\n            const sourceText = sourceCode.getText();\n\n            return allTokens.slice(0, -1).reduce((accumulator, token, index) => accumulator + sourceText.slice(token.range[1], allTokens[index + 1].range[0]), \"\");\n        }\n\n        /**\n         * Returns a template literal form of the given node.\n         * @param {ASTNode} currentNode A node that should be converted to a template literal\n         * @param {string} textBeforeNode Text that should appear before the node\n         * @param {string} textAfterNode Text that should appear after the node\n         * @returns {string} A string form of this node, represented as a template literal\n         */\n        function getTemplateLiteral(currentNode, textBeforeNode, textAfterNode) {\n            if (currentNode.type === \"Literal\" && typeof currentNode.value === \"string\") {\n\n                /*\n                 * If the current node is a string literal, escape any instances of ${ or ` to prevent them from being interpreted\n                 * as a template placeholder. However, if the code already contains a backslash before the ${ or `\n                 * for some reason, don't add another backslash, because that would change the meaning of the code (it would cause\n                 * an actual backslash character to appear before the dollar sign).\n                 */\n                return `\\`${currentNode.raw.slice(1, -1).replace(/\\\\*(\\$\\{|`)/gu, matched => {\n                    if (matched.lastIndexOf(\"\\\\\") % 2) {\n                        return `\\\\${matched}`;\n                    }\n                    return matched;\n\n                // Unescape any quotes that appear in the original Literal that no longer need to be escaped.\n                }).replace(new RegExp(`\\\\\\\\${currentNode.raw[0]}`, \"gu\"), currentNode.raw[0])}\\``;\n            }\n\n            if (currentNode.type === \"TemplateLiteral\") {\n                return sourceCode.getText(currentNode);\n            }\n\n            if (isConcatenation(currentNode) && hasStringLiteral(currentNode) && hasNonStringLiteral(currentNode)) {\n                const plusSign = sourceCode.getFirstTokenBetween(currentNode.left, currentNode.right, token => token.value === \"+\");\n                const textBeforePlus = getTextBetween(currentNode.left, plusSign);\n                const textAfterPlus = getTextBetween(plusSign, currentNode.right);\n                const leftEndsWithCurly = endsWithTemplateCurly(currentNode.left);\n                const rightStartsWithCurly = startsWithTemplateCurly(currentNode.right);\n\n                if (leftEndsWithCurly) {\n\n                    // If the left side of the expression ends with a template curly, add the extra text to the end of the curly bracket.\n                    // `foo${bar}` /* comment */ + 'baz' --> `foo${bar /* comment */  }${baz}`\n                    return getTemplateLiteral(currentNode.left, textBeforeNode, textBeforePlus + textAfterPlus).slice(0, -1) +\n                        getTemplateLiteral(currentNode.right, null, textAfterNode).slice(1);\n                }\n                if (rightStartsWithCurly) {\n\n                    // Otherwise, if the right side of the expression starts with a template curly, add the text there.\n                    // 'foo' /* comment */ + `${bar}baz` --> `foo${ /* comment */  bar}baz`\n                    return getTemplateLiteral(currentNode.left, textBeforeNode, null).slice(0, -1) +\n                        getTemplateLiteral(currentNode.right, textBeforePlus + textAfterPlus, textAfterNode).slice(1);\n                }\n\n                /*\n                 * Otherwise, these nodes should not be combined into a template curly, since there is nowhere to put\n                 * the text between them.\n                 */\n                return `${getTemplateLiteral(currentNode.left, textBeforeNode, null)}${textBeforePlus}+${textAfterPlus}${getTemplateLiteral(currentNode.right, textAfterNode, null)}`;\n            }\n\n            return `\\`\\${${textBeforeNode || \"\"}${sourceCode.getText(currentNode)}${textAfterNode || \"\"}}\\``;\n        }\n\n        /**\n         * Returns a fixer object that converts a non-string binary expression to a template literal\n         * @param {SourceCodeFixer} fixer The fixer object\n         * @param {ASTNode} node A node that should be converted to a template literal\n         * @returns {Object} A fix for this binary expression\n         */\n        function fixNonStringBinaryExpression(fixer, node) {\n            const topBinaryExpr = getTopConcatBinaryExpression(node.parent);\n\n            if (hasOctalEscapeSequence(topBinaryExpr)) {\n                return null;\n            }\n\n            return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));\n        }\n\n        /**\n         * Reports if a given node is string concatenation with non string literals.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {void}\n         */\n        function checkForStringConcat(node) {\n            if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {\n                return;\n            }\n\n            const topBinaryExpr = getTopConcatBinaryExpression(node.parent);\n\n            // Checks whether or not this node had been checked already.\n            if (done[topBinaryExpr.range[0]]) {\n                return;\n            }\n            done[topBinaryExpr.range[0]] = true;\n\n            if (hasNonStringLiteral(topBinaryExpr)) {\n                context.report({\n                    node: topBinaryExpr,\n                    message: \"Unexpected string concatenation.\",\n                    fix: fixer => fixNonStringBinaryExpression(fixer, node)\n                });\n            }\n        }\n\n        return {\n            Program() {\n                done = Object.create(null);\n            },\n\n            Literal: checkForStringConcat,\n            TemplateLiteral: checkForStringConcat\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag non-quoted property names in object literals.\n * @author Mathias Bynens <http://mathiasbynens.be/>\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst espree = require(\"espree\"),\n    keywords = require(\"../util/keywords\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require quotes around object literal property names\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/quote-props\"\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                keywords: {\n                                    type: \"boolean\"\n                                },\n                                unnecessary: {\n                                    type: \"boolean\"\n                                },\n                                numbers: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const MODE = context.options[0],\n            KEYWORDS = context.options[1] && context.options[1].keywords,\n            CHECK_UNNECESSARY = !context.options[1] || context.options[1].unnecessary !== false,\n            NUMBERS = context.options[1] && context.options[1].numbers,\n\n            MESSAGE_UNNECESSARY = \"Unnecessarily quoted property '{{property}}' found.\",\n            MESSAGE_UNQUOTED = \"Unquoted property '{{property}}' found.\",\n            MESSAGE_NUMERIC = \"Unquoted number literal '{{property}}' used as key.\",\n            MESSAGE_RESERVED = \"Unquoted reserved word '{{property}}' used as key.\",\n            sourceCode = context.getSourceCode();\n\n\n        /**\n         * Checks whether a certain string constitutes an ES3 token\n         * @param   {string} tokenStr - The string to be checked.\n         * @returns {boolean} `true` if it is an ES3 token.\n         */\n        function isKeyword(tokenStr) {\n            return keywords.indexOf(tokenStr) >= 0;\n        }\n\n        /**\n         * Checks if an espree-tokenized key has redundant quotes (i.e. whether quotes are unnecessary)\n         * @param   {string} rawKey The raw key value from the source\n         * @param   {espreeTokens} tokens The espree-tokenized node key\n         * @param   {boolean} [skipNumberLiterals=false] Indicates whether number literals should be checked\n         * @returns {boolean} Whether or not a key has redundant quotes.\n         * @private\n         */\n        function areQuotesRedundant(rawKey, tokens, skipNumberLiterals) {\n            return tokens.length === 1 && tokens[0].start === 0 && tokens[0].end === rawKey.length &&\n                ([\"Identifier\", \"Keyword\", \"Null\", \"Boolean\"].indexOf(tokens[0].type) >= 0 ||\n                (tokens[0].type === \"Numeric\" && !skipNumberLiterals && String(+tokens[0].value) === tokens[0].value));\n        }\n\n        /**\n         * Returns a string representation of a property node with quotes removed\n         * @param {ASTNode} key Key AST Node, which may or may not be quoted\n         * @returns {string} A replacement string for this property\n         */\n        function getUnquotedKey(key) {\n            return key.type === \"Identifier\" ? key.name : key.value;\n        }\n\n        /**\n         * Returns a string representation of a property node with quotes added\n         * @param {ASTNode} key Key AST Node, which may or may not be quoted\n         * @returns {string} A replacement string for this property\n         */\n        function getQuotedKey(key) {\n            if (key.type === \"Literal\" && typeof key.value === \"string\") {\n\n                // If the key is already a string literal, don't replace the quotes with double quotes.\n                return sourceCode.getText(key);\n            }\n\n            // Otherwise, the key is either an identifier or a number literal.\n            return `\"${key.type === \"Identifier\" ? key.name : key.value}\"`;\n        }\n\n        /**\n         * Ensures that a property's key is quoted only when necessary\n         * @param   {ASTNode} node Property AST node\n         * @returns {void}\n         */\n        function checkUnnecessaryQuotes(node) {\n            const key = node.key;\n\n            if (node.method || node.computed || node.shorthand) {\n                return;\n            }\n\n            if (key.type === \"Literal\" && typeof key.value === \"string\") {\n                let tokens;\n\n                try {\n                    tokens = espree.tokenize(key.value);\n                } catch (e) {\n                    return;\n                }\n\n                if (tokens.length !== 1) {\n                    return;\n                }\n\n                const isKeywordToken = isKeyword(tokens[0].value);\n\n                if (isKeywordToken && KEYWORDS) {\n                    return;\n                }\n\n                if (CHECK_UNNECESSARY && areQuotesRedundant(key.value, tokens, NUMBERS)) {\n                    context.report({\n                        node,\n                        message: MESSAGE_UNNECESSARY,\n                        data: { property: key.value },\n                        fix: fixer => fixer.replaceText(key, getUnquotedKey(key))\n                    });\n                }\n            } else if (KEYWORDS && key.type === \"Identifier\" && isKeyword(key.name)) {\n                context.report({\n                    node,\n                    message: MESSAGE_RESERVED,\n                    data: { property: key.name },\n                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n                });\n            } else if (NUMBERS && key.type === \"Literal\" && typeof key.value === \"number\") {\n                context.report({\n                    node,\n                    message: MESSAGE_NUMERIC,\n                    data: { property: key.value },\n                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n                });\n            }\n        }\n\n        /**\n         * Ensures that a property's key is quoted\n         * @param   {ASTNode} node Property AST node\n         * @returns {void}\n         */\n        function checkOmittedQuotes(node) {\n            const key = node.key;\n\n            if (!node.method && !node.computed && !node.shorthand && !(key.type === \"Literal\" && typeof key.value === \"string\")) {\n                context.report({\n                    node,\n                    message: MESSAGE_UNQUOTED,\n                    data: { property: key.name || key.value },\n                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n                });\n            }\n        }\n\n        /**\n         * Ensures that an object's keys are consistently quoted, optionally checks for redundancy of quotes\n         * @param   {ASTNode} node Property AST node\n         * @param   {boolean} checkQuotesRedundancy Whether to check quotes' redundancy\n         * @returns {void}\n         */\n        function checkConsistency(node, checkQuotesRedundancy) {\n            const quotedProps = [],\n                unquotedProps = [];\n            let keywordKeyName = null,\n                necessaryQuotes = false;\n\n            node.properties.forEach(property => {\n                const key = property.key;\n\n                if (!key || property.method || property.computed || property.shorthand) {\n                    return;\n                }\n\n                if (key.type === \"Literal\" && typeof key.value === \"string\") {\n\n                    quotedProps.push(property);\n\n                    if (checkQuotesRedundancy) {\n                        let tokens;\n\n                        try {\n                            tokens = espree.tokenize(key.value);\n                        } catch (e) {\n                            necessaryQuotes = true;\n                            return;\n                        }\n\n                        necessaryQuotes = necessaryQuotes || !areQuotesRedundant(key.value, tokens) || KEYWORDS && isKeyword(tokens[0].value);\n                    }\n                } else if (KEYWORDS && checkQuotesRedundancy && key.type === \"Identifier\" && isKeyword(key.name)) {\n                    unquotedProps.push(property);\n                    necessaryQuotes = true;\n                    keywordKeyName = key.name;\n                } else {\n                    unquotedProps.push(property);\n                }\n            });\n\n            if (checkQuotesRedundancy && quotedProps.length && !necessaryQuotes) {\n                quotedProps.forEach(property => {\n                    context.report({\n                        node: property,\n                        message: \"Properties shouldn't be quoted as all quotes are redundant.\",\n                        fix: fixer => fixer.replaceText(property.key, getUnquotedKey(property.key))\n                    });\n                });\n            } else if (unquotedProps.length && keywordKeyName) {\n                unquotedProps.forEach(property => {\n                    context.report({\n                        node: property,\n                        message: \"Properties should be quoted as '{{property}}' is a reserved word.\",\n                        data: { property: keywordKeyName },\n                        fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\n                    });\n                });\n            } else if (quotedProps.length && unquotedProps.length) {\n                unquotedProps.forEach(property => {\n                    context.report({\n                        node: property,\n                        message: \"Inconsistently quoted property '{{key}}' found.\",\n                        data: { key: property.key.name || property.key.value },\n                        fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\n                    });\n                });\n            }\n        }\n\n        return {\n            Property(node) {\n                if (MODE === \"always\" || !MODE) {\n                    checkOmittedQuotes(node);\n                }\n                if (MODE === \"as-needed\") {\n                    checkUnnecessaryQuotes(node);\n                }\n            },\n            ObjectExpression(node) {\n                if (MODE === \"consistent\") {\n                    checkConsistency(node, false);\n                }\n                if (MODE === \"consistent-as-needed\") {\n                    checkConsistency(node, true);\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview A rule to choose between single and double quote marks\n * @author Matt DuVall <http://www.mattduvall.com/>, Brandon Payton\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst QUOTE_SETTINGS = {\n    double: {\n        quote: \"\\\"\",\n        alternateQuote: \"'\",\n        description: \"doublequote\"\n    },\n    single: {\n        quote: \"'\",\n        alternateQuote: \"\\\"\",\n        description: \"singlequote\"\n    },\n    backtick: {\n        quote: \"`\",\n        alternateQuote: \"\\\"\",\n        description: \"backtick\"\n    }\n};\n\n// An unescaped newline is a newline preceded by an even number of backslashes.\nconst UNESCAPED_LINEBREAK_PATTERN = new RegExp(String.raw`(^|[^\\\\])(\\\\\\\\)*[${Array.from(astUtils.LINEBREAKS).join(\"\")}]`, \"u\");\n\n/**\n * Switches quoting of javascript string between ' \" and `\n * escaping and unescaping as necessary.\n * Only escaping of the minimal set of characters is changed.\n * Note: escaping of newlines when switching from backtick to other quotes is not handled.\n * @param {string} str - A string to convert.\n * @returns {string} The string with changed quotes.\n * @private\n */\nQUOTE_SETTINGS.double.convert =\nQUOTE_SETTINGS.single.convert =\nQUOTE_SETTINGS.backtick.convert = function(str) {\n    const newQuote = this.quote;\n    const oldQuote = str[0];\n\n    if (newQuote === oldQuote) {\n        return str;\n    }\n    return newQuote + str.slice(1, -1).replace(/\\\\(\\$\\{|\\r\\n?|\\n|.)|[\"'`]|\\$\\{|(\\r\\n?|\\n)/gu, (match, escaped, newline) => {\n        if (escaped === oldQuote || oldQuote === \"`\" && escaped === \"${\") {\n            return escaped; // unescape\n        }\n        if (match === newQuote || newQuote === \"`\" && match === \"${\") {\n            return `\\\\${match}`; // escape\n        }\n        if (newline && oldQuote === \"`\") {\n            return \"\\\\n\"; // escape newlines\n        }\n        return match;\n    }) + newQuote;\n};\n\nconst AVOID_ESCAPE = \"avoid-escape\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce the consistent use of either backticks, double, or single quotes\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/quotes\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                enum: [\"single\", \"double\", \"backtick\"]\n            },\n            {\n                anyOf: [\n                    {\n                        enum: [\"avoid-escape\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            avoidEscape: {\n                                type: \"boolean\"\n                            },\n                            allowTemplateLiterals: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n\n        const quoteOption = context.options[0],\n            settings = QUOTE_SETTINGS[quoteOption || \"double\"],\n            options = context.options[1],\n            allowTemplateLiterals = options && options.allowTemplateLiterals === true,\n            sourceCode = context.getSourceCode();\n        let avoidEscape = options && options.avoidEscape === true;\n\n        // deprecated\n        if (options === AVOID_ESCAPE) {\n            avoidEscape = true;\n        }\n\n        /**\n         * Determines if a given node is part of JSX syntax.\n         *\n         * This function returns `true` in the following cases:\n         *\n         * - `<div className=\"foo\"></div>` ... If the literal is an attribute value, the parent of the literal is `JSXAttribute`.\n         * - `<div>foo</div>` ... If the literal is a text content, the parent of the literal is `JSXElement`.\n         * - `<>foo</>` ... If the literal is a text content, the parent of the literal is `JSXFragment`.\n         *\n         * In particular, this function returns `false` in the following cases:\n         *\n         * - `<div className={\"foo\"}></div>`\n         * - `<div>{\"foo\"}</div>`\n         *\n         * In both cases, inside of the braces is handled as normal JavaScript.\n         * The braces are `JSXExpressionContainer` nodes.\n         *\n         * @param {ASTNode} node The Literal node to check.\n         * @returns {boolean} True if the node is a part of JSX, false if not.\n         * @private\n         */\n        function isJSXLiteral(node) {\n            return node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\" || node.parent.type === \"JSXFragment\";\n        }\n\n        /**\n         * Checks whether or not a given node is a directive.\n         * The directive is a `ExpressionStatement` which has only a string literal.\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} Whether or not the node is a directive.\n         * @private\n         */\n        function isDirective(node) {\n            return (\n                node.type === \"ExpressionStatement\" &&\n                node.expression.type === \"Literal\" &&\n                typeof node.expression.value === \"string\"\n            );\n        }\n\n        /**\n         * Checks whether or not a given node is a part of directive prologues.\n         * See also: http://www.ecma-international.org/ecma-262/6.0/#sec-directive-prologues-and-the-use-strict-directive\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} Whether or not the node is a part of directive prologues.\n         * @private\n         */\n        function isPartOfDirectivePrologue(node) {\n            const block = node.parent.parent;\n\n            if (block.type !== \"Program\" && (block.type !== \"BlockStatement\" || !astUtils.isFunction(block.parent))) {\n                return false;\n            }\n\n            // Check the node is at a prologue.\n            for (let i = 0; i < block.body.length; ++i) {\n                const statement = block.body[i];\n\n                if (statement === node.parent) {\n                    return true;\n                }\n                if (!isDirective(statement)) {\n                    break;\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether or not a given node is allowed as non backtick.\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} Whether or not the node is allowed as non backtick.\n         * @private\n         */\n        function isAllowedAsNonBacktick(node) {\n            const parent = node.parent;\n\n            switch (parent.type) {\n\n                // Directive Prologues.\n                case \"ExpressionStatement\":\n                    return isPartOfDirectivePrologue(node);\n\n                // LiteralPropertyName.\n                case \"Property\":\n                case \"MethodDefinition\":\n                    return parent.key === node && !parent.computed;\n\n                // ModuleSpecifier.\n                case \"ImportDeclaration\":\n                case \"ExportNamedDeclaration\":\n                case \"ExportAllDeclaration\":\n                    return parent.source === node;\n\n                // Others don't allow.\n                default:\n                    return false;\n            }\n        }\n\n        /**\n         * Checks whether or not a given TemplateLiteral node is actually using any of the special features provided by template literal strings.\n         * @param {ASTNode} node - A TemplateLiteral node to check.\n         * @returns {boolean} Whether or not the TemplateLiteral node is using any of the special features provided by template literal strings.\n         * @private\n         */\n        function isUsingFeatureOfTemplateLiteral(node) {\n            const hasTag = node.parent.type === \"TaggedTemplateExpression\" && node === node.parent.quasi;\n\n            if (hasTag) {\n                return true;\n            }\n\n            const hasStringInterpolation = node.expressions.length > 0;\n\n            if (hasStringInterpolation) {\n                return true;\n            }\n\n            const isMultilineString = node.quasis.length >= 1 && UNESCAPED_LINEBREAK_PATTERN.test(node.quasis[0].value.raw);\n\n            if (isMultilineString) {\n                return true;\n            }\n\n            return false;\n        }\n\n        return {\n\n            Literal(node) {\n                const val = node.value,\n                    rawVal = node.raw;\n\n                if (settings && typeof val === \"string\") {\n                    let isValid = (quoteOption === \"backtick\" && isAllowedAsNonBacktick(node)) ||\n                        isJSXLiteral(node) ||\n                        astUtils.isSurroundedBy(rawVal, settings.quote);\n\n                    if (!isValid && avoidEscape) {\n                        isValid = astUtils.isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.indexOf(settings.quote) >= 0;\n                    }\n\n                    if (!isValid) {\n                        context.report({\n                            node,\n                            message: \"Strings must use {{description}}.\",\n                            data: {\n                                description: settings.description\n                            },\n                            fix(fixer) {\n                                return fixer.replaceText(node, settings.convert(node.raw));\n                            }\n                        });\n                    }\n                }\n            },\n\n            TemplateLiteral(node) {\n\n                // Don't throw an error if backticks are expected or a template literal feature is in use.\n                if (\n                    allowTemplateLiterals ||\n                    quoteOption === \"backtick\" ||\n                    isUsingFeatureOfTemplateLiteral(node)\n                ) {\n                    return;\n                }\n\n                context.report({\n                    node,\n                    message: \"Strings must use {{description}}.\",\n                    data: {\n                        description: settings.description\n                    },\n                    fix(fixer) {\n                        if (isPartOfDirectivePrologue(node)) {\n\n                            /*\n                             * TemplateLiterals in a directive prologue aren't actually directives, but if they're\n                             * in the directive prologue, then fixing them might turn them into directives and change\n                             * the behavior of the code.\n                             */\n                            return null;\n                        }\n                        return fixer.replaceText(node, settings.convert(sourceCode.getText(node)));\n                    }\n                });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag use of parseInt without a radix argument\n * @author James Allardice\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst MODE_ALWAYS = \"always\",\n    MODE_AS_NEEDED = \"as-needed\";\n\n/**\n * Checks whether a given variable is shadowed or not.\n *\n * @param {eslint-scope.Variable} variable - A variable to check.\n * @returns {boolean} `true` if the variable is shadowed.\n */\nfunction isShadowed(variable) {\n    return variable.defs.length >= 1;\n}\n\n/**\n * Checks whether a given node is a MemberExpression of `parseInt` method or not.\n *\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a MemberExpression of `parseInt`\n *      method.\n */\nfunction isParseIntMethod(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        !node.computed &&\n        node.property.type === \"Identifier\" &&\n        node.property.name === \"parseInt\"\n    );\n}\n\n/**\n * Checks whether a given node is a valid value of radix or not.\n *\n * The following values are invalid.\n *\n * - A literal except numbers.\n * - undefined.\n *\n * @param {ASTNode} radix - A node of radix to check.\n * @returns {boolean} `true` if the node is valid.\n */\nfunction isValidRadix(radix) {\n    return !(\n        (radix.type === \"Literal\" && typeof radix.value !== \"number\") ||\n        (radix.type === \"Identifier\" && radix.name === \"undefined\")\n    );\n}\n\n/**\n * Checks whether a given node is a default value of radix or not.\n *\n * @param {ASTNode} radix - A node of radix to check.\n * @returns {boolean} `true` if the node is the literal node of `10`.\n */\nfunction isDefaultRadix(radix) {\n    return radix.type === \"Literal\" && radix.value === 10;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce the consistent use of the radix argument when using `parseInt()`\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/radix\"\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"as-needed\"]\n            }\n        ]\n    },\n\n    create(context) {\n        const mode = context.options[0] || MODE_ALWAYS;\n\n        /**\n         * Checks the arguments of a given CallExpression node and reports it if it\n         * offends this rule.\n         *\n         * @param {ASTNode} node - A CallExpression node to check.\n         * @returns {void}\n         */\n        function checkArguments(node) {\n            const args = node.arguments;\n\n            switch (args.length) {\n                case 0:\n                    context.report({\n                        node,\n                        message: \"Missing parameters.\"\n                    });\n                    break;\n\n                case 1:\n                    if (mode === MODE_ALWAYS) {\n                        context.report({\n                            node,\n                            message: \"Missing radix parameter.\"\n                        });\n                    }\n                    break;\n\n                default:\n                    if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {\n                        context.report({\n                            node,\n                            message: \"Redundant radix parameter.\"\n                        });\n                    } else if (!isValidRadix(args[1])) {\n                        context.report({\n                            node,\n                            message: \"Invalid radix parameter.\"\n                        });\n                    }\n                    break;\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                const scope = context.getScope();\n                let variable;\n\n                // Check `parseInt()`\n                variable = astUtils.getVariableByName(scope, \"parseInt\");\n                if (!isShadowed(variable)) {\n                    variable.references.forEach(reference => {\n                        const node = reference.identifier;\n\n                        if (astUtils.isCallee(node)) {\n                            checkArguments(node.parent);\n                        }\n                    });\n                }\n\n                // Check `Number.parseInt()`\n                variable = astUtils.getVariableByName(scope, \"Number\");\n                if (!isShadowed(variable)) {\n                    variable.references.forEach(reference => {\n                        const node = reference.identifier.parent;\n\n                        if (isParseIntMethod(node) && astUtils.isCallee(node)) {\n                            checkArguments(node.parent);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview disallow assignments that can lead to race conditions due to usage of `await` or `yield`\n * @author Teddy Katz\n */\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"disallow assignments that can lead to race conditions due to usage of `await` or `yield`\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/require-atomic-updates\"\n        },\n\n        fixable: null,\n        schema: [],\n\n        messages: {\n            nonAtomicUpdate: \"Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const identifierToSurroundingFunctionMap = new WeakMap();\n        const expressionsByCodePathSegment = new Map();\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        const resolvedVariableCache = new WeakMap();\n\n        /**\n         * Gets the variable scope around this variable reference\n         * @param {ASTNode} identifier An `Identifier` AST node\n         * @returns {Scope|null} An escope Scope\n         */\n        function getScope(identifier) {\n            for (let currentNode = identifier; currentNode; currentNode = currentNode.parent) {\n                const scope = sourceCode.scopeManager.acquire(currentNode, true);\n\n                if (scope) {\n                    return scope;\n                }\n            }\n            return null;\n        }\n\n        /**\n         * Resolves a given identifier to a given scope\n         * @param {ASTNode} identifier An `Identifier` AST node\n         * @param {Scope} scope An escope Scope\n         * @returns {Variable|null} An escope Variable corresponding to the given identifier\n         */\n        function resolveVariableInScope(identifier, scope) {\n            return scope.variables.find(variable => variable.name === identifier.name) ||\n                (scope.upper ? resolveVariableInScope(identifier, scope.upper) : null);\n        }\n\n        /**\n         * Resolves an identifier to a variable\n         * @param {ASTNode} identifier An identifier node\n         * @returns {Variable|null} The escope Variable that uses this identifier\n         */\n        function resolveVariable(identifier) {\n            if (!resolvedVariableCache.has(identifier)) {\n                const surroundingScope = getScope(identifier);\n\n                if (surroundingScope) {\n                    resolvedVariableCache.set(identifier, resolveVariableInScope(identifier, surroundingScope));\n                } else {\n                    resolvedVariableCache.set(identifier, null);\n                }\n            }\n\n            return resolvedVariableCache.get(identifier);\n        }\n\n        /**\n         * Checks if an expression is a variable that can only be observed within the given function.\n         * @param {ASTNode} expression The expression to check\n         * @param {ASTNode} surroundingFunction The function node\n         * @returns {boolean} `true` if the expression is a variable which is local to the given function, and is never\n         * referenced in a closure.\n         */\n        function isLocalVariableWithoutEscape(expression, surroundingFunction) {\n            if (expression.type !== \"Identifier\") {\n                return false;\n            }\n\n            const variable = resolveVariable(expression);\n\n            if (!variable) {\n                return false;\n            }\n\n            return variable.references.every(reference => identifierToSurroundingFunctionMap.get(reference.identifier) === surroundingFunction) &&\n                variable.defs.every(def => identifierToSurroundingFunctionMap.get(def.name) === surroundingFunction);\n        }\n\n        /**\n         * Reports an AssignmentExpression node that has a non-atomic update\n         * @param {ASTNode} assignmentExpression The assignment that is potentially unsafe\n         * @returns {void}\n         */\n        function reportAssignment(assignmentExpression) {\n            context.report({\n                node: assignmentExpression,\n                messageId: \"nonAtomicUpdate\",\n                data: {\n                    value: sourceCode.getText(assignmentExpression.left)\n                }\n            });\n        }\n\n        const alreadyReportedAssignments = new WeakSet();\n\n        class AssignmentTrackerState {\n            constructor({ openAssignmentsWithoutReads = new Set(), openAssignmentsWithReads = new Set() } = {}) {\n                this.openAssignmentsWithoutReads = openAssignmentsWithoutReads;\n                this.openAssignmentsWithReads = openAssignmentsWithReads;\n            }\n\n            copy() {\n                return new AssignmentTrackerState({\n                    openAssignmentsWithoutReads: new Set(this.openAssignmentsWithoutReads),\n                    openAssignmentsWithReads: new Set(this.openAssignmentsWithReads)\n                });\n            }\n\n            merge(other) {\n                const initialAssignmentsWithoutReadsCount = this.openAssignmentsWithoutReads.size;\n                const initialAssignmentsWithReadsCount = this.openAssignmentsWithReads.size;\n\n                other.openAssignmentsWithoutReads.forEach(assignment => this.openAssignmentsWithoutReads.add(assignment));\n                other.openAssignmentsWithReads.forEach(assignment => this.openAssignmentsWithReads.add(assignment));\n\n                return this.openAssignmentsWithoutReads.size > initialAssignmentsWithoutReadsCount ||\n                    this.openAssignmentsWithReads.size > initialAssignmentsWithReadsCount;\n            }\n\n            enterAssignment(assignmentExpression) {\n                (assignmentExpression.operator === \"=\" ? this.openAssignmentsWithoutReads : this.openAssignmentsWithReads).add(assignmentExpression);\n            }\n\n            exitAssignment(assignmentExpression) {\n                this.openAssignmentsWithoutReads.delete(assignmentExpression);\n                this.openAssignmentsWithReads.delete(assignmentExpression);\n            }\n\n            exitAwaitOrYield(node, surroundingFunction) {\n                return [...this.openAssignmentsWithReads]\n                    .filter(assignment => !isLocalVariableWithoutEscape(assignment.left, surroundingFunction))\n                    .forEach(assignment => {\n                        if (!alreadyReportedAssignments.has(assignment)) {\n                            reportAssignment(assignment);\n                            alreadyReportedAssignments.add(assignment);\n                        }\n                    });\n            }\n\n            exitIdentifierOrMemberExpression(node) {\n                [...this.openAssignmentsWithoutReads]\n                    .filter(assignment => (\n                        assignment.left !== node &&\n                        assignment.left.type === node.type &&\n                        astUtils.equalTokens(assignment.left, node, sourceCode)\n                    ))\n                    .forEach(assignment => {\n                        this.openAssignmentsWithoutReads.delete(assignment);\n                        this.openAssignmentsWithReads.add(assignment);\n                    });\n            }\n        }\n\n        /**\n         * If the control flow graph of a function enters an assignment expression, then does the\n         * both of the following steps in order (possibly with other steps in between) before exiting the\n         * assignment expression, then the assignment might be using an outdated value.\n         * 1. Enters a read of the variable or property assigned in the expression (not necessary if operator assignment is used)\n         * 2. Exits an `await` or `yield` expression\n         *\n         * This function checks for the outdated values and reports them.\n         * @param {CodePathSegment} codePathSegment The current code path segment to traverse\n         * @param {ASTNode} surroundingFunction The function node containing the code path segment\n         * @returns {void}\n         */\n        function findOutdatedReads(\n            codePathSegment,\n            surroundingFunction,\n            {\n                stateBySegmentStart = new WeakMap(),\n                stateBySegmentEnd = new WeakMap()\n            } = {}\n        ) {\n            if (!stateBySegmentStart.has(codePathSegment)) {\n                stateBySegmentStart.set(codePathSegment, new AssignmentTrackerState());\n            }\n\n            const currentState = stateBySegmentStart.get(codePathSegment).copy();\n\n            expressionsByCodePathSegment.get(codePathSegment).forEach(({ entering, node }) => {\n                if (node.type === \"AssignmentExpression\") {\n                    if (entering) {\n                        currentState.enterAssignment(node);\n                    } else {\n                        currentState.exitAssignment(node);\n                    }\n                } else if (!entering && (node.type === \"AwaitExpression\" || node.type === \"YieldExpression\")) {\n                    currentState.exitAwaitOrYield(node, surroundingFunction);\n                } else if (!entering && (node.type === \"Identifier\" || node.type === \"MemberExpression\")) {\n                    currentState.exitIdentifierOrMemberExpression(node);\n                }\n            });\n\n            stateBySegmentEnd.set(codePathSegment, currentState);\n\n            codePathSegment.nextSegments.forEach(nextSegment => {\n                if (stateBySegmentStart.has(nextSegment)) {\n                    if (!stateBySegmentStart.get(nextSegment).merge(currentState)) {\n\n                        /*\n                         * This segment has already been processed with the given set of inputs;\n                         * no need to do it again. After no new state is available to process\n                         * for any control flow segment in the graph, the analysis reaches a fixpoint and\n                         * traversal stops.\n                         */\n                        return;\n                    }\n                } else {\n                    stateBySegmentStart.set(nextSegment, currentState.copy());\n                }\n                findOutdatedReads(\n                    nextSegment,\n                    surroundingFunction,\n                    { stateBySegmentStart, stateBySegmentEnd }\n                );\n            });\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        const currentCodePathSegmentStack = [];\n        let currentCodePathSegment = null;\n        const functionStack = [];\n\n        return {\n            onCodePathStart() {\n                currentCodePathSegmentStack.push(currentCodePathSegment);\n            },\n\n            onCodePathEnd(codePath, node) {\n                currentCodePathSegment = currentCodePathSegmentStack.pop();\n\n                if (astUtils.isFunction(node) && (node.async || node.generator)) {\n                    findOutdatedReads(codePath.initialSegment, node);\n                }\n            },\n\n            onCodePathSegmentStart(segment) {\n                currentCodePathSegment = segment;\n                expressionsByCodePathSegment.set(segment, []);\n            },\n\n            \"AssignmentExpression, Identifier, MemberExpression, AwaitExpression, YieldExpression\"(node) {\n                expressionsByCodePathSegment.get(currentCodePathSegment).push({ entering: true, node });\n            },\n\n            \"AssignmentExpression, Identifier, MemberExpression, AwaitExpression, YieldExpression:exit\"(node) {\n                expressionsByCodePathSegment.get(currentCodePathSegment).push({ entering: false, node });\n            },\n\n            \":function\"(node) {\n                functionStack.push(node);\n            },\n\n            \":function:exit\"() {\n                functionStack.pop();\n            },\n\n            Identifier(node) {\n                if (functionStack.length) {\n                    identifierToSurroundingFunctionMap.set(node, functionStack[functionStack.length - 1]);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to disallow async functions which have no `await` expression.\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Capitalize the 1st letter of the given text.\n *\n * @param {string} text - The text to capitalize.\n * @returns {string} The text that the 1st letter was capitalized.\n */\nfunction capitalizeFirstLetter(text) {\n    return text[0].toUpperCase() + text.slice(1);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow async functions which have no `await` expression\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/require-await\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        let scopeInfo = null;\n\n        /**\n         * Push the scope info object to the stack.\n         *\n         * @returns {void}\n         */\n        function enterFunction() {\n            scopeInfo = {\n                upper: scopeInfo,\n                hasAwait: false\n            };\n        }\n\n        /**\n         * Pop the top scope info object from the stack.\n         * Also, it reports the function if needed.\n         *\n         * @param {ASTNode} node - The node to report.\n         * @returns {void}\n         */\n        function exitFunction(node) {\n            if (node.async && !scopeInfo.hasAwait && !astUtils.isEmptyFunction(node)) {\n                context.report({\n                    node,\n                    loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                    message: \"{{name}} has no 'await' expression.\",\n                    data: {\n                        name: capitalizeFirstLetter(\n                            astUtils.getFunctionNameWithKind(node)\n                        )\n                    }\n                });\n            }\n\n            scopeInfo = scopeInfo.upper;\n        }\n\n        return {\n            FunctionDeclaration: enterFunction,\n            FunctionExpression: enterFunction,\n            ArrowFunctionExpression: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            \"FunctionExpression:exit\": exitFunction,\n            \"ArrowFunctionExpression:exit\": exitFunction,\n\n            AwaitExpression() {\n                scopeInfo.hasAwait = true;\n            },\n            ForOfStatement(node) {\n                if (node.await) {\n                    scopeInfo.hasAwait = true;\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to check for jsdoc presence.\n * @author Gyandeep Singh\n */\n\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require JSDoc comments\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/require-jsdoc\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    require: {\n                        type: \"object\",\n                        properties: {\n                            ClassDeclaration: {\n                                type: \"boolean\",\n                                default: false\n                            },\n                            MethodDefinition: {\n                                type: \"boolean\",\n                                default: false\n                            },\n                            FunctionDeclaration: {\n                                type: \"boolean\",\n                                default: true\n                            },\n                            ArrowFunctionExpression: {\n                                type: \"boolean\",\n                                default: false\n                            },\n                            FunctionExpression: {\n                                type: \"boolean\",\n                                default: false\n                            }\n                        },\n                        additionalProperties: false,\n                        default: {}\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        deprecated: true,\n        replacedBy: []\n    },\n\n    create(context) {\n        const source = context.getSourceCode();\n        const DEFAULT_OPTIONS = {\n            FunctionDeclaration: true,\n            MethodDefinition: false,\n            ClassDeclaration: false,\n            ArrowFunctionExpression: false,\n            FunctionExpression: false\n        };\n        const options = Object.assign(DEFAULT_OPTIONS, context.options[0] && context.options[0].require);\n\n        /**\n         * Report the error message\n         * @param {ASTNode} node node to report\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({ node, message: \"Missing JSDoc comment.\" });\n        }\n\n        /**\n         * Check if the jsdoc comment is present or not.\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkJsDoc(node) {\n            const jsdocComment = source.getJSDocComment(node);\n\n            if (!jsdocComment) {\n                report(node);\n            }\n        }\n\n        return {\n            FunctionDeclaration(node) {\n                if (options.FunctionDeclaration) {\n                    checkJsDoc(node);\n                }\n            },\n            FunctionExpression(node) {\n                if (\n                    (options.MethodDefinition && node.parent.type === \"MethodDefinition\") ||\n                    (options.FunctionExpression && (node.parent.type === \"VariableDeclarator\" || (node.parent.type === \"Property\" && node === node.parent.value)))\n                ) {\n                    checkJsDoc(node);\n                }\n            },\n            ClassDeclaration(node) {\n                if (options.ClassDeclaration) {\n                    checkJsDoc(node);\n                }\n            },\n            ArrowFunctionExpression(node) {\n                if (options.ArrowFunctionExpression && node.parent.type === \"VariableDeclarator\") {\n                    checkJsDoc(node);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce the use of `u` flag on RegExp.\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst {\n    CALL,\n    CONSTRUCT,\n    ReferenceTracker,\n    getStringIfConstant\n} = require(\"eslint-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce the use of `u` flag on RegExp\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/require-unicode-regexp\"\n        },\n\n        messages: {\n            requireUFlag: \"Use the 'u' flag.\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        return {\n            \"Literal[regex]\"(node) {\n                const flags = node.regex.flags || \"\";\n\n                if (!flags.includes(\"u\")) {\n                    context.report({ node, messageId: \"requireUFlag\" });\n                }\n            },\n\n            Program() {\n                const scope = context.getScope();\n                const tracker = new ReferenceTracker(scope);\n                const trackMap = {\n                    RegExp: { [CALL]: true, [CONSTRUCT]: true }\n                };\n\n                for (const { node } of tracker.iterateGlobalReferences(trackMap)) {\n                    const flagsNode = node.arguments[1];\n                    const flags = getStringIfConstant(flagsNode, scope);\n\n                    if (!flagsNode || (typeof flags === \"string\" && !flags.includes(\"u\"))) {\n                        context.report({ node, messageId: \"requireUFlag\" });\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag the generator functions that does not have yield.\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require generator functions to contain `yield`\",\n            category: \"ECMAScript 6\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/require-yield\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const stack = [];\n\n        /**\n         * If the node is a generator function, start counting `yield` keywords.\n         * @param {Node} node - A function node to check.\n         * @returns {void}\n         */\n        function beginChecking(node) {\n            if (node.generator) {\n                stack.push(0);\n            }\n        }\n\n        /**\n         * If the node is a generator function, end counting `yield` keywords, then\n         * reports result.\n         * @param {Node} node - A function node to check.\n         * @returns {void}\n         */\n        function endChecking(node) {\n            if (!node.generator) {\n                return;\n            }\n\n            const countYield = stack.pop();\n\n            if (countYield === 0 && node.body.body.length > 0) {\n                context.report({ node, message: \"This generator function does not have 'yield'.\" });\n            }\n        }\n\n        return {\n            FunctionDeclaration: beginChecking,\n            \"FunctionDeclaration:exit\": endChecking,\n            FunctionExpression: beginChecking,\n            \"FunctionExpression:exit\": endChecking,\n\n            // Increases the count of `yield` keyword.\n            YieldExpression() {\n\n                /* istanbul ignore else */\n                if (stack.length > 0) {\n                    stack[stack.length - 1] += 1;\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Enforce spacing between rest and spread operators and their expressions.\n * @author Kai Cataldo\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce spacing between rest and spread operators and their expressions\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/rest-spread-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode(),\n            alwaysSpace = context.options[0] === \"always\";\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Checks whitespace between rest/spread operators and their expressions\n         * @param {ASTNode} node - The node to check\n         * @returns {void}\n         */\n        function checkWhiteSpace(node) {\n            const operator = sourceCode.getFirstToken(node),\n                nextToken = sourceCode.getTokenAfter(operator),\n                hasWhitespace = sourceCode.isSpaceBetweenTokens(operator, nextToken);\n            let type;\n\n            switch (node.type) {\n                case \"SpreadElement\":\n                    type = \"spread\";\n                    if (node.parent.type === \"ObjectExpression\") {\n                        type += \" property\";\n                    }\n                    break;\n                case \"RestElement\":\n                    type = \"rest\";\n                    if (node.parent.type === \"ObjectPattern\") {\n                        type += \" property\";\n                    }\n                    break;\n                case \"ExperimentalSpreadProperty\":\n                    type = \"spread property\";\n                    break;\n                case \"ExperimentalRestProperty\":\n                    type = \"rest property\";\n                    break;\n                default:\n                    return;\n            }\n\n            if (alwaysSpace && !hasWhitespace) {\n                context.report({\n                    node,\n                    loc: {\n                        line: operator.loc.end.line,\n                        column: operator.loc.end.column\n                    },\n                    message: \"Expected whitespace after {{type}} operator.\",\n                    data: {\n                        type\n                    },\n                    fix(fixer) {\n                        return fixer.replaceTextRange([operator.range[1], nextToken.range[0]], \" \");\n                    }\n                });\n            } else if (!alwaysSpace && hasWhitespace) {\n                context.report({\n                    node,\n                    loc: {\n                        line: operator.loc.end.line,\n                        column: operator.loc.end.column\n                    },\n                    message: \"Unexpected whitespace after {{type}} operator.\",\n                    data: {\n                        type\n                    },\n                    fix(fixer) {\n                        return fixer.removeRange([operator.range[1], nextToken.range[0]]);\n                    }\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            SpreadElement: checkWhiteSpace,\n            RestElement: checkWhiteSpace,\n            ExperimentalSpreadProperty: checkWhiteSpace,\n            ExperimentalRestProperty: checkWhiteSpace\n        };\n    }\n};\n","/**\n * @fileoverview Rule to flag missing semicolons.\n * @author Nicholas C. Zakas\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst FixTracker = require(\"../util/fix-tracker\");\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow semicolons instead of ASI\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/semi\"\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"never\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                beforeStatementContinuationChars: {\n                                    enum: [\"always\", \"any\", \"never\"]\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                omitLastInOneLineBlock: { type: \"boolean\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        }\n    },\n\n    create(context) {\n\n        const OPT_OUT_PATTERN = /^[-[(/+`]/u; // One of [(/+-`\n        const options = context.options[1];\n        const never = context.options[0] === \"never\";\n        const exceptOneLine = Boolean(options && options.omitLastInOneLineBlock);\n        const beforeStatementContinuationChars = options && options.beforeStatementContinuationChars || \"any\";\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports a semicolon error with appropriate location and message.\n         * @param {ASTNode} node The node with an extra or missing semicolon.\n         * @param {boolean} missing True if the semicolon is missing.\n         * @returns {void}\n         */\n        function report(node, missing) {\n            const lastToken = sourceCode.getLastToken(node);\n            let message,\n                fix,\n                loc = lastToken.loc;\n\n            if (!missing) {\n                message = \"Missing semicolon.\";\n                loc = loc.end;\n                fix = function(fixer) {\n                    return fixer.insertTextAfter(lastToken, \";\");\n                };\n            } else {\n                message = \"Extra semicolon.\";\n                loc = loc.start;\n                fix = function(fixer) {\n\n                    /*\n                     * Expand the replacement range to include the surrounding\n                     * tokens to avoid conflicting with no-extra-semi.\n                     * https://github.com/eslint/eslint/issues/7928\n                     */\n                    return new FixTracker(fixer, sourceCode)\n                        .retainSurroundingTokens(lastToken)\n                        .remove(lastToken);\n                };\n            }\n\n            context.report({\n                node,\n                loc,\n                message,\n                fix\n            });\n\n        }\n\n        /**\n         * Check whether a given semicolon token is redandant.\n         * @param {Token} semiToken A semicolon token to check.\n         * @returns {boolean} `true` if the next token is `;` or `}`.\n         */\n        function isRedundantSemi(semiToken) {\n            const nextToken = sourceCode.getTokenAfter(semiToken);\n\n            return (\n                !nextToken ||\n                astUtils.isClosingBraceToken(nextToken) ||\n                astUtils.isSemicolonToken(nextToken)\n            );\n        }\n\n        /**\n         * Check whether a given token is the closing brace of an arrow function.\n         * @param {Token} lastToken A token to check.\n         * @returns {boolean} `true` if the token is the closing brace of an arrow function.\n         */\n        function isEndOfArrowBlock(lastToken) {\n            if (!astUtils.isClosingBraceToken(lastToken)) {\n                return false;\n            }\n            const node = sourceCode.getNodeByRangeIndex(lastToken.range[0]);\n\n            return (\n                node.type === \"BlockStatement\" &&\n                node.parent.type === \"ArrowFunctionExpression\"\n            );\n        }\n\n        /**\n         * Check whether a given node is on the same line with the next token.\n         * @param {Node} node A statement node to check.\n         * @returns {boolean} `true` if the node is on the same line with the next token.\n         */\n        function isOnSameLineWithNextToken(node) {\n            const prevToken = sourceCode.getLastToken(node, 1);\n            const nextToken = sourceCode.getTokenAfter(node);\n\n            return !!nextToken && astUtils.isTokenOnSameLine(prevToken, nextToken);\n        }\n\n        /**\n         * Check whether a given node can connect the next line if the next line is unreliable.\n         * @param {Node} node A statement node to check.\n         * @returns {boolean} `true` if the node can connect the next line.\n         */\n        function maybeAsiHazardAfter(node) {\n            const t = node.type;\n\n            if (t === \"DoWhileStatement\" ||\n                t === \"BreakStatement\" ||\n                t === \"ContinueStatement\" ||\n                t === \"DebuggerStatement\" ||\n                t === \"ImportDeclaration\" ||\n                t === \"ExportAllDeclaration\"\n            ) {\n                return false;\n            }\n            if (t === \"ReturnStatement\") {\n                return Boolean(node.argument);\n            }\n            if (t === \"ExportNamedDeclaration\") {\n                return Boolean(node.declaration);\n            }\n            if (isEndOfArrowBlock(sourceCode.getLastToken(node, 1))) {\n                return false;\n            }\n\n            return true;\n        }\n\n        /**\n         * Check whether a given token can connect the previous statement.\n         * @param {Token} token A token to check.\n         * @returns {boolean} `true` if the token is one of `[`, `(`, `/`, `+`, `-`, ```, `++`, and `--`.\n         */\n        function maybeAsiHazardBefore(token) {\n            return (\n                Boolean(token) &&\n                OPT_OUT_PATTERN.test(token.value) &&\n                token.value !== \"++\" &&\n                token.value !== \"--\"\n            );\n        }\n\n        /**\n         * Check if the semicolon of a given node is unnecessary, only true if:\n         *   - next token is a valid statement divider (`;` or `}`).\n         *   - next token is on a new line and the node is not connectable to the new line.\n         * @param {Node} node A statement node to check.\n         * @returns {boolean} whether the semicolon is unnecessary.\n         */\n        function canRemoveSemicolon(node) {\n            if (isRedundantSemi(sourceCode.getLastToken(node))) {\n                return true; // `;;` or `;}`\n            }\n            if (isOnSameLineWithNextToken(node)) {\n                return false; // One liner.\n            }\n            if (beforeStatementContinuationChars === \"never\" && !maybeAsiHazardAfter(node)) {\n                return true; // ASI works. This statement doesn't connect to the next.\n            }\n            if (!maybeAsiHazardBefore(sourceCode.getTokenAfter(node))) {\n                return true; // ASI works. The next token doesn't connect to this statement.\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks a node to see if it's in a one-liner block statement.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} whether the node is in a one-liner block statement.\n         */\n        function isOneLinerBlock(node) {\n            const parent = node.parent;\n            const nextToken = sourceCode.getTokenAfter(node);\n\n            if (!nextToken || nextToken.value !== \"}\") {\n                return false;\n            }\n            return (\n                !!parent &&\n                parent.type === \"BlockStatement\" &&\n                parent.loc.start.line === parent.loc.end.line\n            );\n        }\n\n        /**\n         * Checks a node to see if it's followed by a semicolon.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkForSemicolon(node) {\n            const isSemi = astUtils.isSemicolonToken(sourceCode.getLastToken(node));\n\n            if (never) {\n                if (isSemi && canRemoveSemicolon(node)) {\n                    report(node, true);\n                } else if (!isSemi && beforeStatementContinuationChars === \"always\" && maybeAsiHazardBefore(sourceCode.getTokenAfter(node))) {\n                    report(node);\n                }\n            } else {\n                const oneLinerBlock = (exceptOneLine && isOneLinerBlock(node));\n\n                if (isSemi && oneLinerBlock) {\n                    report(node, true);\n                } else if (!isSemi && !oneLinerBlock) {\n                    report(node);\n                }\n            }\n        }\n\n        /**\n         * Checks to see if there's a semicolon after a variable declaration.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkForSemicolonForVariableDeclaration(node) {\n            const parent = node.parent;\n\n            if ((parent.type !== \"ForStatement\" || parent.init !== node) &&\n                (!/^For(?:In|Of)Statement/u.test(parent.type) || parent.left !== node)\n            ) {\n                checkForSemicolon(node);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclaration: checkForSemicolonForVariableDeclaration,\n            ExpressionStatement: checkForSemicolon,\n            ReturnStatement: checkForSemicolon,\n            ThrowStatement: checkForSemicolon,\n            DoWhileStatement: checkForSemicolon,\n            DebuggerStatement: checkForSemicolon,\n            BreakStatement: checkForSemicolon,\n            ContinueStatement: checkForSemicolon,\n            ImportDeclaration: checkForSemicolon,\n            ExportAllDeclaration: checkForSemicolon,\n            ExportNamedDeclaration(node) {\n                if (!node.declaration) {\n                    checkForSemicolon(node);\n                }\n            },\n            ExportDefaultDeclaration(node) {\n                if (!/(?:Class|Function)Declaration/u.test(node.declaration.type)) {\n                    checkForSemicolon(node);\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Validates spacing before and after semicolon\n * @author Mathias Schreck\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before and after semicolons\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/semi-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    after: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const config = context.options[0],\n            sourceCode = context.getSourceCode();\n        let requireSpaceBefore = false,\n            requireSpaceAfter = true;\n\n        if (typeof config === \"object\") {\n            requireSpaceBefore = config.before;\n            requireSpaceAfter = config.after;\n        }\n\n        /**\n         * Checks if a given token has leading whitespace.\n         * @param {Object} token The token to check.\n         * @returns {boolean} True if the given token has leading space, false if not.\n         */\n        function hasLeadingSpace(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token);\n\n            return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && sourceCode.isSpaceBetweenTokens(tokenBefore, token);\n        }\n\n        /**\n         * Checks if a given token has trailing whitespace.\n         * @param {Object} token The token to check.\n         * @returns {boolean} True if the given token has trailing space, false if not.\n         */\n        function hasTrailingSpace(token) {\n            const tokenAfter = sourceCode.getTokenAfter(token);\n\n            return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && sourceCode.isSpaceBetweenTokens(token, tokenAfter);\n        }\n\n        /**\n         * Checks if the given token is the last token in its line.\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the token is the last in its line.\n         */\n        function isLastTokenInCurrentLine(token) {\n            const tokenAfter = sourceCode.getTokenAfter(token);\n\n            return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));\n        }\n\n        /**\n         * Checks if the given token is the first token in its line\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the token is the first in its line.\n         */\n        function isFirstTokenInCurrentLine(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token);\n\n            return !(tokenBefore && astUtils.isTokenOnSameLine(token, tokenBefore));\n        }\n\n        /**\n         * Checks if the next token of a given token is a closing parenthesis.\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the next token of a given token is a closing parenthesis.\n         */\n        function isBeforeClosingParen(token) {\n            const nextToken = sourceCode.getTokenAfter(token);\n\n            return (nextToken && astUtils.isClosingBraceToken(nextToken) || astUtils.isClosingParenToken(nextToken));\n        }\n\n        /**\n         * Reports if the given token has invalid spacing.\n         * @param {Token} token The semicolon token to check.\n         * @param {ASTNode} node The corresponding node of the token.\n         * @returns {void}\n         */\n        function checkSemicolonSpacing(token, node) {\n            if (astUtils.isSemicolonToken(token)) {\n                const location = token.loc.start;\n\n                if (hasLeadingSpace(token)) {\n                    if (!requireSpaceBefore) {\n                        context.report({\n                            node,\n                            loc: location,\n                            message: \"Unexpected whitespace before semicolon.\",\n                            fix(fixer) {\n                                const tokenBefore = sourceCode.getTokenBefore(token);\n\n                                return fixer.removeRange([tokenBefore.range[1], token.range[0]]);\n                            }\n                        });\n                    }\n                } else {\n                    if (requireSpaceBefore) {\n                        context.report({\n                            node,\n                            loc: location,\n                            message: \"Missing whitespace before semicolon.\",\n                            fix(fixer) {\n                                return fixer.insertTextBefore(token, \" \");\n                            }\n                        });\n                    }\n                }\n\n                if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {\n                    if (hasTrailingSpace(token)) {\n                        if (!requireSpaceAfter) {\n                            context.report({\n                                node,\n                                loc: location,\n                                message: \"Unexpected whitespace after semicolon.\",\n                                fix(fixer) {\n                                    const tokenAfter = sourceCode.getTokenAfter(token);\n\n                                    return fixer.removeRange([token.range[1], tokenAfter.range[0]]);\n                                }\n                            });\n                        }\n                    } else {\n                        if (requireSpaceAfter) {\n                            context.report({\n                                node,\n                                loc: location,\n                                message: \"Missing whitespace after semicolon.\",\n                                fix(fixer) {\n                                    return fixer.insertTextAfter(token, \" \");\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Checks the spacing of the semicolon with the assumption that the last token is the semicolon.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkNode(node) {\n            const token = sourceCode.getLastToken(node);\n\n            checkSemicolonSpacing(token, node);\n        }\n\n        return {\n            VariableDeclaration: checkNode,\n            ExpressionStatement: checkNode,\n            BreakStatement: checkNode,\n            ContinueStatement: checkNode,\n            DebuggerStatement: checkNode,\n            ReturnStatement: checkNode,\n            ThrowStatement: checkNode,\n            ImportDeclaration: checkNode,\n            ExportNamedDeclaration: checkNode,\n            ExportAllDeclaration: checkNode,\n            ExportDefaultDeclaration: checkNode,\n            ForStatement(node) {\n                if (node.init) {\n                    checkSemicolonSpacing(sourceCode.getTokenAfter(node.init), node);\n                }\n\n                if (node.test) {\n                    checkSemicolonSpacing(sourceCode.getTokenAfter(node.test), node);\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce location of semicolons.\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst SELECTOR = `:matches(${\n    [\n        \"BreakStatement\", \"ContinueStatement\", \"DebuggerStatement\",\n        \"DoWhileStatement\", \"ExportAllDeclaration\",\n        \"ExportDefaultDeclaration\", \"ExportNamedDeclaration\",\n        \"ExpressionStatement\", \"ImportDeclaration\", \"ReturnStatement\",\n        \"ThrowStatement\", \"VariableDeclaration\"\n    ].join(\",\")\n})`;\n\n/**\n * Get the child node list of a given node.\n * This returns `Program#body`, `BlockStatement#body`, or `SwitchCase#consequent`.\n * This is used to check whether a node is the first/last child.\n * @param {Node} node A node to get child node list.\n * @returns {Node[]|null} The child node list.\n */\nfunction getChildren(node) {\n    const t = node.type;\n\n    if (t === \"BlockStatement\" || t === \"Program\") {\n        return node.body;\n    }\n    if (t === \"SwitchCase\") {\n        return node.consequent;\n    }\n    return null;\n}\n\n/**\n * Check whether a given node is the last statement in the parent block.\n * @param {Node} node A node to check.\n * @returns {boolean} `true` if the node is the last statement in the parent block.\n */\nfunction isLastChild(node) {\n    const t = node.parent.type;\n\n    if (t === \"IfStatement\" && node.parent.consequent === node && node.parent.alternate) { // before `else` keyword.\n        return true;\n    }\n    if (t === \"DoWhileStatement\") { // before `while` keyword.\n        return true;\n    }\n    const nodeList = getChildren(node.parent);\n\n    return nodeList !== null && nodeList[nodeList.length - 1] === node; // before `}` or etc.\n}\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce location of semicolons\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/semi-style\"\n        },\n\n        schema: [{ enum: [\"last\", \"first\"] }],\n        fixable: \"whitespace\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const option = context.options[0] || \"last\";\n\n        /**\n         * Check the given semicolon token.\n         * @param {Token} semiToken The semicolon token to check.\n         * @param {\"first\"|\"last\"} expected The expected location to check.\n         * @returns {void}\n         */\n        function check(semiToken, expected) {\n            const prevToken = sourceCode.getTokenBefore(semiToken);\n            const nextToken = sourceCode.getTokenAfter(semiToken);\n            const prevIsSameLine = !prevToken || astUtils.isTokenOnSameLine(prevToken, semiToken);\n            const nextIsSameLine = !nextToken || astUtils.isTokenOnSameLine(semiToken, nextToken);\n\n            if ((expected === \"last\" && !prevIsSameLine) || (expected === \"first\" && !nextIsSameLine)) {\n                context.report({\n                    loc: semiToken.loc,\n                    message: \"Expected this semicolon to be at {{pos}}.\",\n                    data: {\n                        pos: (expected === \"last\")\n                            ? \"the end of the previous line\"\n                            : \"the beginning of the next line\"\n                    },\n                    fix(fixer) {\n                        if (prevToken && nextToken && sourceCode.commentsExistBetween(prevToken, nextToken)) {\n                            return null;\n                        }\n\n                        const start = prevToken ? prevToken.range[1] : semiToken.range[0];\n                        const end = nextToken ? nextToken.range[0] : semiToken.range[1];\n                        const text = (expected === \"last\") ? \";\\n\" : \"\\n;\";\n\n                        return fixer.replaceTextRange([start, end], text);\n                    }\n                });\n            }\n        }\n\n        return {\n            [SELECTOR](node) {\n                if (option === \"first\" && isLastChild(node)) {\n                    return;\n                }\n\n                const lastToken = sourceCode.getLastToken(node);\n\n                if (astUtils.isSemicolonToken(lastToken)) {\n                    check(lastToken, option);\n                }\n            },\n\n            ForStatement(node) {\n                const firstSemi = node.init && sourceCode.getTokenAfter(node.init, astUtils.isSemicolonToken);\n                const secondSemi = node.test && sourceCode.getTokenAfter(node.test, astUtils.isSemicolonToken);\n\n                if (firstSemi) {\n                    check(firstSemi, \"last\");\n                }\n                if (secondSemi) {\n                    check(secondSemi, \"last\");\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to require sorting of import declarations\n * @author Christian Schuller\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce sorted import declarations within modules\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/sort-imports\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreCase: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    memberSyntaxSortOrder: {\n                        type: \"array\",\n                        items: {\n                            enum: [\"none\", \"all\", \"multiple\", \"single\"]\n                        },\n                        uniqueItems: true,\n                        minItems: 4,\n                        maxItems: 4\n                    },\n                    ignoreDeclarationSort: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoreMemberSort: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const configuration = context.options[0] || {},\n            ignoreCase = configuration.ignoreCase || false,\n            ignoreDeclarationSort = configuration.ignoreDeclarationSort || false,\n            ignoreMemberSort = configuration.ignoreMemberSort || false,\n            memberSyntaxSortOrder = configuration.memberSyntaxSortOrder || [\"none\", \"all\", \"multiple\", \"single\"],\n            sourceCode = context.getSourceCode();\n        let previousDeclaration = null;\n\n        /**\n         * Gets the used member syntax style.\n         *\n         * import \"my-module.js\" --> none\n         * import * as myModule from \"my-module.js\" --> all\n         * import {myMember} from \"my-module.js\" --> single\n         * import {foo, bar} from  \"my-module.js\" --> multiple\n         *\n         * @param {ASTNode} node - the ImportDeclaration node.\n         * @returns {string} used member parameter style, [\"all\", \"multiple\", \"single\"]\n         */\n        function usedMemberSyntax(node) {\n            if (node.specifiers.length === 0) {\n                return \"none\";\n            }\n            if (node.specifiers[0].type === \"ImportNamespaceSpecifier\") {\n                return \"all\";\n            }\n            if (node.specifiers.length === 1) {\n                return \"single\";\n            }\n            return \"multiple\";\n\n        }\n\n        /**\n         * Gets the group by member parameter index for given declaration.\n         * @param {ASTNode} node - the ImportDeclaration node.\n         * @returns {number} the declaration group by member index.\n         */\n        function getMemberParameterGroupIndex(node) {\n            return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));\n        }\n\n        /**\n         * Gets the local name of the first imported module.\n         * @param {ASTNode} node - the ImportDeclaration node.\n         * @returns {?string} the local name of the first imported module.\n         */\n        function getFirstLocalMemberName(node) {\n            if (node.specifiers[0]) {\n                return node.specifiers[0].local.name;\n            }\n            return null;\n\n        }\n\n        return {\n            ImportDeclaration(node) {\n                if (!ignoreDeclarationSort) {\n                    if (previousDeclaration) {\n                        const currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node),\n                            previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(previousDeclaration);\n                        let currentLocalMemberName = getFirstLocalMemberName(node),\n                            previousLocalMemberName = getFirstLocalMemberName(previousDeclaration);\n\n                        if (ignoreCase) {\n                            previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();\n                            currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();\n                        }\n\n                        /*\n                         * When the current declaration uses a different member syntax,\n                         * then check if the ordering is correct.\n                         * Otherwise, make a default string compare (like rule sort-vars to be consistent) of the first used local member name.\n                         */\n                        if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {\n                            if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {\n                                context.report({\n                                    node,\n                                    message: \"Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax.\",\n                                    data: {\n                                        syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],\n                                        syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]\n                                    }\n                                });\n                            }\n                        } else {\n                            if (previousLocalMemberName &&\n                                currentLocalMemberName &&\n                                currentLocalMemberName < previousLocalMemberName\n                            ) {\n                                context.report({\n                                    node,\n                                    message: \"Imports should be sorted alphabetically.\"\n                                });\n                            }\n                        }\n                    }\n\n                    previousDeclaration = node;\n                }\n\n                if (!ignoreMemberSort) {\n                    const importSpecifiers = node.specifiers.filter(specifier => specifier.type === \"ImportSpecifier\");\n                    const getSortableName = ignoreCase ? specifier => specifier.local.name.toLowerCase() : specifier => specifier.local.name;\n                    const firstUnsortedIndex = importSpecifiers.map(getSortableName).findIndex((name, index, array) => array[index - 1] > name);\n\n                    if (firstUnsortedIndex !== -1) {\n                        context.report({\n                            node: importSpecifiers[firstUnsortedIndex],\n                            message: \"Member '{{memberName}}' of the import declaration should be sorted alphabetically.\",\n                            data: { memberName: importSpecifiers[firstUnsortedIndex].local.name },\n                            fix(fixer) {\n                                if (importSpecifiers.some(specifier =>\n                                    sourceCode.getCommentsBefore(specifier).length || sourceCode.getCommentsAfter(specifier).length)) {\n\n                                    // If there are comments in the ImportSpecifier list, don't rearrange the specifiers.\n                                    return null;\n                                }\n\n                                return fixer.replaceTextRange(\n                                    [importSpecifiers[0].range[0], importSpecifiers[importSpecifiers.length - 1].range[1]],\n                                    importSpecifiers\n\n                                        // Clone the importSpecifiers array to avoid mutating it\n                                        .slice()\n\n                                        // Sort the array into the desired order\n                                        .sort((specifierA, specifierB) => {\n                                            const aName = getSortableName(specifierA);\n                                            const bName = getSortableName(specifierB);\n\n                                            return aName > bName ? 1 : -1;\n                                        })\n\n                                        // Build a string out of the sorted list of import specifiers and the text between the originals\n                                        .reduce((sourceText, specifier, index) => {\n                                            const textAfterSpecifier = index === importSpecifiers.length - 1\n                                                ? \"\"\n                                                : sourceCode.getText().slice(importSpecifiers[index].range[1], importSpecifiers[index + 1].range[0]);\n\n                                            return sourceText + sourceCode.getText(specifier) + textAfterSpecifier;\n                                        }, \"\")\n                                );\n                            }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to require object keys to be sorted\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\"),\n    naturalCompare = require(\"natural-compare\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the property name of the given `Property` node.\n *\n * - If the property's key is an `Identifier` node, this returns the key's name\n *   whether it's a computed property or not.\n * - If the property has a static name, this returns the static name.\n * - Otherwise, this returns null.\n *\n * @param {ASTNode} node - The `Property` node to get.\n * @returns {string|null} The property name or null.\n * @private\n */\nfunction getPropertyName(node) {\n    return astUtils.getStaticPropertyName(node) || node.key.name || null;\n}\n\n/**\n * Functions which check that the given 2 names are in specific order.\n *\n * Postfix `I` is meant insensitive.\n * Postfix `N` is meant natual.\n *\n * @private\n */\nconst isValidOrders = {\n    asc(a, b) {\n        return a <= b;\n    },\n    ascI(a, b) {\n        return a.toLowerCase() <= b.toLowerCase();\n    },\n    ascN(a, b) {\n        return naturalCompare(a, b) <= 0;\n    },\n    ascIN(a, b) {\n        return naturalCompare(a.toLowerCase(), b.toLowerCase()) <= 0;\n    },\n    desc(a, b) {\n        return isValidOrders.asc(b, a);\n    },\n    descI(a, b) {\n        return isValidOrders.ascI(b, a);\n    },\n    descN(a, b) {\n        return isValidOrders.ascN(b, a);\n    },\n    descIN(a, b) {\n        return isValidOrders.ascIN(b, a);\n    }\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require object keys to be sorted\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/sort-keys\"\n        },\n\n        schema: [\n            {\n                enum: [\"asc\", \"desc\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    caseSensitive: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    natural: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        // Parse options.\n        const order = context.options[0] || \"asc\";\n        const options = context.options[1];\n        const insensitive = options && options.caseSensitive === false;\n        const natual = options && options.natural;\n        const isValidOrder = isValidOrders[\n            order + (insensitive ? \"I\" : \"\") + (natual ? \"N\" : \"\")\n        ];\n\n        // The stack to save the previous property's name for each object literals.\n        let stack = null;\n\n        return {\n            ObjectExpression() {\n                stack = {\n                    upper: stack,\n                    prevName: null\n                };\n            },\n\n            \"ObjectExpression:exit\"() {\n                stack = stack.upper;\n            },\n\n            SpreadElement(node) {\n                if (node.parent.type === \"ObjectExpression\") {\n                    stack.prevName = null;\n                }\n            },\n\n            Property(node) {\n                if (node.parent.type === \"ObjectPattern\") {\n                    return;\n                }\n\n                const prevName = stack.prevName;\n                const thisName = getPropertyName(node);\n\n                stack.prevName = thisName || prevName;\n\n                if (!prevName || !thisName) {\n                    return;\n                }\n\n                if (!isValidOrder(prevName, thisName)) {\n                    context.report({\n                        node,\n                        loc: node.key.loc,\n                        message: \"Expected object keys to be in {{natual}}{{insensitive}}{{order}}ending order. '{{thisName}}' should be before '{{prevName}}'.\",\n                        data: {\n                            thisName,\n                            prevName,\n                            order,\n                            insensitive: insensitive ? \"insensitive \" : \"\",\n                            natual: natual ? \"natural \" : \"\"\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to require sorting of variables within a single Variable Declaration block\n * @author Ilya Volodin\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require variables within the same declaration block to be sorted\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/sort-vars\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreCase: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const configuration = context.options[0] || {},\n            ignoreCase = configuration.ignoreCase || false,\n            sourceCode = context.getSourceCode();\n\n        return {\n            VariableDeclaration(node) {\n                const idDeclarations = node.declarations.filter(decl => decl.id.type === \"Identifier\");\n                const getSortableName = ignoreCase ? decl => decl.id.name.toLowerCase() : decl => decl.id.name;\n                const unfixable = idDeclarations.some(decl => decl.init !== null && decl.init.type !== \"Literal\");\n                let fixed = false;\n\n                idDeclarations.slice(1).reduce((memo, decl) => {\n                    const lastVariableName = getSortableName(memo),\n                        currentVariableName = getSortableName(decl);\n\n                    if (currentVariableName < lastVariableName) {\n                        context.report({\n                            node: decl,\n                            message: \"Variables within the same declaration block should be sorted alphabetically.\",\n                            fix(fixer) {\n                                if (unfixable || fixed) {\n                                    return null;\n                                }\n                                return fixer.replaceTextRange(\n                                    [idDeclarations[0].range[0], idDeclarations[idDeclarations.length - 1].range[1]],\n                                    idDeclarations\n\n                                        // Clone the idDeclarations array to avoid mutating it\n                                        .slice()\n\n                                        // Sort the array into the desired order\n                                        .sort((declA, declB) => {\n                                            const aName = getSortableName(declA);\n                                            const bName = getSortableName(declB);\n\n                                            return aName > bName ? 1 : -1;\n                                        })\n\n                                        // Build a string out of the sorted list of identifier declarations and the text between the originals\n                                        .reduce((sourceText, identifier, index) => {\n                                            const textAfterIdentifier = index === idDeclarations.length - 1\n                                                ? \"\"\n                                                : sourceCode.getText().slice(idDeclarations[index].range[1], idDeclarations[index + 1].range[0]);\n\n                                            return sourceText + sourceCode.getText(identifier) + textAfterIdentifier;\n                                        }, \"\")\n\n                                );\n                            }\n                        });\n                        fixed = true;\n                        return memo;\n                    }\n                    return decl;\n\n                }, idDeclarations[0]);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview A rule to ensure whitespace before blocks.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/space-before-blocks\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            keywords: {\n                                enum: [\"always\", \"never\", \"off\"]\n                            },\n                            functions: {\n                                enum: [\"always\", \"never\", \"off\"]\n                            },\n                            classes: {\n                                enum: [\"always\", \"never\", \"off\"]\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const config = context.options[0],\n            sourceCode = context.getSourceCode();\n        let alwaysFunctions = true,\n            alwaysKeywords = true,\n            alwaysClasses = true,\n            neverFunctions = false,\n            neverKeywords = false,\n            neverClasses = false;\n\n        if (typeof config === \"object\") {\n            alwaysFunctions = config.functions === \"always\";\n            alwaysKeywords = config.keywords === \"always\";\n            alwaysClasses = config.classes === \"always\";\n            neverFunctions = config.functions === \"never\";\n            neverKeywords = config.keywords === \"never\";\n            neverClasses = config.classes === \"never\";\n        } else if (config === \"never\") {\n            alwaysFunctions = false;\n            alwaysKeywords = false;\n            alwaysClasses = false;\n            neverFunctions = true;\n            neverKeywords = true;\n            neverClasses = true;\n        }\n\n        /**\n         * Checks whether or not a given token is an arrow operator (=>) or a keyword\n         * in order to avoid to conflict with `arrow-spacing` and `keyword-spacing`.\n         *\n         * @param {Token} token - A token to check.\n         * @returns {boolean} `true` if the token is an arrow operator.\n         */\n        function isConflicted(token) {\n            return (token.type === \"Punctuator\" && token.value === \"=>\") || token.type === \"Keyword\";\n        }\n\n        /**\n         * Checks the given BlockStatement node has a preceding space if it doesn’t start on a new line.\n         * @param {ASTNode|Token} node The AST node of a BlockStatement.\n         * @returns {void} undefined.\n         */\n        function checkPrecedingSpace(node) {\n            const precedingToken = sourceCode.getTokenBefore(node);\n\n            if (precedingToken && !isConflicted(precedingToken) && astUtils.isTokenOnSameLine(precedingToken, node)) {\n                const hasSpace = sourceCode.isSpaceBetweenTokens(precedingToken, node);\n                const parent = context.getAncestors().pop();\n                let requireSpace;\n                let requireNoSpace;\n\n                if (parent.type === \"FunctionExpression\" || parent.type === \"FunctionDeclaration\") {\n                    requireSpace = alwaysFunctions;\n                    requireNoSpace = neverFunctions;\n                } else if (node.type === \"ClassBody\") {\n                    requireSpace = alwaysClasses;\n                    requireNoSpace = neverClasses;\n                } else {\n                    requireSpace = alwaysKeywords;\n                    requireNoSpace = neverKeywords;\n                }\n\n                if (requireSpace && !hasSpace) {\n                    context.report({\n                        node,\n                        message: \"Missing space before opening brace.\",\n                        fix(fixer) {\n                            return fixer.insertTextBefore(node, \" \");\n                        }\n                    });\n                } else if (requireNoSpace && hasSpace) {\n                    context.report({\n                        node,\n                        message: \"Unexpected space before opening brace.\",\n                        fix(fixer) {\n                            return fixer.removeRange([precedingToken.range[1], node.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Checks if the CaseBlock of an given SwitchStatement node has a preceding space.\n         * @param {ASTNode} node The node of a SwitchStatement.\n         * @returns {void} undefined.\n         */\n        function checkSpaceBeforeCaseBlock(node) {\n            const cases = node.cases;\n            let openingBrace;\n\n            if (cases.length > 0) {\n                openingBrace = sourceCode.getTokenBefore(cases[0]);\n            } else {\n                openingBrace = sourceCode.getLastToken(node, 1);\n            }\n\n            checkPrecedingSpace(openingBrace);\n        }\n\n        return {\n            BlockStatement: checkPrecedingSpace,\n            ClassBody: checkPrecedingSpace,\n            SwitchStatement: checkSpaceBeforeCaseBlock\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to validate spacing before function paren.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before `function` definition opening parenthesis\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/space-before-function-paren\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            anonymous: {\n                                enum: [\"always\", \"never\", \"ignore\"]\n                            },\n                            named: {\n                                enum: [\"always\", \"never\", \"ignore\"]\n                            },\n                            asyncArrow: {\n                                enum: [\"always\", \"never\", \"ignore\"]\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const baseConfig = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\n        const overrideConfig = typeof context.options[0] === \"object\" ? context.options[0] : {};\n\n        /**\n         * Determines whether a function has a name.\n         * @param {ASTNode} node The function node.\n         * @returns {boolean} Whether the function has a name.\n         */\n        function isNamedFunction(node) {\n            if (node.id) {\n                return true;\n            }\n\n            const parent = node.parent;\n\n            return parent.type === \"MethodDefinition\" ||\n                (parent.type === \"Property\" &&\n                    (\n                        parent.kind === \"get\" ||\n                        parent.kind === \"set\" ||\n                        parent.method\n                    )\n                );\n        }\n\n        /**\n         * Gets the config for a given function\n         * @param {ASTNode} node The function node\n         * @returns {string} \"always\", \"never\", or \"ignore\"\n         */\n        function getConfigForFunction(node) {\n            if (node.type === \"ArrowFunctionExpression\") {\n\n                // Always ignore non-async functions and arrow functions without parens, e.g. async foo => bar\n                if (node.async && astUtils.isOpeningParenToken(sourceCode.getFirstToken(node, { skip: 1 }))) {\n                    return overrideConfig.asyncArrow || baseConfig;\n                }\n            } else if (isNamedFunction(node)) {\n                return overrideConfig.named || baseConfig;\n\n            // `generator-star-spacing` should warn anonymous generators. E.g. `function* () {}`\n            } else if (!node.generator) {\n                return overrideConfig.anonymous || baseConfig;\n            }\n\n            return \"ignore\";\n        }\n\n        /**\n         * Checks the parens of a function node\n         * @param {ASTNode} node A function node\n         * @returns {void}\n         */\n        function checkFunction(node) {\n            const functionConfig = getConfigForFunction(node);\n\n            if (functionConfig === \"ignore\") {\n                return;\n            }\n\n            const rightToken = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\n            const leftToken = sourceCode.getTokenBefore(rightToken);\n            const hasSpacing = sourceCode.isSpaceBetweenTokens(leftToken, rightToken);\n\n            if (hasSpacing && functionConfig === \"never\") {\n                context.report({\n                    node,\n                    loc: leftToken.loc.end,\n                    message: \"Unexpected space before function parentheses.\",\n                    fix: fixer => fixer.removeRange([leftToken.range[1], rightToken.range[0]])\n                });\n            } else if (!hasSpacing && functionConfig === \"always\") {\n                context.report({\n                    node,\n                    loc: leftToken.loc.end,\n                    message: \"Missing space before function parentheses.\",\n                    fix: fixer => fixer.insertTextAfter(leftToken, \" \")\n                });\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: checkFunction,\n            FunctionDeclaration: checkFunction,\n            FunctionExpression: checkFunction\n        };\n    }\n};\n","/**\n * @fileoverview Disallows or enforces spaces inside of parentheses.\n * @author Jonathan Rajavuori\n */\n\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing inside parentheses\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/space-in-parens\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            enum: [\"{}\", \"[]\", \"()\", \"empty\"]\n                        },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const MISSING_SPACE_MESSAGE = \"There must be a space inside this paren.\",\n            REJECTED_SPACE_MESSAGE = \"There should be no spaces inside this paren.\",\n            ALWAYS = context.options[0] === \"always\",\n            exceptionsArrayOptions = (context.options[1] && context.options[1].exceptions) || [],\n            options = {};\n        let exceptions;\n\n        if (exceptionsArrayOptions.length) {\n            options.braceException = exceptionsArrayOptions.indexOf(\"{}\") !== -1;\n            options.bracketException = exceptionsArrayOptions.indexOf(\"[]\") !== -1;\n            options.parenException = exceptionsArrayOptions.indexOf(\"()\") !== -1;\n            options.empty = exceptionsArrayOptions.indexOf(\"empty\") !== -1;\n        }\n\n        /**\n         * Produces an object with the opener and closer exception values\n         * @returns {Object} `openers` and `closers` exception values\n         * @private\n         */\n        function getExceptions() {\n            const openers = [],\n                closers = [];\n\n            if (options.braceException) {\n                openers.push(\"{\");\n                closers.push(\"}\");\n            }\n\n            if (options.bracketException) {\n                openers.push(\"[\");\n                closers.push(\"]\");\n            }\n\n            if (options.parenException) {\n                openers.push(\"(\");\n                closers.push(\")\");\n            }\n\n            if (options.empty) {\n                openers.push(\")\");\n                closers.push(\"(\");\n            }\n\n            return {\n                openers,\n                closers\n            };\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines if a token is one of the exceptions for the opener paren\n         * @param {Object} token The token to check\n         * @returns {boolean} True if the token is one of the exceptions for the opener paren\n         */\n        function isOpenerException(token) {\n            return token.type === \"Punctuator\" && exceptions.openers.indexOf(token.value) >= 0;\n        }\n\n        /**\n         * Determines if a token is one of the exceptions for the closer paren\n         * @param {Object} token The token to check\n         * @returns {boolean} True if the token is one of the exceptions for the closer paren\n         */\n        function isCloserException(token) {\n            return token.type === \"Punctuator\" && exceptions.closers.indexOf(token.value) >= 0;\n        }\n\n        /**\n         * Determines if an opener paren should have a missing space after it\n         * @param {Object} left The paren token\n         * @param {Object} right The token after it\n         * @returns {boolean} True if the paren should have a space\n         */\n        function shouldOpenerHaveSpace(left, right) {\n            if (sourceCode.isSpaceBetweenTokens(left, right)) {\n                return false;\n            }\n\n            if (ALWAYS) {\n                if (astUtils.isClosingParenToken(right)) {\n                    return false;\n                }\n                return !isOpenerException(right);\n            }\n            return isOpenerException(right);\n\n        }\n\n        /**\n         * Determines if an closer paren should have a missing space after it\n         * @param {Object} left The token before the paren\n         * @param {Object} right The paren token\n         * @returns {boolean} True if the paren should have a space\n         */\n        function shouldCloserHaveSpace(left, right) {\n            if (astUtils.isOpeningParenToken(left)) {\n                return false;\n            }\n\n            if (sourceCode.isSpaceBetweenTokens(left, right)) {\n                return false;\n            }\n\n            if (ALWAYS) {\n                return !isCloserException(left);\n            }\n            return isCloserException(left);\n\n        }\n\n        /**\n         * Determines if an opener paren should not have an existing space after it\n         * @param {Object} left The paren token\n         * @param {Object} right The token after it\n         * @returns {boolean} True if the paren should reject the space\n         */\n        function shouldOpenerRejectSpace(left, right) {\n            if (right.type === \"Line\") {\n                return false;\n            }\n\n            if (!astUtils.isTokenOnSameLine(left, right)) {\n                return false;\n            }\n\n            if (!sourceCode.isSpaceBetweenTokens(left, right)) {\n                return false;\n            }\n\n            if (ALWAYS) {\n                return isOpenerException(right);\n            }\n            return !isOpenerException(right);\n\n        }\n\n        /**\n         * Determines if an closer paren should not have an existing space after it\n         * @param {Object} left The token before the paren\n         * @param {Object} right The paren token\n         * @returns {boolean} True if the paren should reject the space\n         */\n        function shouldCloserRejectSpace(left, right) {\n            if (astUtils.isOpeningParenToken(left)) {\n                return false;\n            }\n\n            if (!astUtils.isTokenOnSameLine(left, right)) {\n                return false;\n            }\n\n            if (!sourceCode.isSpaceBetweenTokens(left, right)) {\n                return false;\n            }\n\n            if (ALWAYS) {\n                return isCloserException(left);\n            }\n            return !isCloserException(left);\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: function checkParenSpaces(node) {\n                exceptions = getExceptions();\n                const tokens = sourceCode.tokensAndComments;\n\n                tokens.forEach((token, i) => {\n                    const prevToken = tokens[i - 1];\n                    const nextToken = tokens[i + 1];\n\n                    if (!astUtils.isOpeningParenToken(token) && !astUtils.isClosingParenToken(token)) {\n                        return;\n                    }\n\n                    if (token.value === \"(\" && shouldOpenerHaveSpace(token, nextToken)) {\n                        context.report({\n                            node,\n                            loc: token.loc.start,\n                            message: MISSING_SPACE_MESSAGE,\n                            fix(fixer) {\n                                return fixer.insertTextAfter(token, \" \");\n                            }\n                        });\n                    } else if (token.value === \"(\" && shouldOpenerRejectSpace(token, nextToken)) {\n                        context.report({\n                            node,\n                            loc: token.loc.start,\n                            message: REJECTED_SPACE_MESSAGE,\n                            fix(fixer) {\n                                return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                            }\n                        });\n                    } else if (token.value === \")\" && shouldCloserHaveSpace(prevToken, token)) {\n\n                        // context.report(node, token.loc.start, MISSING_SPACE_MESSAGE);\n                        context.report({\n                            node,\n                            loc: token.loc.start,\n                            message: MISSING_SPACE_MESSAGE,\n                            fix(fixer) {\n                                return fixer.insertTextBefore(token, \" \");\n                            }\n                        });\n                    } else if (token.value === \")\" && shouldCloserRejectSpace(prevToken, token)) {\n                        context.report({\n                            node,\n                            loc: token.loc.start,\n                            message: REJECTED_SPACE_MESSAGE,\n                            fix(fixer) {\n                                return fixer.removeRange([prevToken.range[1], token.range[0]]);\n                            }\n                        });\n                    }\n                });\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Require spaces around infix operators\n * @author Michael Ficarra\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require spacing around infix operators\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/space-infix-ops\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    int32Hint: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Returns the first token which violates the rule\n         * @param {ASTNode} left - The left node of the main node\n         * @param {ASTNode} right - The right node of the main node\n         * @param {string} op - The operator of the main node\n         * @returns {Object} The violator token or null\n         * @private\n         */\n        function getFirstNonSpacedToken(left, right, op) {\n            const operator = sourceCode.getFirstTokenBetween(left, right, token => token.value === op);\n            const prev = sourceCode.getTokenBefore(operator);\n            const next = sourceCode.getTokenAfter(operator);\n\n            if (!sourceCode.isSpaceBetweenTokens(prev, operator) || !sourceCode.isSpaceBetweenTokens(operator, next)) {\n                return operator;\n            }\n\n            return null;\n        }\n\n        /**\n         * Reports an AST node as a rule violation\n         * @param {ASTNode} mainNode - The node to report\n         * @param {Object} culpritToken - The token which has a problem\n         * @returns {void}\n         * @private\n         */\n        function report(mainNode, culpritToken) {\n            context.report({\n                node: mainNode,\n                loc: culpritToken.loc.start,\n                message: \"Operator '{{operator}}' must be spaced.\",\n                data: {\n                    operator: culpritToken.value\n                },\n                fix(fixer) {\n                    const previousToken = sourceCode.getTokenBefore(culpritToken);\n                    const afterToken = sourceCode.getTokenAfter(culpritToken);\n                    let fixString = \"\";\n\n                    if (culpritToken.range[0] - previousToken.range[1] === 0) {\n                        fixString = \" \";\n                    }\n\n                    fixString += culpritToken.value;\n\n                    if (afterToken.range[0] - culpritToken.range[1] === 0) {\n                        fixString += \" \";\n                    }\n\n                    return fixer.replaceText(culpritToken, fixString);\n                }\n            });\n        }\n\n        /**\n         * Check if the node is binary then report\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkBinary(node) {\n            const leftNode = (node.left.typeAnnotation) ? node.left.typeAnnotation : node.left;\n            const rightNode = node.right;\n\n            // search for = in AssignmentPattern nodes\n            const operator = node.operator || \"=\";\n\n            const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, operator);\n\n            if (nonSpacedNode) {\n                if (!(int32Hint && sourceCode.getText(node).endsWith(\"|0\"))) {\n                    report(node, nonSpacedNode);\n                }\n            }\n        }\n\n        /**\n         * Check if the node is conditional\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkConditional(node) {\n            const nonSpacedConsequesntNode = getFirstNonSpacedToken(node.test, node.consequent, \"?\");\n            const nonSpacedAlternateNode = getFirstNonSpacedToken(node.consequent, node.alternate, \":\");\n\n            if (nonSpacedConsequesntNode) {\n                report(node, nonSpacedConsequesntNode);\n            } else if (nonSpacedAlternateNode) {\n                report(node, nonSpacedAlternateNode);\n            }\n        }\n\n        /**\n         * Check if the node is a variable\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkVar(node) {\n            const leftNode = (node.id.typeAnnotation) ? node.id.typeAnnotation : node.id;\n            const rightNode = node.init;\n\n            if (rightNode) {\n                const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, \"=\");\n\n                if (nonSpacedNode) {\n                    report(node, nonSpacedNode);\n                }\n            }\n        }\n\n        return {\n            AssignmentExpression: checkBinary,\n            AssignmentPattern: checkBinary,\n            BinaryExpression: checkBinary,\n            LogicalExpression: checkBinary,\n            ConditionalExpression: checkConditional,\n            VariableDeclarator: checkVar\n        };\n\n    }\n};\n","/**\n * @fileoverview This rule shoud require or disallow spaces before or after unary operations.\n * @author Marcin Kumorek\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing before or after unary operators\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/space-unary-ops\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    words: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    nonwords: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    overrides: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"boolean\"\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            unexpectedBefore: \"Unexpected space before unary operator '{{operator}}'.\",\n            unexpectedAfter: \"Unexpected space after unary operator '{{operator}}'.\",\n            unexpectedAfterWord: \"Unexpected space after unary word operator '{{word}}'.\",\n            wordOperator: \"Unary word operator '{{word}}' must be followed by whitespace.\",\n            operator: \"Unary operator '{{operator}}' must be followed by whitespace.\",\n            beforeUnaryExpressions: \"Space is required before unary expressions '{{token}}'.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || { words: true, nonwords: false };\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Check if the node is the first \"!\" in a \"!!\" convert to Boolean expression\n         * @param {ASTnode} node AST node\n         * @returns {boolean} Whether or not the node is first \"!\" in \"!!\"\n         */\n        function isFirstBangInBangBangExpression(node) {\n            return node && node.type === \"UnaryExpression\" && node.argument.operator === \"!\" &&\n                node.argument && node.argument.type === \"UnaryExpression\" && node.argument.operator === \"!\";\n        }\n\n        /**\n         * Checks if an override exists for a given operator.\n         * @param {string} operator Operator\n         * @returns {boolean} Whether or not an override has been provided for the operator\n         */\n        function overrideExistsForOperator(operator) {\n            return options.overrides && Object.prototype.hasOwnProperty.call(options.overrides, operator);\n        }\n\n        /**\n         * Gets the value that the override was set to for this operator\n         * @param {string} operator Operator\n         * @returns {boolean} Whether or not an override enforces a space with this operator\n         */\n        function overrideEnforcesSpaces(operator) {\n            return options.overrides[operator];\n        }\n\n        /**\n         * Verify Unary Word Operator has spaces after the word operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken first token from the AST node\n         * @param {Object} secondToken second token from the AST node\n         * @param {string} word The word to be used for reporting\n         * @returns {void}\n         */\n        function verifyWordHasSpaces(node, firstToken, secondToken, word) {\n            if (secondToken.range[0] === firstToken.range[1]) {\n                context.report({\n                    node,\n                    messageId: \"wordOperator\",\n                    data: {\n                        word\n                    },\n                    fix(fixer) {\n                        return fixer.insertTextAfter(firstToken, \" \");\n                    }\n                });\n            }\n        }\n\n        /**\n         * Verify Unary Word Operator doesn't have spaces after the word operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken first token from the AST node\n         * @param {Object} secondToken second token from the AST node\n         * @param {string} word The word to be used for reporting\n         * @returns {void}\n         */\n        function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {\n            if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedAfterWord\",\n                        data: {\n                            word\n                        },\n                        fix(fixer) {\n                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Check Unary Word Operators for spaces after the word operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken first token from the AST node\n         * @param {Object} secondToken second token from the AST node\n         * @param {string} word The word to be used for reporting\n         * @returns {void}\n         */\n        function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {\n            if (overrideExistsForOperator(word)) {\n                if (overrideEnforcesSpaces(word)) {\n                    verifyWordHasSpaces(node, firstToken, secondToken, word);\n                } else {\n                    verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n                }\n            } else if (options.words) {\n                verifyWordHasSpaces(node, firstToken, secondToken, word);\n            } else {\n                verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n            }\n        }\n\n        /**\n         * Verifies YieldExpressions satisfy spacing requirements\n         * @param {ASTnode} node AST node\n         * @returns {void}\n         */\n        function checkForSpacesAfterYield(node) {\n            const tokens = sourceCode.getFirstTokens(node, 3),\n                word = \"yield\";\n\n            if (!node.argument || node.delegate) {\n                return;\n            }\n\n            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);\n        }\n\n        /**\n         * Verifies AwaitExpressions satisfy spacing requirements\n         * @param {ASTNode} node AwaitExpression AST node\n         * @returns {void}\n         */\n        function checkForSpacesAfterAwait(node) {\n            const tokens = sourceCode.getFirstTokens(node, 3);\n\n            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], \"await\");\n        }\n\n        /**\n         * Verifies UnaryExpression, UpdateExpression and NewExpression have spaces before or after the operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken First token in the expression\n         * @param {Object} secondToken Second token in the expression\n         * @returns {void}\n         */\n        function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {\n            if (node.prefix) {\n                if (isFirstBangInBangBangExpression(node)) {\n                    return;\n                }\n                if (firstToken.range[1] === secondToken.range[0]) {\n                    context.report({\n                        node,\n                        messageId: \"operator\",\n                        data: {\n                            operator: firstToken.value\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextAfter(firstToken, \" \");\n                        }\n                    });\n                }\n            } else {\n                if (firstToken.range[1] === secondToken.range[0]) {\n                    context.report({\n                        node,\n                        messageId: \"beforeUnaryExpressions\",\n                        data: {\n                            token: secondToken.value\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextBefore(secondToken, \" \");\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Verifies UnaryExpression, UpdateExpression and NewExpression don't have spaces before or after the operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken First token in the expression\n         * @param {Object} secondToken Second token in the expression\n         * @returns {void}\n         */\n        function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {\n            if (node.prefix) {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedAfter\",\n                        data: {\n                            operator: firstToken.value\n                        },\n                        fix(fixer) {\n                            if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\n                                return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                            }\n                            return null;\n                        }\n                    });\n                }\n            } else {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedBefore\",\n                        data: {\n                            operator: secondToken.value\n                        },\n                        fix(fixer) {\n                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Verifies UnaryExpression, UpdateExpression and NewExpression satisfy spacing requirements\n         * @param {ASTnode} node AST node\n         * @returns {void}\n         */\n        function checkForSpaces(node) {\n            const tokens = node.type === \"UpdateExpression\" && !node.prefix\n                ? sourceCode.getLastTokens(node, 2)\n                : sourceCode.getFirstTokens(node, 2);\n            const firstToken = tokens[0];\n            const secondToken = tokens[1];\n\n            if ((node.type === \"NewExpression\" || node.prefix) && firstToken.type === \"Keyword\") {\n                checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, firstToken.value);\n                return;\n            }\n\n            const operator = node.prefix ? tokens[0].value : tokens[1].value;\n\n            if (overrideExistsForOperator(operator)) {\n                if (overrideEnforcesSpaces(operator)) {\n                    verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n                } else {\n                    verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n                }\n            } else if (options.nonwords) {\n                verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n            } else {\n                verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            UnaryExpression: checkForSpaces,\n            UpdateExpression: checkForSpaces,\n            NewExpression: checkForSpaces,\n            YieldExpression: checkForSpacesAfterYield,\n            AwaitExpression: checkForSpacesAfterAwait\n        };\n\n    }\n};\n","/**\n * @fileoverview Source code for spaced-comments rule\n * @author Gyandeep Singh\n */\n\n\nconst lodash = require(\"lodash\");\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Escapes the control characters of a given string.\n * @param {string} s - A string to escape.\n * @returns {string} An escaped string.\n */\nfunction escape(s) {\n    return `(?:${lodash.escapeRegExp(s)})`;\n}\n\n/**\n * Escapes the control characters of a given string.\n * And adds a repeat flag.\n * @param {string} s - A string to escape.\n * @returns {string} An escaped string.\n */\nfunction escapeAndRepeat(s) {\n    return `${escape(s)}+`;\n}\n\n/**\n * Parses `markers` option.\n * If markers don't include `\"*\"`, this adds `\"*\"` to allow JSDoc comments.\n * @param {string[]} [markers] - A marker list.\n * @returns {string[]} A marker list.\n */\nfunction parseMarkersOption(markers) {\n\n    // `*` is a marker for JSDoc comments.\n    if (markers.indexOf(\"*\") === -1) {\n        return markers.concat(\"*\");\n    }\n\n    return markers;\n}\n\n/**\n * Creates string pattern for exceptions.\n * Generated pattern:\n *\n * 1. A space or an exception pattern sequence.\n *\n * @param {string[]} exceptions - An exception pattern list.\n * @returns {string} A regular expression string for exceptions.\n */\nfunction createExceptionsPattern(exceptions) {\n    let pattern = \"\";\n\n    /*\n     * A space or an exception pattern sequence.\n     * []                 ==> \"\\s\"\n     * [\"-\"]              ==> \"(?:\\s|\\-+$)\"\n     * [\"-\", \"=\"]         ==> \"(?:\\s|(?:\\-+|=+)$)\"\n     * [\"-\", \"=\", \"--==\"] ==> \"(?:\\s|(?:\\-+|=+|(?:\\-\\-==)+)$)\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5Cs%7C(%3F%3A%5C-%2B%7C%3D%2B%7C(%3F%3A%5C-%5C-%3D%3D)%2B)%24)\n     */\n    if (exceptions.length === 0) {\n\n        // a space.\n        pattern += \"\\\\s\";\n    } else {\n\n        // a space or...\n        pattern += \"(?:\\\\s|\";\n\n        if (exceptions.length === 1) {\n\n            // a sequence of the exception pattern.\n            pattern += escapeAndRepeat(exceptions[0]);\n        } else {\n\n            // a sequence of one of the exception patterns.\n            pattern += \"(?:\";\n            pattern += exceptions.map(escapeAndRepeat).join(\"|\");\n            pattern += \")\";\n        }\n        pattern += `(?:$|[${Array.from(astUtils.LINEBREAKS).join(\"\")}]))`;\n    }\n\n    return pattern;\n}\n\n/**\n * Creates RegExp object for `always` mode.\n * Generated pattern for beginning of comment:\n *\n * 1. First, a marker or nothing.\n * 2. Next, a space or an exception pattern sequence.\n *\n * @param {string[]} markers - A marker list.\n * @param {string[]} exceptions - An exception pattern list.\n * @returns {RegExp} A RegExp object for the beginning of a comment in `always` mode.\n */\nfunction createAlwaysStylePattern(markers, exceptions) {\n    let pattern = \"^\";\n\n    /*\n     * A marker or nothing.\n     * [\"*\"]            ==> \"\\*?\"\n     * [\"*\", \"!\"]       ==> \"(?:\\*|!)?\"\n     * [\"*\", \"/\", \"!<\"] ==> \"(?:\\*|\\/|(?:!<))?\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5C*%7C%5C%2F%7C(%3F%3A!%3C))%3F\n     */\n    if (markers.length === 1) {\n\n        // the marker.\n        pattern += escape(markers[0]);\n    } else {\n\n        // one of markers.\n        pattern += \"(?:\";\n        pattern += markers.map(escape).join(\"|\");\n        pattern += \")\";\n    }\n\n    pattern += \"?\"; // or nothing.\n    pattern += createExceptionsPattern(exceptions);\n\n    return new RegExp(pattern); // eslint-disable-line require-unicode-regexp\n}\n\n/**\n * Creates RegExp object for `never` mode.\n * Generated pattern for beginning of comment:\n *\n * 1. First, a marker or nothing (captured).\n * 2. Next, a space or a tab.\n *\n * @param {string[]} markers - A marker list.\n * @returns {RegExp} A RegExp object for `never` mode.\n */\nfunction createNeverStylePattern(markers) {\n    const pattern = `^(${markers.map(escape).join(\"|\")})?[ \\t]+`;\n\n    return new RegExp(pattern); // eslint-disable-line require-unicode-regexp\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce consistent spacing after the `//` or `/*` in a comment\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/spaced-comment\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    markers: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    line: {\n                        type: \"object\",\n                        properties: {\n                            exceptions: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            markers: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    block: {\n                        type: \"object\",\n                        properties: {\n                            exceptions: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            markers: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            balanced: {\n                                type: \"boolean\",\n                                default: false\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n\n        // Unless the first option is never, require a space\n        const requireSpace = context.options[0] !== \"never\";\n\n        /*\n         * Parse the second options.\n         * If markers don't include `\"*\"`, it's added automatically for JSDoc\n         * comments.\n         */\n        const config = context.options[1] || {};\n        const balanced = config.block && config.block.balanced;\n\n        const styleRules = [\"block\", \"line\"].reduce((rule, type) => {\n            const markers = parseMarkersOption(config[type] && config[type].markers || config.markers || []);\n            const exceptions = config[type] && config[type].exceptions || config.exceptions || [];\n            const endNeverPattern = \"[ \\t]+$\";\n\n            // Create RegExp object for valid patterns.\n            rule[type] = {\n                beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),\n                endRegex: balanced && requireSpace ? new RegExp(`${createExceptionsPattern(exceptions)}$`) : new RegExp(endNeverPattern), // eslint-disable-line require-unicode-regexp\n                hasExceptions: exceptions.length > 0,\n                markers: new RegExp(`^(${markers.map(escape).join(\"|\")})`) // eslint-disable-line require-unicode-regexp\n            };\n\n            return rule;\n        }, {});\n\n        /**\n         * Reports a beginning spacing error with an appropriate message.\n         * @param {ASTNode} node - A comment node to check.\n         * @param {string} message - An error message to report.\n         * @param {Array} match - An array of match results for markers.\n         * @param {string} refChar - Character used for reference in the error message.\n         * @returns {void}\n         */\n        function reportBegin(node, message, match, refChar) {\n            const type = node.type.toLowerCase(),\n                commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n\n            context.report({\n                node,\n                fix(fixer) {\n                    const start = node.range[0];\n                    let end = start + 2;\n\n                    if (requireSpace) {\n                        if (match) {\n                            end += match[0].length;\n                        }\n                        return fixer.insertTextAfterRange([start, end], \" \");\n                    }\n                    end += match[0].length;\n                    return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : \"\"));\n\n                },\n                message,\n                data: { refChar }\n            });\n        }\n\n        /**\n         * Reports an ending spacing error with an appropriate message.\n         * @param {ASTNode} node - A comment node to check.\n         * @param {string} message - An error message to report.\n         * @param {string} match - An array of the matched whitespace characters.\n         * @returns {void}\n         */\n        function reportEnd(node, message, match) {\n            context.report({\n                node,\n                fix(fixer) {\n                    if (requireSpace) {\n                        return fixer.insertTextAfterRange([node.range[0], node.range[1] - 2], \" \");\n                    }\n                    const end = node.range[1] - 2,\n                        start = end - match[0].length;\n\n                    return fixer.replaceTextRange([start, end], \"\");\n\n                },\n                message\n            });\n        }\n\n        /**\n         * Reports a given comment if it's invalid.\n         * @param {ASTNode} node - a comment node to check.\n         * @returns {void}\n         */\n        function checkCommentForSpace(node) {\n            const type = node.type.toLowerCase(),\n                rule = styleRules[type],\n                commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n\n            // Ignores empty comments.\n            if (node.value.length === 0) {\n                return;\n            }\n\n            const beginMatch = rule.beginRegex.exec(node.value);\n            const endMatch = rule.endRegex.exec(node.value);\n\n            // Checks.\n            if (requireSpace) {\n                if (!beginMatch) {\n                    const hasMarker = rule.markers.exec(node.value);\n                    const marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;\n\n                    if (rule.hasExceptions) {\n                        reportBegin(node, \"Expected exception block, space or tab after '{{refChar}}' in comment.\", hasMarker, marker);\n                    } else {\n                        reportBegin(node, \"Expected space or tab after '{{refChar}}' in comment.\", hasMarker, marker);\n                    }\n                }\n\n                if (balanced && type === \"block\" && !endMatch) {\n                    reportEnd(node, \"Expected space or tab before '*/' in comment.\");\n                }\n            } else {\n                if (beginMatch) {\n                    if (!beginMatch[1]) {\n                        reportBegin(node, \"Unexpected space or tab after '{{refChar}}' in comment.\", beginMatch, commentIdentifier);\n                    } else {\n                        reportBegin(node, \"Unexpected space or tab after marker ({{refChar}}) in comment.\", beginMatch, beginMatch[1]);\n                    }\n                }\n\n                if (balanced && type === \"block\" && endMatch) {\n                    reportEnd(node, \"Unexpected space or tab before '*/' in comment.\", endMatch);\n                }\n            }\n        }\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments.filter(token => token.type !== \"Shebang\").forEach(checkCommentForSpace);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to control usage of strict mode directives.\n * @author Brandon Mills\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets all of the Use Strict Directives in the Directive Prologue of a group of\n * statements.\n * @param {ASTNode[]} statements Statements in the program or function body.\n * @returns {ASTNode[]} All of the Use Strict Directives.\n */\nfunction getUseStrictDirectives(statements) {\n    const directives = [];\n\n    for (let i = 0; i < statements.length; i++) {\n        const statement = statements[i];\n\n        if (\n            statement.type === \"ExpressionStatement\" &&\n            statement.expression.type === \"Literal\" &&\n            statement.expression.value === \"use strict\"\n        ) {\n            directives[i] = statement;\n        } else {\n            break;\n        }\n    }\n\n    return directives;\n}\n\n/**\n * Checks whether a given parameter is a simple parameter.\n *\n * @param {ASTNode} node - A pattern node to check.\n * @returns {boolean} `true` if the node is an Identifier node.\n */\nfunction isSimpleParameter(node) {\n    return node.type === \"Identifier\";\n}\n\n/**\n * Checks whether a given parameter list is a simple parameter list.\n *\n * @param {ASTNode[]} params - A parameter list to check.\n * @returns {boolean} `true` if the every parameter is an Identifier node.\n */\nfunction isSimpleParameterList(params) {\n    return params.every(isSimpleParameter);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require or disallow strict mode directives\",\n            category: \"Strict Mode\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/strict\"\n        },\n\n        schema: [\n            {\n                enum: [\"never\", \"global\", \"function\", \"safe\"]\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            function: \"Use the function form of 'use strict'.\",\n            global: \"Use the global form of 'use strict'.\",\n            multiple: \"Multiple 'use strict' directives.\",\n            never: \"Strict mode is not permitted.\",\n            unnecessary: \"Unnecessary 'use strict' directive.\",\n            module: \"'use strict' is unnecessary inside of modules.\",\n            implied: \"'use strict' is unnecessary when implied strict mode is enabled.\",\n            unnecessaryInClasses: \"'use strict' is unnecessary inside of classes.\",\n            nonSimpleParameterList: \"'use strict' directive inside a function with non-simple parameter list throws a syntax error since ES2016.\",\n            wrap: \"Wrap {{name}} in a function with 'use strict' directive.\"\n        }\n    },\n\n    create(context) {\n\n        const ecmaFeatures = context.parserOptions.ecmaFeatures || {},\n            scopes = [],\n            classScopes = [];\n        let mode = context.options[0] || \"safe\";\n\n        if (ecmaFeatures.impliedStrict) {\n            mode = \"implied\";\n        } else if (mode === \"safe\") {\n            mode = ecmaFeatures.globalReturn ? \"global\" : \"function\";\n        }\n\n        /**\n         * Determines whether a reported error should be fixed, depending on the error type.\n         * @param {string} errorType The type of error\n         * @returns {boolean} `true` if the reported error should be fixed\n         */\n        function shouldFix(errorType) {\n            return errorType === \"multiple\" || errorType === \"unnecessary\" || errorType === \"module\" || errorType === \"implied\" || errorType === \"unnecessaryInClasses\";\n        }\n\n        /**\n         * Gets a fixer function to remove a given 'use strict' directive.\n         * @param {ASTNode} node The directive that should be removed\n         * @returns {Function} A fixer function\n         */\n        function getFixFunction(node) {\n            return fixer => fixer.remove(node);\n        }\n\n        /**\n         * Report a slice of an array of nodes with a given message.\n         * @param {ASTNode[]} nodes Nodes.\n         * @param {string} start Index to start from.\n         * @param {string} end Index to end before.\n         * @param {string} messageId Message to display.\n         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\n         * @returns {void}\n         */\n        function reportSlice(nodes, start, end, messageId, fix) {\n            nodes.slice(start, end).forEach(node => {\n                context.report({ node, messageId, fix: fix ? getFixFunction(node) : null });\n            });\n        }\n\n        /**\n         * Report all nodes in an array with a given message.\n         * @param {ASTNode[]} nodes Nodes.\n         * @param {string} messageId Message id to display.\n         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\n         * @returns {void}\n         */\n        function reportAll(nodes, messageId, fix) {\n            reportSlice(nodes, 0, nodes.length, messageId, fix);\n        }\n\n        /**\n         * Report all nodes in an array, except the first, with a given message.\n         * @param {ASTNode[]} nodes Nodes.\n         * @param {string} messageId Message id to display.\n         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\n         * @returns {void}\n         */\n        function reportAllExceptFirst(nodes, messageId, fix) {\n            reportSlice(nodes, 1, nodes.length, messageId, fix);\n        }\n\n        /**\n         * Entering a function in 'function' mode pushes a new nested scope onto the\n         * stack. The new scope is true if the nested function is strict mode code.\n         * @param {ASTNode} node The function declaration or expression.\n         * @param {ASTNode[]} useStrictDirectives The Use Strict Directives of the node.\n         * @returns {void}\n         */\n        function enterFunctionInFunctionMode(node, useStrictDirectives) {\n            const isInClass = classScopes.length > 0,\n                isParentGlobal = scopes.length === 0 && classScopes.length === 0,\n                isParentStrict = scopes.length > 0 && scopes[scopes.length - 1],\n                isStrict = useStrictDirectives.length > 0;\n\n            if (isStrict) {\n                if (!isSimpleParameterList(node.params)) {\n                    context.report({ node: useStrictDirectives[0], messageId: \"nonSimpleParameterList\" });\n                } else if (isParentStrict) {\n                    context.report({ node: useStrictDirectives[0], messageId: \"unnecessary\", fix: getFixFunction(useStrictDirectives[0]) });\n                } else if (isInClass) {\n                    context.report({ node: useStrictDirectives[0], messageId: \"unnecessaryInClasses\", fix: getFixFunction(useStrictDirectives[0]) });\n                }\n\n                reportAllExceptFirst(useStrictDirectives, \"multiple\", true);\n            } else if (isParentGlobal) {\n                if (isSimpleParameterList(node.params)) {\n                    context.report({ node, messageId: \"function\" });\n                } else {\n                    context.report({\n                        node,\n                        messageId: \"wrap\",\n                        data: { name: astUtils.getFunctionNameWithKind(node) }\n                    });\n                }\n            }\n\n            scopes.push(isParentStrict || isStrict);\n        }\n\n        /**\n         * Exiting a function in 'function' mode pops its scope off the stack.\n         * @returns {void}\n         */\n        function exitFunctionInFunctionMode() {\n            scopes.pop();\n        }\n\n        /**\n         * Enter a function and either:\n         * - Push a new nested scope onto the stack (in 'function' mode).\n         * - Report all the Use Strict Directives (in the other modes).\n         * @param {ASTNode} node The function declaration or expression.\n         * @returns {void}\n         */\n        function enterFunction(node) {\n            const isBlock = node.body.type === \"BlockStatement\",\n                useStrictDirectives = isBlock\n                    ? getUseStrictDirectives(node.body.body) : [];\n\n            if (mode === \"function\") {\n                enterFunctionInFunctionMode(node, useStrictDirectives);\n            } else if (useStrictDirectives.length > 0) {\n                if (isSimpleParameterList(node.params)) {\n                    reportAll(useStrictDirectives, mode, shouldFix(mode));\n                } else {\n                    context.report({ node: useStrictDirectives[0], messageId: \"nonSimpleParameterList\" });\n                    reportAllExceptFirst(useStrictDirectives, \"multiple\", true);\n                }\n            }\n        }\n\n        const rule = {\n            Program(node) {\n                const useStrictDirectives = getUseStrictDirectives(node.body);\n\n                if (node.sourceType === \"module\") {\n                    mode = \"module\";\n                }\n\n                if (mode === \"global\") {\n                    if (node.body.length > 0 && useStrictDirectives.length === 0) {\n                        context.report({ node, messageId: \"global\" });\n                    }\n                    reportAllExceptFirst(useStrictDirectives, \"multiple\", true);\n                } else {\n                    reportAll(useStrictDirectives, mode, shouldFix(mode));\n                }\n            },\n            FunctionDeclaration: enterFunction,\n            FunctionExpression: enterFunction,\n            ArrowFunctionExpression: enterFunction\n        };\n\n        if (mode === \"function\") {\n            Object.assign(rule, {\n\n                // Inside of class bodies are always strict mode.\n                ClassBody() {\n                    classScopes.push(true);\n                },\n                \"ClassBody:exit\"() {\n                    classScopes.pop();\n                },\n\n                \"FunctionDeclaration:exit\": exitFunctionInFunctionMode,\n                \"FunctionExpression:exit\": exitFunctionInFunctionMode,\n                \"ArrowFunctionExpression:exit\": exitFunctionInFunctionMode\n            });\n        }\n\n        return rule;\n    }\n};\n","/**\n * @fileoverview Rule to enforce spacing around colons of switch statements.\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce spacing around colons of switch statements\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/switch-colon-spacing\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: { type: \"boolean\", default: false },\n                    after: { type: \"boolean\", default: true }\n                },\n                additionalProperties: false\n            }\n        ],\n        fixable: \"whitespace\",\n        messages: {\n            expectedBefore: \"Expected space(s) before this colon.\",\n            expectedAfter: \"Expected space(s) after this colon.\",\n            unexpectedBefore: \"Unexpected space(s) before this colon.\",\n            unexpectedAfter: \"Unexpected space(s) after this colon.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = context.options[0] || {};\n        const beforeSpacing = options.before === true; // false by default\n        const afterSpacing = options.after !== false; // true by default\n\n        /**\n         * Get the colon token of the given SwitchCase node.\n         * @param {ASTNode} node The SwitchCase node to get.\n         * @returns {Token} The colon token of the node.\n         */\n        function getColonToken(node) {\n            if (node.test) {\n                return sourceCode.getTokenAfter(node.test, astUtils.isColonToken);\n            }\n            return sourceCode.getFirstToken(node, 1);\n        }\n\n        /**\n         * Check whether the spacing between the given 2 tokens is valid or not.\n         * @param {Token} left The left token to check.\n         * @param {Token} right The right token to check.\n         * @param {boolean} expected The expected spacing to check. `true` if there should be a space.\n         * @returns {boolean} `true` if the spacing between the tokens is valid.\n         */\n        function isValidSpacing(left, right, expected) {\n            return (\n                astUtils.isClosingBraceToken(right) ||\n                !astUtils.isTokenOnSameLine(left, right) ||\n                sourceCode.isSpaceBetweenTokens(left, right) === expected\n            );\n        }\n\n        /**\n         * Check whether comments exist between the given 2 tokens.\n         * @param {Token} left The left token to check.\n         * @param {Token} right The right token to check.\n         * @returns {boolean} `true` if comments exist between the given 2 tokens.\n         */\n        function commentsExistBetween(left, right) {\n            return sourceCode.getFirstTokenBetween(\n                left,\n                right,\n                {\n                    includeComments: true,\n                    filter: astUtils.isCommentToken\n                }\n            ) !== null;\n        }\n\n        /**\n         * Fix the spacing between the given 2 tokens.\n         * @param {RuleFixer} fixer The fixer to fix.\n         * @param {Token} left The left token of fix range.\n         * @param {Token} right The right token of fix range.\n         * @param {boolean} spacing The spacing style. `true` if there should be a space.\n         * @returns {Fix|null} The fix object.\n         */\n        function fix(fixer, left, right, spacing) {\n            if (commentsExistBetween(left, right)) {\n                return null;\n            }\n            if (spacing) {\n                return fixer.insertTextAfter(left, \" \");\n            }\n            return fixer.removeRange([left.range[1], right.range[0]]);\n        }\n\n        return {\n            SwitchCase(node) {\n                const colonToken = getColonToken(node);\n                const beforeToken = sourceCode.getTokenBefore(colonToken);\n                const afterToken = sourceCode.getTokenAfter(colonToken);\n\n                if (!isValidSpacing(beforeToken, colonToken, beforeSpacing)) {\n                    context.report({\n                        node,\n                        loc: colonToken.loc,\n                        messageId: beforeSpacing ? \"expectedBefore\" : \"unexpectedBefore\",\n                        fix: fixer => fix(fixer, beforeToken, colonToken, beforeSpacing)\n                    });\n                }\n                if (!isValidSpacing(colonToken, afterToken, afterSpacing)) {\n                    context.report({\n                        node,\n                        loc: colonToken.loc,\n                        messageId: afterSpacing ? \"expectedAfter\" : \"unexpectedAfter\",\n                        fix: fixer => fix(fixer, colonToken, afterToken, afterSpacing)\n                    });\n                }\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to enforce description with the `Symbol` object\n * @author Jarek Rencz\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require symbol descriptions\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/symbol-description\"\n        },\n        fixable: null,\n        schema: [],\n        messages: {\n            expected: \"Expected Symbol to have a description.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Reports if node does not conform the rule in case rule is set to\n         * report missing description\n         *\n         * @param {ASTNode} node - A CallExpression node to check.\n         * @returns {void}\n         */\n        function checkArgument(node) {\n            if (node.arguments.length === 0) {\n                context.report({\n                    node,\n                    messageId: \"expected\"\n                });\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                const scope = context.getScope();\n                const variable = astUtils.getVariableByName(scope, \"Symbol\");\n\n                if (variable && variable.defs.length === 0) {\n                    variable.references.forEach(reference => {\n                        const node = reference.identifier;\n\n                        if (astUtils.isCallee(node)) {\n                            checkArgument(node.parent);\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to enforce spacing around embedded expressions of template strings\n * @author Toru Nagashima\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst OPEN_PAREN = /\\$\\{$/u;\nconst CLOSE_PAREN = /^\\}/u;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow spacing around embedded expressions of template strings\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/template-curly-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            { enum: [\"always\", \"never\"] }\n        ],\n        messages: {\n            expectedBefore: \"Expected space(s) before '}'.\",\n            expectedAfter: \"Expected space(s) after '${'.\",\n            unexpectedBefore: \"Unexpected space(s) before '}'.\",\n            unexpectedAfter: \"Unexpected space(s) after '${'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const always = context.options[0] === \"always\";\n        const prefix = always ? \"expected\" : \"unexpected\";\n\n        /**\n         * Checks spacing before `}` of a given token.\n         * @param {Token} token - A token to check. This is a Template token.\n         * @returns {void}\n         */\n        function checkSpacingBefore(token) {\n            const prevToken = sourceCode.getTokenBefore(token);\n\n            if (prevToken &&\n                CLOSE_PAREN.test(token.value) &&\n                astUtils.isTokenOnSameLine(prevToken, token) &&\n                sourceCode.isSpaceBetweenTokens(prevToken, token) !== always\n            ) {\n                context.report({\n                    loc: token.loc.start,\n                    messageId: `${prefix}Before`,\n                    fix(fixer) {\n                        if (always) {\n                            return fixer.insertTextBefore(token, \" \");\n                        }\n                        return fixer.removeRange([\n                            prevToken.range[1],\n                            token.range[0]\n                        ]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Checks spacing after `${` of a given token.\n         * @param {Token} token - A token to check. This is a Template token.\n         * @returns {void}\n         */\n        function checkSpacingAfter(token) {\n            const nextToken = sourceCode.getTokenAfter(token);\n\n            if (nextToken &&\n                OPEN_PAREN.test(token.value) &&\n                astUtils.isTokenOnSameLine(token, nextToken) &&\n                sourceCode.isSpaceBetweenTokens(token, nextToken) !== always\n            ) {\n                context.report({\n                    loc: {\n                        line: token.loc.end.line,\n                        column: token.loc.end.column - 2\n                    },\n                    messageId: `${prefix}After`,\n                    fix(fixer) {\n                        if (always) {\n                            return fixer.insertTextAfter(token, \" \");\n                        }\n                        return fixer.removeRange([\n                            token.range[1],\n                            nextToken.range[0]\n                        ]);\n                    }\n                });\n            }\n        }\n\n        return {\n            TemplateElement(node) {\n                const token = sourceCode.getFirstToken(node);\n\n                checkSpacingBefore(token);\n                checkSpacingAfter(token);\n            }\n        };\n    }\n};\n","/**\n * @fileoverview Rule to check spacing between template tags and their literals\n * @author Jonathan Wilsson\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow spacing between template tags and their literals\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/template-tag-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            { enum: [\"always\", \"never\"] }\n        ],\n        messages: {\n            unexpected: \"Unexpected space between template tag and template literal.\",\n            missing: \"Missing space between template tag and template literal.\"\n        }\n    },\n\n    create(context) {\n        const never = context.options[0] !== \"always\";\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check if a space is present between a template tag and its literal\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkSpacing(node) {\n            const tagToken = sourceCode.getTokenBefore(node.quasi);\n            const literalToken = sourceCode.getFirstToken(node.quasi);\n            const hasWhitespace = sourceCode.isSpaceBetweenTokens(tagToken, literalToken);\n\n            if (never && hasWhitespace) {\n                context.report({\n                    node,\n                    loc: tagToken.loc.start,\n                    messageId: \"unexpected\",\n                    fix(fixer) {\n                        const comments = sourceCode.getCommentsBefore(node.quasi);\n\n                        // Don't fix anything if there's a single line comment after the template tag\n                        if (comments.some(comment => comment.type === \"Line\")) {\n                            return null;\n                        }\n\n                        return fixer.replaceTextRange(\n                            [tagToken.range[1], literalToken.range[0]],\n                            comments.reduce((text, comment) => text + sourceCode.getText(comment), \"\")\n                        );\n                    }\n                });\n            } else if (!never && !hasWhitespace) {\n                context.report({\n                    node,\n                    loc: tagToken.loc.start,\n                    messageId: \"missing\",\n                    fix(fixer) {\n                        return fixer.insertTextAfter(tagToken, \" \");\n                    }\n                });\n            }\n        }\n\n        return {\n            TaggedTemplateExpression: checkSpacing\n        };\n    }\n};\n","/**\n * @fileoverview Require or disallow Unicode BOM\n * @author Andrew Johnston <https://github.com/ehjay>\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow Unicode byte order mark (BOM)\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/unicode-bom\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            }\n        ],\n        messages: {\n            expected: \"Expected Unicode BOM (Byte Order Mark).\",\n            unexpected: \"Unexpected Unicode BOM (Byte Order Mark).\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            Program: function checkUnicodeBOM(node) {\n\n                const sourceCode = context.getSourceCode(),\n                    location = { column: 0, line: 1 },\n                    requireBOM = context.options[0] || \"never\";\n\n                if (!sourceCode.hasBOM && (requireBOM === \"always\")) {\n                    context.report({\n                        node,\n                        loc: location,\n                        messageId: \"expected\",\n                        fix(fixer) {\n                            return fixer.insertTextBeforeRange([0, 1], \"\\uFEFF\");\n                        }\n                    });\n                } else if (sourceCode.hasBOM && (requireBOM === \"never\")) {\n                    context.report({\n                        node,\n                        loc: location,\n                        messageId: \"unexpected\",\n                        fix(fixer) {\n                            return fixer.removeRange([-1, 0]);\n                        }\n                    });\n                }\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag comparisons to the value NaN\n * @author James Allardice\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"require calls to `isNaN()` when checking for `NaN`\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/use-isnan\"\n        },\n\n        schema: [],\n        messages: {\n            useIsNaN: \"Use the isNaN function to compare with NaN.\"\n        }\n    },\n\n    create(context) {\n\n        return {\n            BinaryExpression(node) {\n                if (/^(?:[<>]|[!=]=)=?$/u.test(node.operator) && (node.left.name === \"NaN\" || node.right.name === \"NaN\")) {\n                    context.report({ node, messageId: \"useIsNaN\" });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Validates JSDoc comments are syntactically correct\n * @author Nicholas C. Zakas\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst doctrine = require(\"doctrine\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"enforce valid JSDoc comments\",\n            category: \"Possible Errors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/valid-jsdoc\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    prefer: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"string\"\n                        }\n                    },\n                    preferType: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"string\"\n                        }\n                    },\n                    requireReturn: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    requireParamDescription: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    requireReturnDescription: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    matchDescription: {\n                        type: \"string\"\n                    },\n                    requireReturnType: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    requireParamType: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            unexpectedTag: \"Unexpected @{{title}} tag; function has no return statement.\",\n            expected: \"Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.\",\n            use: \"Use @{{name}} instead.\",\n            useType: \"Use '{{expectedTypeName}}' instead of '{{currentTypeName}}'.\",\n            syntaxError: \"JSDoc syntax error.\",\n            missingBrace: \"JSDoc type missing brace.\",\n            missingParamDesc: \"Missing JSDoc parameter description for '{{name}}'.\",\n            missingParamType: \"Missing JSDoc parameter type for '{{name}}'.\",\n            missingReturnType: \"Missing JSDoc return type.\",\n            missingReturnDesc: \"Missing JSDoc return description.\",\n            missingReturn: \"Missing JSDoc @{{returns}} for function.\",\n            missingParam: \"Missing JSDoc for parameter '{{name}}'.\",\n            duplicateParam: \"Duplicate JSDoc parameter '{{name}}'.\",\n            unsatisfiedDesc: \"JSDoc description does not satisfy the regex pattern.\"\n        },\n\n        deprecated: true,\n        replacedBy: []\n    },\n\n    create(context) {\n\n        const options = context.options[0] || {},\n            prefer = options.prefer || {},\n            sourceCode = context.getSourceCode(),\n\n            // these both default to true, so you have to explicitly make them false\n            requireReturn = options.requireReturn !== false,\n            requireParamDescription = options.requireParamDescription !== false,\n            requireReturnDescription = options.requireReturnDescription !== false,\n            requireReturnType = options.requireReturnType !== false,\n            requireParamType = options.requireParamType !== false,\n            preferType = options.preferType || {},\n            checkPreferType = Object.keys(preferType).length !== 0;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // Using a stack to store if a function returns or not (handling nested functions)\n        const fns = [];\n\n        /**\n         * Check if node type is a Class\n         * @param {ASTNode} node node to check.\n         * @returns {boolean} True is its a class\n         * @private\n         */\n        function isTypeClass(node) {\n            return node.type === \"ClassExpression\" || node.type === \"ClassDeclaration\";\n        }\n\n        /**\n         * When parsing a new function, store it in our function stack.\n         * @param {ASTNode} node A function node to check.\n         * @returns {void}\n         * @private\n         */\n        function startFunction(node) {\n            fns.push({\n                returnPresent: (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") ||\n                    isTypeClass(node) || node.async\n            });\n        }\n\n        /**\n         * Indicate that return has been found in the current function.\n         * @param {ASTNode} node The return node.\n         * @returns {void}\n         * @private\n         */\n        function addReturn(node) {\n            const functionState = fns[fns.length - 1];\n\n            if (functionState && node.argument !== null) {\n                functionState.returnPresent = true;\n            }\n        }\n\n        /**\n         * Check if return tag type is void or undefined\n         * @param {Object} tag JSDoc tag\n         * @returns {boolean} True if its of type void or undefined\n         * @private\n         */\n        function isValidReturnType(tag) {\n            return tag.type === null || tag.type.name === \"void\" || tag.type.type === \"UndefinedLiteral\";\n        }\n\n        /**\n         * Check if type should be validated based on some exceptions\n         * @param {Object} type JSDoc tag\n         * @returns {boolean} True if it can be validated\n         * @private\n         */\n        function canTypeBeValidated(type) {\n            return type !== \"UndefinedLiteral\" && // {undefined} as there is no name property available.\n                   type !== \"NullLiteral\" && // {null}\n                   type !== \"NullableLiteral\" && // {?}\n                   type !== \"FunctionType\" && // {function(a)}\n                   type !== \"AllLiteral\"; // {*}\n        }\n\n        /**\n         * Extract the current and expected type based on the input type object\n         * @param {Object} type JSDoc tag\n         * @returns {{currentType: Doctrine.Type, expectedTypeName: string}} The current type annotation and\n         * the expected name of the annotation\n         * @private\n         */\n        function getCurrentExpectedTypes(type) {\n            let currentType;\n\n            if (type.name) {\n                currentType = type;\n            } else if (type.expression) {\n                currentType = type.expression;\n            }\n\n            return {\n                currentType,\n                expectedTypeName: currentType && preferType[currentType.name]\n            };\n        }\n\n        /**\n         * Gets the location of a JSDoc node in a file\n         * @param {Token} jsdocComment The comment that this node is parsed from\n         * @param {{range: number[]}} parsedJsdocNode A tag or other node which was parsed from this comment\n         * @returns {{start: SourceLocation, end: SourceLocation}} The 0-based source location for the tag\n         */\n        function getAbsoluteRange(jsdocComment, parsedJsdocNode) {\n            return {\n                start: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[0]),\n                end: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[1])\n            };\n        }\n\n        /**\n         * Validate type for a given JSDoc node\n         * @param {Object} jsdocNode JSDoc node\n         * @param {Object} type JSDoc tag\n         * @returns {void}\n         * @private\n         */\n        function validateType(jsdocNode, type) {\n            if (!type || !canTypeBeValidated(type.type)) {\n                return;\n            }\n\n            const typesToCheck = [];\n            let elements = [];\n\n            switch (type.type) {\n                case \"TypeApplication\": // {Array.<String>}\n                    elements = type.applications[0].type === \"UnionType\" ? type.applications[0].elements : type.applications;\n                    typesToCheck.push(getCurrentExpectedTypes(type));\n                    break;\n                case \"RecordType\": // {{20:String}}\n                    elements = type.fields;\n                    break;\n                case \"UnionType\": // {String|number|Test}\n                case \"ArrayType\": // {[String, number, Test]}\n                    elements = type.elements;\n                    break;\n                case \"FieldType\": // Array.<{count: number, votes: number}>\n                    if (type.value) {\n                        typesToCheck.push(getCurrentExpectedTypes(type.value));\n                    }\n                    break;\n                default:\n                    typesToCheck.push(getCurrentExpectedTypes(type));\n            }\n\n            elements.forEach(validateType.bind(null, jsdocNode));\n\n            typesToCheck.forEach(typeToCheck => {\n                if (typeToCheck.expectedTypeName &&\n                    typeToCheck.expectedTypeName !== typeToCheck.currentType.name) {\n                    context.report({\n                        node: jsdocNode,\n                        messageId: \"useType\",\n                        loc: getAbsoluteRange(jsdocNode, typeToCheck.currentType),\n                        data: {\n                            currentTypeName: typeToCheck.currentType.name,\n                            expectedTypeName: typeToCheck.expectedTypeName\n                        },\n                        fix(fixer) {\n                            return fixer.replaceTextRange(\n                                typeToCheck.currentType.range.map(indexInComment => jsdocNode.range[0] + 2 + indexInComment),\n                                typeToCheck.expectedTypeName\n                            );\n                        }\n                    });\n                }\n            });\n        }\n\n        /**\n         * Validate the JSDoc node and output warnings if anything is wrong.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkJSDoc(node) {\n            const jsdocNode = sourceCode.getJSDocComment(node),\n                functionData = fns.pop(),\n                paramTagsByName = Object.create(null),\n                paramTags = [];\n            let hasReturns = false,\n                returnsTag,\n                hasConstructor = false,\n                isInterface = false,\n                isOverride = false,\n                isAbstract = false;\n\n            // make sure only to validate JSDoc comments\n            if (jsdocNode) {\n                let jsdoc;\n\n                try {\n                    jsdoc = doctrine.parse(jsdocNode.value, {\n                        strict: true,\n                        unwrap: true,\n                        sloppy: true,\n                        range: true\n                    });\n                } catch (ex) {\n\n                    if (/braces/iu.test(ex.message)) {\n                        context.report({ node: jsdocNode, messageId: \"missingBrace\" });\n                    } else {\n                        context.report({ node: jsdocNode, messageId: \"syntaxError\" });\n                    }\n\n                    return;\n                }\n\n                jsdoc.tags.forEach(tag => {\n\n                    switch (tag.title.toLowerCase()) {\n\n                        case \"param\":\n                        case \"arg\":\n                        case \"argument\":\n                            paramTags.push(tag);\n                            break;\n\n                        case \"return\":\n                        case \"returns\":\n                            hasReturns = true;\n                            returnsTag = tag;\n                            break;\n\n                        case \"constructor\":\n                        case \"class\":\n                            hasConstructor = true;\n                            break;\n\n                        case \"override\":\n                        case \"inheritdoc\":\n                            isOverride = true;\n                            break;\n\n                        case \"abstract\":\n                        case \"virtual\":\n                            isAbstract = true;\n                            break;\n\n                        case \"interface\":\n                            isInterface = true;\n                            break;\n\n                        // no default\n                    }\n\n                    // check tag preferences\n                    if (Object.prototype.hasOwnProperty.call(prefer, tag.title) && tag.title !== prefer[tag.title]) {\n                        const entireTagRange = getAbsoluteRange(jsdocNode, tag);\n\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"use\",\n                            loc: {\n                                start: entireTagRange.start,\n                                end: {\n                                    line: entireTagRange.start.line,\n                                    column: entireTagRange.start.column + `@${tag.title}`.length\n                                }\n                            },\n                            data: { name: prefer[tag.title] },\n                            fix(fixer) {\n                                return fixer.replaceTextRange(\n                                    [\n                                        jsdocNode.range[0] + tag.range[0] + 3,\n                                        jsdocNode.range[0] + tag.range[0] + tag.title.length + 3\n                                    ],\n                                    prefer[tag.title]\n                                );\n                            }\n                        });\n                    }\n\n                    // validate the types\n                    if (checkPreferType && tag.type) {\n                        validateType(jsdocNode, tag.type);\n                    }\n                });\n\n                paramTags.forEach(param => {\n                    if (requireParamType && !param.type) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"missingParamType\",\n                            loc: getAbsoluteRange(jsdocNode, param),\n                            data: { name: param.name }\n                        });\n                    }\n                    if (!param.description && requireParamDescription) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"missingParamDesc\",\n                            loc: getAbsoluteRange(jsdocNode, param),\n                            data: { name: param.name }\n                        });\n                    }\n                    if (paramTagsByName[param.name]) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"duplicateParam\",\n                            loc: getAbsoluteRange(jsdocNode, param),\n                            data: { name: param.name }\n                        });\n                    } else if (param.name.indexOf(\".\") === -1) {\n                        paramTagsByName[param.name] = param;\n                    }\n                });\n\n                if (hasReturns) {\n                    if (!requireReturn && !functionData.returnPresent && (returnsTag.type === null || !isValidReturnType(returnsTag)) && !isAbstract) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"unexpectedTag\",\n                            loc: getAbsoluteRange(jsdocNode, returnsTag),\n                            data: {\n                                title: returnsTag.title\n                            }\n                        });\n                    } else {\n                        if (requireReturnType && !returnsTag.type) {\n                            context.report({ node: jsdocNode, messageId: \"missingReturnType\" });\n                        }\n\n                        if (!isValidReturnType(returnsTag) && !returnsTag.description && requireReturnDescription) {\n                            context.report({ node: jsdocNode, messageId: \"missingReturnDesc\" });\n                        }\n                    }\n                }\n\n                // check for functions missing @returns\n                if (!isOverride && !hasReturns && !hasConstructor && !isInterface &&\n                    node.parent.kind !== \"get\" && node.parent.kind !== \"constructor\" &&\n                    node.parent.kind !== \"set\" && !isTypeClass(node)) {\n                    if (requireReturn || (functionData.returnPresent && !node.async)) {\n                        context.report({\n                            node: jsdocNode,\n                            messageId: \"missingReturn\",\n                            data: {\n                                returns: prefer.returns || \"returns\"\n                            }\n                        });\n                    }\n                }\n\n                // check the parameters\n                const jsdocParamNames = Object.keys(paramTagsByName);\n\n                if (node.params) {\n                    node.params.forEach((param, paramsIndex) => {\n                        const bindingParam = param.type === \"AssignmentPattern\"\n                            ? param.left\n                            : param;\n\n                        // TODO(nzakas): Figure out logical things to do with destructured, default, rest params\n                        if (bindingParam.type === \"Identifier\") {\n                            const name = bindingParam.name;\n\n                            if (jsdocParamNames[paramsIndex] && (name !== jsdocParamNames[paramsIndex])) {\n                                context.report({\n                                    node: jsdocNode,\n                                    messageId: \"expected\",\n                                    loc: getAbsoluteRange(jsdocNode, paramTagsByName[jsdocParamNames[paramsIndex]]),\n                                    data: {\n                                        name,\n                                        jsdocName: jsdocParamNames[paramsIndex]\n                                    }\n                                });\n                            } else if (!paramTagsByName[name] && !isOverride) {\n                                context.report({\n                                    node: jsdocNode,\n                                    messageId: \"missingParam\",\n                                    data: {\n                                        name\n                                    }\n                                });\n                            }\n                        }\n                    });\n                }\n\n                if (options.matchDescription) {\n                    const regex = new RegExp(options.matchDescription); // eslint-disable-line require-unicode-regexp\n\n                    if (!regex.test(jsdoc.description)) {\n                        context.report({ node: jsdocNode, messageId: \"unsatisfiedDesc\" });\n                    }\n                }\n\n            }\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ArrowFunctionExpression: startFunction,\n            FunctionExpression: startFunction,\n            FunctionDeclaration: startFunction,\n            ClassExpression: startFunction,\n            ClassDeclaration: startFunction,\n            \"ArrowFunctionExpression:exit\": checkJSDoc,\n            \"FunctionExpression:exit\": checkJSDoc,\n            \"FunctionDeclaration:exit\": checkJSDoc,\n            \"ClassExpression:exit\": checkJSDoc,\n            \"ClassDeclaration:exit\": checkJSDoc,\n            ReturnStatement: addReturn\n        };\n\n    }\n};\n","/**\n * @fileoverview Ensures that the results of typeof are compared against a valid string\n * @author Ian Christian Myers\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"enforce comparing `typeof` expressions against valid strings\",\n            category: \"Possible Errors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/valid-typeof\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    requireStringLiterals: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            invalidValue: \"Invalid typeof comparison value.\",\n            notString: \"Typeof comparisons should be to string literals.\"\n        }\n    },\n\n    create(context) {\n\n        const VALID_TYPES = [\"symbol\", \"undefined\", \"object\", \"boolean\", \"number\", \"string\", \"function\"],\n            OPERATORS = [\"==\", \"===\", \"!=\", \"!==\"];\n\n        const requireStringLiterals = context.options[0] && context.options[0].requireStringLiterals;\n\n        /**\n         * Determines whether a node is a typeof expression.\n         * @param {ASTNode} node The node\n         * @returns {boolean} `true` if the node is a typeof expression\n         */\n        function isTypeofExpression(node) {\n            return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            UnaryExpression(node) {\n                if (isTypeofExpression(node)) {\n                    const parent = context.getAncestors().pop();\n\n                    if (parent.type === \"BinaryExpression\" && OPERATORS.indexOf(parent.operator) !== -1) {\n                        const sibling = parent.left === node ? parent.right : parent.left;\n\n                        if (sibling.type === \"Literal\" || sibling.type === \"TemplateLiteral\" && !sibling.expressions.length) {\n                            const value = sibling.type === \"Literal\" ? sibling.value : sibling.quasis[0].value.cooked;\n\n                            if (VALID_TYPES.indexOf(value) === -1) {\n                                context.report({ node: sibling, messageId: \"invalidValue\" });\n                            }\n                        } else if (requireStringLiterals && !isTypeofExpression(sibling)) {\n                            context.report({ node: sibling, messageId: \"notString\" });\n                        }\n                    }\n                }\n            }\n\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to enforce var declarations are only at the top of a function.\n * @author Danny Fritz\n * @author Gyandeep Singh\n */\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `var` declarations be placed at the top of their containing scope\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/vars-on-top\"\n        },\n\n        schema: [],\n        messages: {\n            top: \"All 'var' declarations must be at the top of the function scope.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * @param {ASTNode} node - any node\n         * @returns {boolean} whether the given node structurally represents a directive\n         */\n        function looksLikeDirective(node) {\n            return node.type === \"ExpressionStatement\" &&\n                node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n        }\n\n        /**\n         * Check to see if its a ES6 import declaration\n         * @param {ASTNode} node - any node\n         * @returns {boolean} whether the given node represents a import declaration\n         */\n        function looksLikeImport(node) {\n            return node.type === \"ImportDeclaration\" || node.type === \"ImportSpecifier\" ||\n                node.type === \"ImportDefaultSpecifier\" || node.type === \"ImportNamespaceSpecifier\";\n        }\n\n        /**\n         * Checks whether a given node is a variable declaration or not.\n         *\n         * @param {ASTNode} node - any node\n         * @returns {boolean} `true` if the node is a variable declaration.\n         */\n        function isVariableDeclaration(node) {\n            return (\n                node.type === \"VariableDeclaration\" ||\n                (\n                    node.type === \"ExportNamedDeclaration\" &&\n                    node.declaration &&\n                    node.declaration.type === \"VariableDeclaration\"\n                )\n            );\n        }\n\n        /**\n         * Checks whether this variable is on top of the block body\n         * @param {ASTNode} node - The node to check\n         * @param {ASTNode[]} statements - collection of ASTNodes for the parent node block\n         * @returns {boolean} True if var is on top otherwise false\n         */\n        function isVarOnTop(node, statements) {\n            const l = statements.length;\n            let i = 0;\n\n            // skip over directives\n            for (; i < l; ++i) {\n                if (!looksLikeDirective(statements[i]) && !looksLikeImport(statements[i])) {\n                    break;\n                }\n            }\n\n            for (; i < l; ++i) {\n                if (!isVariableDeclaration(statements[i])) {\n                    return false;\n                }\n                if (statements[i] === node) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether variable is on top at the global level\n         * @param {ASTNode} node - The node to check\n         * @param {ASTNode} parent - Parent of the node\n         * @returns {void}\n         */\n        function globalVarCheck(node, parent) {\n            if (!isVarOnTop(node, parent.body)) {\n                context.report({ node, messageId: \"top\" });\n            }\n        }\n\n        /**\n         * Checks whether variable is on top at functional block scope level\n         * @param {ASTNode} node - The node to check\n         * @param {ASTNode} parent - Parent of the node\n         * @param {ASTNode} grandParent - Parent of the node's parent\n         * @returns {void}\n         */\n        function blockScopeVarCheck(node, parent, grandParent) {\n            if (!(/Function/u.test(grandParent.type) &&\n                    parent.type === \"BlockStatement\" &&\n                    isVarOnTop(node, parent.body))) {\n                context.report({ node, messageId: \"top\" });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            \"VariableDeclaration[kind='var']\"(node) {\n                if (node.parent.type === \"ExportNamedDeclaration\") {\n                    globalVarCheck(node.parent, node.parent.parent);\n                } else if (node.parent.type === \"Program\") {\n                    globalVarCheck(node, node.parent);\n                } else {\n                    blockScopeVarCheck(node, node.parent, node.parent.parent);\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag when IIFE is not wrapped in parens\n * @author Ilya Volodin\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require parentheses around immediate `function` invocations\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/wrap-iife\"\n        },\n\n        schema: [\n            {\n                enum: [\"outside\", \"inside\", \"any\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    functionPrototypeMethods: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            wrapInvocation: \"Wrap an immediate function invocation in parentheses.\",\n            wrapExpression: \"Wrap only the function expression in parens.\",\n            moveInvocation: \"Move the invocation into the parens that contain the function.\"\n        }\n    },\n\n    create(context) {\n\n        const style = context.options[0] || \"outside\";\n        const includeFunctionPrototypeMethods = context.options[1] && context.options[1].functionPrototypeMethods;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check if the node is wrapped in ()\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if it is wrapped\n         * @private\n         */\n        function wrapped(node) {\n            return astUtils.isParenthesised(sourceCode, node);\n        }\n\n        /**\n         * Get the function node from an IIFE\n         * @param {ASTNode} node node to evaluate\n         * @returns {ASTNode} node that is the function expression of the given IIFE, or null if none exist\n         */\n        function getFunctionNodeFromIIFE(node) {\n            const callee = node.callee;\n\n            if (callee.type === \"FunctionExpression\") {\n                return callee;\n            }\n\n            if (includeFunctionPrototypeMethods &&\n                callee.type === \"MemberExpression\" &&\n                callee.object.type === \"FunctionExpression\" &&\n                (astUtils.getStaticPropertyName(callee) === \"call\" || astUtils.getStaticPropertyName(callee) === \"apply\")\n            ) {\n                return callee.object;\n            }\n\n            return null;\n        }\n\n\n        return {\n            CallExpression(node) {\n                const innerNode = getFunctionNodeFromIIFE(node);\n\n                if (!innerNode) {\n                    return;\n                }\n\n                const callExpressionWrapped = wrapped(node),\n                    functionExpressionWrapped = wrapped(innerNode);\n\n                if (!callExpressionWrapped && !functionExpressionWrapped) {\n                    context.report({\n                        node,\n                        messageId: \"wrapInvocation\",\n                        fix(fixer) {\n                            const nodeToSurround = style === \"inside\" ? innerNode : node;\n\n                            return fixer.replaceText(nodeToSurround, `(${sourceCode.getText(nodeToSurround)})`);\n                        }\n                    });\n                } else if (style === \"inside\" && !functionExpressionWrapped) {\n                    context.report({\n                        node,\n                        messageId: \"wrapExpression\",\n                        fix(fixer) {\n\n                            /*\n                             * The outer call expression will always be wrapped at this point.\n                             * Replace the range between the end of the function expression and the end of the call expression.\n                             * for example, in `(function(foo) {}(bar))`, the range `(bar))` should get replaced with `)(bar)`.\n                             * Replace the parens from the outer expression, and parenthesize the function expression.\n                             */\n                            const parenAfter = sourceCode.getTokenAfter(node);\n\n                            return fixer.replaceTextRange(\n                                [innerNode.range[1], parenAfter.range[1]],\n                                `)${sourceCode.getText().slice(innerNode.range[1], parenAfter.range[0])}`\n                            );\n                        }\n                    });\n                } else if (style === \"outside\" && !callExpressionWrapped) {\n                    context.report({\n                        node,\n                        messageId: \"moveInvocation\",\n                        fix(fixer) {\n\n                            /*\n                             * The inner function expression will always be wrapped at this point.\n                             * It's only necessary to replace the range between the end of the function expression\n                             * and the call expression. For example, in `(function(foo) {})(bar)`, the range `)(bar)`\n                             * should get replaced with `(bar))`.\n                             */\n                            const parenAfter = sourceCode.getTokenAfter(innerNode);\n\n                            return fixer.replaceTextRange(\n                                [parenAfter.range[0], node.range[1]],\n                                `${sourceCode.getText().slice(parenAfter.range[1], node.range[1])})`\n                            );\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to flag when regex literals are not wrapped in parens\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require parenthesis around regex literals\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/wrap-regex\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            requireParens: \"Wrap the regexp literal in parens to disambiguate the slash.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n\n            Literal(node) {\n                const token = sourceCode.getFirstToken(node),\n                    nodeType = token.type;\n\n                if (nodeType === \"RegularExpression\") {\n                    const beforeToken = sourceCode.getTokenBefore(node);\n                    const afterToken = sourceCode.getTokenAfter(node);\n                    const ancestors = context.getAncestors();\n                    const grandparent = ancestors[ancestors.length - 1];\n\n                    if (grandparent.type === \"MemberExpression\" && grandparent.object === node &&\n                        !(beforeToken && beforeToken.value === \"(\" && afterToken && afterToken.value === \")\")) {\n                        context.report({\n                            node,\n                            messageId: \"requireParens\",\n                            fix: fixer => fixer.replaceText(node, `(${sourceCode.getText(node)})`)\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to check the spacing around the * in yield* expressions.\n * @author Bryan Smith\n */\n\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"require or disallow spacing around the `*` in `yield*` expressions\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/yield-star-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"before\", \"after\", \"both\", \"neither\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            before: { type: \"boolean\" },\n                            after: { type: \"boolean\" }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n        messages: {\n            missingBefore: \"Missing space before *.\",\n            missingAfter: \"Missing space after *.\",\n            unexpectedBefore: \"Unexpected space before *.\",\n            unexpectedAfter: \"Unexpected space after *.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const mode = (function(option) {\n            if (!option || typeof option === \"string\") {\n                return {\n                    before: { before: true, after: false },\n                    after: { before: false, after: true },\n                    both: { before: true, after: true },\n                    neither: { before: false, after: false }\n                }[option || \"after\"];\n            }\n            return option;\n        }(context.options[0]));\n\n        /**\n         * Checks the spacing between two tokens before or after the star token.\n         * @param {string} side Either \"before\" or \"after\".\n         * @param {Token} leftToken `function` keyword token if side is \"before\", or\n         *     star token if side is \"after\".\n         * @param {Token} rightToken Star token if side is \"before\", or identifier\n         *     token if side is \"after\".\n         * @returns {void}\n         */\n        function checkSpacing(side, leftToken, rightToken) {\n            if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken) !== mode[side]) {\n                const after = leftToken.value === \"*\";\n                const spaceRequired = mode[side];\n                const node = after ? leftToken : rightToken;\n                let messageId = \"\";\n\n                if (spaceRequired) {\n                    messageId = side === \"before\" ? \"missingBefore\" : \"missingAfter\";\n                } else {\n                    messageId = side === \"before\" ? \"unexpectedBefore\" : \"unexpectedAfter\";\n                }\n\n                context.report({\n                    node,\n                    messageId,\n                    fix(fixer) {\n                        if (spaceRequired) {\n                            if (after) {\n                                return fixer.insertTextAfter(node, \" \");\n                            }\n                            return fixer.insertTextBefore(node, \" \");\n                        }\n                        return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Enforces the spacing around the star if node is a yield* expression.\n         * @param {ASTNode} node A yield expression node.\n         * @returns {void}\n         */\n        function checkExpression(node) {\n            if (!node.delegate) {\n                return;\n            }\n\n            const tokens = sourceCode.getFirstTokens(node, 3);\n            const yieldToken = tokens[0];\n            const starToken = tokens[1];\n            const nextToken = tokens[2];\n\n            checkSpacing(\"before\", yieldToken, starToken);\n            checkSpacing(\"after\", starToken, nextToken);\n        }\n\n        return {\n            YieldExpression: checkExpression\n        };\n\n    }\n};\n","/**\n * @fileoverview Rule to require or disallow yoda comparisons\n * @author Nicholas C. Zakas\n */\n\n\n//--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\n\nconst astUtils = require(\"../util/ast-utils\");\n\n//--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines whether an operator is a comparison operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is a comparison operator.\n */\nfunction isComparisonOperator(operator) {\n    return (/^(==|===|!=|!==|<|>|<=|>=)$/u).test(operator);\n}\n\n/**\n * Determines whether an operator is an equality operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is an equality operator.\n */\nfunction isEqualityOperator(operator) {\n    return (/^(==|===)$/u).test(operator);\n}\n\n/**\n * Determines whether an operator is one used in a range test.\n * Allowed operators are `<` and `<=`.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether the operator is used in range tests.\n */\nfunction isRangeTestOperator(operator) {\n    return [\"<\", \"<=\"].indexOf(operator) >= 0;\n}\n\n/**\n * Determines whether a non-Literal node is a negative number that should be\n * treated as if it were a single Literal node.\n * @param {ASTNode} node Node to test.\n * @returns {boolean} True if the node is a negative number that looks like a\n *                    real literal and should be treated as such.\n */\nfunction looksLikeLiteral(node) {\n    return (node.type === \"UnaryExpression\" &&\n        node.operator === \"-\" &&\n        node.prefix &&\n        node.argument.type === \"Literal\" &&\n        typeof node.argument.value === \"number\");\n}\n\n/**\n * Attempts to derive a Literal node from nodes that are treated like literals.\n * @param {ASTNode} node Node to normalize.\n * @param {number} [defaultValue] The default value to be returned if the node\n *                                is not a Literal.\n * @returns {ASTNode} One of the following options.\n *  1. The original node if the node is already a Literal\n *  2. A normalized Literal node with the negative number as the value if the\n *     node represents a negative number literal.\n *  3. The Literal node which has the `defaultValue` argument if it exists.\n *  4. Otherwise `null`.\n */\nfunction getNormalizedLiteral(node, defaultValue) {\n    if (node.type === \"Literal\") {\n        return node;\n    }\n\n    if (looksLikeLiteral(node)) {\n        return {\n            type: \"Literal\",\n            value: -node.argument.value,\n            raw: `-${node.argument.value}`\n        };\n    }\n\n    if (defaultValue) {\n        return {\n            type: \"Literal\",\n            value: defaultValue,\n            raw: String(defaultValue)\n        };\n    }\n\n    return null;\n}\n\n/**\n * Checks whether two expressions reference the same value. For example:\n *     a = a\n *     a.b = a.b\n *     a[0] = a[0]\n *     a['b'] = a['b']\n * @param   {ASTNode} a Left side of the comparison.\n * @param   {ASTNode} b Right side of the comparison.\n * @returns {boolean}   True if both sides match and reference the same value.\n */\nfunction same(a, b) {\n    if (a.type !== b.type) {\n        return false;\n    }\n\n    switch (a.type) {\n        case \"Identifier\":\n            return a.name === b.name;\n\n        case \"Literal\":\n            return a.value === b.value;\n\n        case \"MemberExpression\": {\n            const nameA = astUtils.getStaticPropertyName(a);\n\n            // x.y = x[\"y\"]\n            if (nameA) {\n                return (\n                    same(a.object, b.object) &&\n                    nameA === astUtils.getStaticPropertyName(b)\n                );\n            }\n\n            /*\n             * x[0] = x[0]\n             * x[y] = x[y]\n             * x.y = x.y\n             */\n            return (\n                a.computed === b.computed &&\n                same(a.object, b.object) &&\n                same(a.property, b.property)\n            );\n        }\n\n        case \"ThisExpression\":\n            return true;\n\n        default:\n            return false;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require or disallow \\\"Yoda\\\" conditions\",\n            category: \"Best Practices\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/yoda\"\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptRange: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    onlyEquality: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            expected: \"Expected literal to be on the {{expectedSide}} side of {{operator}}.\"\n        }\n    },\n\n    create(context) {\n\n        // Default to \"never\" (!always) if no option\n        const always = (context.options[0] === \"always\");\n        const exceptRange = (context.options[1] && context.options[1].exceptRange);\n        const onlyEquality = (context.options[1] && context.options[1].onlyEquality);\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether node represents a range test.\n         * A range test is a \"between\" test like `(0 <= x && x < 1)` or an \"outside\"\n         * test like `(x < 0 || 1 <= x)`. It must be wrapped in parentheses, and\n         * both operators must be `<` or `<=`. Finally, the literal on the left side\n         * must be less than or equal to the literal on the right side so that the\n         * test makes any sense.\n         * @param {ASTNode} node LogicalExpression node to test.\n         * @returns {boolean} Whether node is a range test.\n         */\n        function isRangeTest(node) {\n            const left = node.left,\n                right = node.right;\n\n            /**\n             * Determines whether node is of the form `0 <= x && x < 1`.\n             * @returns {boolean} Whether node is a \"between\" range test.\n             */\n            function isBetweenTest() {\n                let leftLiteral, rightLiteral;\n\n                return (node.operator === \"&&\" &&\n                    (leftLiteral = getNormalizedLiteral(left.left)) &&\n                    (rightLiteral = getNormalizedLiteral(right.right, Number.POSITIVE_INFINITY)) &&\n                    leftLiteral.value <= rightLiteral.value &&\n                    same(left.right, right.left));\n            }\n\n            /**\n             * Determines whether node is of the form `x < 0 || 1 <= x`.\n             * @returns {boolean} Whether node is an \"outside\" range test.\n             */\n            function isOutsideTest() {\n                let leftLiteral, rightLiteral;\n\n                return (node.operator === \"||\" &&\n                    (leftLiteral = getNormalizedLiteral(left.right, Number.NEGATIVE_INFINITY)) &&\n                    (rightLiteral = getNormalizedLiteral(right.left)) &&\n                    leftLiteral.value <= rightLiteral.value &&\n                    same(left.left, right.right));\n            }\n\n            /**\n             * Determines whether node is wrapped in parentheses.\n             * @returns {boolean} Whether node is preceded immediately by an open\n             *                    paren token and followed immediately by a close\n             *                    paren token.\n             */\n            function isParenWrapped() {\n                return astUtils.isParenthesised(sourceCode, node);\n            }\n\n            return (node.type === \"LogicalExpression\" &&\n                left.type === \"BinaryExpression\" &&\n                right.type === \"BinaryExpression\" &&\n                isRangeTestOperator(left.operator) &&\n                isRangeTestOperator(right.operator) &&\n                (isBetweenTest() || isOutsideTest()) &&\n                isParenWrapped());\n        }\n\n        const OPERATOR_FLIP_MAP = {\n            \"===\": \"===\",\n            \"!==\": \"!==\",\n            \"==\": \"==\",\n            \"!=\": \"!=\",\n            \"<\": \">\",\n            \">\": \"<\",\n            \"<=\": \">=\",\n            \">=\": \"<=\"\n        };\n\n        /**\n         * Returns a string representation of a BinaryExpression node with its sides/operator flipped around.\n         * @param {ASTNode} node The BinaryExpression node\n         * @returns {string} A string representation of the node with the sides and operator flipped\n         */\n        function getFlippedString(node) {\n            const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n            const textBeforeOperator = sourceCode.getText().slice(sourceCode.getTokenBefore(operatorToken).range[1], operatorToken.range[0]);\n            const textAfterOperator = sourceCode.getText().slice(operatorToken.range[1], sourceCode.getTokenAfter(operatorToken).range[0]);\n            const leftText = sourceCode.getText().slice(node.range[0], sourceCode.getTokenBefore(operatorToken).range[1]);\n            const rightText = sourceCode.getText().slice(sourceCode.getTokenAfter(operatorToken).range[0], node.range[1]);\n\n            return rightText + textBeforeOperator + OPERATOR_FLIP_MAP[operatorToken.value] + textAfterOperator + leftText;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            BinaryExpression(node) {\n                const expectedLiteral = always ? node.left : node.right;\n                const expectedNonLiteral = always ? node.right : node.left;\n\n                // If `expectedLiteral` is not a literal, and `expectedNonLiteral` is a literal, raise an error.\n                if (\n                    (expectedNonLiteral.type === \"Literal\" || looksLikeLiteral(expectedNonLiteral)) &&\n                    !(expectedLiteral.type === \"Literal\" || looksLikeLiteral(expectedLiteral)) &&\n                    !(!isEqualityOperator(node.operator) && onlyEquality) &&\n                    isComparisonOperator(node.operator) &&\n                    !(exceptRange && isRangeTest(context.getAncestors().pop()))\n                ) {\n                    context.report({\n                        node,\n                        messageId: \"expected\",\n                        data: {\n                            operator: node.operator,\n                            expectedSide: always ? \"left\" : \"right\"\n                        },\n                        fix: fixer => fixer.replaceText(node, getFlippedString(node))\n                    });\n                }\n\n            }\n        };\n\n    }\n};\n","/**\n * @fileoverview Tracks performance of individual rules.\n * @author Brandon Mills\n */\n\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/* istanbul ignore next */\n/**\n * Align the string to left\n * @param {string} str string to evaluate\n * @param {int} len length of the string\n * @param {string} ch delimiter character\n * @returns {string} modified string\n * @private\n */\nfunction alignLeft(str, len, ch) {\n    return str + new Array(len - str.length + 1).join(ch || \" \");\n}\n\n/* istanbul ignore next */\n/**\n * Align the string to right\n * @param {string} str string to evaluate\n * @param {int} len length of the string\n * @param {string} ch delimiter character\n * @returns {string} modified string\n * @private\n */\nfunction alignRight(str, len, ch) {\n    return new Array(len - str.length + 1).join(ch || \" \") + str;\n}\n\n//------------------------------------------------------------------------------\n// Module definition\n//------------------------------------------------------------------------------\n\nconst enabled = !!process.env.TIMING;\n\nconst HEADERS = [\"Rule\", \"Time (ms)\", \"Relative\"];\nconst ALIGN = [alignLeft, alignRight, alignRight];\n\n/* istanbul ignore next */\n/**\n * display the data\n * @param {Object} data Data object to be displayed\n * @returns {string} modified string\n * @private\n */\nfunction display(data) {\n    let total = 0;\n    const rows = Object.keys(data)\n        .map(key => {\n            const time = data[key];\n\n            total += time;\n            return [key, time];\n        })\n        .sort((a, b) => b[1] - a[1])\n        .slice(0, 10);\n\n    rows.forEach(row => {\n        row.push(`${(row[1] * 100 / total).toFixed(1)}%`);\n        row[1] = row[1].toFixed(3);\n    });\n\n    rows.unshift(HEADERS);\n\n    const widths = [];\n\n    rows.forEach(row => {\n        const len = row.length;\n\n        for (let i = 0; i < len; i++) {\n            const n = row[i].length;\n\n            if (!widths[i] || n > widths[i]) {\n                widths[i] = n;\n            }\n        }\n    });\n\n    const table = rows.map(row => (\n        row\n            .map((cell, index) => ALIGN[index](cell, widths[index]))\n            .join(\" | \")\n    ));\n\n    table.splice(1, 0, widths.map((width, index) => {\n        const extraAlignment = index !== 0 && index !== widths.length - 1 ? 2 : 1;\n\n        return ALIGN[index](\":\", width + extraAlignment, \"-\");\n    }).join(\"|\"));\n\n    console.log(table.join(\"\\n\")); // eslint-disable-line no-console\n}\n\n/* istanbul ignore next */\nmodule.exports = (function() {\n\n    const data = Object.create(null);\n\n    /**\n     * Time the run\n     * @param {*} key key from the data object\n     * @param {Function} fn function to be called\n     * @returns {Function} function to be executed\n     * @private\n     */\n    function time(key, fn) {\n        if (typeof data[key] === \"undefined\") {\n            data[key] = 0;\n        }\n\n        return function(...args) {\n            let t = process.hrtime();\n\n            fn(...args);\n            t = process.hrtime(t);\n            data[key] += t[0] * 1e3 + t[1] / 1e6;\n        };\n    }\n\n    if (enabled) {\n        process.on(\"exit\", () => {\n            display(data);\n        });\n    }\n\n    return {\n        time,\n        enabled\n    };\n\n}());\n","/**\n * @fileoverview Config Comment Parser\n * @author Nicholas C. Zakas\n */\n\n/* eslint-disable class-methods-use-this*/\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst levn = require(\"levn\"),\n    ConfigOps = require(\"../config/config-ops\");\n\nconst debug = require(\"debug\")(\"eslint:config-comment-parser\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object to parse ESLint configuration comments inside JavaScript files.\n * @name ConfigCommentParser\n */\nmodule.exports = class ConfigCommentParser {\n\n    /**\n     * Parses a list of \"name:string_value\" or/and \"name\" options divided by comma or\n     * whitespace. Used for \"global\" and \"exported\" comments.\n     * @param {string} string The string to parse.\n     * @param {Comment} comment The comment node which has the string.\n     * @returns {Object} Result map object of names and string values, or null values if no value was provided\n     */\n    parseStringConfig(string, comment) {\n        debug(\"Parsing String config\");\n\n        const items = {};\n\n        // Collapse whitespace around `:` and `,` to make parsing easier\n        const trimmedString = string.replace(/\\s*([:,])\\s*/gu, \"$1\");\n\n        trimmedString.split(/\\s|,+/u).forEach(name => {\n            if (!name) {\n                return;\n            }\n\n            // value defaults to null (if not provided), e.g: \"foo\" => [\"foo\", null]\n            const [key, value = null] = name.split(\":\");\n\n            items[key] = { value, comment };\n        });\n        return items;\n    }\n\n    /**\n     * Parses a JSON-like config.\n     * @param {string} string The string to parse.\n     * @param {Object} location Start line and column of comments for potential error message.\n     * @returns {({success: true, config: Object}|{success: false, error: Problem})} Result map object\n     */\n    parseJsonConfig(string, location) {\n        debug(\"Parsing JSON config\");\n\n        let items = {};\n\n        // Parses a JSON-like comment by the same way as parsing CLI option.\n        try {\n            items = levn.parse(\"Object\", string) || {};\n\n            // Some tests say that it should ignore invalid comments such as `/*eslint no-alert:abc*/`.\n            // Also, commaless notations have invalid severity:\n            //     \"no-alert: 2 no-console: 2\" --> {\"no-alert\": \"2 no-console: 2\"}\n            // Should ignore that case as well.\n            if (ConfigOps.isEverySeverityValid(items)) {\n                return {\n                    success: true,\n                    config: items\n                };\n            }\n        } catch (ex) {\n\n            debug(\"Levn parsing failed; falling back to manual parsing.\");\n\n            // ignore to parse the string by a fallback.\n        }\n\n        /*\n         * Optionator cannot parse commaless notations.\n         * But we are supporting that. So this is a fallback for that.\n         */\n        items = {};\n        const normalizedString = string.replace(/([a-zA-Z0-9\\-/]+):/gu, \"\\\"$1\\\":\").replace(/(\\]|[0-9])\\s+(?=\")/u, \"$1,\");\n\n        try {\n            items = JSON.parse(`{${normalizedString}}`);\n        } catch (ex) {\n            debug(\"Manual parsing failed.\");\n\n            return {\n                success: false,\n                error: {\n                    ruleId: null,\n                    fatal: true,\n                    severity: 2,\n                    message: `Failed to parse JSON from '${normalizedString}': ${ex.message}`,\n                    line: location.start.line,\n                    column: location.start.column + 1\n                }\n            };\n\n        }\n\n        return {\n            success: true,\n            config: items\n        };\n    }\n\n    /**\n     * Parses a config of values separated by comma.\n     * @param {string} string The string to parse.\n     * @returns {Object} Result map of values and true values\n     */\n    parseListConfig(string) {\n        debug(\"Parsing list config\");\n\n        const items = {};\n\n        // Collapse whitespace around commas\n        string.replace(/\\s*,\\s*/gu, \",\").split(/,+/u).forEach(name => {\n            const trimmedName = name.trim();\n\n            if (trimmedName) {\n                items[trimmedName] = true;\n            }\n        });\n        return items;\n    }\n\n};\n","module.exports = {\n  \"_from\": \"eslint@^5.5.0\",\n  \"_id\": \"eslint@5.16.0\",\n  \"_inBundle\": false,\n  \"_integrity\": \"sha512-S3Rz11i7c8AA5JPv7xAH+dOyq/Cu/VXHiHXBPOU1k/JAM5dXqQPt3qcrhpHSorXmrpu2g0gkIBVXAqCpzfoZIg==\",\n  \"_location\": \"/eslint\",\n  \"_phantomChildren\": {},\n  \"_requested\": {\n    \"type\": \"range\",\n    \"registry\": true,\n    \"raw\": \"eslint@^5.5.0\",\n    \"name\": \"eslint\",\n    \"escapedName\": \"eslint\",\n    \"rawSpec\": \"^5.5.0\",\n    \"saveSpec\": null,\n    \"fetchSpec\": \"^5.5.0\"\n  },\n  \"_requiredBy\": [\n    \"/\"\n  ],\n  \"_resolved\": \"https://registry.npmjs.org/eslint/-/eslint-5.16.0.tgz\",\n  \"_shasum\": \"a1e3ac1aae4a3fbd8296fcf8f7ab7314cbb6abea\",\n  \"_spec\": \"eslint@^5.5.0\",\n  \"_where\": \"E:\\\\1-safe\\\\safety-vx\",\n  \"author\": {\n    \"name\": \"Nicholas C. Zakas\",\n    \"email\": \"nicholas+npm@nczconsulting.com\"\n  },\n  \"bin\": {\n    \"eslint\": \"./bin/eslint.js\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/eslint/eslint/issues/\"\n  },\n  \"bundleDependencies\": false,\n  \"dependencies\": {\n    \"@babel/code-frame\": \"^7.0.0\",\n    \"ajv\": \"^6.9.1\",\n    \"chalk\": \"^2.1.0\",\n    \"cross-spawn\": \"^6.0.5\",\n    \"debug\": \"^4.0.1\",\n    \"doctrine\": \"^3.0.0\",\n    \"eslint-scope\": \"^4.0.3\",\n    \"eslint-utils\": \"^1.3.1\",\n    \"eslint-visitor-keys\": \"^1.0.0\",\n    \"espree\": \"^5.0.1\",\n    \"esquery\": \"^1.0.1\",\n    \"esutils\": \"^2.0.2\",\n    \"file-entry-cache\": \"^5.0.1\",\n    \"functional-red-black-tree\": \"^1.0.1\",\n    \"glob\": \"^7.1.2\",\n    \"globals\": \"^11.7.0\",\n    \"ignore\": \"^4.0.6\",\n    \"import-fresh\": \"^3.0.0\",\n    \"imurmurhash\": \"^0.1.4\",\n    \"inquirer\": \"^6.2.2\",\n    \"js-yaml\": \"^3.13.0\",\n    \"json-stable-stringify-without-jsonify\": \"^1.0.1\",\n    \"levn\": \"^0.3.0\",\n    \"lodash\": \"^4.17.11\",\n    \"minimatch\": \"^3.0.4\",\n    \"mkdirp\": \"^0.5.1\",\n    \"natural-compare\": \"^1.4.0\",\n    \"optionator\": \"^0.8.2\",\n    \"path-is-inside\": \"^1.0.2\",\n    \"progress\": \"^2.0.0\",\n    \"regexpp\": \"^2.0.1\",\n    \"semver\": \"^5.5.1\",\n    \"strip-ansi\": \"^4.0.0\",\n    \"strip-json-comments\": \"^2.0.1\",\n    \"table\": \"^5.2.3\",\n    \"text-table\": \"^0.2.0\"\n  },\n  \"deprecated\": false,\n  \"description\": \"An AST-based pattern checker for JavaScript.\",\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.2.2\",\n    \"@babel/polyfill\": \"^7.2.5\",\n    \"@babel/preset-env\": \"^7.3.1\",\n    \"babel-loader\": \"^8.0.5\",\n    \"beefy\": \"^2.1.8\",\n    \"brfs\": \"^2.0.0\",\n    \"chai\": \"^4.0.1\",\n    \"cheerio\": \"^0.22.0\",\n    \"common-tags\": \"^1.8.0\",\n    \"coveralls\": \"^3.0.1\",\n    \"dateformat\": \"^3.0.3\",\n    \"ejs\": \"^2.6.1\",\n    \"eslint-config-eslint\": \"file:packages/eslint-config-eslint\",\n    \"eslint-plugin-eslint-plugin\": \"^2.0.1\",\n    \"eslint-plugin-internal-rules\": \"file:tools/internal-rules\",\n    \"eslint-plugin-node\": \"^8.0.0\",\n    \"eslint-release\": \"^1.2.0\",\n    \"eslump\": \"^2.0.0\",\n    \"esprima\": \"^4.0.1\",\n    \"jsdoc\": \"^3.5.5\",\n    \"karma\": \"^3.1.4\",\n    \"karma-chrome-launcher\": \"^2.2.0\",\n    \"karma-mocha\": \"^1.3.0\",\n    \"karma-mocha-reporter\": \"^2.2.3\",\n    \"karma-webpack\": \"^4.0.0-rc.6\",\n    \"leche\": \"^2.2.3\",\n    \"load-perf\": \"^0.2.0\",\n    \"markdownlint\": \"^0.12.0\",\n    \"mocha\": \"^5.0.5\",\n    \"mock-fs\": \"^4.8.0\",\n    \"npm-license\": \"^0.3.3\",\n    \"nyc\": \"^13.3.0\",\n    \"proxyquire\": \"^2.0.1\",\n    \"puppeteer\": \"^1.12.2\",\n    \"shelljs\": \"^0.8.2\",\n    \"sinon\": \"^3.3.0\",\n    \"temp\": \"^0.9.0\",\n    \"through\": \"^2.3.8\",\n    \"webpack\": \"^4.29.3\",\n    \"webpack-cli\": \"^3.2.3\"\n  },\n  \"engines\": {\n    \"node\": \"^6.14.0 || ^8.10.0 || >=9.10.0\"\n  },\n  \"files\": [\n    \"LICENSE\",\n    \"README.md\",\n    \"bin\",\n    \"conf\",\n    \"lib\",\n    \"messages\"\n  ],\n  \"homepage\": \"https://eslint.org\",\n  \"keywords\": [\n    \"ast\",\n    \"lint\",\n    \"javascript\",\n    \"ecmascript\",\n    \"espree\"\n  ],\n  \"license\": \"MIT\",\n  \"main\": \"./lib/api.js\",\n  \"name\": \"eslint\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/eslint/eslint.git\"\n  },\n  \"scripts\": {\n    \"coveralls\": \"cat ./coverage/lcov.info | coveralls\",\n    \"docs\": \"node Makefile.js docs\",\n    \"fuzz\": \"node Makefile.js fuzz\",\n    \"generate-alpharelease\": \"node Makefile.js generatePrerelease -- alpha\",\n    \"generate-betarelease\": \"node Makefile.js generatePrerelease -- beta\",\n    \"generate-rcrelease\": \"node Makefile.js generatePrerelease -- rc\",\n    \"generate-release\": \"node Makefile.js generateRelease\",\n    \"gensite\": \"node Makefile.js gensite\",\n    \"lint\": \"node Makefile.js lint\",\n    \"perf\": \"node Makefile.js perf\",\n    \"profile\": \"beefy tests/bench/bench.js --open -- -t brfs -t ./tests/bench/xform-rules.js -r espree\",\n    \"publish-release\": \"node Makefile.js publishRelease\",\n    \"test\": \"node Makefile.js test\",\n    \"webpack\": \"node Makefile.js webpack\"\n  },\n  \"version\": \"5.16.0\"\n}\n","/**\n * @fileoverview An object that caches and applies source code fixes.\n * @author Nicholas C. Zakas\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"debug\")(\"eslint:source-code-fixer\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst BOM = \"\\uFEFF\";\n\n/**\n * Compares items in a messages array by range.\n * @param {Message} a The first message.\n * @param {Message} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareMessagesByFixRange(a, b) {\n    return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];\n}\n\n/**\n * Compares items in a messages array by line and column.\n * @param {Message} a The first message.\n * @param {Message} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareMessagesByLocation(a, b) {\n    return a.line - b.line || a.column - b.column;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Utility for apply fixes to source code.\n * @constructor\n */\nfunction SourceCodeFixer() {\n    Object.freeze(this);\n}\n\n/**\n * Applies the fixes specified by the messages to the given text. Tries to be\n * smart about the fixes and won't apply fixes over the same area in the text.\n * @param {string} sourceText The text to apply the changes to.\n * @param {Message[]} messages The array of messages reported by ESLint.\n * @param {boolean|Function} [shouldFix=true] Determines whether each message should be fixed\n * @returns {Object} An object containing the fixed text and any unfixed messages.\n */\nSourceCodeFixer.applyFixes = function(sourceText, messages, shouldFix) {\n    debug(\"Applying fixes\");\n\n    if (shouldFix === false) {\n        debug(\"shouldFix parameter was false, not attempting fixes\");\n        return {\n            fixed: false,\n            messages,\n            output: sourceText\n        };\n    }\n\n    // clone the array\n    const remainingMessages = [],\n        fixes = [],\n        bom = sourceText.startsWith(BOM) ? BOM : \"\",\n        text = bom ? sourceText.slice(1) : sourceText;\n    let lastPos = Number.NEGATIVE_INFINITY,\n        output = bom;\n\n    /**\n     * Try to use the 'fix' from a problem.\n     * @param   {Message} problem The message object to apply fixes from\n     * @returns {boolean}         Whether fix was successfully applied\n     */\n    function attemptFix(problem) {\n        const fix = problem.fix;\n        const start = fix.range[0];\n        const end = fix.range[1];\n\n        // Remain it as a problem if it's overlapped or it's a negative range\n        if (lastPos >= start || start > end) {\n            remainingMessages.push(problem);\n            return false;\n        }\n\n        // Remove BOM.\n        if ((start < 0 && end >= 0) || (start === 0 && fix.text.startsWith(BOM))) {\n            output = \"\";\n        }\n\n        // Make output to this fix.\n        output += text.slice(Math.max(0, lastPos), Math.max(0, start));\n        output += fix.text;\n        lastPos = end;\n        return true;\n    }\n\n    messages.forEach(problem => {\n        if (Object.prototype.hasOwnProperty.call(problem, \"fix\")) {\n            fixes.push(problem);\n        } else {\n            remainingMessages.push(problem);\n        }\n    });\n\n    if (fixes.length) {\n        debug(\"Found fixes to apply\");\n        let fixesWereApplied = false;\n\n        for (const problem of fixes.sort(compareMessagesByFixRange)) {\n            if (typeof shouldFix !== \"function\" || shouldFix(problem)) {\n                attemptFix(problem);\n\n                /*\n                 * The only time attemptFix will fail is if a previous fix was\n                 * applied which conflicts with it.  So we can mark this as true.\n                 */\n                fixesWereApplied = true;\n            } else {\n                remainingMessages.push(problem);\n            }\n        }\n        output += text.slice(Math.max(0, lastPos));\n\n        return {\n            fixed: fixesWereApplied,\n            messages: remainingMessages.sort(compareMessagesByLocation),\n            output\n        };\n    }\n\n    debug(\"No fixes to apply\");\n    return {\n        fixed: false,\n        messages,\n        output: bom + text\n    };\n\n};\n\nmodule.exports = SourceCodeFixer;\n","/**\n * @fileoverview Main CLI object.\n * @author Nicholas C. Zakas\n */\n\n\n\n/*\n * The CLI object should *not* call process.exit() directly. It should only return\n * exit codes. This allows other programs to use the CLI object and still control\n * when the program exits.\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\"),\n    path = require(\"path\"),\n    defaultOptions = require(\"../conf/default-cli-options\"),\n    Linter = require(\"./linter\"),\n    lodash = require(\"lodash\"),\n    IgnoredPaths = require(\"./util/ignored-paths\"),\n    Config = require(\"./config\"),\n    ConfigOps = require(\"./config/config-ops\"),\n    LintResultCache = require(\"./util/lint-result-cache\"),\n    globUtils = require(\"./util/glob-utils\"),\n    validator = require(\"./config/config-validator\"),\n    hash = require(\"./util/hash\"),\n    ModuleResolver = require(\"./util/module-resolver\"),\n    naming = require(\"./util/naming\"),\n    pkg = require(\"../package.json\"),\n    loadRules = require(\"./load-rules\");\n\nconst debug = require(\"debug\")(\"eslint:cli-engine\");\nconst resolver = new ModuleResolver();\nconst validFixTypes = new Set([\"problem\", \"suggestion\", \"layout\"]);\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * The options to configure a CLI engine with.\n * @typedef {Object} CLIEngineOptions\n * @property {boolean} allowInlineConfig Enable or disable inline configuration comments.\n * @property {Object} baseConfig Base config object, extended by all configs used with this CLIEngine instance\n * @property {boolean} cache Enable result caching.\n * @property {string} cacheLocation The cache file to use instead of .eslintcache.\n * @property {string} configFile The configuration file to use.\n * @property {string} cwd The value to use for the current working directory.\n * @property {string[]} envs An array of environments to load.\n * @property {string[]} extensions An array of file extensions to check.\n * @property {boolean|Function} fix Execute in autofix mode. If a function, should return a boolean.\n * @property {string[]} fixTypes Array of rule types to apply fixes for.\n * @property {string[]} globals An array of global variables to declare.\n * @property {boolean} ignore False disables use of .eslintignore.\n * @property {string} ignorePath The ignore file to use instead of .eslintignore.\n * @property {string} ignorePattern A glob pattern of files to ignore.\n * @property {boolean} useEslintrc False disables looking for .eslintrc\n * @property {string} parser The name of the parser to use.\n * @property {Object} parserOptions An object of parserOption settings to use.\n * @property {string[]} plugins An array of plugins to load.\n * @property {Object<string,*>} rules An object of rules to use.\n * @property {string[]} rulePaths An array of directories to load custom rules from.\n * @property {boolean} reportUnusedDisableDirectives `true` adds reports for unused eslint-disable directives\n */\n\n/**\n * A linting warning or error.\n * @typedef {Object} LintMessage\n * @property {string} message The message to display to the user.\n */\n\n/**\n * A linting result.\n * @typedef {Object} LintResult\n * @property {string} filePath The path to the file that was linted.\n * @property {LintMessage[]} messages All of the messages for the result.\n * @property {number} errorCount Number of errors for the result.\n * @property {number} warningCount Number of warnings for the result.\n * @property {number} fixableErrorCount Number of fixable errors for the result.\n * @property {number} fixableWarningCount Number of fixable warnings for the result.\n * @property {string=} [source] The source code of the file that was linted.\n * @property {string=} [output] The source code of the file that was linted, with as many fixes applied as possible.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines if each fix type in an array is supported by ESLint and throws\n * an error if not.\n * @param {string[]} fixTypes An array of fix types to check.\n * @returns {void}\n * @throws {Error} If an invalid fix type is found.\n */\nfunction validateFixTypes(fixTypes) {\n    for (const fixType of fixTypes) {\n        if (!validFixTypes.has(fixType)) {\n            throw new Error(`Invalid fix type \"${fixType}\" found.`);\n        }\n    }\n}\n\n/**\n * It will calculate the error and warning count for collection of messages per file\n * @param {Object[]} messages - Collection of messages\n * @returns {Object} Contains the stats\n * @private\n */\nfunction calculateStatsPerFile(messages) {\n    return messages.reduce((stat, message) => {\n        if (message.fatal || message.severity === 2) {\n            stat.errorCount++;\n            if (message.fix) {\n                stat.fixableErrorCount++;\n            }\n        } else {\n            stat.warningCount++;\n            if (message.fix) {\n                stat.fixableWarningCount++;\n            }\n        }\n        return stat;\n    }, {\n        errorCount: 0,\n        warningCount: 0,\n        fixableErrorCount: 0,\n        fixableWarningCount: 0\n    });\n}\n\n/**\n * It will calculate the error and warning count for collection of results from all files\n * @param {Object[]} results - Collection of messages from all the files\n * @returns {Object} Contains the stats\n * @private\n */\nfunction calculateStatsPerRun(results) {\n    return results.reduce((stat, result) => {\n        stat.errorCount += result.errorCount;\n        stat.warningCount += result.warningCount;\n        stat.fixableErrorCount += result.fixableErrorCount;\n        stat.fixableWarningCount += result.fixableWarningCount;\n        return stat;\n    }, {\n        errorCount: 0,\n        warningCount: 0,\n        fixableErrorCount: 0,\n        fixableWarningCount: 0\n    });\n}\n\n/**\n * Processes an source code using ESLint.\n * @param {string} text The source code to check.\n * @param {Object} configHelper The configuration options for ESLint.\n * @param {string} filename An optional string representing the texts filename.\n * @param {boolean|Function} fix Indicates if fixes should be processed.\n * @param {boolean} allowInlineConfig Allow/ignore comments that change config.\n * @param {boolean} reportUnusedDisableDirectives Allow/ignore comments that change config.\n * @param {Linter} linter Linter context\n * @returns {{rules: LintResult, config: Object}} The results for linting on this text and the fully-resolved config for it.\n * @private\n */\nfunction processText(text, configHelper, filename, fix, allowInlineConfig, reportUnusedDisableDirectives, linter) {\n    let filePath,\n        fileExtension,\n        processor;\n\n    if (filename) {\n        filePath = path.resolve(filename);\n        fileExtension = path.extname(filename);\n    }\n\n    const effectiveFilename = filename || \"<text>\";\n\n    debug(`Linting ${effectiveFilename}`);\n    const config = configHelper.getConfig(filePath);\n\n    if (config.plugins) {\n        configHelper.plugins.loadAll(config.plugins);\n    }\n\n    const loadedPlugins = configHelper.plugins.getAll();\n\n    for (const plugin in loadedPlugins) {\n        if (loadedPlugins[plugin].processors && Object.keys(loadedPlugins[plugin].processors).indexOf(fileExtension) >= 0) {\n            processor = loadedPlugins[plugin].processors[fileExtension];\n            break;\n        }\n    }\n\n    const autofixingEnabled = typeof fix !== \"undefined\" && (!processor || processor.supportsAutofix);\n    const fixedResult = linter.verifyAndFix(text, config, {\n        filename: effectiveFilename,\n        allowInlineConfig,\n        reportUnusedDisableDirectives,\n        fix: !!autofixingEnabled && fix,\n        preprocess: processor && (rawText => processor.preprocess(rawText, effectiveFilename)),\n        postprocess: processor && (problemLists => processor.postprocess(problemLists, effectiveFilename))\n    });\n    const stats = calculateStatsPerFile(fixedResult.messages);\n\n    const result = {\n        filePath: effectiveFilename,\n        messages: fixedResult.messages,\n        errorCount: stats.errorCount,\n        warningCount: stats.warningCount,\n        fixableErrorCount: stats.fixableErrorCount,\n        fixableWarningCount: stats.fixableWarningCount\n    };\n\n    if (fixedResult.fixed) {\n        result.output = fixedResult.output;\n    }\n\n    if (result.errorCount + result.warningCount > 0 && typeof result.output === \"undefined\") {\n        result.source = text;\n    }\n\n    return { result, config };\n}\n\n/**\n * Processes an individual file using ESLint. Files used here are known to\n * exist, so no need to check that here.\n * @param {string} filename The filename of the file being checked.\n * @param {Object} configHelper The configuration options for ESLint.\n * @param {Object} options The CLIEngine options object.\n * @param {Linter} linter Linter context\n * @returns {{rules: LintResult, config: Object}} The results for linting on this text and the fully-resolved config for it.\n * @private\n */\nfunction processFile(filename, configHelper, options, linter) {\n\n    const text = fs.readFileSync(path.resolve(filename), \"utf8\");\n\n    return processText(\n        text,\n        configHelper,\n        filename,\n        options.fix,\n        options.allowInlineConfig,\n        options.reportUnusedDisableDirectives,\n        linter\n    );\n}\n\n/**\n * Returns result with warning by ignore settings\n * @param {string} filePath - File path of checked code\n * @param {string} baseDir  - Absolute path of base directory\n * @returns {LintResult} Result with single warning\n * @private\n */\nfunction createIgnoreResult(filePath, baseDir) {\n    let message;\n    const isHidden = /^\\./u.test(path.basename(filePath));\n    const isInNodeModules = baseDir && path.relative(baseDir, filePath).startsWith(\"node_modules\");\n    const isInBowerComponents = baseDir && path.relative(baseDir, filePath).startsWith(\"bower_components\");\n\n    if (isHidden) {\n        message = \"File ignored by default.  Use a negated ignore pattern (like \\\"--ignore-pattern '!<relative/path/to/filename>'\\\") to override.\";\n    } else if (isInNodeModules) {\n        message = \"File ignored by default. Use \\\"--ignore-pattern '!node_modules/*'\\\" to override.\";\n    } else if (isInBowerComponents) {\n        message = \"File ignored by default. Use \\\"--ignore-pattern '!bower_components/*'\\\" to override.\";\n    } else {\n        message = \"File ignored because of a matching ignore pattern. Use \\\"--no-ignore\\\" to override.\";\n    }\n\n    return {\n        filePath: path.resolve(filePath),\n        messages: [\n            {\n                fatal: false,\n                severity: 1,\n                message\n            }\n        ],\n        errorCount: 0,\n        warningCount: 1,\n        fixableErrorCount: 0,\n        fixableWarningCount: 0\n    };\n}\n\n/**\n * Produces rule warnings (i.e. deprecation) from configured rules\n * @param {(Array<string>|Set<string>)} usedRules - Rules configured\n * @param {Map} loadedRules - Map of loaded rules\n * @returns {Array<Object>} Contains rule warnings\n * @private\n */\nfunction createRuleDeprecationWarnings(usedRules, loadedRules) {\n    const usedDeprecatedRules = [];\n\n    usedRules.forEach(name => {\n        const loadedRule = loadedRules.get(name);\n\n        if (loadedRule && loadedRule.meta && loadedRule.meta.deprecated) {\n            const deprecatedRule = { ruleId: name };\n            const replacedBy = lodash.get(loadedRule, \"meta.replacedBy\", []);\n\n            if (replacedBy.every(newRule => lodash.isString(newRule))) {\n                deprecatedRule.replacedBy = replacedBy;\n            }\n\n            usedDeprecatedRules.push(deprecatedRule);\n        }\n    });\n\n    return usedDeprecatedRules;\n}\n\n/**\n * Checks if the given message is an error message.\n * @param {Object} message The message to check.\n * @returns {boolean} Whether or not the message is an error message.\n * @private\n */\nfunction isErrorMessage(message) {\n    return message.severity === 2;\n}\n\n\n/**\n * return the cacheFile to be used by eslint, based on whether the provided parameter is\n * a directory or looks like a directory (ends in `path.sep`), in which case the file\n * name will be the `cacheFile/.cache_hashOfCWD`\n *\n * if cacheFile points to a file or looks like a file then in will just use that file\n *\n * @param {string} cacheFile The name of file to be used to store the cache\n * @param {string} cwd Current working directory\n * @returns {string} the resolved path to the cache file\n */\nfunction getCacheFile(cacheFile, cwd) {\n\n    /*\n     * make sure the path separators are normalized for the environment/os\n     * keeping the trailing path separator if present\n     */\n    const normalizedCacheFile = path.normalize(cacheFile);\n\n    const resolvedCacheFile = path.resolve(cwd, normalizedCacheFile);\n    const looksLikeADirectory = normalizedCacheFile.slice(-1) === path.sep;\n\n    /**\n     * return the name for the cache file in case the provided parameter is a directory\n     * @returns {string} the resolved path to the cacheFile\n     */\n    function getCacheFileForDirectory() {\n        return path.join(resolvedCacheFile, `.cache_${hash(cwd)}`);\n    }\n\n    let fileStats;\n\n    try {\n        fileStats = fs.lstatSync(resolvedCacheFile);\n    } catch (ex) {\n        fileStats = null;\n    }\n\n\n    /*\n     * in case the file exists we need to verify if the provided path\n     * is a directory or a file. If it is a directory we want to create a file\n     * inside that directory\n     */\n    if (fileStats) {\n\n        /*\n         * is a directory or is a file, but the original file the user provided\n         * looks like a directory but `path.resolve` removed the `last path.sep`\n         * so we need to still treat this like a directory\n         */\n        if (fileStats.isDirectory() || looksLikeADirectory) {\n            return getCacheFileForDirectory();\n        }\n\n        // is file so just use that file\n        return resolvedCacheFile;\n    }\n\n    /*\n     * here we known the file or directory doesn't exist,\n     * so we will try to infer if its a directory if it looks like a directory\n     * for the current operating system.\n     */\n\n    // if the last character passed is a path separator we assume is a directory\n    if (looksLikeADirectory) {\n        return getCacheFileForDirectory();\n    }\n\n    return resolvedCacheFile;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nclass CLIEngine {\n\n    /**\n     * Creates a new instance of the core CLI engine.\n     * @param {CLIEngineOptions} providedOptions The options for this instance.\n     * @constructor\n     */\n    constructor(providedOptions) {\n\n        const options = Object.assign(\n            Object.create(null),\n            defaultOptions,\n            { cwd: process.cwd() },\n            providedOptions\n        );\n\n        /*\n         * if an --ignore-path option is provided, ensure that the ignore\n         * file exists and is not a directory\n         */\n        if (options.ignore && options.ignorePath) {\n            try {\n                if (!fs.statSync(options.ignorePath).isFile()) {\n                    throw new Error(`${options.ignorePath} is not a file`);\n                }\n            } catch (e) {\n                e.message = `Error: Could not load file ${options.ignorePath}\\nError: ${e.message}`;\n                throw e;\n            }\n        }\n\n        /**\n         * Stored options for this instance\n         * @type {Object}\n         */\n        this.options = options;\n        this.linter = new Linter();\n\n        // load in additional rules\n        if (this.options.rulePaths) {\n            const cwd = this.options.cwd;\n\n            this.options.rulePaths.forEach(rulesdir => {\n                debug(`Loading rules from ${rulesdir}`);\n                this.linter.defineRules(loadRules(rulesdir, cwd));\n            });\n        }\n\n        if (this.options.rules && Object.keys(this.options.rules).length) {\n            const loadedRules = this.linter.getRules();\n\n            // Ajv validator with default schema will mutate original object, so we must clone it recursively.\n            this.options.rules = lodash.cloneDeep(this.options.rules);\n\n            Object.keys(this.options.rules).forEach(name => {\n                validator.validateRuleOptions(loadedRules.get(name), name, this.options.rules[name], \"CLI\");\n            });\n        }\n\n        this.config = new Config(this.options, this.linter);\n\n        if (this.options.cache) {\n            const cacheFile = getCacheFile(this.options.cacheLocation || this.options.cacheFile, this.options.cwd);\n\n            /**\n             * Cache used to avoid operating on files that haven't changed since the\n             * last successful execution.\n             * @type {Object}\n             */\n            this._lintResultCache = new LintResultCache(cacheFile, this.config);\n        }\n\n        // setup special filter for fixes\n        if (this.options.fix && this.options.fixTypes && this.options.fixTypes.length > 0) {\n\n            debug(`Using fix types ${this.options.fixTypes}`);\n\n            // throw an error if any invalid fix types are found\n            validateFixTypes(this.options.fixTypes);\n\n            // convert to Set for faster lookup\n            const fixTypes = new Set(this.options.fixTypes);\n\n            // save original value of options.fix in case it's a function\n            const originalFix = (typeof this.options.fix === \"function\")\n                ? this.options.fix : () => this.options.fix;\n\n            // create a cache of rules (but don't populate until needed)\n            this._rulesCache = null;\n\n            this.options.fix = lintResult => {\n                const rule = this._rulesCache.get(lintResult.ruleId);\n                const matches = rule.meta && fixTypes.has(rule.meta.type);\n\n                return matches && originalFix(lintResult);\n            };\n        }\n\n    }\n\n    getRules() {\n        return this.linter.getRules();\n    }\n\n    /**\n     * Returns results that only contains errors.\n     * @param {LintResult[]} results The results to filter.\n     * @returns {LintResult[]} The filtered results.\n     */\n    static getErrorResults(results) {\n        const filtered = [];\n\n        results.forEach(result => {\n            const filteredMessages = result.messages.filter(isErrorMessage);\n\n            if (filteredMessages.length > 0) {\n                filtered.push(\n                    Object.assign(result, {\n                        messages: filteredMessages,\n                        errorCount: filteredMessages.length,\n                        warningCount: 0,\n                        fixableErrorCount: result.fixableErrorCount,\n                        fixableWarningCount: 0\n                    })\n                );\n            }\n        });\n\n        return filtered;\n    }\n\n    /**\n     * Outputs fixes from the given results to files.\n     * @param {Object} report The report object created by CLIEngine.\n     * @returns {void}\n     */\n    static outputFixes(report) {\n        report.results.filter(result => Object.prototype.hasOwnProperty.call(result, \"output\")).forEach(result => {\n            fs.writeFileSync(result.filePath, result.output);\n        });\n    }\n\n\n    /**\n     * Add a plugin by passing its configuration\n     * @param {string} name Name of the plugin.\n     * @param {Object} pluginobject Plugin configuration object.\n     * @returns {void}\n     */\n    addPlugin(name, pluginobject) {\n        this.config.plugins.define(name, pluginobject);\n    }\n\n    /**\n     * Resolves the patterns passed into executeOnFiles() into glob-based patterns\n     * for easier handling.\n     * @param {string[]} patterns The file patterns passed on the command line.\n     * @returns {string[]} The equivalent glob patterns.\n     */\n    resolveFileGlobPatterns(patterns) {\n        return globUtils.resolveFileGlobPatterns(patterns.filter(Boolean), this.options);\n    }\n\n    /**\n     * Executes the current configuration on an array of file and directory names.\n     * @param {string[]} patterns An array of file and directory names.\n     * @returns {Object} The results for all files that were linted.\n     */\n    executeOnFiles(patterns) {\n        const options = this.options,\n            lintResultCache = this._lintResultCache,\n            configHelper = this.config;\n        const cacheFile = getCacheFile(this.options.cacheLocation || this.options.cacheFile, this.options.cwd);\n\n        if (!options.cache && fs.existsSync(cacheFile)) {\n            fs.unlinkSync(cacheFile);\n        }\n\n        const startTime = Date.now();\n        const fileList = globUtils.listFilesToProcess(patterns, options);\n        const allUsedRules = new Set();\n        const results = fileList.map(fileInfo => {\n            if (fileInfo.ignored) {\n                return createIgnoreResult(fileInfo.filename, options.cwd);\n            }\n\n            if (options.cache) {\n                const cachedLintResults = lintResultCache.getCachedLintResults(fileInfo.filename);\n\n                if (cachedLintResults) {\n                    const resultHadMessages = cachedLintResults.messages && cachedLintResults.messages.length;\n\n                    if (resultHadMessages && options.fix) {\n                        debug(`Reprocessing cached file to allow autofix: ${fileInfo.filename}`);\n                    } else {\n                        debug(`Skipping file since it hasn't changed: ${fileInfo.filename}`);\n\n                        return cachedLintResults;\n                    }\n                }\n            }\n\n            // if there's a cache, populate it\n            if (\"_rulesCache\" in this) {\n                this._rulesCache = this.getRules();\n            }\n\n            debug(`Processing ${fileInfo.filename}`);\n\n            const { result, config } = processFile(fileInfo.filename, configHelper, options, this.linter);\n\n            Object.keys(config.rules)\n                .filter(ruleId => ConfigOps.getRuleSeverity(config.rules[ruleId]))\n                .forEach(ruleId => allUsedRules.add(ruleId));\n\n            return result;\n        });\n\n        if (options.cache) {\n            results.forEach(result => {\n\n                /*\n                 * Store the lint result in the LintResultCache.\n                 * NOTE: The LintResultCache will remove the file source and any\n                 * other properties that are difficult to serialize, and will\n                 * hydrate those properties back in on future lint runs.\n                 */\n                lintResultCache.setCachedLintResults(result.filePath, result);\n            });\n\n            // persist the cache to disk\n            lintResultCache.reconcile();\n        }\n\n        const stats = calculateStatsPerRun(results);\n\n        const usedDeprecatedRules = createRuleDeprecationWarnings(allUsedRules, this.getRules());\n\n        debug(`Linting complete in: ${Date.now() - startTime}ms`);\n\n        return {\n            results,\n            errorCount: stats.errorCount,\n            warningCount: stats.warningCount,\n            fixableErrorCount: stats.fixableErrorCount,\n            fixableWarningCount: stats.fixableWarningCount,\n            usedDeprecatedRules\n        };\n    }\n\n    /**\n     * Executes the current configuration on text.\n     * @param {string} text A string of JavaScript code to lint.\n     * @param {string} filename An optional string representing the texts filename.\n     * @param {boolean} warnIgnored Always warn when a file is ignored\n     * @returns {Object} The results for the linting.\n     */\n    executeOnText(text, filename, warnIgnored) {\n\n        const results = [],\n            options = this.options,\n            configHelper = this.config,\n            ignoredPaths = new IgnoredPaths(options);\n\n        // resolve filename based on options.cwd (for reporting, ignoredPaths also resolves)\n\n        const resolvedFilename = filename && !path.isAbsolute(filename)\n            ? path.resolve(options.cwd, filename)\n            : filename;\n        let usedDeprecatedRules;\n\n        if (resolvedFilename && ignoredPaths.contains(resolvedFilename)) {\n            if (warnIgnored) {\n                results.push(createIgnoreResult(resolvedFilename, options.cwd));\n            }\n            usedDeprecatedRules = [];\n        } else {\n\n            // if there's a cache, populate it\n            if (\"_rulesCache\" in this) {\n                this._rulesCache = this.getRules();\n            }\n\n            const { result, config } = processText(\n                text,\n                configHelper,\n                resolvedFilename,\n                options.fix,\n                options.allowInlineConfig,\n                options.reportUnusedDisableDirectives,\n                this.linter\n            );\n\n            results.push(result);\n            usedDeprecatedRules = createRuleDeprecationWarnings(\n                Object.keys(config.rules).filter(rule => ConfigOps.getRuleSeverity(config.rules[rule])),\n                this.getRules()\n            );\n        }\n\n        const stats = calculateStatsPerRun(results);\n\n        return {\n            results,\n            errorCount: stats.errorCount,\n            warningCount: stats.warningCount,\n            fixableErrorCount: stats.fixableErrorCount,\n            fixableWarningCount: stats.fixableWarningCount,\n            usedDeprecatedRules\n        };\n    }\n\n    /**\n     * Returns a configuration object for the given file based on the CLI options.\n     * This is the same logic used by the ESLint CLI executable to determine\n     * configuration for each file it processes.\n     * @param {string} filePath The path of the file to retrieve a config object for.\n     * @returns {Object} A configuration object for the file.\n     */\n    getConfigForFile(filePath) {\n        const configHelper = this.config;\n\n        return configHelper.getConfig(filePath);\n    }\n\n    /**\n     * Checks if a given path is ignored by ESLint.\n     * @param {string} filePath The path of the file to check.\n     * @returns {boolean} Whether or not the given path is ignored.\n     */\n    isPathIgnored(filePath) {\n        const resolvedPath = path.resolve(this.options.cwd, filePath);\n        const ignoredPaths = new IgnoredPaths(this.options);\n\n        return ignoredPaths.contains(resolvedPath);\n    }\n\n    /**\n     * Returns the formatter representing the given format or null if no formatter\n     * with the given name can be found.\n     * @param {string} [format] The name of the format to load or the path to a\n     *      custom formatter.\n     * @returns {Function} The formatter function or null if not found.\n     */\n    getFormatter(format) {\n\n        // default is stylish\n        const resolvedFormatName = format || \"stylish\";\n\n        // only strings are valid formatters\n        if (typeof resolvedFormatName === \"string\") {\n\n            // replace \\ with / for Windows compatibility\n            const normalizedFormatName = resolvedFormatName.replace(/\\\\/gu, \"/\");\n\n            const cwd = this.options ? this.options.cwd : process.cwd();\n            const namespace = naming.getNamespaceFromTerm(normalizedFormatName);\n\n            let formatterPath;\n\n            // if there's a slash, then it's a file\n            if (!namespace && normalizedFormatName.indexOf(\"/\") > -1) {\n                formatterPath = path.resolve(cwd, normalizedFormatName);\n            } else {\n                try {\n                    const npmFormat = naming.normalizePackageName(normalizedFormatName, \"eslint-formatter\");\n\n                    formatterPath = resolver.resolve(npmFormat, `${cwd}/node_modules`);\n                } catch (e) {\n                    formatterPath = `./formatters/${normalizedFormatName}`;\n                }\n            }\n\n            try {\n                return require(formatterPath);\n            } catch (ex) {\n                ex.message = `There was a problem loading formatter: ${formatterPath}\\nError: ${ex.message}`;\n                throw ex;\n            }\n\n        } else {\n            return null;\n        }\n    }\n}\n\nCLIEngine.version = pkg.version;\nCLIEngine.getFormatter = CLIEngine.prototype.getFormatter;\n\nmodule.exports = CLIEngine;\n","/**\n * @fileoverview Default CLIEngineOptions.\n * @author Ian VanSchooten\n */\n\n\n\nmodule.exports = {\n    configFile: null,\n    baseConfig: false,\n    rulePaths: [],\n    useEslintrc: true,\n    envs: [],\n    globals: [],\n    extensions: [\".js\"],\n    ignore: true,\n    ignorePath: null,\n    cache: false,\n\n    /*\n     * in order to honor the cacheFile option if specified\n     * this option should not have a default value otherwise\n     * it will always be used\n     */\n    cacheLocation: \"\",\n    cacheFile: \".eslintcache\",\n    fix: false,\n    allowInlineConfig: true,\n    reportUnusedDisableDirectives: false,\n    globInputPaths: true\n};\n","/**\n * @fileoverview Responsible for loading ignore config files and managing ignore patterns\n * @author Jonathan Rajavuori\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\"),\n    path = require(\"path\"),\n    ignore = require(\"ignore\"),\n    pathUtils = require(\"./path-utils\");\n\nconst debug = require(\"debug\")(\"eslint:ignored-paths\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst ESLINT_IGNORE_FILENAME = \".eslintignore\";\n\n/**\n * Adds `\"*\"` at the end of `\"node_modules/\"`,\n * so that subtle directories could be re-included by .gitignore patterns\n * such as `\"!node_modules/should_not_ignored\"`\n */\nconst DEFAULT_IGNORE_DIRS = [\n    \"/node_modules/*\",\n    \"/bower_components/*\"\n];\nconst DEFAULT_OPTIONS = {\n    dotfiles: false,\n    cwd: process.cwd()\n};\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Find a file in the current directory.\n * @param {string} cwd Current working directory\n * @param {string} name File name\n * @returns {string} Path of ignore file or an empty string.\n */\nfunction findFile(cwd, name) {\n    const ignoreFilePath = path.resolve(cwd, name);\n\n    return fs.existsSync(ignoreFilePath) && fs.statSync(ignoreFilePath).isFile() ? ignoreFilePath : \"\";\n}\n\n/**\n * Find an ignore file in the current directory.\n * @param {string} cwd Current working directory\n * @returns {string} Path of ignore file or an empty string.\n */\nfunction findIgnoreFile(cwd) {\n    return findFile(cwd, ESLINT_IGNORE_FILENAME);\n}\n\n/**\n * Find an package.json file in the current directory.\n * @param {string} cwd Current working directory\n * @returns {string} Path of package.json file or an empty string.\n */\nfunction findPackageJSONFile(cwd) {\n    return findFile(cwd, \"package.json\");\n}\n\n/**\n * Merge options with defaults\n * @param {Object} options Options to merge with DEFAULT_OPTIONS constant\n * @returns {Object} Merged options\n */\nfunction mergeDefaultOptions(options) {\n    return Object.assign({}, DEFAULT_OPTIONS, options);\n}\n\n/* eslint-disable valid-jsdoc */\n/**\n * Normalize the path separators in a given string.\n * On Windows environment, this replaces `\\` by `/`.\n * Otherwrise, this does nothing.\n * @param {string} str The path string to normalize.\n * @returns {string} The normalized path.\n */\nconst normalizePathSeps = path.sep === \"/\"\n    ? (str => str)\n    : ((seps, str) => str.replace(seps, \"/\")).bind(null, new RegExp(`\\\\${path.sep}`, \"gu\"));\n/* eslint-enable valid-jsdoc */\n\n/**\n * Converts a glob pattern to a new glob pattern relative to a different directory\n * @param {string} globPattern The glob pattern, relative the the old base directory\n * @param {string} relativePathToOldBaseDir A relative path from the new base directory to the old one\n * @returns {string} A glob pattern relative to the new base directory\n */\nfunction relativize(globPattern, relativePathToOldBaseDir) {\n    if (relativePathToOldBaseDir === \"\") {\n        return globPattern;\n    }\n\n    const prefix = globPattern.startsWith(\"!\") ? \"!\" : \"\";\n    const globWithoutPrefix = globPattern.replace(/^!/u, \"\");\n\n    if (globWithoutPrefix.startsWith(\"/\")) {\n        return `${prefix}/${normalizePathSeps(relativePathToOldBaseDir)}${globWithoutPrefix}`;\n    }\n\n    return globPattern;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * IgnoredPaths class\n */\nclass IgnoredPaths {\n\n    /**\n     * @param {Object} providedOptions object containing 'ignore', 'ignorePath' and 'patterns' properties\n     */\n    constructor(providedOptions) {\n        const options = mergeDefaultOptions(providedOptions);\n\n        this.cache = {};\n\n        this.defaultPatterns = [].concat(DEFAULT_IGNORE_DIRS, options.patterns || []);\n\n        this.ignoreFileDir = options.ignore !== false && options.ignorePath\n            ? path.dirname(path.resolve(options.cwd, options.ignorePath))\n            : options.cwd;\n        this.options = options;\n        this._baseDir = null;\n\n        this.ig = {\n            custom: ignore(),\n            default: ignore()\n        };\n\n        this.defaultPatterns.forEach(pattern => this.addPatternRelativeToCwd(this.ig.default, pattern));\n        if (options.dotfiles !== true) {\n\n            /*\n             * ignore files beginning with a dot, but not files in a parent or\n             * ancestor directory (which in relative format will begin with `../`).\n             */\n            this.addPatternRelativeToCwd(this.ig.default, \".*\");\n            this.addPatternRelativeToCwd(this.ig.default, \"!../\");\n        }\n\n        /*\n         * Add a way to keep track of ignored files.  This was present in node-ignore\n         * 2.x, but dropped for now as of 3.0.10.\n         */\n        this.ig.custom.ignoreFiles = [];\n        this.ig.default.ignoreFiles = [];\n\n        if (options.ignore !== false) {\n            let ignorePath;\n\n            if (options.ignorePath) {\n                debug(\"Using specific ignore file\");\n\n                try {\n                    fs.statSync(options.ignorePath);\n                    ignorePath = options.ignorePath;\n                } catch (e) {\n                    e.message = `Cannot read ignore file: ${options.ignorePath}\\nError: ${e.message}`;\n                    throw e;\n                }\n            } else {\n                debug(`Looking for ignore file in ${options.cwd}`);\n                ignorePath = findIgnoreFile(options.cwd);\n\n                try {\n                    fs.statSync(ignorePath);\n                    debug(`Loaded ignore file ${ignorePath}`);\n                } catch (e) {\n                    debug(\"Could not find ignore file in cwd\");\n                }\n            }\n\n            if (ignorePath) {\n                debug(`Adding ${ignorePath}`);\n                this.addIgnoreFile(this.ig.custom, ignorePath);\n                this.addIgnoreFile(this.ig.default, ignorePath);\n            } else {\n                try {\n\n                    // if the ignoreFile does not exist, check package.json for eslintIgnore\n                    const packageJSONPath = findPackageJSONFile(options.cwd);\n\n                    if (packageJSONPath) {\n                        let packageJSONOptions;\n\n                        try {\n                            packageJSONOptions = JSON.parse(fs.readFileSync(packageJSONPath, \"utf8\"));\n                        } catch (e) {\n                            debug(\"Could not read package.json file to check eslintIgnore property\");\n                            e.messageTemplate = \"failed-to-read-json\";\n                            e.messageData = {\n                                path: packageJSONPath,\n                                message: e.message\n                            };\n                            throw e;\n                        }\n\n                        if (packageJSONOptions.eslintIgnore) {\n                            if (Array.isArray(packageJSONOptions.eslintIgnore)) {\n                                packageJSONOptions.eslintIgnore.forEach(pattern => {\n                                    this.addPatternRelativeToIgnoreFile(this.ig.custom, pattern);\n                                    this.addPatternRelativeToIgnoreFile(this.ig.default, pattern);\n                                });\n                            } else {\n                                throw new TypeError(\"Package.json eslintIgnore property requires an array of paths\");\n                            }\n                        }\n                    }\n                } catch (e) {\n                    debug(\"Could not find package.json to check eslintIgnore property\");\n                    throw e;\n                }\n            }\n\n            if (options.ignorePattern) {\n                this.addPatternRelativeToCwd(this.ig.custom, options.ignorePattern);\n                this.addPatternRelativeToCwd(this.ig.default, options.ignorePattern);\n            }\n        }\n    }\n\n    /*\n     * If `ignoreFileDir` is a subdirectory of `cwd`, all paths will be normalized to be relative to `cwd`.\n     * Otherwise, all paths will be normalized to be relative to `ignoreFileDir`.\n     * This ensures that the final normalized ignore rule will not contain `..`, which is forbidden in\n     * ignore rules.\n     */\n\n    addPatternRelativeToCwd(ig, pattern) {\n        const baseDir = this.getBaseDir();\n        const cookedPattern = baseDir === this.options.cwd\n            ? pattern\n            : relativize(pattern, path.relative(baseDir, this.options.cwd));\n\n        ig.addPattern(cookedPattern);\n        debug(\"addPatternRelativeToCwd:\\n  original = %j\\n  cooked   = %j\", pattern, cookedPattern);\n    }\n\n    addPatternRelativeToIgnoreFile(ig, pattern) {\n        const baseDir = this.getBaseDir();\n        const cookedPattern = baseDir === this.ignoreFileDir\n            ? pattern\n            : relativize(pattern, path.relative(baseDir, this.ignoreFileDir));\n\n        ig.addPattern(cookedPattern);\n        debug(\"addPatternRelativeToIgnoreFile:\\n  original = %j\\n  cooked   = %j\", pattern, cookedPattern);\n    }\n\n    // Detect the common ancestor\n    getBaseDir() {\n        if (!this._baseDir) {\n            const a = path.resolve(this.options.cwd);\n            const b = path.resolve(this.ignoreFileDir);\n            let lastSepPos = 0;\n\n            // Set the shorter one (it's the common ancestor if one includes the other).\n            this._baseDir = a.length < b.length ? a : b;\n\n            // Set the common ancestor.\n            for (let i = 0; i < a.length && i < b.length; ++i) {\n                if (a[i] !== b[i]) {\n                    this._baseDir = a.slice(0, lastSepPos);\n                    break;\n                }\n                if (a[i] === path.sep) {\n                    lastSepPos = i;\n                }\n            }\n\n            // If it's only Windows drive letter, it needs \\\n            if (/^[A-Z]:$/u.test(this._baseDir)) {\n                this._baseDir += \"\\\\\";\n            }\n\n            debug(\"baseDir = %j\", this._baseDir);\n        }\n        return this._baseDir;\n    }\n\n    /**\n     * read ignore filepath\n     * @param {string} filePath, file to add to ig\n     * @returns {Array} raw ignore rules\n     */\n    readIgnoreFile(filePath) {\n        if (typeof this.cache[filePath] === \"undefined\") {\n            this.cache[filePath] = fs.readFileSync(filePath, \"utf8\").split(/\\r?\\n/gu).filter(Boolean);\n        }\n        return this.cache[filePath];\n    }\n\n    /**\n     * add ignore file to node-ignore instance\n     * @param {Object} ig instance of node-ignore\n     * @param {string} filePath file to add to ig\n     * @returns {void}\n     */\n    addIgnoreFile(ig, filePath) {\n        ig.ignoreFiles.push(filePath);\n        this\n            .readIgnoreFile(filePath)\n            .forEach(ignoreRule => this.addPatternRelativeToIgnoreFile(ig, ignoreRule));\n    }\n\n    /**\n     * Determine whether a file path is included in the default or custom ignore patterns\n     * @param {string} filepath Path to check\n     * @param {string} [category=undefined] check 'default', 'custom' or both (undefined)\n     * @returns {boolean} true if the file path matches one or more patterns, false otherwise\n     */\n    contains(filepath, category) {\n\n        let result = false;\n        const absolutePath = path.resolve(this.options.cwd, filepath);\n        const relativePath = pathUtils.getRelativePath(absolutePath, this.getBaseDir());\n\n        if (typeof category === \"undefined\") {\n            result = (this.ig.default.filter([relativePath]).length === 0) ||\n                (this.ig.custom.filter([relativePath]).length === 0);\n        } else {\n            result = (this.ig[category].filter([relativePath]).length === 0);\n        }\n        debug(\"contains:\");\n        debug(\"  target = %j\", filepath);\n        debug(\"  result = %j\", result);\n\n        return result;\n\n    }\n\n    /**\n     * Returns a list of dir patterns for glob to ignore\n     * @returns {function()} method to check whether a folder should be ignored by glob.\n     */\n    getIgnoredFoldersGlobChecker() {\n        const baseDir = this.getBaseDir();\n        const ig = ignore();\n\n        DEFAULT_IGNORE_DIRS.forEach(ignoreDir => this.addPatternRelativeToCwd(ig, ignoreDir));\n\n        if (this.options.dotfiles !== true) {\n\n            // Ignore hidden folders.  (This cannot be \".*\", or else it's not possible to unignore hidden files)\n            ig.add([\".*/*\", \"!../*\"]);\n        }\n\n        if (this.options.ignore) {\n            ig.add(this.ig.custom);\n        }\n\n        const filter = ig.createFilter();\n\n        return function(absolutePath) {\n            const relative = pathUtils.getRelativePath(absolutePath, baseDir);\n\n            if (!relative) {\n                return false;\n            }\n\n            return !filter(relative);\n        };\n    }\n}\n\nmodule.exports = IgnoredPaths;\n","/**\n * @fileoverview Common helpers for operations on filenames and paths\n * @author Ian VanSchooten\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst path = require(\"path\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\n * Replace Windows with posix style paths\n *\n * @param {string} filepath   Path to convert\n * @returns {string}          Converted filepath\n */\nfunction convertPathToPosix(filepath) {\n    const normalizedFilepath = path.normalize(filepath);\n    const posixFilepath = normalizedFilepath.replace(/\\\\/gu, \"/\");\n\n    return posixFilepath;\n}\n\n/**\n * Converts an absolute filepath to a relative path from a given base path\n *\n * For example, if the filepath is `/my/awesome/project/foo.bar`,\n * and the base directory is `/my/awesome/project/`,\n * then this function should return `foo.bar`.\n *\n * path.relative() does something similar, but it requires a baseDir (`from` argument).\n * This function makes it optional and just removes a leading slash if the baseDir is not given.\n *\n * It does not take into account symlinks (for now).\n *\n * @param {string} filepath  Path to convert to relative path.  If already relative,\n *                           it will be assumed to be relative to process.cwd(),\n *                           converted to absolute, and then processed.\n * @param {string} [baseDir] Absolute base directory to resolve the filepath from.\n *                           If not provided, all this function will do is remove\n *                           a leading slash.\n * @returns {string} Relative filepath\n */\nfunction getRelativePath(filepath, baseDir) {\n    const absolutePath = path.isAbsolute(filepath)\n        ? filepath\n        : path.resolve(filepath);\n\n    if (baseDir) {\n        if (!path.isAbsolute(baseDir)) {\n            throw new Error(`baseDir should be an absolute path: ${baseDir}`);\n        }\n        return path.relative(baseDir, absolutePath);\n    }\n    return absolutePath.replace(/^\\//u, \"\");\n\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    convertPathToPosix,\n    getRelativePath\n};\n","/**\n * @fileoverview Responsible for loading config files\n * @author Seth McLaughlin\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst path = require(\"path\"),\n    os = require(\"os\"),\n    ConfigOps = require(\"./config/config-ops\"),\n    ConfigFile = require(\"./config/config-file\"),\n    ConfigCache = require(\"./config/config-cache\"),\n    Plugins = require(\"./config/plugins\"),\n    FileFinder = require(\"./util/file-finder\");\n\nconst debug = require(\"debug\")(\"eslint:config\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst PERSONAL_CONFIG_DIR = os.homedir();\nconst SUBCONFIG_SEP = \":\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines if any rules were explicitly passed in as options.\n * @param {Object} options The options used to create our configuration.\n * @returns {boolean} True if rules were passed in as options, false otherwise.\n * @private\n */\nfunction hasRules(options) {\n    return options.rules && Object.keys(options.rules).length > 0;\n}\n\n/**\n * Determines if a module is can be resolved.\n * @param {string} moduleId The ID (name) of the module\n * @returns {boolean} True if it is resolvable; False otherwise.\n */\nfunction isResolvable(moduleId) {\n    try {\n        require.resolve(moduleId);\n        return true;\n    } catch (err) {\n        return false;\n    }\n}\n\n//------------------------------------------------------------------------------\n// API\n//------------------------------------------------------------------------------\n\n/**\n * Configuration class\n */\nclass Config {\n\n    /**\n     * @param {Object} providedOptions Options to be passed in\n     * @param {Linter} linterContext Linter instance object\n     */\n    constructor(providedOptions, linterContext) {\n        const options = providedOptions || {};\n\n        this.linterContext = linterContext;\n        this.plugins = new Plugins(linterContext.environments, linterContext.defineRule.bind(linterContext));\n\n        this.options = options;\n        this.ignore = options.ignore;\n        this.ignorePath = options.ignorePath;\n        this.parser = options.parser;\n        this.parserOptions = options.parserOptions || {};\n\n        this.configCache = new ConfigCache();\n\n        this.baseConfig = options.baseConfig\n            ? ConfigOps.merge({}, ConfigFile.loadObject(options.baseConfig, this))\n            : { rules: {} };\n        this.baseConfig.filePath = \"\";\n        this.baseConfig.baseDirectory = this.options.cwd;\n\n        this.configCache.setConfig(this.baseConfig.filePath, this.baseConfig);\n        this.configCache.setMergedVectorConfig(this.baseConfig.filePath, this.baseConfig);\n\n        this.useEslintrc = (options.useEslintrc !== false);\n\n        this.env = (options.envs || []).reduce((envs, name) => {\n            envs[name] = true;\n            return envs;\n        }, {});\n\n        /*\n         * Handle declared globals.\n         * For global variable foo, handle \"foo:false\" and \"foo:true\" to set\n         * whether global is writable.\n         * If user declares \"foo\", convert to \"foo:false\".\n         */\n        this.globals = (options.globals || []).reduce((globals, def) => {\n            const parts = def.split(SUBCONFIG_SEP);\n\n            globals[parts[0]] = (parts.length > 1 && parts[1] === \"true\");\n\n            return globals;\n        }, {});\n\n        this.loadSpecificConfig(options.configFile);\n\n        // Empty values in configs don't merge properly\n        const cliConfigOptions = {\n            env: this.env,\n            rules: this.options.rules,\n            globals: this.globals,\n            parserOptions: this.parserOptions,\n            plugins: this.options.plugins\n        };\n\n        this.cliConfig = {};\n        Object.keys(cliConfigOptions).forEach(configKey => {\n            const value = cliConfigOptions[configKey];\n\n            if (value) {\n                this.cliConfig[configKey] = value;\n            }\n        });\n    }\n\n    /**\n     * Loads the config options from a config specified on the command line.\n     * @param {string} [config] A shareable named config or path to a config file.\n     * @returns {void}\n     */\n    loadSpecificConfig(config) {\n        if (config) {\n            debug(`Using command line config ${config}`);\n            const isNamedConfig =\n                isResolvable(config) ||\n                isResolvable(`eslint-config-${config}`) ||\n                config.charAt(0) === \"@\";\n\n            this.specificConfig = ConfigFile.load(\n                isNamedConfig ? config : path.resolve(this.options.cwd, config),\n                this\n            );\n        }\n    }\n\n    /**\n     * Gets the personal config object from user's home directory.\n     * @returns {Object} the personal config object (null if there is no personal config)\n     * @private\n     */\n    getPersonalConfig() {\n        if (typeof this.personalConfig === \"undefined\") {\n            let config;\n            const filename = ConfigFile.getFilenameForDirectory(PERSONAL_CONFIG_DIR);\n\n            if (filename) {\n                debug(\"Using personal config\");\n                config = ConfigFile.load(filename, this);\n            }\n\n            this.personalConfig = config || null;\n        }\n\n        return this.personalConfig;\n    }\n\n    /**\n     * Builds a hierarchy of config objects, including the base config, all local configs from the directory tree,\n     * and a config file specified on the command line, if applicable.\n     * @param {string} directory a file in whose directory we start looking for a local config\n     * @returns {Object[]} The config objects, in ascending order of precedence\n     * @private\n     */\n    getConfigHierarchy(directory) {\n        debug(`Constructing config file hierarchy for ${directory}`);\n\n        // Step 1: Always include baseConfig\n        let configs = [this.baseConfig];\n\n        // Step 2: Add user-specified config from .eslintrc.* and package.json files\n        if (this.useEslintrc) {\n            debug(\"Using .eslintrc and package.json files\");\n            configs = configs.concat(this.getLocalConfigHierarchy(directory));\n        } else {\n            debug(\"Not using .eslintrc or package.json files\");\n        }\n\n        // Step 3: Merge in command line config file\n        if (this.specificConfig) {\n            debug(\"Using command line config file\");\n            configs.push(this.specificConfig);\n        }\n\n        return configs;\n    }\n\n    /**\n     * Gets a list of config objects extracted from local config files that apply to the current directory, in\n     * descending order, beginning with the config that is highest in the directory tree.\n     * @param {string} directory The directory to start looking in for local config files.\n     * @returns {Object[]} The shallow local config objects, in ascending order of precedence (closest to the current\n     * directory at the end), or an empty array if there are no local configs.\n     * @private\n     */\n    getLocalConfigHierarchy(directory) {\n        const localConfigFiles = this.findLocalConfigFiles(directory),\n            projectConfigPath = ConfigFile.getFilenameForDirectory(this.options.cwd),\n            searched = [],\n            configs = [];\n\n        for (const localConfigFile of localConfigFiles) {\n            const localConfigDirectory = path.dirname(localConfigFile);\n            const localConfigHierarchyCache = this.configCache.getHierarchyLocalConfigs(localConfigDirectory);\n\n            if (localConfigHierarchyCache) {\n                const localConfigHierarchy = localConfigHierarchyCache.concat(configs);\n\n                this.configCache.setHierarchyLocalConfigs(searched, localConfigHierarchy);\n                return localConfigHierarchy;\n            }\n\n            /*\n             * Don't consider the personal config file in the home directory,\n             * except if the home directory is the same as the current working directory\n             */\n            if (localConfigDirectory === PERSONAL_CONFIG_DIR && localConfigFile !== projectConfigPath) {\n                continue;\n            }\n\n            debug(`Loading ${localConfigFile}`);\n            const localConfig = ConfigFile.load(localConfigFile, this);\n\n            // Ignore empty config files\n            if (!localConfig) {\n                continue;\n            }\n\n            debug(`Using ${localConfigFile}`);\n            configs.unshift(localConfig);\n            searched.push(localConfigDirectory);\n\n            // Stop traversing if a config is found with the root flag set\n            if (localConfig.root) {\n                break;\n            }\n        }\n\n        if (!configs.length && !this.specificConfig) {\n\n            // Fall back on the personal config from ~/.eslintrc\n            debug(\"Using personal config file\");\n            const personalConfig = this.getPersonalConfig();\n\n            if (personalConfig) {\n                configs.unshift(personalConfig);\n            } else if (!hasRules(this.options) && !this.options.baseConfig) {\n\n                // No config file, no manual configuration, and no rules, so error.\n                const noConfigError = new Error(\"No ESLint configuration found.\");\n\n                noConfigError.messageTemplate = \"no-config-found\";\n                noConfigError.messageData = {\n                    directory,\n                    filesExamined: localConfigFiles\n                };\n\n                throw noConfigError;\n            }\n        }\n\n        // Set the caches for the parent directories\n        this.configCache.setHierarchyLocalConfigs(searched, configs);\n\n        return configs;\n    }\n\n    /**\n     * Gets the vector of applicable configs and subconfigs from the hierarchy for a given file. A vector is an array of\n     * entries, each of which in an object specifying a config file path and an array of override indices corresponding\n     * to entries in the config file's overrides section whose glob patterns match the specified file path; e.g., the\n     * vector entry { configFile: '/home/john/app/.eslintrc', matchingOverrides: [0, 2] } would indicate that the main\n     * project .eslintrc file and its first and third override blocks apply to the current file.\n     * @param {string} filePath The file path for which to build the hierarchy and config vector.\n     * @returns {Array<Object>} config vector applicable to the specified path\n     * @private\n     */\n    getConfigVector(filePath) {\n        const directory = filePath ? path.dirname(filePath) : this.options.cwd;\n\n        return this.getConfigHierarchy(directory).map(config => {\n            const vectorEntry = {\n                filePath: config.filePath,\n                matchingOverrides: []\n            };\n\n            if (config.overrides) {\n                const relativePath = path.relative(config.baseDirectory, filePath || directory);\n\n                config.overrides.forEach((override, i) => {\n                    if (ConfigOps.pathMatchesGlobs(relativePath, override.files, override.excludedFiles)) {\n                        vectorEntry.matchingOverrides.push(i);\n                    }\n                });\n            }\n\n            return vectorEntry;\n        });\n    }\n\n    /**\n     * Finds local config files from the specified directory and its parent directories.\n     * @param {string} directory The directory to start searching from.\n     * @returns {GeneratorFunction} The paths of local config files found.\n     */\n    findLocalConfigFiles(directory) {\n        if (!this.localConfigFinder) {\n            this.localConfigFinder = new FileFinder(ConfigFile.CONFIG_FILES, this.options.cwd);\n        }\n\n        return this.localConfigFinder.findAllInDirectoryAndParents(directory);\n    }\n\n    /**\n     * Builds the authoritative config object for the specified file path by merging the hierarchy of config objects\n     * that apply to the current file, including the base config (conf/eslint-recommended), the user's personal config\n     * from their homedir, all local configs from the directory tree, any specific config file passed on the command\n     * line, any configuration overrides set directly on the command line, and finally the environment configs\n     * (conf/environments).\n     * @param {string} filePath a file in whose directory we start looking for a local config\n     * @returns {Object} config object\n     */\n    getConfig(filePath) {\n        const vector = this.getConfigVector(filePath);\n        let config = this.configCache.getMergedConfig(vector);\n\n        if (config) {\n            debug(\"Using config from cache\");\n            return config;\n        }\n\n        // Step 1: Merge in the filesystem configurations (base, local, and personal)\n        config = ConfigOps.getConfigFromVector(vector, this.configCache);\n\n        // Step 2: Merge in command line configurations\n        config = ConfigOps.merge(config, this.cliConfig);\n\n        if (this.cliConfig.plugins) {\n            this.plugins.loadAll(this.cliConfig.plugins);\n        }\n\n        /*\n         * Step 3: Override parser only if it is passed explicitly through the command line\n         * or if it's not defined yet (because the final object will at least have the parser key)\n         */\n        if (this.parser || !config.parser) {\n            config = ConfigOps.merge(config, { parser: this.parser });\n        }\n\n        // Step 4: Apply environments to the config\n        config = ConfigOps.applyEnvironments(config, this.linterContext.environments);\n\n        this.configCache.setMergedConfig(vector, config);\n\n        return config;\n    }\n}\n\nmodule.exports = Config;\n","/**\n * @fileoverview Helper to locate and load configuration files.\n * @author Nicholas C. Zakas\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\"),\n    path = require(\"path\"),\n    ConfigOps = require(\"./config-ops\"),\n    validator = require(\"./config-validator\"),\n    ModuleResolver = require(\"../util/module-resolver\"),\n    naming = require(\"../util/naming\"),\n    pathIsInside = require(\"path-is-inside\"),\n    stripComments = require(\"strip-json-comments\"),\n    stringify = require(\"json-stable-stringify-without-jsonify\"),\n    importFresh = require(\"import-fresh\");\n\nconst debug = require(\"debug\")(\"eslint:config-file\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines sort order for object keys for json-stable-stringify\n *\n * see: https://github.com/samn/json-stable-stringify#cmp\n *\n * @param   {Object} a The first comparison object ({key: akey, value: avalue})\n * @param   {Object} b The second comparison object ({key: bkey, value: bvalue})\n * @returns {number}   1 or -1, used in stringify cmp method\n */\nfunction sortByKey(a, b) {\n    return a.key > b.key ? 1 : -1;\n}\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nconst CONFIG_FILES = [\n    \".eslintrc.js\",\n    \".eslintrc.yaml\",\n    \".eslintrc.yml\",\n    \".eslintrc.json\",\n    \".eslintrc\",\n    \"package.json\"\n];\n\nconst resolver = new ModuleResolver();\n\n/**\n * Convenience wrapper for synchronously reading file contents.\n * @param {string} filePath The filename to read.\n * @returns {string} The file contents, with the BOM removed.\n * @private\n */\nfunction readFile(filePath) {\n    return fs.readFileSync(filePath, \"utf8\").replace(/^\\ufeff/u, \"\");\n}\n\n/**\n * Determines if a given string represents a filepath or not using the same\n * conventions as require(), meaning that the first character must be nonalphanumeric\n * and not the @ sign which is used for scoped packages to be considered a file path.\n * @param {string} filePath The string to check.\n * @returns {boolean} True if it's a filepath, false if not.\n * @private\n */\nfunction isFilePath(filePath) {\n    return path.isAbsolute(filePath) || !/\\w|@/u.test(filePath.charAt(0));\n}\n\n/**\n * Loads a YAML configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {Object} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadYAMLConfigFile(filePath) {\n    debug(`Loading YAML config file: ${filePath}`);\n\n    // lazy load YAML to improve performance when not used\n    const yaml = require(\"js-yaml\");\n\n    try {\n\n        // empty YAML file can be null, so always use\n        return yaml.safeLoad(readFile(filePath)) || {};\n    } catch (e) {\n        debug(`Error reading YAML file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a JSON configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {Object} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadJSONConfigFile(filePath) {\n    debug(`Loading JSON config file: ${filePath}`);\n\n    try {\n        return JSON.parse(stripComments(readFile(filePath)));\n    } catch (e) {\n        debug(`Error reading JSON file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        e.messageTemplate = \"failed-to-read-json\";\n        e.messageData = {\n            path: filePath,\n            message: e.message\n        };\n        throw e;\n    }\n}\n\n/**\n * Loads a legacy (.eslintrc) configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {Object} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadLegacyConfigFile(filePath) {\n    debug(`Loading config file: ${filePath}`);\n\n    // lazy load YAML to improve performance when not used\n    const yaml = require(\"js-yaml\");\n\n    try {\n        return yaml.safeLoad(stripComments(readFile(filePath))) || /* istanbul ignore next */ {};\n    } catch (e) {\n        debug(`Error reading YAML file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a JavaScript configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {Object} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadJSConfigFile(filePath) {\n    debug(`Loading JS config file: ${filePath}`);\n    try {\n        return importFresh(filePath);\n    } catch (e) {\n        debug(`Error reading JavaScript file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a configuration from a package.json file.\n * @param {string} filePath The filename to load.\n * @returns {Object} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadPackageJSONConfigFile(filePath) {\n    debug(`Loading package.json config file: ${filePath}`);\n    try {\n        return loadJSONConfigFile(filePath).eslintConfig || null;\n    } catch (e) {\n        debug(`Error reading package.json file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Creates an error to notify about a missing config to extend from.\n * @param {string} configName The name of the missing config.\n * @returns {Error} The error object to throw\n * @private\n */\nfunction configMissingError(configName) {\n    const error = new Error(`Failed to load config \"${configName}\" to extend from.`);\n\n    error.messageTemplate = \"extend-config-missing\";\n    error.messageData = {\n        configName\n    };\n    return error;\n}\n\n/**\n * Loads a configuration file regardless of the source. Inspects the file path\n * to determine the correctly way to load the config file.\n * @param {Object} file The path to the configuration.\n * @returns {Object} The configuration information.\n * @private\n */\nfunction loadConfigFile(file) {\n    const filePath = file.filePath;\n    let config;\n\n    switch (path.extname(filePath)) {\n        case \".js\":\n            config = loadJSConfigFile(filePath);\n            if (file.configName) {\n                config = config.configs[file.configName];\n                if (!config) {\n                    throw configMissingError(file.configFullName);\n                }\n            }\n            break;\n\n        case \".json\":\n            if (path.basename(filePath) === \"package.json\") {\n                config = loadPackageJSONConfigFile(filePath);\n                if (config === null) {\n                    return null;\n                }\n            } else {\n                config = loadJSONConfigFile(filePath);\n            }\n            break;\n\n        case \".yaml\":\n        case \".yml\":\n            config = loadYAMLConfigFile(filePath);\n            break;\n\n        default:\n            config = loadLegacyConfigFile(filePath);\n    }\n\n    return ConfigOps.merge(ConfigOps.createEmptyConfig(), config);\n}\n\n/**\n * Writes a configuration file in JSON format.\n * @param {Object} config The configuration object to write.\n * @param {string} filePath The filename to write to.\n * @returns {void}\n * @private\n */\nfunction writeJSONConfigFile(config, filePath) {\n    debug(`Writing JSON config file: ${filePath}`);\n\n    const content = stringify(config, { cmp: sortByKey, space: 4 });\n\n    fs.writeFileSync(filePath, content, \"utf8\");\n}\n\n/**\n * Writes a configuration file in YAML format.\n * @param {Object} config The configuration object to write.\n * @param {string} filePath The filename to write to.\n * @returns {void}\n * @private\n */\nfunction writeYAMLConfigFile(config, filePath) {\n    debug(`Writing YAML config file: ${filePath}`);\n\n    // lazy load YAML to improve performance when not used\n    const yaml = require(\"js-yaml\");\n\n    const content = yaml.safeDump(config, { sortKeys: true });\n\n    fs.writeFileSync(filePath, content, \"utf8\");\n}\n\n/**\n * Writes a configuration file in JavaScript format.\n * @param {Object} config The configuration object to write.\n * @param {string} filePath The filename to write to.\n * @throws {Error} If an error occurs linting the config file contents.\n * @returns {void}\n * @private\n */\nfunction writeJSConfigFile(config, filePath) {\n    debug(`Writing JS config file: ${filePath}`);\n\n    let contentToWrite;\n    const stringifiedContent = `module.exports = ${stringify(config, { cmp: sortByKey, space: 4 })};`;\n\n    try {\n        const CLIEngine = require(\"../cli-engine\");\n        const linter = new CLIEngine({\n            baseConfig: config,\n            fix: true,\n            useEslintrc: false\n        });\n        const report = linter.executeOnText(stringifiedContent);\n\n        contentToWrite = report.results[0].output || stringifiedContent;\n    } catch (e) {\n        debug(\"Error linting JavaScript config file, writing unlinted version\");\n        const errorMessage = e.message;\n\n        contentToWrite = stringifiedContent;\n        e.message = \"An error occurred while generating your JavaScript config file. \";\n        e.message += \"A config file was still generated, but the config file itself may not follow your linting rules.\";\n        e.message += `\\nError: ${errorMessage}`;\n        throw e;\n    } finally {\n        fs.writeFileSync(filePath, contentToWrite, \"utf8\");\n    }\n}\n\n/**\n * Writes a configuration file.\n * @param {Object} config The configuration object to write.\n * @param {string} filePath The filename to write to.\n * @returns {void}\n * @throws {Error} When an unknown file type is specified.\n * @private\n */\nfunction write(config, filePath) {\n    switch (path.extname(filePath)) {\n        case \".js\":\n            writeJSConfigFile(config, filePath);\n            break;\n\n        case \".json\":\n            writeJSONConfigFile(config, filePath);\n            break;\n\n        case \".yaml\":\n        case \".yml\":\n            writeYAMLConfigFile(config, filePath);\n            break;\n\n        default:\n            throw new Error(\"Can't write to unknown file type.\");\n    }\n}\n\n/**\n * Determines the base directory for node packages referenced in a config file.\n * This does not include node_modules in the path so it can be used for all\n * references relative to a config file.\n * @param {string} configFilePath The config file referencing the file.\n * @returns {string} The base directory for the file path.\n * @private\n */\nfunction getBaseDir(configFilePath) {\n\n    // calculates the path of the project including ESLint as dependency\n    const projectPath = path.resolve(__dirname, \"../../../\");\n\n    if (configFilePath && pathIsInside(configFilePath, projectPath)) {\n\n        // be careful of https://github.com/substack/node-resolve/issues/78\n        return path.join(path.resolve(configFilePath));\n    }\n\n    /*\n     * default to ESLint project path since it's unlikely that plugins will be\n     * in this directory\n     */\n    return path.join(projectPath);\n}\n\n/**\n * Determines the lookup path, including node_modules, for package\n * references relative to a config file.\n * @param {string} configFilePath The config file referencing the file.\n * @returns {string} The lookup path for the file path.\n * @private\n */\nfunction getLookupPath(configFilePath) {\n    const basedir = getBaseDir(configFilePath);\n\n    return path.join(basedir, \"node_modules\");\n}\n\n/**\n * Resolves a eslint core config path\n * @param {string} name The eslint config name.\n * @returns {string} The resolved path of the config.\n * @private\n */\nfunction getEslintCoreConfigPath(name) {\n    if (name === \"eslint:recommended\") {\n\n        /*\n         * Add an explicit substitution for eslint:recommended to\n         * conf/eslint-recommended.js.\n         */\n        return path.resolve(__dirname, \"../../conf/eslint-recommended.js\");\n    }\n\n    if (name === \"eslint:all\") {\n\n        /*\n         * Add an explicit substitution for eslint:all to conf/eslint-all.js\n         */\n        return path.resolve(__dirname, \"../../conf/eslint-all.js\");\n    }\n\n    throw configMissingError(name);\n}\n\n/**\n * Applies values from the \"extends\" field in a configuration file.\n * @param {Object} config The configuration information.\n * @param {Config} configContext Plugin context for the config instance\n * @param {string} filePath The file path from which the configuration information\n *      was loaded.\n * @param {string} [relativeTo] The path to resolve relative to.\n * @returns {Object} A new configuration object with all of the \"extends\" fields\n *      loaded and merged.\n * @private\n */\nfunction applyExtends(config, configContext, filePath, relativeTo) {\n    let configExtends = config.extends;\n\n    // normalize into an array for easier handling\n    if (!Array.isArray(config.extends)) {\n        configExtends = [config.extends];\n    }\n\n    // Make the last element in an array take the highest precedence\n    return configExtends.reduceRight((previousValue, parentPath) => {\n        try {\n            let extensionPath;\n\n            if (parentPath.startsWith(\"eslint:\")) {\n                extensionPath = getEslintCoreConfigPath(parentPath);\n            } else if (isFilePath(parentPath)) {\n\n                /*\n                 * If the `extends` path is relative, use the directory of the current configuration\n                 * file as the reference point. Otherwise, use as-is.\n                 */\n                extensionPath = (path.isAbsolute(parentPath)\n                    ? parentPath\n                    : path.join(relativeTo || path.dirname(filePath), parentPath)\n                );\n            } else {\n                extensionPath = parentPath;\n            }\n            debug(`Loading ${extensionPath}`);\n\n            // eslint-disable-next-line no-use-before-define\n            return ConfigOps.merge(load(extensionPath, configContext, relativeTo), previousValue);\n        } catch (e) {\n\n            /*\n             * If the file referenced by `extends` failed to load, add the path\n             * to the configuration file that referenced it to the error\n             * message so the user is able to see where it was referenced from,\n             * then re-throw.\n             */\n            e.message += `\\nReferenced from: ${filePath}`;\n            throw e;\n        }\n\n    }, config);\n}\n\n/**\n * Resolves a configuration file path into the fully-formed path, whether filename\n * or package name.\n * @param {string} filePath The filepath to resolve.\n * @param {string} [relativeTo] The path to resolve relative to.\n * @returns {Object} An object containing 3 properties:\n * - 'filePath' (required) the resolved path that can be used directly to load the configuration.\n * - 'configName' the name of the configuration inside the plugin.\n * - 'configFullName' (required) the name of the configuration as used in the eslint config(e.g. 'plugin:node/recommended'),\n *     or the absolute path to a config file. This should uniquely identify a config.\n * @private\n */\nfunction resolve(filePath, relativeTo) {\n    if (isFilePath(filePath)) {\n        const fullPath = path.resolve(relativeTo || \"\", filePath);\n\n        return { filePath: fullPath, configFullName: fullPath };\n    }\n    let normalizedPackageName;\n\n    if (filePath.startsWith(\"plugin:\")) {\n        const configFullName = filePath;\n        const pluginName = filePath.slice(7, filePath.lastIndexOf(\"/\"));\n        const configName = filePath.slice(filePath.lastIndexOf(\"/\") + 1);\n\n        normalizedPackageName = naming.normalizePackageName(pluginName, \"eslint-plugin\");\n        debug(`Attempting to resolve ${normalizedPackageName}`);\n\n        return {\n            filePath: require.resolve(normalizedPackageName),\n            configName,\n            configFullName\n        };\n    }\n    normalizedPackageName = naming.normalizePackageName(filePath, \"eslint-config\");\n    debug(`Attempting to resolve ${normalizedPackageName}`);\n\n    return {\n        filePath: resolver.resolve(normalizedPackageName, getLookupPath(relativeTo)),\n        configFullName: filePath\n    };\n\n\n}\n\n/**\n * Loads a configuration file from the given file path.\n * @param {Object} resolvedPath The value from calling resolve() on a filename or package name.\n * @param {Config} configContext Plugins context\n * @returns {Object} The configuration information.\n */\nfunction loadFromDisk(resolvedPath, configContext) {\n    const dirname = path.dirname(resolvedPath.filePath),\n        lookupPath = getLookupPath(dirname);\n    let config = loadConfigFile(resolvedPath);\n\n    if (config) {\n\n        // ensure plugins are properly loaded first\n        if (config.plugins) {\n            configContext.plugins.loadAll(config.plugins);\n        }\n\n        // include full path of parser if present\n        if (config.parser) {\n            if (isFilePath(config.parser)) {\n                config.parser = path.resolve(dirname || \"\", config.parser);\n            } else {\n                config.parser = resolver.resolve(config.parser, lookupPath);\n            }\n        }\n\n        const ruleMap = configContext.linterContext.getRules();\n\n        // validate the configuration before continuing\n        validator.validate(config, ruleMap.get.bind(ruleMap), configContext.linterContext.environments, resolvedPath.configFullName);\n\n        /*\n         * If an `extends` property is defined, it represents a configuration file to use as\n         * a \"parent\". Load the referenced file and merge the configuration recursively.\n         */\n        if (config.extends) {\n            config = applyExtends(config, configContext, resolvedPath.filePath, dirname);\n        }\n    }\n\n    return config;\n}\n\n/**\n * Loads a config object, applying extends if present.\n * @param {Object} configObject a config object to load\n * @param {Config} configContext Context for the config instance\n * @returns {Object} the config object with extends applied if present, or the passed config if not\n * @private\n */\nfunction loadObject(configObject, configContext) {\n    return configObject.extends ? applyExtends(configObject, configContext, \"\") : configObject;\n}\n\n/**\n * Loads a config object from the config cache based on its filename, falling back to the disk if the file is not yet\n * cached.\n * @param {string} filePath the path to the config file\n * @param {Config} configContext Context for the config instance\n * @param {string} [relativeTo] The path to resolve relative to.\n * @returns {Object} the parsed config object (empty object if there was a parse error)\n * @private\n */\nfunction load(filePath, configContext, relativeTo) {\n    const resolvedPath = resolve(filePath, relativeTo);\n\n    const cachedConfig = configContext.configCache.getConfig(resolvedPath.configFullName);\n\n    if (cachedConfig) {\n        return cachedConfig;\n    }\n\n    const config = loadFromDisk(resolvedPath, configContext);\n\n    if (config) {\n        config.filePath = resolvedPath.filePath;\n        config.baseDirectory = path.dirname(resolvedPath.filePath);\n        configContext.configCache.setConfig(resolvedPath.configFullName, config);\n    }\n\n    return config;\n}\n\n/**\n * Checks whether the given filename points to a file\n * @param {string} filename A path to a file\n * @returns {boolean} `true` if a file exists at the given location\n */\nfunction isExistingFile(filename) {\n    try {\n        return fs.statSync(filename).isFile();\n    } catch (err) {\n        if (err.code === \"ENOENT\") {\n            return false;\n        }\n        throw err;\n    }\n}\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n\n    getBaseDir,\n    getLookupPath,\n    load,\n    loadObject,\n    resolve,\n    write,\n    applyExtends,\n    CONFIG_FILES,\n\n    /**\n     * Retrieves the configuration filename for a given directory. It loops over all\n     * of the valid configuration filenames in order to find the first one that exists.\n     * @param {string} directory The directory to check for a config file.\n     * @returns {?string} The filename of the configuration file for the directory\n     *      or null if there is no configuration file in the directory.\n     */\n    getFilenameForDirectory(directory) {\n        return CONFIG_FILES.map(filename => path.join(directory, filename)).find(isExistingFile) || null;\n    }\n};\n","/**\n * @fileoverview Implements the Node.js require.resolve algorithm\n * @author Nicholas C. Zakas\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Module = require(\"module\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nconst DEFAULT_OPTIONS = {\n\n    /*\n     * module.paths is an array of paths to search for resolving things relative\n     * to this file. Module.globalPaths contains all of the special Node.js\n     * directories that can also be searched for modules.\n     *\n     * Need to check for existence of module.paths because Jest seems not to\n     * include it. See https://github.com/eslint/eslint/issues/5791.\n     */\n    lookupPaths: module.paths ? module.paths.concat(Module.globalPaths) : Module.globalPaths.concat()\n};\n\n/**\n * Resolves modules based on a set of options.\n */\nclass ModuleResolver {\n\n    /**\n     * Resolves modules based on a set of options.\n     * @param {Object} options The options for resolving modules.\n     * @param {string[]} options.lookupPaths An array of paths to include in the\n     *      lookup with the highest priority paths coming first.\n     */\n    constructor(options) {\n        this.options = Object.assign({}, DEFAULT_OPTIONS, options || {});\n    }\n\n    /**\n     * Resolves the file location of a given module relative to the configured\n     * lookup paths.\n     * @param {string} name The module name to resolve.\n     * @param {string} extraLookupPath An extra path to look into for the module.\n     *      This path is used with the highest priority.\n     * @returns {string} The resolved file path for the module.\n     * @throws {Error} If the module cannot be resolved.\n     */\n    resolve(name, extraLookupPath) {\n\n        /*\n         * First, clone the lookup paths so we're not messing things up for\n         * subsequent calls to this function. Then, move the extraLookupPath to the\n         * top of the lookup paths list so it will be searched first.\n         */\n        const lookupPaths = [extraLookupPath, ...this.options.lookupPaths];\n\n        /**\n         * Module._findPath is an internal method to Node.js, then one they use to\n         * lookup file paths when require() is called. So, we are hooking into the\n         * exact same logic that Node.js uses.\n         */\n        const result = Module._findPath(name, lookupPaths); // eslint-disable-line no-underscore-dangle\n\n        if (!result) {\n            throw new Error(`Cannot find module '${name}'`);\n        }\n\n        return result;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public API\n//------------------------------------------------------------------------------\n\nmodule.exports = ModuleResolver;\n","/**\n * @fileoverview Common helpers for naming of plugins, formatters and configs\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst pathUtils = require(\"../util/path-utils\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nconst NAMESPACE_REGEX = /^@.*\\//iu;\n\n/**\n * Brings package name to correct format based on prefix\n * @param {string} name The name of the package.\n * @param {string} prefix Can be either \"eslint-plugin\", \"eslint-config\" or \"eslint-formatter\"\n * @returns {string} Normalized name of the package\n * @private\n */\nfunction normalizePackageName(name, prefix) {\n    let normalizedName = name;\n\n    /**\n     * On Windows, name can come in with Windows slashes instead of Unix slashes.\n     * Normalize to Unix first to avoid errors later on.\n     * https://github.com/eslint/eslint/issues/5644\n     */\n    if (normalizedName.indexOf(\"\\\\\") > -1) {\n        normalizedName = pathUtils.convertPathToPosix(normalizedName);\n    }\n\n    if (normalizedName.charAt(0) === \"@\") {\n\n        /**\n         * it's a scoped package\n         * package name is the prefix, or just a username\n         */\n        const scopedPackageShortcutRegex = new RegExp(`^(@[^/]+)(?:/(?:${prefix})?)?$`, \"u\"),\n            scopedPackageNameRegex = new RegExp(`^${prefix}(-|$)`, \"u\");\n\n        if (scopedPackageShortcutRegex.test(normalizedName)) {\n            normalizedName = normalizedName.replace(scopedPackageShortcutRegex, `$1/${prefix}`);\n        } else if (!scopedPackageNameRegex.test(normalizedName.split(\"/\")[1])) {\n\n            /**\n             * for scoped packages, insert the prefix after the first / unless\n             * the path is already @scope/eslint or @scope/eslint-xxx-yyy\n             */\n            normalizedName = normalizedName.replace(/^@([^/]+)\\/(.*)$/u, `@$1/${prefix}-$2`);\n        }\n    } else if (normalizedName.indexOf(`${prefix}-`) !== 0) {\n        normalizedName = `${prefix}-${normalizedName}`;\n    }\n\n    return normalizedName;\n}\n\n/**\n * Removes the prefix from a fullname.\n * @param {string} fullname The term which may have the prefix.\n * @param {string} prefix The prefix to remove.\n * @returns {string} The term without prefix.\n */\nfunction getShorthandName(fullname, prefix) {\n    if (fullname[0] === \"@\") {\n        let matchResult = new RegExp(`^(@[^/]+)/${prefix}$`, \"u\").exec(fullname);\n\n        if (matchResult) {\n            return matchResult[1];\n        }\n\n        matchResult = new RegExp(`^(@[^/]+)/${prefix}-(.+)$`, \"u\").exec(fullname);\n        if (matchResult) {\n            return `${matchResult[1]}/${matchResult[2]}`;\n        }\n    } else if (fullname.startsWith(`${prefix}-`)) {\n        return fullname.slice(prefix.length + 1);\n    }\n\n    return fullname;\n}\n\n/**\n * Gets the scope (namespace) of a term.\n * @param {string} term The term which may have the namespace.\n * @returns {string} The namepace of the term if it has one.\n */\nfunction getNamespaceFromTerm(term) {\n    const match = term.match(NAMESPACE_REGEX);\n\n    return match ? match[0] : \"\";\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    normalizePackageName,\n    getShorthandName,\n    getNamespaceFromTerm\n};\n","/**\n * @fileoverview Responsible for caching config files\n * @author Sylvan Mably\n */\n\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Get a string hash for a config vector\n * @param {Array<Object>} vector config vector to hash\n * @returns {string} hash of the vector values\n * @private\n */\nfunction hash(vector) {\n    return JSON.stringify(vector);\n}\n\n//------------------------------------------------------------------------------\n// API\n//------------------------------------------------------------------------------\n\n/**\n * Configuration caching class\n */\nmodule.exports = class ConfigCache {\n\n    constructor() {\n        this.configFullNameCache = new Map();\n        this.localHierarchyCache = new Map();\n        this.mergedVectorCache = new Map();\n        this.mergedCache = new Map();\n    }\n\n    /**\n     * Gets a config object from the cache for the specified config file path.\n     * @param {string} configFullName the name of the configuration as used in the eslint config(e.g. 'plugin:node/recommended'),\n     * or the absolute path to a config file. This should uniquely identify a config.\n     * @returns {Object|null} config object, if found in the cache, otherwise null\n     * @private\n     */\n    getConfig(configFullName) {\n        return this.configFullNameCache.get(configFullName);\n    }\n\n    /**\n     * Sets a config object in the cache for the specified config file path.\n     * @param {string} configFullName the name of the configuration as used in the eslint config(e.g. 'plugin:node/recommended'),\n     * or the absolute path to a config file. This should uniquely identify a config.\n     * @param {Object} config the config object to add to the cache\n     * @returns {void}\n     * @private\n     */\n    setConfig(configFullName, config) {\n        this.configFullNameCache.set(configFullName, config);\n    }\n\n    /**\n     * Gets a list of hierarchy-local config objects that apply to the specified directory.\n     * @param {string} directory the path to the directory\n     * @returns {Object[]|null} a list of config objects, if found in the cache, otherwise null\n     * @private\n     */\n    getHierarchyLocalConfigs(directory) {\n        return this.localHierarchyCache.get(directory);\n    }\n\n    /**\n     * For each of the supplied parent directories, sets the list of config objects for that directory to the\n     * appropriate subset of the supplied parent config objects.\n     * @param {string[]} parentDirectories a list of parent directories to add to the config cache\n     * @param {Object[]} parentConfigs a list of config objects that apply to the lowest directory in parentDirectories\n     * @returns {void}\n     * @private\n     */\n    setHierarchyLocalConfigs(parentDirectories, parentConfigs) {\n        parentDirectories.forEach((localConfigDirectory, i) => {\n            const directoryParentConfigs = parentConfigs.slice(0, parentConfigs.length - i);\n\n            this.localHierarchyCache.set(localConfigDirectory, directoryParentConfigs);\n        });\n    }\n\n    /**\n     * Gets a merged config object corresponding to the supplied vector.\n     * @param {Array<Object>} vector the vector to find a merged config for\n     * @returns {Object|null} a merged config object, if found in the cache, otherwise null\n     * @private\n     */\n    getMergedVectorConfig(vector) {\n        return this.mergedVectorCache.get(hash(vector));\n    }\n\n    /**\n     * Sets a merged config object in the cache for the supplied vector.\n     * @param {Array<Object>} vector the vector to save a merged config for\n     * @param {Object} config the merged config object to add to the cache\n     * @returns {void}\n     * @private\n     */\n    setMergedVectorConfig(vector, config) {\n        this.mergedVectorCache.set(hash(vector), config);\n    }\n\n    /**\n     * Gets a merged config object corresponding to the supplied vector, including configuration options from outside\n     * the vector.\n     * @param {Array<Object>} vector the vector to find a merged config for\n     * @returns {Object|null} a merged config object, if found in the cache, otherwise null\n     * @private\n     */\n    getMergedConfig(vector) {\n        return this.mergedCache.get(hash(vector));\n    }\n\n    /**\n     * Sets a merged config object in the cache for the supplied vector, including configuration options from outside\n     * the vector.\n     * @param {Array<Object>} vector the vector to save a merged config for\n     * @param {Object} config the merged config object to add to the cache\n     * @returns {void}\n     * @private\n     */\n    setMergedConfig(vector, config) {\n        this.mergedCache.set(hash(vector), config);\n    }\n};\n","/**\n * @fileoverview Plugins manager\n * @author Nicholas C. Zakas\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"debug\")(\"eslint:plugins\");\nconst naming = require(\"../util/naming\");\nconst path = require(\"path\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Plugin class\n */\nclass Plugins {\n\n    /**\n     * Creates the plugins context\n     * @param {Environments} envContext - env context\n     * @param {function(string, Rule): void} defineRule - Callback for when a plugin is defined which introduces rules\n     */\n    constructor(envContext, defineRule) {\n        this._plugins = Object.create(null);\n        this._environments = envContext;\n        this._defineRule = defineRule;\n    }\n\n    /**\n     * Defines a plugin with a given name rather than loading from disk.\n     * @param {string} pluginName The name of the plugin to load.\n     * @param {Object} plugin The plugin object.\n     * @returns {void}\n     */\n    define(pluginName, plugin) {\n        const longName = naming.normalizePackageName(pluginName, \"eslint-plugin\");\n        const shortName = naming.getShorthandName(longName, \"eslint-plugin\");\n\n        // load up environments and rules\n        this._plugins[shortName] = plugin;\n        this._environments.importPlugin(plugin, shortName);\n\n        if (plugin.rules) {\n            Object.keys(plugin.rules).forEach(ruleId => {\n                const qualifiedRuleId = `${shortName}/${ruleId}`,\n                    rule = plugin.rules[ruleId];\n\n                this._defineRule(qualifiedRuleId, rule);\n            });\n        }\n    }\n\n    /**\n     * Gets a plugin with the given name.\n     * @param {string} pluginName The name of the plugin to retrieve.\n     * @returns {Object} The plugin or null if not loaded.\n     */\n    get(pluginName) {\n        return this._plugins[pluginName] || null;\n    }\n\n    /**\n     * Returns all plugins that are loaded.\n     * @returns {Object} The plugins cache.\n     */\n    getAll() {\n        return this._plugins;\n    }\n\n    /**\n     * Loads a plugin with the given name.\n     * @param {string} pluginName The name of the plugin to load.\n     * @returns {void}\n     * @throws {Error} If the plugin cannot be loaded.\n     */\n    load(pluginName) {\n        const longName = naming.normalizePackageName(pluginName, \"eslint-plugin\");\n        const shortName = naming.getShorthandName(longName, \"eslint-plugin\");\n        let plugin = null;\n\n        if (pluginName.match(/\\s+/u)) {\n            const whitespaceError = new Error(`Whitespace found in plugin name '${pluginName}'`);\n\n            whitespaceError.messageTemplate = \"whitespace-found\";\n            whitespaceError.messageData = {\n                pluginName: longName\n            };\n            throw whitespaceError;\n        }\n\n        if (!this._plugins[shortName]) {\n            try {\n                plugin = require(longName);\n            } catch (pluginLoadErr) {\n                try {\n\n                    // Check whether the plugin exists\n                    require.resolve(longName);\n                } catch (missingPluginErr) {\n\n                    // If the plugin can't be resolved, display the missing plugin error (usually a config or install error)\n                    debug(`Failed to load plugin ${longName}.`);\n                    missingPluginErr.message = `Failed to load plugin ${pluginName}: ${missingPluginErr.message}`;\n                    missingPluginErr.messageTemplate = \"plugin-missing\";\n                    missingPluginErr.messageData = {\n                        pluginName: longName,\n                        eslintPath: path.resolve(__dirname, \"../..\")\n                    };\n                    throw missingPluginErr;\n                }\n\n                // Otherwise, the plugin exists and is throwing on module load for some reason, so print the stack trace.\n                throw pluginLoadErr;\n            }\n\n            // This step is costly, so skip if debug is disabled\n            if (debug.enabled) {\n                const resolvedPath = require.resolve(longName);\n\n                let version = null;\n\n                try {\n                    version = require(`${longName}/package.json`).version;\n                } catch (e) {\n\n                    // Do nothing\n                }\n\n                const loadedPluginAndVersion = version\n                    ? `${longName}@${version}`\n                    : `${longName}, version unknown`;\n\n                debug(`Loaded plugin ${pluginName} (${loadedPluginAndVersion}) (from ${resolvedPath})`);\n            }\n\n            this.define(pluginName, plugin);\n        }\n    }\n\n    /**\n     * Loads all plugins from an array.\n     * @param {string[]} pluginNames An array of plugins names.\n     * @returns {void}\n     * @throws {Error} If a plugin cannot be loaded.\n     * @throws {Error} If \"plugins\" in config is not an array\n     */\n    loadAll(pluginNames) {\n\n        // if \"plugins\" in config is not an array, throw an error so user can fix their config.\n        if (!Array.isArray(pluginNames)) {\n            const pluginNotArrayMessage = \"ESLint configuration error: \\\"plugins\\\" value must be an array\";\n\n            debug(`${pluginNotArrayMessage}: ${JSON.stringify(pluginNames)}`);\n\n            throw new Error(pluginNotArrayMessage);\n        }\n\n        // load each plugin by name\n        pluginNames.forEach(this.load, this);\n    }\n}\n\nmodule.exports = Plugins;\n","/**\n * @fileoverview Util class to find config files.\n * @author Aliaksei Shytkin\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\"),\n    path = require(\"path\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Get the entries for a directory. Including a try-catch may be detrimental to\n * function performance, so move it out here a separate function.\n * @param {string} directory The directory to search in.\n * @returns {string[]} The entries in the directory or an empty array on error.\n * @private\n */\nfunction getDirectoryEntries(directory) {\n    try {\n\n        return fs.readdirSync(directory);\n    } catch (ex) {\n        return [];\n    }\n}\n\n/**\n * Create a hash of filenames from a directory listing\n * @param {string[]} entries Array of directory entries.\n * @param {string} directory Path to a current directory.\n * @param {string[]} supportedConfigs List of support filenames.\n * @returns {Object} Hashmap of filenames\n */\nfunction normalizeDirectoryEntries(entries, directory, supportedConfigs) {\n    const fileHash = {};\n\n    entries.forEach(entry => {\n        if (supportedConfigs.indexOf(entry) >= 0) {\n            const resolvedEntry = path.resolve(directory, entry);\n\n            if (fs.statSync(resolvedEntry).isFile()) {\n                fileHash[entry] = resolvedEntry;\n            }\n        }\n    });\n    return fileHash;\n}\n\n//------------------------------------------------------------------------------\n// API\n//------------------------------------------------------------------------------\n\n/**\n * FileFinder class\n */\nclass FileFinder {\n\n    /**\n     * @param {string[]} files The basename(s) of the file(s) to find.\n     * @param {stirng} cwd Current working directory\n     */\n    constructor(files, cwd) {\n        this.fileNames = Array.isArray(files) ? files : [files];\n        this.cwd = cwd || process.cwd();\n        this.cache = {};\n    }\n\n    /**\n     * Find all instances of files with the specified file names, in directory and\n     * parent directories. Cache the results.\n     * Does not check if a matching directory entry is a file.\n     * Searches for all the file names in this.fileNames.\n     * Is currently used by lib/config.js to find .eslintrc and package.json files.\n     * @param  {string} relativeDirectory The directory to start the search from.\n     * @returns {GeneratorFunction} to iterate the file paths found\n     */\n    *findAllInDirectoryAndParents(relativeDirectory) {\n        const cache = this.cache;\n\n        const initialDirectory = relativeDirectory\n            ? path.resolve(this.cwd, relativeDirectory)\n            : this.cwd;\n\n        if (Object.prototype.hasOwnProperty.call(cache, initialDirectory)) {\n            yield* cache[initialDirectory];\n            return; // to avoid doing the normal loop afterwards\n        }\n\n        const dirs = [];\n        const fileNames = this.fileNames;\n        let searched = 0;\n        let directory = initialDirectory;\n\n        do {\n            dirs[searched++] = directory;\n            cache[directory] = [];\n\n            const filesMap = normalizeDirectoryEntries(getDirectoryEntries(directory), directory, fileNames);\n\n            if (Object.keys(filesMap).length) {\n                for (let k = 0; k < fileNames.length; k++) {\n\n                    if (filesMap[fileNames[k]]) {\n                        const filePath = filesMap[fileNames[k]];\n\n                        // Add the file path to the cache of each directory searched.\n                        for (let j = 0; j < searched; j++) {\n                            cache[dirs[j]].push(filePath);\n                        }\n                        yield filePath;\n                        break;\n                    }\n                }\n            }\n\n            const child = directory;\n\n            // Assign parent directory to directory.\n            directory = path.dirname(directory);\n\n            if (directory === child) {\n                return;\n            }\n\n        } while (!Object.prototype.hasOwnProperty.call(cache, directory));\n\n        // Add what has been cached previously to the cache of each directory searched.\n        for (let i = 0; i < searched; i++) {\n            cache[dirs[i]].push(...cache[directory]);\n        }\n\n        yield* cache[dirs[0]];\n    }\n}\n\nmodule.exports = FileFinder;\n","/**\n * @fileoverview Utility for caching lint results.\n * @author Kevin Partington\n */\n\n\n//-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n    fs = require(\"fs\"),\n    fileEntryCache = require(\"file-entry-cache\"),\n    hash = require(\"./hash\"),\n    pkg = require(\"../../package.json\"),\n    stringify = require(\"json-stable-stringify-without-jsonify\");\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst configHashCache = new WeakMap();\n\n/**\n * Calculates the hash of the config file used to validate a given file\n * @param {Object} configHelper The config helper for retrieving configuration information\n * @param {string} filename The path of the file to retrieve a config object for to calculate the hash\n * @returns {string} The hash of the config\n */\nfunction hashOfConfigFor(configHelper, filename) {\n    const config = configHelper.getConfig(filename);\n\n    if (!configHashCache.has(config)) {\n        configHashCache.set(config, hash(`${pkg.version}_${stringify(config)}`));\n    }\n\n    return configHashCache.get(config);\n}\n\n//-----------------------------------------------------------------------------\n// Public Interface\n//-----------------------------------------------------------------------------\n\n/**\n * Lint result cache. This wraps around the file-entry-cache module,\n * transparently removing properties that are difficult or expensive to\n * serialize and adding them back in on retrieval.\n */\nclass LintResultCache {\n\n    /**\n     * Creates a new LintResultCache instance.\n     * @constructor\n     * @param {string} cacheFileLocation The cache file location.\n     * @param {Object} configHelper The configuration helper (used for\n     *   configuration lookup by file path).\n     */\n    constructor(cacheFileLocation, configHelper) {\n        assert(cacheFileLocation, \"Cache file location is required\");\n        assert(configHelper, \"Config helper is required\");\n\n        this.fileEntryCache = fileEntryCache.create(cacheFileLocation);\n        this.configHelper = configHelper;\n    }\n\n    /**\n     * Retrieve cached lint results for a given file path, if present in the\n     * cache. If the file is present and has not been changed, rebuild any\n     * missing result information.\n     * @param {string} filePath The file for which to retrieve lint results.\n     * @returns {Object|null} The rebuilt lint results, or null if the file is\n     *   changed or not in the filesystem.\n     */\n    getCachedLintResults(filePath) {\n\n        /*\n         * Cached lint results are valid if and only if:\n         * 1. The file is present in the filesystem\n         * 2. The file has not changed since the time it was previously linted\n         * 3. The ESLint configuration has not changed since the time the file\n         *    was previously linted\n         * If any of these are not true, we will not reuse the lint results.\n         */\n\n        const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);\n        const hashOfConfig = hashOfConfigFor(this.configHelper, filePath);\n        const changed = fileDescriptor.changed || fileDescriptor.meta.hashOfConfig !== hashOfConfig;\n\n        if (fileDescriptor.notFound || changed) {\n            return null;\n        }\n\n        // If source is present but null, need to reread the file from the filesystem.\n        if (fileDescriptor.meta.results && fileDescriptor.meta.results.source === null) {\n            fileDescriptor.meta.results.source = fs.readFileSync(filePath, \"utf-8\");\n        }\n\n        return fileDescriptor.meta.results;\n    }\n\n    /**\n     * Set the cached lint results for a given file path, after removing any\n     * information that will be both unnecessary and difficult to serialize.\n     * Avoids caching results with an \"output\" property (meaning fixes were\n     * applied), to prevent potentially incorrect results if fixes are not\n     * written to disk.\n     * @param {string} filePath The file for which to set lint results.\n     * @param {Object} result The lint result to be set for the file.\n     * @returns {void}\n     */\n    setCachedLintResults(filePath, result) {\n        if (result && Object.prototype.hasOwnProperty.call(result, \"output\")) {\n            return;\n        }\n\n        const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);\n\n        if (fileDescriptor && !fileDescriptor.notFound) {\n\n            // Serialize the result, except that we want to remove the file source if present.\n            const resultToSerialize = Object.assign({}, result);\n\n            /*\n             * Set result.source to null.\n             * In `getCachedLintResults`, if source is explicitly null, we will\n             * read the file from the filesystem to set the value again.\n             */\n            if (Object.prototype.hasOwnProperty.call(resultToSerialize, \"source\")) {\n                resultToSerialize.source = null;\n            }\n\n            fileDescriptor.meta.results = resultToSerialize;\n            fileDescriptor.meta.hashOfConfig = hashOfConfigFor(this.configHelper, result.filePath);\n        }\n    }\n\n    /**\n     * Persists the in-memory cache to disk.\n     * @returns {void}\n     */\n    reconcile() {\n        this.fileEntryCache.reconcile();\n    }\n}\n\nmodule.exports = LintResultCache;\n","/**\n * @fileoverview Defining the hashing function in one place.\n * @author Michael Ficarra\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst murmur = require(\"imurmurhash\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\n * hash the given string\n * @param  {string} str the string to hash\n * @returns {string}    the hash\n */\nfunction hash(str) {\n    return murmur(str).result().toString(36);\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = hash;\n","/**\n * @fileoverview Utilities for working with globs and the filesystem.\n * @author Ian VanSchooten\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\"),\n    fs = require(\"fs\"),\n    path = require(\"path\"),\n    GlobSync = require(\"./glob\"),\n\n    pathUtils = require(\"./path-utils\"),\n    IgnoredPaths = require(\"./ignored-paths\");\n\nconst debug = require(\"debug\")(\"eslint:glob-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a directory exists at the given location\n * @param {string} resolvedPath A path from the CWD\n * @returns {boolean} `true` if a directory exists\n */\nfunction directoryExists(resolvedPath) {\n    return fs.existsSync(resolvedPath) && fs.statSync(resolvedPath).isDirectory();\n}\n\n/**\n * Checks if a provided path is a directory and returns a glob string matching\n * all files under that directory if so, the path itself otherwise.\n *\n * Reason for this is that `glob` needs `/**` to collect all the files under a\n * directory where as our previous implementation without `glob` simply walked\n * a directory that is passed. So this is to maintain backwards compatibility.\n *\n * Also makes sure all path separators are POSIX style for `glob` compatibility.\n *\n * @param {Object}   [options]                    An options object\n * @param {string[]} [options.extensions=[\".js\"]] An array of accepted extensions\n * @param {string}   [options.cwd=process.cwd()]  The cwd to use to resolve relative pathnames\n * @returns {Function} A function that takes a pathname and returns a glob that\n *                     matches all files with the provided extensions if\n *                     pathname is a directory.\n */\nfunction processPath(options) {\n    const cwd = (options && options.cwd) || process.cwd();\n    let extensions = (options && options.extensions) || [\".js\"];\n\n    extensions = extensions.map(ext => ext.replace(/^\\./u, \"\"));\n\n    let suffix = \"/**\";\n\n    if (extensions.length === 1) {\n        suffix += `/*.${extensions[0]}`;\n    } else {\n        suffix += `/*.{${extensions.join(\",\")}}`;\n    }\n\n    /**\n     * A function that converts a directory name to a glob pattern\n     *\n     * @param {string} pathname The directory path to be modified\n     * @returns {string} The glob path or the file path itself\n     * @private\n     */\n    return function(pathname) {\n        if (pathname === \"\") {\n            return \"\";\n        }\n\n        let newPath = pathname;\n        const resolvedPath = path.resolve(cwd, pathname);\n\n        if (directoryExists(resolvedPath)) {\n            newPath = pathname.replace(/[/\\\\]$/u, \"\") + suffix;\n        }\n\n        return pathUtils.convertPathToPosix(newPath);\n    };\n}\n\n/**\n * The error type when no files match a glob.\n */\nclass NoFilesFoundError extends Error {\n\n    /**\n     * @param {string} pattern - The glob pattern which was not found.\n     */\n    constructor(pattern) {\n        super(`No files matching '${pattern}' were found.`);\n\n        this.messageTemplate = \"file-not-found\";\n        this.messageData = { pattern };\n    }\n\n}\n\n/**\n * The error type when there are files matched by a glob, but all of them have been ignored.\n */\nclass AllFilesIgnoredError extends Error {\n\n    /**\n     * @param {string} pattern - The glob pattern which was not found.\n     */\n    constructor(pattern) {\n        super(`All files matched by '${pattern}' are ignored.`);\n        this.messageTemplate = \"all-files-ignored\";\n        this.messageData = { pattern };\n    }\n}\n\nconst NORMAL_LINT = {};\nconst SILENTLY_IGNORE = {};\nconst IGNORE_AND_WARN = {};\n\n/**\n * Tests whether a file should be linted or ignored\n * @param {string} filename The file to be processed\n * @param {{ignore: (boolean|null)}} options If `ignore` is false, updates the behavior to\n * not process custom ignore paths, and lint files specified by direct path even if they\n * match the default ignore path\n * @param {boolean} isDirectPath True if the file was provided as a direct path\n * (as opposed to being resolved from a glob)\n * @param {IgnoredPaths} ignoredPaths An instance of IgnoredPaths to check whether a given\n * file is ignored.\n * @returns {(NORMAL_LINT|SILENTLY_IGNORE|IGNORE_AND_WARN)} A directive for how the\n * file should be processed (either linted normally, or silently ignored, or ignored\n * with a warning that it is being ignored)\n */\nfunction testFileAgainstIgnorePatterns(filename, options, isDirectPath, ignoredPaths) {\n    const shouldProcessCustomIgnores = options.ignore !== false;\n    const shouldLintIgnoredDirectPaths = options.ignore === false;\n    const fileMatchesIgnorePatterns = ignoredPaths.contains(filename, \"default\") ||\n        (shouldProcessCustomIgnores && ignoredPaths.contains(filename, \"custom\"));\n\n    if (fileMatchesIgnorePatterns && isDirectPath && !shouldLintIgnoredDirectPaths) {\n        return IGNORE_AND_WARN;\n    }\n\n    if (!fileMatchesIgnorePatterns || (isDirectPath && shouldLintIgnoredDirectPaths)) {\n        return NORMAL_LINT;\n    }\n\n    return SILENTLY_IGNORE;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Resolves any directory patterns into glob-based patterns for easier handling.\n * @param   {string[]} patterns               File patterns (such as passed on the command line).\n * @param   {Object} options                  An options object.\n * @param   {string} [options.globInputPaths] False disables glob resolution.\n * @returns {string[]} The equivalent glob patterns and filepath strings.\n */\nfunction resolveFileGlobPatterns(patterns, options) {\n    if (options.globInputPaths === false) {\n        return patterns;\n    }\n\n    const processPathExtensions = processPath(options);\n\n    return patterns.map(processPathExtensions);\n}\n\nconst dotfilesPattern = /(?:(?:^\\.)|(?:[/\\\\]\\.))[^/\\\\.].*/u;\n\n/**\n * Build a list of absolute filesnames on which ESLint will act.\n * Ignored files are excluded from the results, as are duplicates.\n *\n * @param   {string[]} globPatterns                     Glob patterns.\n * @param   {Object}   [providedOptions]                An options object.\n * @param   {string}   [providedOptions.cwd]            CWD (considered for relative filenames)\n * @param   {boolean}  [providedOptions.ignore]         False disables use of .eslintignore.\n * @param   {string}   [providedOptions.ignorePath]     The ignore file to use instead of .eslintignore.\n * @param   {string}   [providedOptions.ignorePattern]  A pattern of files to ignore.\n * @param   {string}   [providedOptions.globInputPaths] False disables glob resolution.\n * @returns {string[]} Resolved absolute filenames.\n */\nfunction listFilesToProcess(globPatterns, providedOptions) {\n    const options = providedOptions || { ignore: true };\n    const cwd = options.cwd || process.cwd();\n\n    const getIgnorePaths = lodash.memoize(\n        optionsObj =>\n            new IgnoredPaths(optionsObj)\n    );\n\n    /*\n     * The test \"should use default options if none are provided\" (source-code-utils.js) checks that 'module.exports.resolveFileGlobPatterns' was called.\n     * So it cannot use the local function \"resolveFileGlobPatterns\".\n     */\n    const resolvedGlobPatterns = module.exports.resolveFileGlobPatterns(globPatterns, options);\n\n    debug(\"Creating list of files to process.\");\n    const resolvedPathsByGlobPattern = resolvedGlobPatterns.map(pattern => {\n        if (pattern === \"\") {\n            return [{\n                filename: \"\",\n                behavior: SILENTLY_IGNORE\n            }];\n        }\n\n        const file = path.resolve(cwd, pattern);\n\n        if (options.globInputPaths === false || (fs.existsSync(file) && fs.statSync(file).isFile())) {\n            const ignoredPaths = getIgnorePaths(options);\n            const fullPath = options.globInputPaths === false ? file : fs.realpathSync(file);\n\n            return [{\n                filename: fullPath,\n                behavior: testFileAgainstIgnorePatterns(fullPath, options, true, ignoredPaths)\n            }];\n        }\n\n        // regex to find .hidden or /.hidden patterns, but not ./relative or ../relative\n        const globIncludesDotfiles = dotfilesPattern.test(pattern);\n        let newOptions = options;\n\n        if (!options.dotfiles) {\n            newOptions = Object.assign({}, options, { dotfiles: globIncludesDotfiles });\n        }\n\n        const ignoredPaths = getIgnorePaths(newOptions);\n        const shouldIgnore = ignoredPaths.getIgnoredFoldersGlobChecker();\n        const globOptions = {\n            nodir: true,\n            dot: true,\n            cwd\n        };\n\n        return new GlobSync(pattern, globOptions, shouldIgnore).found.map(globMatch => {\n            const relativePath = path.resolve(cwd, globMatch);\n\n            return {\n                filename: relativePath,\n                behavior: testFileAgainstIgnorePatterns(relativePath, options, false, ignoredPaths)\n            };\n        });\n    });\n\n    const allPathDescriptors = resolvedPathsByGlobPattern.reduce((pathsForAllGlobs, pathsForCurrentGlob, index) => {\n        if (pathsForCurrentGlob.every(pathDescriptor => pathDescriptor.behavior === SILENTLY_IGNORE && pathDescriptor.filename !== \"\")) {\n            throw new (pathsForCurrentGlob.length ? AllFilesIgnoredError : NoFilesFoundError)(globPatterns[index]);\n        }\n\n        pathsForCurrentGlob.forEach(pathDescriptor => {\n            switch (pathDescriptor.behavior) {\n                case NORMAL_LINT:\n                    pathsForAllGlobs.push({ filename: pathDescriptor.filename, ignored: false });\n                    break;\n                case IGNORE_AND_WARN:\n                    pathsForAllGlobs.push({ filename: pathDescriptor.filename, ignored: true });\n                    break;\n                case SILENTLY_IGNORE:\n\n                    // do nothing\n                    break;\n\n                default:\n                    throw new Error(`Unexpected file behavior for ${pathDescriptor.filename}`);\n            }\n        });\n\n        return pathsForAllGlobs;\n    }, []);\n\n    return lodash.uniqBy(allPathDescriptors, pathDescriptor => pathDescriptor.filename);\n}\n\nmodule.exports = {\n    resolveFileGlobPatterns,\n    listFilesToProcess\n};\n","/**\n * @fileoverview An inherited `glob.GlobSync` to support .gitignore patterns.\n * @author Kael Zhang\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Sync = require(\"glob\").GlobSync,\n    util = require(\"util\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nconst IGNORE = Symbol(\"ignore\");\n\n/**\n * Subclass of `glob.GlobSync`\n * @param {string}     pattern      Pattern to be matched.\n * @param {Object}     options      `options` for `glob`\n * @param {function()} shouldIgnore Method to check whether a directory should be ignored.\n * @constructor\n */\nfunction GlobSync(pattern, options, shouldIgnore) {\n\n    /**\n     * We don't put this thing to argument `options` to avoid\n     * further problems, such as `options` validation.\n     *\n     * Use `Symbol` as much as possible to avoid confliction.\n     */\n    this[IGNORE] = shouldIgnore;\n\n    Sync.call(this, pattern, options);\n}\n\nutil.inherits(GlobSync, Sync);\n\n/* eslint no-underscore-dangle: [\"error\", { \"allow\": [\"_readdir\", \"_mark\"] }] */\n\nGlobSync.prototype._readdir = function(abs, inGlobStar) {\n\n    /**\n     * `options.nodir` makes `options.mark` as `true`.\n     * Mark `abs` first\n     * to make sure `\"node_modules\"` will be ignored immediately with ignore pattern `\"node_modules/\"`.\n     *\n     * There is a built-in cache about marked `File.Stat` in `glob`, so that we could not worry about the extra invocation of `this._mark()`\n     */\n    const marked = this._mark(abs);\n\n    if (this[IGNORE](marked)) {\n        return null;\n    }\n\n    return Sync.prototype._readdir.call(this, abs, inGlobStar);\n};\n\n\nmodule.exports = GlobSync;\n","/**\n * @fileoverview Module for loading rules from files and directories.\n * @author Michael Ficarra\n */\n\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\"),\n    path = require(\"path\");\n\nconst rulesDirCache = {};\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Load all rule modules from specified directory.\n * @param {string} relativeRulesDir Path to rules directory, may be relative.\n * @param {string} cwd Current working directory\n * @returns {Object} Loaded rule modules by rule ids (file names).\n */\nmodule.exports = function(relativeRulesDir, cwd) {\n    const rulesDir = path.resolve(cwd, relativeRulesDir);\n\n    // cache will help performance as IO operation are expensive\n    if (rulesDirCache[rulesDir]) {\n        return rulesDirCache[rulesDir];\n    }\n\n    const rules = Object.create(null);\n\n    fs.readdirSync(rulesDir).forEach(file => {\n        if (path.extname(file) !== \".js\") {\n            return;\n        }\n        rules[file.slice(0, -3)] = path.join(rulesDir, file);\n    });\n    rulesDirCache[rulesDir] = rules;\n\n    return rules;\n};\n","/**\n * @fileoverview Mocha test wrapper\n * @author Ilya Volodin\n */\n\n\n/* global describe, it */\n\n/*\n * This is a wrapper around mocha to allow for DRY unittests for eslint\n * Format:\n * RuleTester.run(\"{ruleName}\", {\n *      valid: [\n *          \"{code}\",\n *          { code: \"{code}\", options: {options}, globals: {globals}, parser: \"{parser}\", settings: {settings} }\n *      ],\n *      invalid: [\n *          { code: \"{code}\", errors: {numErrors} },\n *          { code: \"{code}\", errors: [\"{errorMessage}\"] },\n *          { code: \"{code}\", options: {options}, globals: {globals}, parser: \"{parser}\", settings: {settings}, errors: [{ message: \"{errorMessage}\", type: \"{errorNodeType}\"}] }\n *      ]\n *  });\n *\n * Variables:\n * {code} - String that represents the code to be tested\n * {options} - Arguments that are passed to the configurable rules.\n * {globals} - An object representing a list of variables that are\n *             registered as globals\n * {parser} - String representing the parser to use\n * {settings} - An object representing global settings for all rules\n * {numErrors} - If failing case doesn't need to check error message,\n *               this integer will specify how many errors should be\n *               received\n * {errorMessage} - Message that is returned by the rule on failure\n * {errorNodeType} - AST node type that is returned by they rule as\n *                   a cause of the failure.\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\"),\n    assert = require(\"assert\"),\n    util = require(\"util\"),\n    validator = require(\"../config/config-validator\"),\n    ajv = require(\"../util/ajv\"),\n    Linter = require(\"../linter\"),\n    Environments = require(\"../config/environments\"),\n    SourceCodeFixer = require(\"../util/source-code-fixer\"),\n    interpolate = require(\"../util/interpolate\");\n\n//------------------------------------------------------------------------------\n// Private Members\n//------------------------------------------------------------------------------\n\n/*\n * testerDefaultConfig must not be modified as it allows to reset the tester to\n * the initial default configuration\n */\nconst testerDefaultConfig = { rules: {} };\nlet defaultConfig = { rules: {} };\n\n/*\n * List every parameters possible on a test case that are not related to eslint\n * configuration\n */\nconst RuleTesterParameters = [\n    \"code\",\n    \"filename\",\n    \"options\",\n    \"errors\",\n    \"output\"\n];\n\nconst hasOwnProperty = Function.call.bind(Object.hasOwnProperty);\n\n/**\n * Clones a given value deeply.\n * Note: This ignores `parent` property.\n *\n * @param {any} x - A value to clone.\n * @returns {any} A cloned value.\n */\nfunction cloneDeeplyExcludesParent(x) {\n    if (typeof x === \"object\" && x !== null) {\n        if (Array.isArray(x)) {\n            return x.map(cloneDeeplyExcludesParent);\n        }\n\n        const retv = {};\n\n        for (const key in x) {\n            if (key !== \"parent\" && hasOwnProperty(x, key)) {\n                retv[key] = cloneDeeplyExcludesParent(x[key]);\n            }\n        }\n\n        return retv;\n    }\n\n    return x;\n}\n\n/**\n * Freezes a given value deeply.\n *\n * @param {any} x - A value to freeze.\n * @returns {void}\n */\nfunction freezeDeeply(x) {\n    if (typeof x === \"object\" && x !== null) {\n        if (Array.isArray(x)) {\n            x.forEach(freezeDeeply);\n        } else {\n            for (const key in x) {\n                if (key !== \"parent\" && hasOwnProperty(x, key)) {\n                    freezeDeeply(x[key]);\n                }\n            }\n        }\n        Object.freeze(x);\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n// default separators for testing\nconst DESCRIBE = Symbol(\"describe\");\nconst IT = Symbol(\"it\");\n\n/**\n * This is `it` default handler if `it` don't exist.\n * @this {Mocha}\n * @param {string} text - The description of the test case.\n * @param {Function} method - The logic of the test case.\n * @returns {any} Returned value of `method`.\n */\nfunction itDefaultHandler(text, method) {\n    try {\n        return method.call(this);\n    } catch (err) {\n        if (err instanceof assert.AssertionError) {\n            err.message += ` (${util.inspect(err.actual)} ${err.operator} ${util.inspect(err.expected)})`;\n        }\n        throw err;\n    }\n}\n\n/**\n * This is `describe` default handler if `describe` don't exist.\n * @this {Mocha}\n * @param {string} text - The description of the test case.\n * @param {Function} method - The logic of the test case.\n * @returns {any} Returned value of `method`.\n */\nfunction describeDefaultHandler(text, method) {\n    return method.call(this);\n}\n\nclass RuleTester {\n\n    /**\n     * Creates a new instance of RuleTester.\n     * @param {Object} [testerConfig] Optional, extra configuration for the tester\n     * @constructor\n     */\n    constructor(testerConfig) {\n\n        /**\n         * The configuration to use for this tester. Combination of the tester\n         * configuration and the default configuration.\n         * @type {Object}\n         */\n        this.testerConfig = lodash.merge(\n\n            // we have to clone because merge uses the first argument for recipient\n            lodash.cloneDeep(defaultConfig),\n            testerConfig,\n            { rules: { \"rule-tester/validate-ast\": \"error\" } }\n        );\n\n        /**\n         * Rule definitions to define before tests.\n         * @type {Object}\n         */\n        this.rules = {};\n        this.linter = new Linter();\n    }\n\n    /**\n     * Set the configuration to use for all future tests\n     * @param {Object} config the configuration to use.\n     * @returns {void}\n     */\n    static setDefaultConfig(config) {\n        if (typeof config !== \"object\") {\n            throw new TypeError(\"RuleTester.setDefaultConfig: config must be an object\");\n        }\n        defaultConfig = config;\n\n        // Make sure the rules object exists since it is assumed to exist later\n        defaultConfig.rules = defaultConfig.rules || {};\n    }\n\n    /**\n     * Get the current configuration used for all tests\n     * @returns {Object} the current configuration\n     */\n    static getDefaultConfig() {\n        return defaultConfig;\n    }\n\n    /**\n     * Reset the configuration to the initial configuration of the tester removing\n     * any changes made until now.\n     * @returns {void}\n     */\n    static resetDefaultConfig() {\n        defaultConfig = lodash.cloneDeep(testerDefaultConfig);\n    }\n\n\n    /*\n     * If people use `mocha test.js --watch` command, `describe` and `it` function\n     * instances are different for each execution. So `describe` and `it` should get fresh instance\n     * always.\n     */\n    static get describe() {\n        return (\n            this[DESCRIBE] ||\n            (typeof describe === \"function\" ? describe : describeDefaultHandler)\n        );\n    }\n\n    static set describe(value) {\n        this[DESCRIBE] = value;\n    }\n\n    static get it() {\n        return (\n            this[IT] ||\n            (typeof it === \"function\" ? it : itDefaultHandler)\n        );\n    }\n\n    static set it(value) {\n        this[IT] = value;\n    }\n\n    /**\n     * Define a rule for one particular run of tests.\n     * @param {string} name The name of the rule to define.\n     * @param {Function} rule The rule definition.\n     * @returns {void}\n     */\n    defineRule(name, rule) {\n        this.rules[name] = rule;\n    }\n\n    /**\n     * Adds a new rule test to execute.\n     * @param {string} ruleName The name of the rule to run.\n     * @param {Function} rule The rule to test.\n     * @param {Object} test The collection of tests to run.\n     * @returns {void}\n     */\n    run(ruleName, rule, test) {\n\n        const testerConfig = this.testerConfig,\n            requiredScenarios = [\"valid\", \"invalid\"],\n            scenarioErrors = [],\n            linter = this.linter;\n\n        if (lodash.isNil(test) || typeof test !== \"object\") {\n            throw new TypeError(`Test Scenarios for rule ${ruleName} : Could not find test scenario object`);\n        }\n\n        requiredScenarios.forEach(scenarioType => {\n            if (lodash.isNil(test[scenarioType])) {\n                scenarioErrors.push(`Could not find any ${scenarioType} test scenarios`);\n            }\n        });\n\n        if (scenarioErrors.length > 0) {\n            throw new Error([\n                `Test Scenarios for rule ${ruleName} is invalid:`\n            ].concat(scenarioErrors).join(\"\\n\"));\n        }\n\n\n        linter.defineRule(ruleName, Object.assign({}, rule, {\n\n            // Create a wrapper rule that freezes the `context` properties.\n            create(context) {\n                freezeDeeply(context.options);\n                freezeDeeply(context.settings);\n                freezeDeeply(context.parserOptions);\n\n                return (typeof rule === \"function\" ? rule : rule.create)(context);\n            }\n        }));\n\n        linter.defineRules(this.rules);\n\n        const ruleMap = linter.getRules();\n\n        /**\n         * Run the rule for the given item\n         * @param {string|Object} item Item to run the rule against\n         * @returns {Object} Eslint run result\n         * @private\n         */\n        function runRuleForItem(item) {\n            let config = lodash.cloneDeep(testerConfig),\n                code, filename, beforeAST, afterAST;\n\n            if (typeof item === \"string\") {\n                code = item;\n            } else {\n                code = item.code;\n\n                /*\n                 * Assumes everything on the item is a config except for the\n                 * parameters used by this tester\n                 */\n                const itemConfig = lodash.omit(item, RuleTesterParameters);\n\n                /*\n                 * Create the config object from the tester config and this item\n                 * specific configurations.\n                 */\n                config = lodash.merge(\n                    config,\n                    itemConfig\n                );\n            }\n\n            if (item.filename) {\n                filename = item.filename;\n            }\n\n            if (Object.prototype.hasOwnProperty.call(item, \"options\")) {\n                assert(Array.isArray(item.options), \"options must be an array\");\n                config.rules[ruleName] = [1].concat(item.options);\n            } else {\n                config.rules[ruleName] = 1;\n            }\n\n            const schema = validator.getRuleOptionsSchema(rule);\n\n            /*\n             * Setup AST getters.\n             * The goal is to check whether or not AST was modified when\n             * running the rule under test.\n             */\n            linter.defineRule(\"rule-tester/validate-ast\", () => ({\n                Program(node) {\n                    beforeAST = cloneDeeplyExcludesParent(node);\n                },\n                \"Program:exit\"(node) {\n                    afterAST = node;\n                }\n            }));\n\n            if (schema) {\n                ajv.validateSchema(schema);\n\n                if (ajv.errors) {\n                    const errors = ajv.errors.map(error => {\n                        const field = error.dataPath[0] === \".\" ? error.dataPath.slice(1) : error.dataPath;\n\n                        return `\\t${field}: ${error.message}`;\n                    }).join(\"\\n\");\n\n                    throw new Error([`Schema for rule ${ruleName} is invalid:`, errors]);\n                }\n            }\n\n            validator.validate(config, ruleMap.get.bind(ruleMap), new Environments(), \"rule-tester\");\n\n            return {\n                messages: linter.verify(code, config, filename, true),\n                beforeAST,\n                afterAST: cloneDeeplyExcludesParent(afterAST)\n            };\n        }\n\n        /**\n         * Check if the AST was changed\n         * @param {ASTNode} beforeAST AST node before running\n         * @param {ASTNode} afterAST AST node after running\n         * @returns {void}\n         * @private\n         */\n        function assertASTDidntChange(beforeAST, afterAST) {\n            if (!lodash.isEqual(beforeAST, afterAST)) {\n                assert.fail(\"Rule should not modify AST.\");\n            }\n        }\n\n        /**\n         * Check if the template is valid or not\n         * all valid cases go through this\n         * @param {string|Object} item Item to run the rule against\n         * @returns {void}\n         * @private\n         */\n        function testValidTemplate(item) {\n            const result = runRuleForItem(item);\n            const messages = result.messages;\n\n            assert.strictEqual(messages.length, 0, util.format(\"Should have no errors but had %d: %s\",\n                messages.length, util.inspect(messages)));\n\n            assertASTDidntChange(result.beforeAST, result.afterAST);\n        }\n\n        /**\n         * Asserts that the message matches its expected value. If the expected\n         * value is a regular expression, it is checked against the actual\n         * value.\n         * @param {string} actual Actual value\n         * @param {string|RegExp} expected Expected value\n         * @returns {void}\n         * @private\n         */\n        function assertMessageMatches(actual, expected) {\n            if (expected instanceof RegExp) {\n\n                // assert.js doesn't have a built-in RegExp match function\n                assert.ok(\n                    expected.test(actual),\n                    `Expected '${actual}' to match ${expected}`\n                );\n            } else {\n                assert.strictEqual(actual, expected);\n            }\n        }\n\n        /**\n         * Check if the template is invalid or not\n         * all invalid cases go through this.\n         * @param {string|Object} item Item to run the rule against\n         * @returns {void}\n         * @private\n         */\n        function testInvalidTemplate(item) {\n            assert.ok(item.errors || item.errors === 0,\n                `Did not specify errors for an invalid test of ${ruleName}`);\n\n            const result = runRuleForItem(item);\n            const messages = result.messages;\n\n\n            if (typeof item.errors === \"number\") {\n                assert.strictEqual(messages.length, item.errors, util.format(\"Should have %d error%s but had %d: %s\",\n                    item.errors, item.errors === 1 ? \"\" : \"s\", messages.length, util.inspect(messages)));\n            } else {\n                assert.strictEqual(\n                    messages.length, item.errors.length,\n                    util.format(\n                        \"Should have %d error%s but had %d: %s\",\n                        item.errors.length, item.errors.length === 1 ? \"\" : \"s\", messages.length, util.inspect(messages)\n                    )\n                );\n\n                const hasMessageOfThisRule = messages.some(m => m.ruleId === ruleName);\n\n                for (let i = 0, l = item.errors.length; i < l; i++) {\n                    const error = item.errors[i];\n                    const message = messages[i];\n\n                    assert(!message.fatal, `A fatal parsing error occurred: ${message.message}`);\n                    assert(hasMessageOfThisRule, \"Error rule name should be the same as the name of the rule being tested\");\n\n                    if (typeof error === \"string\" || error instanceof RegExp) {\n\n                        // Just an error message.\n                        assertMessageMatches(message.message, error);\n                    } else if (typeof error === \"object\") {\n\n                        /*\n                         * Error object.\n                         * This may have a message, messageId, data, node type, line, and/or\n                         * column.\n                         */\n                        if (hasOwnProperty(error, \"message\")) {\n                            assert.ok(!hasOwnProperty(error, \"messageId\"), \"Error should not specify both 'message' and a 'messageId'.\");\n                            assert.ok(!hasOwnProperty(error, \"data\"), \"Error should not specify both 'data' and 'message'.\");\n                            assertMessageMatches(message.message, error.message);\n                        } else if (hasOwnProperty(error, \"messageId\")) {\n                            assert.ok(\n                                hasOwnProperty(rule, \"meta\") && hasOwnProperty(rule.meta, \"messages\"),\n                                \"Error can not use 'messageId' if rule under test doesn't define 'meta.messages'.\"\n                            );\n                            if (!hasOwnProperty(rule.meta.messages, error.messageId)) {\n                                const friendlyIDList = `[${Object.keys(rule.meta.messages).map(key => `'${key}'`).join(\", \")}]`;\n\n                                assert(false, `Invalid messageId '${error.messageId}'. Expected one of ${friendlyIDList}.`);\n                            }\n                            assert.strictEqual(\n                                error.messageId,\n                                message.messageId,\n                                `messageId '${message.messageId}' does not match expected messageId '${error.messageId}'.`\n                            );\n                            if (hasOwnProperty(error, \"data\")) {\n\n                                /*\n                                 *  if data was provided, then directly compare the returned message to a synthetic\n                                 *  interpolated message using the same message ID and data provided in the test.\n                                 *  See https://github.com/eslint/eslint/issues/9890 for context.\n                                 */\n                                const unformattedOriginalMessage = rule.meta.messages[error.messageId];\n                                const rehydratedMessage = interpolate(unformattedOriginalMessage, error.data);\n\n                                assert.strictEqual(\n                                    message.message,\n                                    rehydratedMessage,\n                                    `Hydrated message \"${rehydratedMessage}\" does not match \"${message.message}\"`\n                                );\n                            }\n                        }\n\n                        assert.ok(\n                            hasOwnProperty(error, \"data\") ? hasOwnProperty(error, \"messageId\") : true,\n                            \"Error must specify 'messageId' if 'data' is used.\"\n                        );\n\n                        if (error.type) {\n                            assert.strictEqual(message.nodeType, error.type, `Error type should be ${error.type}, found ${message.nodeType}`);\n                        }\n\n                        if (Object.prototype.hasOwnProperty.call(error, \"line\")) {\n                            assert.strictEqual(message.line, error.line, `Error line should be ${error.line}`);\n                        }\n\n                        if (Object.prototype.hasOwnProperty.call(error, \"column\")) {\n                            assert.strictEqual(message.column, error.column, `Error column should be ${error.column}`);\n                        }\n\n                        if (Object.prototype.hasOwnProperty.call(error, \"endLine\")) {\n                            assert.strictEqual(message.endLine, error.endLine, `Error endLine should be ${error.endLine}`);\n                        }\n\n                        if (Object.prototype.hasOwnProperty.call(error, \"endColumn\")) {\n                            assert.strictEqual(message.endColumn, error.endColumn, `Error endColumn should be ${error.endColumn}`);\n                        }\n                    } else {\n\n                        // Message was an unexpected type\n                        assert.fail(`Error should be a string, object, or RegExp, but found (${util.inspect(message)})`);\n                    }\n                }\n            }\n\n            if (Object.prototype.hasOwnProperty.call(item, \"output\")) {\n                if (item.output === null) {\n                    assert.strictEqual(\n                        messages.filter(message => message.fix).length,\n                        0,\n                        \"Expected no autofixes to be suggested\"\n                    );\n                } else {\n                    const fixResult = SourceCodeFixer.applyFixes(item.code, messages);\n\n                    assert.strictEqual(fixResult.output, item.output, \"Output is incorrect.\");\n                }\n            }\n\n            assertASTDidntChange(result.beforeAST, result.afterAST);\n        }\n\n        /*\n         * This creates a mocha test suite and pipes all supplied info through\n         * one of the templates above.\n         */\n        RuleTester.describe(ruleName, () => {\n            RuleTester.describe(\"valid\", () => {\n                test.valid.forEach(valid => {\n                    RuleTester.it(typeof valid === \"object\" ? valid.code : valid, () => {\n                        testValidTemplate(valid);\n                    });\n                });\n            });\n\n            RuleTester.describe(\"invalid\", () => {\n                test.invalid.forEach(invalid => {\n                    RuleTester.it(invalid.code, () => {\n                        testInvalidTemplate(invalid);\n                    });\n                });\n            });\n        });\n    }\n}\n\nRuleTester[DESCRIBE] = RuleTester[IT] = null;\n\nmodule.exports = RuleTester;\n"]}